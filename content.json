{"meta":{"title":"Memory","subtitle":"永远相信美好的事情即将发生","description":null,"author":"nlby","url":"http://nlbyd1119.online","root":"/"},"pages":[],"posts":[{"title":"基本模式与相关技术、问题","slug":"基本模式与相关技术、问题","date":"2020-09-26T06:45:09.000Z","updated":"2020-09-26T14:21:05.391Z","comments":true,"path":"2020/09/26/基本模式与相关技术、问题/","link":"","permalink":"http://nlbyd1119.online/2020/09/26/%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E3%80%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"本篇是在基本了解过前端vue+elementui、各种模板、前端框架，学习过基于springboot的基本配置、ORM框架、统一处理等，以及中间件redis及一些数据库后，对这一系列技术如何学习、使用进行总结，算是要解决长久以来的一些不确定的问题。此外，也会对一些零碎的概念或问题进行解答。 参考 zimughttps://edu.51cto.com/course/19170.html 教程https://www.kancloud.cn/hanxt/springboot2/1776439 文档https://gitee.com/hanxt/boot-launch/tree/master/ 新版代码baizhi 一些问题的解答 一、VO PO BO DTO DOhttps://www.kancloud.cn/hanxt/springboot2/1776439https://blog.csdn.net/u011870547/article/details/81077153https://blog.csdn.net/hz_blog/article/details/8506823?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-3.nonecasehttps://blog.csdn.net/qq_41604862/article/details/79675223?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_paramhttps://blog.csdn.net/jslrjb/article/details/86597851https://blog.csdn.net/weixin_30298497/article/details/99066720?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061PO：persistent object 持久对象1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。2 ．在hibernate持久化框架中与insert/delet操作密切相关。3 ．PO中不应该包含任何对数据库的操作。POJO ：plain ordinary java object 无规则简单java对象一个中间对象，可以转化为PO、DTO、VO。1 ．POJO持久化之后==〉PO（在运行期，由Hibernate中的cglib动态把POJO转换为PO，PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。PO对于programmer来说完全透明，由于是运行期生成PO，所以可以支持增量编译，增量调试。）2 ．POJO传输过程中==〉DTO3 ．POJO用作表示层==〉VOPO 和VO都应该属于它。BO：business object 业务对象业务对象主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。封装业务逻辑为一个对象（可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用）。关于BO主要有三种概念1 、只包含业务对象的属性；2 、只包含业务方法；3 、两者都包含。在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。VO：value object 值对象 / view object 表现层对象1 ．主要对应页面显示（web页面/swt、swing界面）的数据对象。2 ．可以和表对应，也可以不，这根据业务的需要。DTO（TO）：Data Transfer Object 数据传输对象1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。DAO：data access object数据访问对象1 ．主要用来封装对DB的访问（CRUD操作）。2 ．通过接收Business层的数据，把POJO持久化为PO。 12345VO与DTO的区别大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。 二、postman一般测试方法 三、序列化与IDhttps://blog.csdn.net/wangqiang9x/article/details/84541316https://blog.csdn.net/wangqiang9x/article/details/90409507https://blog.csdn.net/liji_xc/article/details/47302455https://blog.csdn.net/liji_xc/article/details/47290695https://blog.csdn.net/u013815832/article/details/95212567?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_paramhttps://www.cnblogs.com/yansum/p/12602561.htmlhttps://www.cnblogs.com/lixuwu/p/10662339.htmlhttps://www.jianshu.com/p/d1f100cebf2ahttp://www.360doc.com/content/15/0413/20/15242507_462975436.shtmlhttps://www.csdn.net/gather_26/MtTacgwsNDI0OTktYmxvZwO0O0OO0O0O.htmlhttps://www.imooc.com/qadetail/110529?t=109890 1234567891011121314151617181920什么是序列化反序列化？Java序列化是将对象转换为字节流的过程，因此我们可以将其存储在磁盘上或通过网络发送。反序列化是相反的过程–将字节流转换为内存中的对象。序列化过程在序列化期间，java运行时将版本号与每个可序列化的类相关联,此数字称为 serialVersionUID。在反序列化期间,用于验证序列化对象的发送者和接收者是否已为该对象加载了与序列化兼容的类。如果接收者为对象加载的类serialVersionUID与相应的发送者的类不同，则反序列化将导致InvalidClassException。假设一个英国人和另一个印度人都将分别执行序列化和反序列化。在这种情况下， 为了验证在印度的接收者是经过验证的人，JVM会创建一个唯一ID，称为SerialVersionUID。在大多数情况下，序列化和反序列化这两个活动都是由具有相同系统和相同位置的单个人完成的。但是在序列化中，发送者和接收者不是同一个人，即，这些人可能不同，机器或系统可能不同，并且位置必须不同。在序列化中，发送方和接收方都应仅在开始时具有.class文件，即，要进行序列化的人和准备反序列化的人仅应在开始时包含相同的.class文件。序列化：序列化时，每个对象发送方JVM都会保存一个Unique Identifier。JVM负责根据发送方系统中存在的相应.class文件生成该唯一ID。反序列化：反序列化时，接收方JVM将与对象关联的唯一ID与本地类Unique ID进行比较，即JVM还将基于接收方系统中存在的相应.class文件创建唯一ID。如果两个唯一的ID都匹配，则将仅执行反序列化。否则，我们将获得Runtime Exception，提示InvalidClassException。这个唯一的标识符不过是SerialVersionUID。SerialVersionUID的生成：就平台和版本而言，发送者和接收者都应使用相同的JVM。否则，由于不同的SerialVersionUID，接收器无法反序列化。发送方和接收方都应使用相同的.class文件版本。序列化后，如果接收方的.class文件中有任何更改，则接收方无法反序列化。为了在内部生成SerialVersionUID，JVM可能使用复杂的算法，这可能会导致性能问题。 如何生成序列化idhttps://blog.csdn.net/aa494661239/article/details/80520418修改idea设置 一键生成四、日期处理与显示 五、TODOhttps://blog.csdn.net/carter_yu/article/details/90410540https://www.cnblogs.com/Tpf386/p/11684437.htmlhttps://blog.csdn.net/shi_hong_fei_hei/article/details/86606414https://jingyan.baidu.com/article/ff42efa9c25811c19e2202ef.htmlhttps://blog.csdn.net/qq_36205206/article/details/94723082https://www.w3cschool.cn/intellij_idea_doc/intellij_idea_doc-nx4b2dto.html 六、多表 七、增改 技术选型与学习 从数据库到前端，可以分为七个部分。一、数据库选型与相关主要是mysql redis mongodb 这几种的相关原理、命令、配置 二、ORM框架基本的jdbc、spring data系列和mybatis+mp，基本看下来其实最后写法都差不多。spring data系列是由代码生成表，mybatis+相关插件+mp是由表生成代码。需要注意的三方面，一是配置，一是多表的实现，一是分页的实现。对于mybatis，有总结的最佳使用方法。https://www.kancloud.cn/hanxt/springboot2/1177609 12mybatis，尤其涉及多表+动态，建议使用xml方式使用驼峰映射结果属性 三、统一返回数据和异常处理https://www.kancloud.cn/hanxt/springboot2/1177634https://www.kancloud.cn/hanxt/springboot2/1177635问题：分页的封装 四、视图三种方案： elementui + vue layui freemarker 五、其他框架spring cloud搜索 六、中间件等消息队列分布式文件系统nginx日志：springboot默认实现使用logback 门面使用slf4j 七、机制jwt实现权限管理文件相关 工具 hutoolshttps://hutool.cn/docs/#/https://www.bilibili.com/video/BV1bQ4y1M7d9?p=2 实验 为将这些技术进行集中搭配处理，总结可用的技术点，需要对作者代码进行测试，自行编写案例进行测试实践。先归纳一下要集成的技术点： 第一部分（通用）：统一数据处理、异常处理、日志配置、swagger、lombok 第二部分（单表ORM选择）：mybatis + mp | spring data jpa | mongodb | redis总结单表规范 第三部分（多表和分页实现策略） 第四部分（前端选型）：完全分离、layui、freemarker 第五部分：结合机制、功能点 jwt poi 第六部分：安全框架 由此，应进行的步骤： 首先是对单个点的源码进行测试，这个基本不能单独做，需要看哪check就行。 所以关键是新建一个应用，模拟一个简单场景，以此来集成各个技术。 1234模拟如下场景：一个简单的有角色权限的系统（当前先不加安全控制）因此先简单模拟一个作者--书籍--读者的关系 两两间一对多 读者和作者先不涉及系统的用户和角色概念目前先做的是这样一个关联关系集成各种技术的小案例 问题记录 一、mysql在华为云上安装mysql并连接时，又出现问题2003-can&#39;t connect to MYSQL参考 https://www.cnblogs.com/chenjw-note/p/5887908.html修改配置 把bind-address = 127.0.0.1 设置成bind-address = 0.0.0.0然后连接仍有问题，1130-host . is not allowed to connect to this MySql server,MySQL参考 https://www.cnblogs.com/liangzhihong/p/10452207.html修改mysql远程访问权限 1234567891011你想root使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码 GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; 输入命令FLUSH PRIVILEGES; 再次远程连接数据库成功。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"自定义控件其一","slug":"自定义控件其一","date":"2020-09-15T14:47:05.000Z","updated":"2020-09-15T14:48:34.365Z","comments":true,"path":"2020/09/15/自定义控件其一/","link":"","permalink":"http://nlbyd1119.online/2020/09/15/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%85%B6%E4%B8%80/","excerpt":"","text":"","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"zimug_study_index","slug":"zimug_study_index","date":"2020-09-15T12:46:31.000Z","updated":"2020-09-15T12:59:37.476Z","comments":true,"path":"2020/09/15/zimug_study_index/","link":"","permalink":"http://nlbyd1119.online/2020/09/15/zimug_study_index/","excerpt":"","text":"本篇的目的在于对zimug的springboot课程中涉及到的知识点进行索引整理。一、通用工具 lombokhttps://www.kancloud.cn/hanxt/springboot2/1315474 swagger 热部署 测试mockito 二、基本数据处理与概念 restful http的四种传参方法与相关注解https://www.kancloud.cn/hanxt/springboot2/1730303 json数据处理 jacksonhttps://www.kancloud.cn/hanxt/springboot2/1177587 通用数据响应接口 三、配置管理 四、数据库开发框架 五、静态资源与模板","categories":[{"name":"功能点学习","slug":"功能点学习","permalink":"http://nlbyd1119.online/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"mybatis-plus","slug":"mybatis-plus","date":"2020-09-15T11:42:28.000Z","updated":"2020-09-15T12:18:56.305Z","comments":true,"path":"2020/09/15/mybatis-plus/","link":"","permalink":"http://nlbyd1119.online/2020/09/15/mybatis-plus/","excerpt":"","text":"Mybatis-PlusMybatis-plus就是在mybatis基础上增加了类似与spring data的功能。 1. 概述1.1 什么是mybatis-plus官网:https://mybatis.plus/guide/ MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 1.2 官方愿景1.3 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 1.4 支持数据库 mysql 、 mariadb 、 oracle 、 db2 、 h2 、 hsql 、 sqlite 、 postgresql 、 sqlserver 2. 快速入门2.1 创建springboot项目1.并引入依赖12345 &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 注意:不需要在引入mybatis的相关依赖,只引入这一个即可,当然数据库相关的驱动还的显式引入 2.在入口类加入注解1234567@SpringBootApplication@MapperScan(\"com.baizhi.dao\")public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; 3.编写配置文件12345678spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mybatis-plus?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootlogging.level.root=infologging.level.com.baizhi.dao=debug 2.2 创建数据库以及表结构12345678910DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, `bir` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;SET FOREIGN_KEY_CHECKS = 1; 2.3 开发实体类1234567@Data //lombok的注解用来生成get set 等相关方法public class User &#123; private String id; private String name; private Integer age; private Date bir;&#125; 2.4 开发mapper通用实现123import com.baomidou.mybatisplus.core.mapper.BaseMapper; //提供了各种CRUD方法public interface UserDAO extends BaseMapper&lt;User&gt; &#123; &#125; 2.5 测试1234567@Autowiredprivate UserDAO userDAO;@Testvoid contextLoads() &#123; List&lt;User&gt; users = userDAO.selectList(null); System.out.println(users);&#125; 3.常用注解说明 @TableName @TableId @TableField 3.1 @TableName注解 描述:用来将实体对象与数据库表名完成映射 修饰范围: 用在类上 常见属性: value: String类型,指定映射的表名 resultMap:String类型,用来指定XML配置中resultMap的id值 3.2 @TableId注解 描述：主键注解 修饰范围:用在属性上 常见属性: value: String类型,指定实体类中与表中对应的主键列名 type: 枚举类型,指定主键生成类型 3.3 @TableField 描述：字段注解(非主键) 修饰范围:用在属性上 常用属性: value: String类型,用来指定对应的数据库表中的字段名 el: String类型,映射为原生 #{ ... } 逻辑,相当于写在 xml 里的 #{ ... } 部分 3.0不存在 exist boolean是否为数据库表字段 true代表是数据库字段,false代表不是 4.常用方法4.1 查询方法 查询所有 12345@Testpublic void testFindAll()&#123; List&lt;User&gt; users = userDAO.selectList(null); users.forEach(user-&gt; System.out.println(\"user = \" + user));&#125; 查询一个 12345@Testpublic void testFindOne()&#123; User user = userDAO.selectById(\"1\"); System.out.println(\"user = \" + user);&#125; 条件查询 12345678910//条件查询@Testpublic void testFind()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //queryWrapper.eq(\"age\",23);//设置等值查询 //queryWrapper.lt(\"age\",23);//设置小于查询 //queryWrapper.ge(\"age\",23);//小于等于查询 gt 大于 ge 大于等于 List&lt;User&gt; users = userDAO.selectList(queryWrapper); users.forEach(user-&gt; System.out.println(user));&#125; 模糊查询 1234567@Testpublic void testFindAll()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.likeRight(\"username\",\"小\"); List&lt;User&gt; users = userDAO.selectList(queryWrapper); users.forEach(user-&gt; System.out.println(\"user = \" + user));&#125; like 相当于 %?% likeLeft 相当于 %? likeRight 相当于 ?% 4.2 添加方法 ​ 添加方法 123456@Testpublic void testSave()&#123; User entity = new User(); entity.setAge(23).setName(\"小明明\").setBir(new Date()); userDAO.insert(entity);&#125; 4.3 修改方法 基于id修改 123456@Testpublic void testUpdateById()&#123; User user = userDAO.selectById(\"1\"); user.setAge(24); userDAO.updateById(user);&#125; 基于条件修改 12345678@Testpublic void testUpdate()&#123; User user = userDAO.selectById(\"1\"); user.setName(\"小陈陈\"); QueryWrapper&lt;User&gt; updateWrapper = new QueryWrapper&lt;&gt;(); updateWrapper.eq(true,\"age\",23); userDAO.update(user, updateWrapper);&#125; 4.4 删除方法 基于id删除 1234@Testpublic void testDeleteById()&#123; userDAO.deleteById(\"3\");&#125; 基于条件删除 123456@Testpublic void testDelete()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.lambda().eq(true,User::getAge,23); userDAO.delete(wrapper);&#125; 5.Mybatis-Plus分页查询0.预先配置 注意:使用分页查询必须设置mybatis-plus提供的分页插件,才能实现分页效果 12345678910@EnableTransactionManagement@Configuration@MapperScan(\"com.baizhi.dao\")public class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); return paginationInterceptor; &#125;&#125; 注意事项:目前分页查询仅仅支持单表查询,不能再表连接时使用分页插件 1.分页查询 非条件分页查询 123456@Testpublic void testFindAll()&#123; IPage&lt;User&gt; page = new Page&lt;&gt;(1,2); page = userDAO.selectPage(page, null); page.getRecords().forEach(user -&gt; System.out.println(\"user = \" + user));&#125; 带条件分页查询 12345678@Testpublic void testFindAll()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(\"age\",23); IPage&lt;User&gt; page = new Page&lt;&gt;(1,2); page = userDAO.selectPage(page, queryWrapper); page.getRecords().forEach(user-&gt; System.out.println(\"user = \" + user));&#125; 6. Mybatis-Plus多数据源配置引言为了确保数据库产品的稳定性，很多数据库拥有双机热备功能。也就是，第一台数据库服务器，是对外提供增删改业务的生产服务器；第二台数据库服务器，主要进行读的操作。· 6.1 引入dynamic-datasource-spring-boot-starter12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 6.2 配置数据源123456789spring.datasource.primary=master #指定默认数据源spring.datasource.dynamic.datasource.master.driver-class-name=com.mysql.jdbc.Driverspring.datasource.dynamic.datasource.master.url=jdbc:mysql://localhost:3306/mybatis-plus?characterEncoding=UTF-8spring.datasource.dynamic.datasource.master.username=rootspring.datasource.dynamic.datasource.master.password=rootspring.datasource.dynamic.datasource.slave_1.driver-class-name=com.mysql.jdbc.Driverspring.datasource.dynamic.datasource.slave_1.url=jdbc:mysql://localhost:3306/mybatis-plus-1?characterEncoding=UTF-8spring.datasource.dynamic.datasource.slave_1.username=rootspring.datasource.dynamic.datasource.slave_1.password=root 6.3 创建多个数据库模拟不同mysql服务6.4 @DS注解 作用: 用来切换数据源的注解 修饰范围: 方法上和类上，同时存在方法注解优先于类上注解。 Value属性: 切换数据源名称 6.5 开发业务层 业务接口 1234public interface UserService&#123; List&lt;User&gt; findAll(); void save(User user);&#125; 业务实现类 1234567891011121314151617@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDAO userDAO; @Override public List&lt;User&gt; findAll() &#123; return userDAO.selectList(null); &#125; @Override public void save(User user) &#123; userDAO.insert(user); &#125;&#125; 6.6 测试结果1234567891011121314151617181920212223242526272829package com.baizhi;import com.baizhi.entity.User;import com.baizhi.service.UserService;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.Date;@SpringBootTestpublic class TestUserService &#123; @Autowired private UserService userService; @Test public void testFindAll()&#123; userService.findAll().forEach(user-&gt; System.out.println(\"user = \" + user)); &#125; @Test public void testSave()&#123; User user = new User(); user.setName(\"aaa\").setAge(23).setBir(new Date()); userService.save(user); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://nlbyd1119.online/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"传感器","slug":"a-hw-1","date":"2020-09-12T14:49:21.000Z","updated":"2020-09-13T06:07:28.216Z","comments":true,"path":"2020/09/12/a-hw-1/","link":"","permalink":"http://nlbyd1119.online/2020/09/12/a-hw-1/","excerpt":"","text":"传感器概述 123456789传感器是第二代智能手机的重要标志之一。可以毫不客气地说，现在市面上的Android手机和平板电脑（TV除外）都内置了传感器。否则很多游戏和应用就无法使用了。AndroidSDK支持的传感器并不是每一部Android设备都支持所有的传感器。大多数Android设备只支持一部分传感器。例如，方向传感器（电子罗盘）、重力传感器（屏幕翻转、赛车游戏等）。动作（Motion）传感器环境（Environmental）传感器位置（Position）传感器 一、动作传感器 123456这类传感器在三个轴（X、Y、Z）上测量加速度和旋转角度。包括如下几个传感器。加速（accelerometer）传感器重力（gravity）传感器陀螺仪（gyroscope）传感器旋转向量（rotational vector ）传感器 二、环境传感器 12345这类传感器可以测量不同环境的参数，例如，周围环境的空气温度和压强、光照强度和湿度。包括如下几个传感器。湿度（barometer）传感器光线（photometer）传感器温度（thermometer）传感器 三、位置传感器 123这类传感器可以测量设备的物理位置。包括如下几个传感器。方向（orientation）传感器磁力（magnetometer）传感器 四、Android sensor framework 123456789Android SDK提供了Android sensor framework，可以用来访问当前Android设备内置的传感器。ASF提供了很多类和接口，可以帮助我们完成各种与传感器有关的任务。例如，可以利用ASF完成下面的工作。确定当前Android设备内置了哪些传感器。确定某一个传感器的技术指标。例如，该传感器能测量的最大范围、传感器的制造商、对电量的要求、测量的精度等。获取传感器传回来的数据，以及定义传感器回传数据的精度。注册和注销传感器事件监听器，这些监听器用于监听传感器的变化，通常从传感器回传的数据需要利用这些监听器完成。 五、硬件传感器和软件传感器 12345678910ASF允许我们访问很多传感器类型，这些传感器有一些是基于硬件的传感器，还有一些是基于软件的传感器。基于硬件的传感器就是直接以芯片形式嵌入到Android设备中，这些传感器直接从外部环境获取数据，例如，加速传感器、磁场传感器都属于硬件传感器。基于软件的传感器并不是实际的硬件芯片，尽管这些传感器重使用上很像基于硬件的传感器。基于软件的传感器传回的数据本质上也来自于基于硬件的传感器，只是这些数据通常会经过二次加工，也就是说，基于软件的传感器传回的数据可能来自一个或多个基于硬件的传感器，并且有可能Android系统使用某些算法处理了这些数据。所以基于软件的传感器也可以称为虚拟（virtual）传感器或合成（synthetic）传感器。 六、ASF支持的传感器 12345678910111213141516所有的常量都在Sensor类中定义。1. TYPE_ACCELEROMETER：加速传感器（硬件传感器）2. TYPE_AMBIENT_TEMPERATURE：温度传感器（硬件传感器）3. TYPE_GRAVITY：重力传感器（硬件或软件传感器）4. TYPE_GYROSCOPE：陀螺仪传感器（硬件传感器）5. TYPE_LIGHT：光线传感器（硬件传感器）6. TYPE_LINEAR_ACCELERATION：线性加速传感器（硬件或软件传感器）7. TYPE_MAGNETIC_FIELD：磁场传感器（硬件传感器）8. TYPE_ORIENTATION：方向传感器（软件传感器），数据来自重力和磁场传感器9. TYPE_PRESSURE：压力传感器（硬件传感器）10.TYPE_PROXIMITY：临近传感器（硬件传感器）11.TYPE_RELATIVE_HUMIDITY：湿度传感器（硬件传感器）12.TYPE_ROTATION_VECTOR：旋转向量传感器（硬件或软件传感器）13. TYPE_TEMPERATURE：温度传感器（硬件传感器），从Android4.0（APILevel=14）开始被TYPE_AMBIENT_TEMPERATURE取代。 七、ASF主要类和接口 12345678910SensorManager类：用于创建sensorservice的实例。该类提供了很多用于访问和枚举传感器，注册和注销传感器监听器的方法。而且还提供了与传感器精度、扫描频率、校正有关的常量。Sensor类：提供了一些用于获取传感器技术参数的方法。如版本、类型、生产商等。SensorEvent类：系统使用该类创建传感器事件对象。该对象可以提供与传感器事件有关的信息。传感器事件对象包括的信息有原始的传感器回传数据、传感器类型、数据的精度以及触发事件的时间。SensorEventListener接口：该接口包含两个回调方法，当传感器的回传值或精度发生变化时，系统会调用这两个回调方法。 八、获取本机所有传感器信息 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private TextView tvSensors; private SensorManager sensorManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvSensors = (TextView) findViewById(R.id.tvSensors); sensorManager = (SensorManager)getSystemService(SENSOR_SERVICE); List&lt;Sensor&gt; sensors = sensorManager.getSensorList(Sensor.TYPE_ALL); for(Sensor sensor: sensors) &#123; tvSensors.append(sensor.getName() + \"\\n\"); &#125; &#125;&#125;","categories":[{"name":"硬件","slug":"硬件","permalink":"http://nlbyd1119.online/categories/%E7%A1%AC%E4%BB%B6/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"vue-elementui","slug":"vue-elementui","date":"2020-09-12T06:50:15.000Z","updated":"2020-09-12T13:46:44.302Z","comments":true,"path":"2020/09/12/vue-elementui/","link":"","permalink":"http://nlbyd1119.online/2020/09/12/vue-elementui/","excerpt":"","text":"vue","categories":[{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"vue基本/组件路由/脚手架","slug":"vue基本-组件路由-脚手架","date":"2020-09-12T06:48:52.000Z","updated":"2020-09-12T13:46:47.832Z","comments":true,"path":"2020/09/12/vue基本-组件路由-脚手架/","link":"","permalink":"http://nlbyd1119.online/2020/09/12/vue%E5%9F%BA%E6%9C%AC-%E7%BB%84%E4%BB%B6%E8%B7%AF%E7%94%B1-%E8%84%9A%E6%89%8B%E6%9E%B6/","excerpt":"","text":"vue","categories":[{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"redis","slug":"redis","date":"2020-09-12T06:47:40.000Z","updated":"2020-09-15T12:24:25.787Z","comments":true,"path":"2020/09/12/redis/","link":"","permalink":"http://nlbyd1119.online/2020/09/12/redis/","excerpt":"","text":"redis 概述与特性 Redis是一个高性能key/value内存型数据库 Redis支持丰富的数据类型 String List Set ZSet Hash Redis支持持久化 内存数据 持久到硬盘中 Redis单线程,单进程 线程安全 分布式锁 效率高 环境与启动 一、windows本机win7下环境配置：在redis中文网http://www.redis.cn/ 下载相关软件安装客户端redis desktop manager 可查看库情况二、Linuxdocker方式 库和键相关指令 一、操作库 12345678910# 1.Redis中库说明- 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15- 可以使用select 库的编号 来选择一个redis的库# 2.Redis中操作库的指令- 清空当前的库 FLUSHDB- 清空全部的库 FLUSHALL# 3.redis客户端显示中文- ./redis-cli -p 7000 --raw 二、操作库设置、删除、是否存在、设置失效期限（三个）、匹配、移动、剩余生成时间（两个）、随机返回、重命名、判断类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# 1.DEL指令- 语法 : DEL key [key ...] - 作用 : 删除给定的一个或多个key 。不存在的key 会被忽略。- 可用版本： &gt;= 1.0.0- 返回值： 被删除key 的数量。 # 2.EXISTS指令- 语法: EXISTS key- 作用: 检查给定key 是否存在。- 可用版本： &gt;= 1.0.0- 返回值： 若key 存在，返回1 ，否则返回0。# 3.EXPIRE- 语法: EXPIRE key seconds- 作用: 为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。- 可用版本： &gt;= 1.0.0- 时间复杂度： O(1)- 返回值：设置成功返回1 。# 4.KEYS- 语法 : KEYS pattern- 作用 : 查找所有符合给定模式pattern 的key 。- 语法: KEYS * 匹配数据库中所有key 。 KEYS h?llo 匹配hello ，hallo 和hxllo 等。 KEYS h*llo 匹配hllo 和heeeeello 等。 KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 \"\\\" 隔开- 可用版本： &gt;= 1.0.0- 返回值： 符合给定模式的key 列表。# 5.MOVE- 语法 : MOVE key db- 作用 : 将当前数据库的key 移动到给定的数据库db 当中。- 可用版本： &gt;= 1.0.0- 返回值： 移动成功返回1 ，失败则返回0 。# 6.PEXPIRE- 语法 : PEXPIRE key milliseconds- 作用 : 这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。- 可用版本： &gt;= 2.6.0- 时间复杂度： O(1)- 返回值：设置成功，返回1 key 不存在或设置失败，返回0# 7.PEXPIREAT- 语法 : PEXPIREAT key milliseconds-timestamp- 作用 : 这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。- 可用版本： &gt;= 2.6.0- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)# 8.TTL- 语法 : TTL key- 作用 : 以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。- 可用版本： &gt;= 1.0.0- 返回值： 当key 不存在时，返回-2 。 当key 存在但没有设置剩余生存时间时，返回-1 。 否则，以秒为单位，返回key 的剩余生存时间。- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。# 9.PTTL- 语法 : PTTL key- 作用 : 这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。- 可用版本： &gt;= 2.6.0- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。- 否则，以毫秒为单位，返回key 的剩余生存时间。- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。# 10.RANDOMKEY- 语法 : RANDOMKEY- 作用 : 从当前数据库中随机返回(不删除) 一个key 。- 可用版本： &gt;= 1.0.0- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。# 11.RENAME- 语法 : RENAME key newkey- 作用 : 将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。- 可用版本： &gt;= 1.0.0- 返回值： 改名成功时提示OK ，失败时候返回一个错误。# 12.TYPE- 语法 : TYPE key- 作用 : 返回key 所储存的值的类型。- 可用版本： &gt;= 1.0.0- 返回值： none (key 不存在) string (字符串) list (列表) set (集合) zset (有序集) hash (哈希表) 数据类型及相关指令 一、String 12345678910111213141516171819| 命令 | 说明 || ------------------------------------------ | ------------------------------------------ || set | 设置一个key/value || get | 根据key获得对应的value || mset | 一次设置多个key value || mget | 一次获得多个key的value || getset | 获得原始key的值，同时设置新值 || strlen | 获得对应key存储value的长度 || append | 为对应key的value追加内容 || getrange 索引0开始 | 截取value的内容 || setex | 设置一个key存活的有效期（秒） || psetex | 设置一个key存活的有效期（毫秒） || setnx | 存在不做任何操作,不存在添加 || msetnx原子操作(只要有一个存在不做任何操作) | 可以同时设置多个key,只有有一个存在都不保存 || decr | 进行数值类型的-1操作 || decrby | 根据提供的数据进行减法操作 || Incr | 进行数值类型的+1操作 || incrby | 根据提供的数据进行加法操作 || Incrbyfloat | 根据提供的数据加入浮点数 | 二、Set 12345678910111213| 命令 | 说明 || ----------- | -------------------------------------------------- || sadd | 为集合添加元素 || smembers | 显示集合中所有元素 无序 || scard | 返回集合中元素的个数 || spop | 随机返回一个元素 并将元素在集合中删除 || smove | 从一个集合中向另一个集合移动元素 必须是同一种类型 || srem | 从集合中删除一个元素 || sismember | 判断一个集合中是否含有这个元素 || srandmember | 随机返回元素 || sdiff | 去掉第一个集合中其它集合含有的相同元素 || sinter | 求交集 || sunion | 求和集 | 三、ZSet 1234567891011| 命令 | 说明 || -------------------------- | ---------------------------- || zadd | 添加一个有序集合元素 || zcard | 返回集合的元素个数 || zrange 升序 zrevrange 降序 | 返回一个范围内的元素 || zrangebyscore | 按照分数查找一个范围内的元素 || zrank | 返回排名 || zrevrank | 倒序排名 || zscore | 显示某一个元素的分数 || zrem | 移除某一个元素 || zincrby | 给某个特定元素加分 | 四、Hash 1234567891011121314| 命令 | 说明 || ------------ | ----------------------- || hset | 设置一个key/value对 || hget | 获得一个key对应的value || hgetall | 获得所有的key/value对 || hdel | 删除某一个key/value对 || hexists | 判断一个key是否存在 || hkeys | 获得所有的key || hvals | 获得所有的value || hmset | 设置多个key/value || hmget | 获得多个key的value || hsetnx | 设置一个不存在的key的值 || hincrby | 为value进行加法运算 || hincrbyfloat | 为value加入浮点值 | 持久化机制 client redis[内存] —–&gt; 内存数据- 数据持久化–&gt;磁盘Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是: 快照(Snapshot) AOF (Append Only File) 只追加日志文件 一、快照特点这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是redis的默认开启持久化方式,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。快照生成方式 客户端方式: BGSAVE 和 SAVE指令 服务器配置自动触发 123456789101112# 1.客户端方式之BGSAVE- a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`# 2.客户端方式之SAVE- b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令# 3.服务器配置方式之满足配置自动触发- 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令# 4.服务器接收客户端shutdown指令- 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器 配置生成快照名称和位置 12345#1.修改生成快照名称- dbfilename dump.rdb# 2.修改生成位置- dir ./ 二、AOF特点这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.开启AOF持久化在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启 123# 1.开启AOF持久化- a.修改 appendonly yes 开启持久化- b.修改 appendfilename \"appendonly.aof\" 指定生成文件名称 日志追加频率 12345678910111213141516# 1.always 【谨慎使用】- 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度- 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;- 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;- 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。# 2.everysec 【推荐】- 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘- 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。# 3.no 【不推荐】- 说明: 由操作系统决定何时同步 - 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。修改日志同步频率- 修改appendfsync everysec|always|no 指定 三、AOF重写AOF带来的问题AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。AOF重写用来在一定程度上减小AOF文件的体积触发重写方式 123456# 1.客户端方式触发重写- 执行BGREWRITEAOF命令 不会阻塞redis的服务# 2.服务器配置方式自动触发- 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓- 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大 重写原理 注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。 12345# 重写流程- 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令- 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。- 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。- 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。 四、总结两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。 无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。 java操作redis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321 &lt;!--引入jedis连接依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt;TestRedis.javaimport redis.clients.jedis.Jedis;import java.util.Set;//测试redis连接public class TestRedis &#123; public static void main(String[] args) &#123; //创建jedis客户端对象 Jedis jedis = new Jedis(\"192.168.202.205\",7000); //选择使用一个库 默认:使用 0号库 jedis.select(0); //获取redis中所有key信息 Set&lt;String&gt; keys = jedis.keys(\"*\"); keys.forEach(key-&gt; System.out.println(\"key = \" + key)); //操作库相关 //jedis.flushDB();//清空当前库 jedis.flushAll();//清空所有库 //释放资源 jedis.close(); &#125;&#125;TestKey.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;public class TestKey &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试key相关 @Test public void testKeys()&#123; //删除一个key jedis.del(\"name\"); //删除多个key //jedis.del(\"name\",\"age\"); //判断一个key是否存在exits Boolean name = jedis.exists(\"name\"); System.out.println(name); //设置一个key超时时间 expire pexpire //Long age = jedis.expire(\"age\", 100); //System.out.println(age); //获取一个key超时时间 ttl Long age1 = jedis.ttl(\"newage\"); System.out.println(age1); //随机获取一个key String s = jedis.randomKey(); //修改key名称 // jedis.rename(\"age\",\"newage\"); //查看可以对应值的类型 String name1 = jedis.type(\"name\"); System.out.println(name1); String maps = jedis.type(\"maps\"); System.out.println(maps); &#125;&#125;TestString.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.List;public class TestString &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试String相关 @Test public void testString()&#123; //set jedis.set(\"name\",\"小陈\"); //get String s = jedis.get(\"name\"); System.out.println(s); //mset jedis.mset(\"content\",\"好人\",\"address\",\"海淀区\"); //mget List&lt;String&gt; mget = jedis.mget(\"name\", \"content\", \"address\"); mget.forEach(v-&gt; System.out.println(\"v = \" + v)); //getset String set = jedis.getSet(\"name\", \"小明\"); System.out.println(set); //............ &#125;&#125;TestList.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.BinaryClient;import redis.clients.jedis.Jedis;import java.util.List;public class TestList &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试List相关 @Test public void testList()&#123; //lpush jedis.lpush(\"names1\",\"张三\",\"王五\",\"赵柳\",\"win7\"); //rpush jedis.rpush(\"names1\",\"xiaomingming\"); //lrange List&lt;String&gt; names1 = jedis.lrange(\"names1\", 0, -1); names1.forEach(name-&gt; System.out.println(\"name = \" + name)); //lpop rpop String names11 = jedis.lpop(\"names1\"); System.out.println(names11); //llen jedis.linsert(\"lists\", BinaryClient.LIST_POSITION.BEFORE,\"xiaohei\",\"xiaobai\"); &#125;&#125;TestSet.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;public class TestSet &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试SET相关 @Test public void testSet()&#123; //sadd jedis.sadd(\"names\",\"zhangsan\",\"lisi\"); //smembers jedis.smembers(\"names\"); //sismember jedis.sismember(\"names\",\"xiaochen\"); //... &#125;&#125;TestZSet.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.BinaryClient;import redis.clients.jedis.Jedis;import java.util.List;public class TestZSet &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试ZSET相关 @Test public void testZset()&#123; //zadd jedis.zadd(\"names\",10,\"张三\"); //zrange jedis.zrange(\"names\",0,-1); //zcard jedis.zcard(\"names\"); //zrangeByScore jedis.zrangeByScore(\"names\",\"0\",\"100\",0,5); //.. &#125;&#125;TestHash.javaimport org.junit.After;import org.junit.Before;import org.junit.Test;import redis.clients.jedis.Jedis;public class TestHash &#123; private Jedis jedis; @Before public void before()&#123; this.jedis = new Jedis(\"192.168.202.205\", 7000); &#125; @After public void after()&#123; jedis.close(); &#125; //测试HASH相关 @Test public void testHash()&#123; //hset jedis.hset(\"maps\",\"name\",\"zhangsan\"); //hget jedis.hget(\"maps\",\"name\"); //hgetall jedis.hgetAll(\"mps\"); //hkeys jedis.hkeys(\"maps\"); //hvals jedis.hvals(\"maps\"); //.... &#125;&#125; springboot整合redis Spring Boot Data(数据) Redis 中提供了RedisTemplate和StringRedisTemplate，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。 注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口一、环境准备 12345678910引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;配置application.propertiespring.redis.host=localhostspring.redis.port=6379spring.redis.database=0 二、使用StringRedisTemplate和RedisTemplate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//启动springboot应用@SpringBootTestpublic class TestStringRedisTemplate &#123; //注入StringRedisTemplate @Autowired private StringRedisTemplate stringRedisTemplate; //key value 都是字符串 //操作redis中key相关 @Test public void testKey()&#123; //stringRedisTemplate.delete(\"name\");//删除一个key Boolean hasKey = stringRedisTemplate.hasKey(\"name\");//判断某个key是否存在 System.out.println(hasKey); DataType name = stringRedisTemplate.type(\"name\");//判断key所对应值的类型 System.out.println(name); Set&lt;String&gt; keys = stringRedisTemplate.keys(\"*\");//获取redis中所有key keys.forEach(key -&gt; System.out.println(\"key = \" + key)); Long expire = stringRedisTemplate.getExpire(\"age\");//获取key超时时间 -1 永不超时 -2 key不存在 &gt;=0 过期时间 System.out.println(expire); stringRedisTemplate.randomKey();//在redis中随机获取一个key //stringRedisTemplate.rename(\"age\",\"age1\");//修改key名字 要求key必须存在 不存在 报错 //stringRedisTemplate.renameIfAbsent(\"name\",\"name1\");//修改key名字 判断key是否存在 stringRedisTemplate.move(\"name1\",1);//移动key到指定库 &#125; //操作redis中字符串 opsForValue 实际操作就是redis中String类型 @Test public void testString()&#123; stringRedisTemplate.opsForValue().set(\"name\",\"小陈\"); //set 用来设置一个key value String value= stringRedisTemplate.opsForValue().get(\"name\"); //用来获取一个key对应value System.out.println(\"value = \" + value); stringRedisTemplate.opsForValue().set(\"code\",\"2357\",120, TimeUnit.SECONDS);//设置一个key 超时时间 stringRedisTemplate.opsForValue().append(\"name\",\"他是是一个好人,单纯少年!\");//追加 &#125; //操作redis中list类型 opsForList 实际操作就是redis中list类型 @Test public void testList()&#123; //stringRedisTemplate.opsForList().leftPush(\"names\",\"小陈\");//创建一个列表 并放入一个元素 //stringRedisTemplate.opsForList().leftPushAll(\"names\",\"小陈\",\"小张\",\"小王\");//创建一个列表 放入多个元素 List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add(\"xiaoming\"); names.add(\"xiaosan\"); //stringRedisTemplate.opsForList().leftPushAll(\"names\",names);//创建一个列表 放入多个元素 List&lt;String&gt; stringList = stringRedisTemplate.opsForList().range(\"names\", 0, -1); //遍历list stringList.forEach(value-&gt; System.out.println(\"value = \" + value)); stringRedisTemplate.opsForList().trim(\"names\",1,3); //截取指定区间的list &#125; //操作redis中set类型 opsForSet 实际操作就是redis中set类型 @Test public void testSet()&#123; stringRedisTemplate.opsForSet().add(\"sets\",\"张三\",\"张三\",\"小陈\",\"xiaoming\");//创建set 并放入多个元素 Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(\"sets\");//查看set中成员 sets.forEach(value-&gt; System.out.println(\"value = \" + value)); Long size = stringRedisTemplate.opsForSet().size(\"sets\");//获取set集合元素个数 System.out.println(\"size = \" + size); &#125; //操作redis中Zset类型 opsForZSet 实际操作就是redis中Zset类型 @Test public void testZset()&#123; stringRedisTemplate.opsForZSet().add(\"zsets\",\"小黑\",20);//创建并放入元素 Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(\"zsets\", 0, -1);//指定范围查询 zsets.forEach(value-&gt; System.out.println(value)); System.out.println(\"=====================================\"); Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zsets1 = stringRedisTemplate.opsForZSet().rangeByScoreWithScores(\"zsets\", 0, 1000);//获取指定元素以及分数 zsets1.forEach(typedTuple -&gt;&#123; System.out.println(typedTuple.getValue()); System.out.println(typedTuple.getScore()); &#125;); &#125; //操作redis中Hash类型 opsForHash 实际操作就是redis中Hash类型 @Test public void testHash()&#123; stringRedisTemplate.opsForHash().put(\"maps\",\"name\",\"张三\");//创建一个hash类型 并放入key value Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(\"age\",\"12\"); map.put(\"bir\",\"2012-12-12\"); stringRedisTemplate.opsForHash().putAll(\"maps\",map); //放入多个key value List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(\"maps\", Arrays.asList(\"name\", \"age\"));//获取多个key的value values.forEach(value-&gt; System.out.println(value)); String value = (String) stringRedisTemplate.opsForHash().get(\"maps\", \"name\");//获取hash中某个key的值 List&lt;Object&gt; vals = stringRedisTemplate.opsForHash().values(\"maps\");//获取所有values Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(\"maps\");//获取所有keys &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//启动springboot应用@SpringBootTestpublic class TestRedisTemplate &#123; //注入RedisTemplate key Object Value Object ===&gt; 对象序列化 name new User() ====&gt; name序列化 对象序列化结果 @Autowired private RedisTemplate redisTemplate; //opsForxxx Value String List Set Zset hash @Test public void testRedisTemplate()&#123; /** * redisTemplate对象中 key 和 value 的序列化都是 JdkSerializationRedisSerializer * key: string * value: object * 修改默认key序列化方案 : key StringRedisSerializer */ //修改key序列化方案 String类型序列 redisTemplate.setKeySerializer(new StringRedisSerializer()); //修改hash key 序列化方案 redisTemplate.setHashKeySerializer(new StringRedisSerializer()); User user = new User(); user.setId(UUID.randomUUID().toString()).setName(\"小陈\").setAge(23).setBir(new Date()); redisTemplate.opsForValue().set(\"user\", user);//redis进行设置 对象需要经过序列化 User user1 = (User) redisTemplate.opsForValue().get(\"user\"); System.out.println(user1); redisTemplate.opsForList().leftPush(\"list\",user); redisTemplate.opsForSet().add(\"set\",user); redisTemplate.opsForZSet().add(\"zset\",user,10); redisTemplate.opsForHash().put(\"map\",\"name\",user); &#125;&#125; 三、绑定api和应用场景 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//启动springboot应用@SpringBootTestpublic class TestRedisTemplate &#123; //注入RedisTemplate key Object Value Object ===&gt; 对象序列化 name new User() ====&gt; name序列化 对象序列化结果 @Autowired private RedisTemplate redisTemplate; //opsForxxx Value String List Set Zset hash @Test public void testRedisTemplate()&#123; /** * redisTemplate对象中 key 和 value 的序列化都是 JdkSerializationRedisSerializer * key: string * value: object * 修改默认key序列化方案 : key StringRedisSerializer */ //修改key序列化方案 String类型序列 redisTemplate.setKeySerializer(new StringRedisSerializer()); //修改hash key 序列化方案 redisTemplate.setHashKeySerializer(new StringRedisSerializer()); User user = new User(); user.setId(UUID.randomUUID().toString()).setName(\"小陈\").setAge(23).setBir(new Date()); redisTemplate.opsForValue().set(\"user\", user);//redis进行设置 对象需要经过序列化 User user1 = (User) redisTemplate.opsForValue().get(\"user\"); System.out.println(user1); redisTemplate.opsForList().leftPush(\"list\",user); redisTemplate.opsForSet().add(\"set\",user); redisTemplate.opsForZSet().add(\"zset\",user,10); redisTemplate.opsForHash().put(\"map\",\"name\",user); &#125;&#125; 分布式缓存 基于mybatis缓存和redis实现的分布式缓存（每个cache标签是在每个mapper中配置的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.nlby.boot_redis.cache;import com.nlby.boot_redis.util.ApplicationContextUtils;import org.apache.ibatis.cache.Cache;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;import org.springframework.util.DigestUtils;import java.util.concurrent.TimeUnit;//自定义Redis缓存实现public class RedisCache implements Cache &#123; //当前放入缓存的mapper的namespace private final String id; //必须存在构造方法 public RedisCache(String id) &#123; System.out.println(\"id:=====================&gt; \" + id); this.id = id; &#125; //返回cache唯一标识 @Override public String getId() &#123; return this.id; &#125; //缓存放入值 redis RedisTemplate StringRedisTemplate @Override public void putObject(Object key, Object value) &#123; System.out.println(\"key:\" + key.toString()); System.out.println(\"value:\" + value);// //通过application工具类获取redisTemplate// RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");// redisTemplate.setKeySerializer(new StringRedisSerializer());// redisTemplate.setHashKeySerializer(new StringRedisSerializer()); //使用redishash类型作为缓存存储模型 key hashkey value getRedisTemplate().opsForHash().put(id.toString(),getKeyToMD5(key.toString()),value); if(id.equals(\"com.baizhi.dao.UserDAO\"))&#123; //缓存超时 client 用户 client 员工 getRedisTemplate().expire(id.toString(),1, TimeUnit.HOURS); &#125; if(id.equals(\"com.baizhi.dao.CityDAO\"))&#123; //缓存超时 client 用户 client 员工 getRedisTemplate().expire(id.toString(),30, TimeUnit.MINUTES); &#125; //.....指定不同业务模块设置不同缓存超时时间 &#125; //获取中获取数据 @Override public Object getObject(Object key) &#123; System.out.println(\"key:\" + key.toString());// //通过application工具类获取redisTemplate// RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\");// redisTemplate.setKeySerializer(new StringRedisSerializer());// redisTemplate.setHashKeySerializer(new StringRedisSerializer()); //根据key 从redis的hash类型中获取数据 return getRedisTemplate().opsForHash().get(id.toString(), getKeyToMD5(key.toString())); &#125; //注意:这个方法为mybatis保留方法 默认没有实现 后续版本可能会实现 @Override public Object removeObject(Object key) &#123; System.out.println(\"根据指定key删除缓存\"); return null; &#125; @Override public void clear() &#123; System.out.println(\"清空缓存~~~\"); //清空namespace getRedisTemplate().delete(id.toString());//清空缓存 &#125; //用来计算缓存数量 @Override public int getSize() &#123; //获取hash中key value数量 return getRedisTemplate().opsForHash().size(id.toString()).intValue(); &#125; //封装redisTemplate private RedisTemplate getRedisTemplate()&#123; //通过application工具类获取redisTemplate RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(\"redisTemplate\"); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); return redisTemplate; &#125; //封装一个对key进行md5处理方法 private String getKeyToMD5(String key)&#123; return DigestUtils.md5DigestAsHex(key.getBytes()); &#125;&#125;","categories":[{"name":"NoSql","slug":"NoSql","permalink":"http://nlbyd1119.online/categories/NoSql/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"可视化页面设计工具","slug":"可视化页面设计工具","date":"2020-08-04T11:24:33.000Z","updated":"2020-08-04T12:05:23.814Z","comments":true,"path":"2020/08/04/可视化页面设计工具/","link":"","permalink":"http://nlbyd1119.online/2020/08/04/%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1%E5%B7%A5%E5%85%B7/","excerpt":"","text":"为给后端练习提供一个方便的创建简单前端网站的方案，就可视化的页面设计工具这一目标进行搜索，寻找可用的工具。 先写结论 若是创建简单的网站，则使用bootstrap提供的在线网站就行了：http://www.ibootstrap.cn/ 经测试可用需引入 1234&lt;link href=\"http://cdn.staticfile.org/twitter-bootstrap/3.0.1/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;script type=\"text/javascript\" src=\"http://cdn.staticfile.org/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://cdn.staticfile.org/jqueryui/1.10.2/jquery-ui.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://cdn.staticfile.org/twitter-bootstrap/3.0.1/js/bootstrap.min.js\"&gt;&lt;/script&gt; 另一类似的也可用https://www.bootcss.com/p/layoutit/ 若是正经开发前端可使用adobe公司的 Dreamweaver相关教程https://www.bilibili.com/video/BV1NE411C7bR?from=search&amp;seid=10991897659299638582https://search.bilibili.com/all?keyword=Dreamweaver&amp;from_source=nav_search_new 其他可能有用的网站或工具 http://www.coolsite360.com/sites/a3iqel_draft/simple#http://www.coolsite360.com/s/?first=truehttp://www.diygw.com/index.htmlhttps://www.layoutit.com/build 参考文章 https://www.edutt.com/news_show_336013/http://www.html580.com/6164https://blog.csdn.net/zyxhangiian123456789/article/details/100901970https://blog.csdn.net/qq_21213785/article/details/84059121https://blog.csdn.net/qq_33131171/article/details/100883137https://www.v2ex.com/amp/t/568094https://www.cnblogs.com/danhuai/p/12172558.htmlhttps://ant-design.gitee.io/docs/spec/introduce-cn","categories":[{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"zimug_study_1","slug":"zimug_study_1","date":"2020-08-03T13:02:43.000Z","updated":"2020-09-04T01:51:35.082Z","comments":true,"path":"2020/08/03/zimug_study_1/","link":"","permalink":"http://nlbyd1119.online/2020/08/03/zimug_study_1/","excerpt":"从七月初到现在近一个月内，断断续续的看了zimug的spring security视频教程和springboot的前十几节教程，一直想总结一下里面可以学习的点，但始终没时间，现在抽空开始这个系列进行测试记录和要点总结，旨在吸收学习其写法。","text":"从七月初到现在近一个月内，断断续续的看了zimug的spring security视频教程和springboot的前十几节教程，一直想总结一下里面可以学习的点，但始终没时间，现在抽空开始这个系列进行测试记录和要点总结，旨在吸收学习其写法。 首先，记述一下准备过程中的问题 zimug的源码是充分利用 version control的怎样运行checkout后的代码为何有这个问题，因为在将zimug的权限相关代码clone并用idea打开后，发现源码并没有执行的选项，在springboot的引导类中没有运行的选项。这使我以为是checkout到某个旧版本导致的错误，但后面观察到的两点，说明问题不是这个地方引起的。首先，我把代码切到了最新版本，还是没有，然后我又看zimug的另一个springboot的源码，发现切到旧版本也是有运行选项的。然后就发现其实是导入的github项目中有两个模块，但导入时idea并没有将其识别为模块，因此相关依赖没导入，也不可能有运行选项，因为编译器就没把它当可运行的模块。在project structure中import module，选择相应文件夹，选择import module from external model – maven即可将其添加为模块，可以识别后就能运行了。 运行后，发现两点首先是报错org.apache.catalina.LifecycleException: Protocol handler start failed，根据 https://blog.csdn.net/qq_39410381/article/details/103263766 是端口已被占用导致的然后是在version control下，修改了某个tag的代码，编译器中该文件文件名会变绿 这样确保了可以进行运行测试 对zimug权限源码基本环境的要点进行分析 一、swagger2构建API文档两部分，一是配置，二是导出文档方法。配置应从swagger文档组成分析结合代码进行，理清能实现怎样的效果；导出，应自行测试完全符合需求的步骤。（一）基本使用引入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 配置完成后，访问如一下url即可查看接口文档http://ip:port/swagger-ui.html（二）配置配置分两个部分，基础配置和文档组成的配置基础配置需要一个单独的配置文件，包括基本文档头信息、需扫描包和url的配置 12345678910111213141516171819202122232425@Configuration@EnableSwagger2public class SwaggerConfig &#123; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"boot lanunch 项目 API文档\") .description(\"简单优雅的restfun风格\") .termsOfServiceUrl(\"http://github.nlby.com\") .version(\"1.0\") .build(); &#125; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //扫描basePackage包下面的“/rest/”路径下的内容作为接口文档构建的目标 .apis(RequestHandlerSelectors.basePackage(\"com.zimug.boot.launch\")) .paths(PathSelectors.regex(\"/rest/.*\")) .build(); &#125;&#125; 然后是通过在controller和实体类中添加注解实现的详细文档配置。先总结下接口文档的组成部分和一些注意点： 首先，除文档头部信息外的主要部分，是以每个controller为单位，其下再有对应的post get put delete操作。形式上根据标签划分，这个标签可以通过在controller上添加如@Api(tags = “Article”)形式的注解指定，如果不指定那么默认以该controller的名称加中划线连接。 对于一个controller的某个特定方法，其组成从上到下依次是：HTTP方法类型–url–方法名；返回成功状态说明–返回值例子/模型类–返回Content Type；请求参数–测试值–描述–参数类型；返回值信息（状态码及返回数据与相应含义，除200外的）；测试选项。 示例如下：（三）导出markdown和html格式的文档依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-core&lt;/artifactId&gt; &lt;version&gt;1.5.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-models&lt;/artifactId&gt; &lt;version&gt;1.5.16&lt;/version&gt;&lt;/dependency&gt; 导出markdown 12345678910111213141516@Testpublic void generateMarkdownDocsToFile() throws Exception &#123; // 输出Markdown到单文件 Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder() .withMarkupLanguage(MarkupLanguage.MARKDOWN) .withOutputLanguage(Language.ZH) .withPathsGroupedBy(GroupBy.TAGS) .withGeneratedExamples() .withoutInlineSchema() .build(); Swagger2MarkupConverter.from(new URL(\"http://localhost:8888/v2/api-docs\")) .withConfig(config) .build() .toFile(Paths.get(\"src/main/resources/docs/markdown\"));&#125; 导出html需要先通过代码生成asciidoc，再通过插件生成 123456789101112131415161718192021@ExtendWith(SpringExtension.class) //@RunWith(SpringRunner.class) //Junit4开发者使用这个注解@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)public class SwaggerExportTests &#123; @Test public void generateAsciiDocs() throws Exception &#123; // 输出Ascii格式 Swagger2MarkupConfig config = new Swagger2MarkupConfigBuilder() .withMarkupLanguage(MarkupLanguage.ASCIIDOC) //设置生成格式 .withOutputLanguage(Language.ZH) //设置语言中文还是其他语言 .withPathsGroupedBy(GroupBy.TAGS) .withGeneratedExamples() .withoutInlineSchema() .build(); Swagger2MarkupConverter.from(new URL(\"http://localhost:8888/v2/api-docs\")) .withConfig(config) .build() .toFile(Paths.get(\"src/main/resources/docs/asciidoc\")); &#125;&#125; 123456789101112&lt;plugin&gt; &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt; &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;configuration&gt; &lt;swaggerInput&gt;http://localhost:8888/v2/api-docs&lt;/swaggerInput&gt;&lt;!---swagger-api-json路径--&gt; &lt;outputDir&gt;src/main/resources/docs/asciidoc&lt;/outputDir&gt;&lt;!---生成路径--&gt; &lt;config&gt; &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;&lt;!--生成格式--&gt; &lt;/config&gt; &lt;/configuration&gt;&lt;/plugin&gt; 需要注意的是，tiFile指定的路径最后是表示文件名而非文件夹名 二、lombok @Data注解在java类上使用@Data注解，将为我们在编译期自动生成成员变量的get和set方法equals方法canEqual方法hashCode方法toString方法 @Slf4j注解将在编译期自动帮我们引入Logger日志常量，我们在代码中就直接使用log.info或log.debug打印日志即可。 @Builder注解在Java类上使用Builder注解之后，我们可以使用如下代码为对象属性赋值 AllArgsConstructor注解AllArgsConstructor注解将为我们在编译期自动生成：全参构造函数。有全参构造函数注解，自然就有无参构造函数注解：NoArgsConstructor注解。 @Accessorshttps://blog.csdn.net/weixin_38229356/article/details/82937420https://www.jianshu.com/p/bc01f3cf235d 三、统一数据处理（一）统一数据响应接口下面这个类是用于统一数据响应接口标准的。它的作用是：统一所有开发人员响应前端请求的返回结果格式，减少前后端开发人员沟通成本，是一种RESTful接口标准化的开发约定。下面代码只对请求成功的情况进行封装。 1234567891011121314151617181920212223242526272829303132333435363738394041@Datapublic class AjaxResponse &#123; private boolean isok; //请求是否处理成功 private int code; //请求响应状态码（200、400、500） private String message; //请求结果描述信息 private Object data; //请求结果数据（通常用于查询操作） private AjaxResponse()&#123;&#125; //请求成功的响应，不带查询数据（用于删除、修改、新增接口） public static AjaxResponse success()&#123; AjaxResponse ajaxResponse = new AjaxResponse(); ajaxResponse.setIsok(true); ajaxResponse.setCode(200); ajaxResponse.setMessage(\"请求响应成功!\"); return ajaxResponse; &#125; //请求成功的响应，带有查询数据（用于数据查询接口） public static AjaxResponse success(Object obj)&#123; AjaxResponse ajaxResponse = new AjaxResponse(); ajaxResponse.setIsok(true); ajaxResponse.setCode(200); ajaxResponse.setMessage(\"请求响应成功!\"); ajaxResponse.setData(obj); return ajaxResponse; &#125; //请求成功的响应，带有查询数据（用于数据查询接口） public static AjaxResponse success(Object obj,String message)&#123; AjaxResponse ajaxResponse = new AjaxResponse(); ajaxResponse.setIsok(true); ajaxResponse.setCode(200); ajaxResponse.setMessage(message); ajaxResponse.setData(obj); return ajaxResponse; &#125;&#125; （二）HTTP协议的四种传参方式https://www.kancloud.cn/hanxt/springboot2/1730303（三）JSON数据处理https://www.kancloud.cn/hanxt/springboot2/1177587Jackson这些注解通常用于标注java实体类或实体类的属性。@JsonPropertyOrder(value={“pname1”,”pname2”}) 改变子属性在JSON序列化中的默认定义的顺序。如：param1在先，param2在后。@JsonIgnore 排除某个属性不做序列化与反序列化@JsonProperty(anotherName) 为某个属性换一个名称，体现在JSON数据里面@JsonInclude(JsonInclude.Include.NON_NULL) 排除为空的元素不做序列化反序列化@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”, timezone = “GMT+8”) 指定日期类型的属性格式","categories":[{"name":"功能点学习","slug":"功能点学习","permalink":"http://nlbyd1119.online/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"sql_study_1","slug":"sql_study_1","date":"2020-08-03T08:09:57.000Z","updated":"2020-08-03T09:01:56.296Z","comments":true,"path":"2020/08/03/sql_study_1/","link":"","permalink":"http://nlbyd1119.online/2020/08/03/sql_study_1/","excerpt":"对牛客网sql练习61道做一个简单总结","text":"对牛客网sql练习61道做一个简单总结 牛客网 https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&amp;rp=1&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking相关视频 https://www.bilibili.com/video/BV175411s7yr?p=6161道题，大概分为两个部分，前35道基本全是查询，后26道是一些其他语句的用法，最难写的大概在22-35这十几道。 PDF To Markdown ConverterDebug ViewResult View 查找最晚入职员工的所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天12345678CREATE TABLE &#96;employees&#96; (&#96;emp_no&#96; int(11) NOT NULL comment &#39;员工编号&#39;,&#96;birth_date&#96; date NOT NULL,&#96;first_name&#96; varchar(14) NOT NULL,&#96;last_name&#96; varchar(16) NOT NULL,&#96;gender&#96; char(1) NOT NULL,&#96;hire_date&#96; date NOT NULL,PRIMARY KEY (&#96;emp_no&#96;)); 123select *from employeeswhere hire_date &#x3D; (select max(hire_date) from employees); 01. 查找最晚入职员工的所有信息2020 年 5 月 18 日 8: 题目描述查找入职员工时间排名倒数第三的员工所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天12345678CREATE TABLE &#96;employees&#96; (&#96;emp_no&#96; int(11) NOT NULL,&#96;birth_date&#96; date NOT NULL,&#96;first_name&#96; varchar(14) NOT NULL,&#96;last_name&#96; varchar(16) NOT NULL,&#96;gender&#96; char(1) NOT NULL,&#96;hire_date&#96; date NOT NULL,PRIMARY KEY (&#96;emp_no&#96;)); 12345678select *from employeeswhere hire_date &#x3D; (select distinct hire_datefrom employeesorder by hire_date desclimit 2,); 02.查找入职员工时间排名倒数第三的员工所有信息2020 年 5 月 18 日 8: 题目描述查找各个部门当前(to_date=’9999- 01 - 01’)领导当前薪水详情以及其对应部门编号dept_no(请注 意输出结果，dept_no列是最后一列) CREATE TABLE dept_manager ( dept_no char(4) NOT NULL comment ‘部门编号’, emp_no int(11) NOT NULL comment ‘员工编号’, from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries ( emp_no int(11) NOT NULL comment ‘员工编号’, salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s.*, d.dept_nofrom salaries sinner join dept_manager don s.emp_no = d.emp_nowhere s.to_date=’9999- 01 - 01’and d.to_date=’9999- 01 - 01’; 03.查找各个部门当前领导当前薪水详情以及其对应部门编号dept_no2020 年 5 月 18 日 8: 题目描述查找所有已经分配部门的员工的last_name和first_name以及dept_no(请注意输出描述里各个列 的前后顺序) CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_nofrom employees einner join dept_emp don e.emp_no = d.emp_no; 04.查找所有已经分配部门的员工的last_name和first_name2020 年 5 月 18 日 8: 题目描述查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括暂时没有分配具体 部门的员工(请注意输出描述里各个列的前后顺序) CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_nofrom employees eleft join dept_emp don e.emp_no = d.emp_no; 注意：INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。主LEFT JOIN 从 会读取左边数据表的全部数据，即便右边表无对应数据。从RIGHT JOIN 主 会读取右边数据表的全部数据，即便左边表无对应数据。05.查找所有员工的last_name和first_name以及对应部门编号dept_no2020 年 5 月 18 日 8: 题目描述查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序(请注 意，一个员工可能有多次涨薪的情况) CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL, hire_date date NOT NULL,#入职 PRIMARY KEY (emp_no)); CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL, from_date date NOT NULL,#入职日期=from_date to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, s.salaryfrom employees einner join salaries son e.emp_no = s.emp_nowhere e.hire_date = s.from_dateorder by e.emp_no desc; 06.查找所有员工入职时候的薪水情况2020 年 5 月 18 日 8: 题目描述查找薪水涨幅超过 15 次的员工号emp_no以及其对应的涨幅次数t CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s.emp_no, count() tfrom salaries sgroup by s.emp_nohaving count() &gt; 15; 07.查找薪水涨幅超过 15 次的员工号emp_no以及其对应的涨幅次数t2020 年 5 月 18 日 8: 题目描述找出所有员工当前(to_date=’9999- 01 - 01’)具体的薪水salary情况，对于相同的薪水只显示一次, 并按照逆序显示 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select distinct salaryfrom salaries swhere s.to_date=’9999- 01 - 01’order by salary desc; select salaryfrom salaries swhere s.to_date=’9999- 01 - 01’group by salaryorder by salary desc; 08.找出所有员工当前具体的薪水salary情况2020 年 5 月 18 日 8: 题目描述获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示 to_date=’9999- 01 - 01’CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.emp_no, s.salaryfrom dept_manager dinner join salaries son d.emp_no = s.emp_nowhere d.to_date=’9999- 01 - 01’and s.to_date=’9999- 01 - 01’; 09.获取所有部门当前manager的当前薪水情况2020 年 5 月 18 日 8: 题目描述获取所有非manager的员工emp_no CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select emp_nofrom employeeswhere emp_no not in(select e.emp_nofrom employees einner join dept_manager don e.emp_no = d.emp_no); 10.获取所有非manager的员工emp_no2020 年 5 月 18 日 8: 题目描述获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示 to_date=’9999- 01 - 01’。 结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。 CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); select e.emp_no, m.emp_nofrom dept_emp einner join dept_manager mon e.dept_no = m.dept_nowhere e.emp_no &lt;&gt; m.emp_noand e.to_date=’9999- 01 - 01’and m.to_date=’9999- 01 - 01’; 11.获取所有员工当前的manager2020 年 5 月 18 日 8: 题目描述获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.emp_no, max(salary)from dept_emp dinner join salaries son d.emp_no = s.emp_nowhere d.to_date = ‘9999- 01 - 01’and s.to_date = ‘9999- 01 - 01’group by d.dept_no; 12.获取所有部门中当前员工薪水最高的相关信息2020 年 5 月 18 日 8: 题目描述从titles表获取按照title进行分组，每组个数大于等于 2 ，给出title以及对应的数目t。 CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select title, count() tfrom titlesgroup by titlehaving count() &gt;= 2; 13.从titles表获取按照title进行分组2020 年 5 月 18 日 8: 题目描述从titles表获取按照title进行分组，每组个数大于等于 2 ，给出title以及对应的数目t。 注意对于重复的emp_no进行忽略。 CREATE TABLE IF NOT EXISTS titles (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select title, count(distinct emp_no) tfrom titlesgroup by titlehaving t &gt;= 2; 14.从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略2020 年 5 月 18 日 8: 题目描述12345678910查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE &#96;employees&#96; (&#96;emp_no&#96; int(11) NOT NULL,&#96;birth_date&#96; date NOT NULL,&#96;first_name&#96; varchar(14) NOT NULL,&#96;last_name&#96; varchar(16) NOT NULL,&#96;gender&#96; char(1) NOT NULL,&#96;hire_date&#96; date NOT NULL,PRIMARY KEY (&#96;emp_no&#96;)); 12345select *from employees ewhere e.emp_no &amp; 1 &#x3D; 1and e.last_name !&#x3D; &#39;Mary&#39;order by e.hire_date desc; 15.查找employees表所有emp_no为奇数2020 年 5 月 18 日 8: 题目描述统计出当前各个title类型对应的员工当前（to_date=’9999- 01 - 01’）薪水对应的平均工资。结果 给出title以及平均工资avg。 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));CREATE TABLE IF NOT EXISTS “titles” (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); select t.title, avg(s.salary) avgfrom titles tinner join salaries son t.emp_no = s.emp_nowhere t.to_date=’9999- 01 - 01’and s.to_date=’9999- 01 - 01’group by t.title; 16.统计出当前各个title类型对应的员工当前薪水对应的平均工资2020 年 5 月 18 日 8: 题目描述获取当前（to_date=’9999- 01 - 01’）薪水第二多的员工的emp_no以及其对应的薪水salary CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select emp_no,salaryfrom salarieswhere to_date=’9999- 01 - 01’and salary = (select distinct salaryfrom salariesorder by salary desclimit 1,); 17.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary2020 年 5 月 18 日 8: 题目描述查找当前薪水(to_date=’9999- 01 - 01’)排名第二多的 员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, max(s.salary), e.last_name, e.first_namefrom employees einner join salaries son e.emp_no = s.emp_nowhere s.to_date = ‘9999- 01 - 01’and s.salary not in(select max(salary)from salarieswhere to_date = ‘9999- 01 - 01’); 18.查找当前薪水排名第二多的员工编号emp_no2020 年 5 月 18 日 8: 题目描述查找所有员工的last_name和first_name以及对应的dept_name， 也包括暂时没有分配部门的员工left join CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no)); CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name,first_name,dept_namefrom employees eleft join dept_emp de on e.emp_no = de.emp_noleft join departments d on d.dept_no = de.dept_no; 19.查找所有员工的last_name和first_name以及对应的dept_name2020 年 5 月 18 日 8: 题目描述查找员工编号emp_no为 10001 其自入职以来的薪水salary涨幅值growth CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select( #最近的-刚入职的 (select salary from salaries where emp_no = 10001 order by salary desc) (select salary from salaries where emp_no = 10001 order by salary)) growth; 20.查找员工编号emp_now为 10001 其自入职以来的薪水salary涨幅值growth2020 年 5 月 18 日 8: 题目描述查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅 growth，并按照growth进行升序 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select e.emp_no, (s1.salary -s2.salary) as growthfrom employees einner join salaries s1 on e.emp_no = s1.emp_no and s1.to_date = ‘9999- 01 - 01’#当前薪资 inner join salaries s2 on e.emp_no = s2.emp_no and e.hire_date = s2.from_date#入职薪资 order by growth asc; 21.查找所有员工自入职以来的薪水涨幅情况2020 年 5 月 18 日 8:47 题目描述统计各个部门的工资记录数，给出部门编码dept_no、部门名称dept_name以及次数sum CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select d.dept_no, d.dept_name,count(s.salary) ‘sum’from departments dinner join dept_emp de on d.dept_no = de.dept_noinner join salaries s on de.emp_no = s.emp_nogroup by d.dept_no; 22.统计各个部门对应员工涨幅的次数总和2020 年 5 月 18 日 8:47 题目描述对所有员工的当前(to_date=’9999- 01 - 01’)薪水按照salary进行按照 1 - N的排名， 相同salary并列且按照emp_no升序排列 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出描述: emp_no salary rank 110005 94692 1 110009 94409 2 110010 94409 2 110001 88958 3 110007 88070 4 110004 74057 5 110002 72527 6 110003 43311 7 110006 43311 7 110011 25828 8 来自&lt;https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tqId=29775&amp;tPage=2&amp;rp=&amp;ru=/ta/sql&amp;qru=/ta/sql/question-ranking&gt; select s1.emp_no, s1.salary, count(distinct s2.salary) rankfrom salaries s1, salaries s2where s1.to_date=’9999- 01 - 01’and s2.to_date=’9999- 01 - 01’and s1.salary &lt;= s2.salarygroup by s1.emp_noorder by s1.salary desc,s1.emp_no asc 23.对所有员工的当前薪水按照salary进行按照 1 - N的排名2020 年 5 月 18 日 8:47 题目描述获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ， 当前表示to_date=’9999- 01 - 01’ CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 1.查询所有员工的情况2.筛选掉manager员工 select de.dept_no,e.emp_no,s.salaryfrom employees einner join salaries son e.emp_no = s.emp_no and s.to_date=’9999- 01 - 01’inner join dept_emp deon e.emp_no = de.emp_nowhere de.emp_no not in(select emp_nofrom dept_manager dmwhere dm.to_date=’9999- 01 - 01’); 24.获取所有非manager员工当前的薪水情况2020 年 5 月 18 日 8:47 题目描述获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999- 01 - 01’, 结果第一列给出员工的emp_no， 第二列给出其manager的manager_no， 第三列给出该员工当前的薪水emp_salary, 第四列给该员工对应的manager当前的薪水manager_salary CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select de.emp_no emp_no,dm.emp_no manager_no,s1.salary emp_salary,s2.salary manager_salaryfrom dept_emp de, salaries s1, dept_manager dm, salaries s2where de.emp_no = s1.emp_noand s1.to_date=’9999- 01 - 01’and de.to_date=’9999- 01 - 01’and dm.emp_no = s2.emp_noand s2.to_date=’9999- 01 - 01’and dm.to_date=’9999- 01 - 01’and de.dept_no = dm.dept_noand s1.salary &gt; s2.salary; 25.获取员工其当前的薪水比其manager当前薪水还高的相关信息2020 年 5 月 18 日 8:47 题目描述汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当 前员工所有的title以及该类型title对应的数目count CREATE TABLE departments (dept_no char(4) NOT NULL,dept_name varchar(40) NOT NULL,PRIMARY KEY (dept_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE IF NOT EXISTS titles (emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); 输出描述:dept_no dept_name title count 1d001 Marketing Senior Engineer 1 1d001 Marketing Staff 1 1d002 Finance Senior Engineer 1 1d003 Human Resources Senior Staff 1 1d004 Production Senior Engineer 2 1d005 Development Senior Staff 1 1d006 Quality Management Engineer 2 1d006 Quality Management Senior Engineer 1 来自&lt;https://www.nowcoder.com/practice/4bcb6a7d3e39423291d2f7bdbbff87f8?tpId=82&amp;tqId=29778&amp;tPage=2&amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; select de.dept_no,d.dept_name,t.title,count(t.title) ‘count’from dept_emp deinner join titles ton de.emp_no = t.emp_noand de.to_date=’9999- 01 - 01’and t.to_date=’9999- 01 - 01’inner join departments d 26.汇总各个部门当前员工的title类型的分配数目2020 年 5 月 18 日 8:47 inner join departments don de.dept_no = d.dept_nogroup by de.dept_no, t.title; 题目描述给出每个员工每年薪水涨幅超过 5000 的员工编号emp_no、薪水变更开始日期from_date以及薪 水涨幅值salary_growth，并按照salary_growth逆序排列。 提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date) CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); select s2.emp_no,s2.from_date,(s2.salary -s1.salary) salary_growthfrom salaries s1, salaries s2where s1.emp_no = s2.emp_noand salary_growth &gt; 5000and (strftime(‘%Y’, s2.to_date) -strftime(‘%Y’, s1.to_date) = 1or strftime(‘%Y’, s2.from_date) -strftime(‘%Y’, s1.from_date) = 1)order by salary_growth desc; 27.给出每个员工每年薪水涨幅超过 5000 的员工编号emp_no2020 年 5 月 18 日 8:47 题目描述film表 1字段 说明 1film_id 电影id 1title 电影名称 1description 电影描述信息 CREATE TABLE IF NOT EXISTS film ( film_id smallint(5) NOT NULL DEFAULT ‘0’, title varchar(255) NOT NULL, description text, PRIMARY KEY (film_id)); category表 1字段 说明 1category_id 电影分类id 1name 电影分类名称 1last_update 电影分类最后更新时间 CREATE TABLE category ( category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, PRIMARY KEY ( category_id )); film_category表 1字段 说明 1film_id 电影id 1category_id 电影分类id 1last_update 电影id和分类id对应关系的最后更新时间 CREATE TABLE film_category ( film_id smallint(5) NOT NULL, category_id tinyint(3) NOT NULL, last_update timestamp); 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数 量&gt;=5部 来自&lt;https://www.nowcoder.com/practice/3a303a39cc40489b99a7e1867e6507c5?tpId=82&amp;tqId=29780&amp;tPage=2&amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; 28.查找描述信息中包括robot的电影对应的分类名称以及电影数目2020 年 5 月 18 日 8:47 &amp;rp=&amp;ru=%2Fta%2Fsql&amp;qru=%2Fta%2Fsql%2Fquestion-ranking&gt; 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影 数量&gt;=5部 CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL, description text, #描述信息like ‘%robot%’ PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select c.name,count(fc.film_id) numfrom category cinner join film_category fcon c.category_id = fc.category_idinner join(select *from film fwhere f.description like ‘%robot%’) f_robot on f_robot.film_id = fc.film_idinner join(select *,count(fc1.film_id) num1from film_category fc1group by category_idhaving num1 &gt;= 5) f5 on f5.category_id = fc.category_id; 使用join查询方式找出没有分类的电影id以及名称 CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL, description text, #描述信息like ‘%robot%’ PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select f.film_id, f.titlefrom film fleft join film_category fcon f.film_id = fc.film_idwhere fc.category_id is null; 29.使用join查询方式找出没有分类的电影id以及名称2020 年 5 月 18 日 8:47 使用子查询的方式找出属于Action分类的所有电影对应的title,description CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT ‘0’,title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id)); CREATE TABLE category (category_id tinyint(3) NOT NULL , name varchar(25) NOT NULL, last_update timestamp, #分类名称 PRIMARY KEY ( category_id )); CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, last_update timestamp); select f.title, f.descriptionfrom film fwhere f.film_id in(select film_idfrom film_category fcwhere fc.category_id in(select c.category_idfrom category cwhere c.name=’Action’)); 30.使用子查询的方式找出属于Action分类的所有电影对应的title,description2020 年 5 月 18 日 8:47 题目描述获取select * from employees对应的执行计划 explain select * from employees; 31.获取select2020 年 5 月 18 日 18:14 题目描述将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分 CREATE TABLE employees ( emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select last_name||’ ‘||first_name as namefrom employees; 32.将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分2020 年 5 月 18 日 18:14 题目描述创建一个actor表，包含如下列信息 列表 类型 是否为NULL 含义 actor_id smallint(5) not null主键id first_name varchar(45) not null名字 last_name varchar(45) not null姓氏 last_update timestamp not null最后更新时间，默认是系统的当前时间 create table actor(actor_id smallint(5) not null primary key,first_name varchar(45) not null,last_name varchar(45) not null,last_update timestamp not null default (datetime(‘now’,’localtime’))); 33.创建一个actor表，包含如下列信息2020 年 5 月 18 日 18:14 题目描述对于表actor批量插入如下数据 CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) actor_id first_name last_name last_update1 PENELOPE GUINESS 2006 - 02 - 15 12:34:332 NICK WAHLBERG 2006 - 02 - 15 12:34:33 insert into actorvalues (1, ‘PENELOPE’, ‘GUINESS’, ‘2006- 02 - 15 12:34:33’),(2, ‘NICK’, ‘WAHLBERG’, ‘2006- 02 - 15 12:34:33’) insert into actorselect 1,’PENELOPE’,’GUINESS’,’2006- 02 - 15 12:34:33’union select 2,’NICK’,’WAHLBERG’,’2006- 02 - 15 12:34:33’; 34.批量插入数据2020 年 5 月 18 日 18:14 题目描述对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作 CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) actor_id first_name last_name last_update‘3’ ‘ED’ ‘CHASE’’2006- 02 - 15 12:34:33’ insert or ignore into actorvalues (3,’ED’,’CHASE’,’2006- 02 - 15 12:34:33’); 35.批量插入数据,如果数据已经存在，请忽略，不使用replace操作2020 年 5 月 18 日 18:14 题目描述对于如下表actor，其对应的数据为: actor_id first_name last_name last_update1 PENELOPE GUINESS 2006 - 02 - 15 12:34:332 NICK WAHLBERG 2006 - 02 - 15 12:34:33 创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。actor_name表 结构如下： 列表 类型 是否为NULL 含义 first_name varchar(45) not null名字 last_name varchar(45) not null姓氏 create table actor_name asselect first_name,last_name from actor; 36.创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表2020 年 5 月 18 日 18:14 题目描述针对如下表actor结构创建索引： CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) 对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname create unique index uniq_idx_firstname on actor(first_name);create index idx_lastname on actor(last_name); 37.对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname2020 年 5 月 18 日 18:14 题目描述针对actor表创建视图actor_name_view， 只包含first_name以及last_name两列， 并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v： CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(‘now’,’localtime’))) create view actor_name_view (first_name_v,last_name_v) asselect first_name, last_name from actor; 38.针对actor表创建视图actor_name_view2020 年 5 月 18 日 18:14 题目描述针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。 CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));create index idx_emp_no on salaries(emp_no); select *from salariesindexed by idx_emp_nowhere emp_no = 10005; MYSQL中强制索引查询使用：FORCE INDEX(indexname); SQLite中强制索引查询使用：INDEXED BY indexname; 来自https://www.nowcoder.com/profile/340487413/codeBookDetail?submissionId=36255256 SQLite中，使用 INDEXED BY 语句进行强制索引查询，可参考： http://www.runoob.com/sqlite/sqlite-indexed-by.html 11 SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no &#x3D; 10005 MySQL中，使用 FORCE INDEX 语句进行强制索引查询，可参考： http://www.jb51.net/article/49807.htm 11 SELECT * FROM salaries FORCE INDEX idx_emp_no WHERE emp_no &#x3D; 10005 来自https://www.nowcoder.com/profile/340487413/codeBookDetail?submissionId=36255256 39.针对上面的salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005,2020 年 5 月 18 日 18:14 题目描述12345678存在actor表，包含如下列信息：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&#39;now&#39;,&#39;localtime&#39;)));现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为&#39;0000 00:00:00&#39; 1alter table actor add column create_date datetime not null default &#39;0000- 00 - 00 00:00:00&#39;; 40.在last_update后面新增加一列名字为create_date2020 年 5 月 18 日 18:14 题目描述构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数 据到audit中。 CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,NAME TEXT NOT NULL); create trigger audit_log after insert on employees_testbegininsert into audit values (new.ID, new.NAME);end; 41.构造一个触发器audit_log，在向employees表中插入一条数据的时候，触发插入相关的数据到audit中2020 年 5 月 18 日 18:18 题目描述删除emp_no重复的记录，只保留最小的id对应的记录。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values(‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); 1.group by和min 找到每个emp_no中 最小的id 2.删除不是这个最小id 数据 delete from titles_testwhere id not in(select min(id)from titles_testgroup by emp_no); 42.删除emp_no重复的记录，只保留最小的id对应的记录。2020 年 5 月 18 日 18:18 题目描述将所有to_date为 9999 - 01 - 01 的全部更新为NULL,且from_date更新为 2001 - 01 - 01 。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); update titles_test set to_date = null, from_date = ‘2001- 01 - 01’where to_date = ‘9999- 01 - 01’; 43.将所有to_date为 9999 - 01 - 01 的全部更新为NULL,且2020 年 5 月 18 日 18:18 题目描述将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用 replace实现。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); replace into titles_test select 5,10005,title,from_date,to_datefrom titles_testwhere id = 5and emp_no = 10001; 44.将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。2020 年 5 月 18 日 18:18 题目描述将titles_test表名修改为titles_2017。 CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL); insert into titles_test values (‘1’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘2’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘3’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘4’, ‘10004’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’),(‘5’, ‘10001’, ‘Senior Engineer’, ‘1986- 06 - 26’, ‘9999- 01 - 01’),(‘6’, ‘10002’, ‘Staff’, ‘1996- 08 - 03’, ‘9999- 01 - 01’),(‘7’, ‘10003’, ‘Senior Engineer’, ‘1995- 12 - 03’, ‘9999- 01 - 01’); alter table titles_test rename to titles_2017; 45.将titles_test表名修改为titles_20172020 年 5 月 18 日 18:19 题目描述在audit表上创建外键约束，其emp_no对应employees_test表的主键id。 CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL); CREATE TABLE audit(EMP_no INT NOT NULL,create_date datetime NOT NULL); drop table audit;create table audit(EMP_no int not null,create_date datetime NOT NULL,foreign key(EMP_no) references employees_test(ID)); 46.在audit表上创建外键约束，其emp_no对应employees_test表的主键id2020 年 5 月 18 日 18:19 题目描述存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005; 如何获取emp_v和employees有相同的数据？ CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); select * from emp_v; select e.*from employees e, emp_v evwhere e.emp_no = ev.emp_no; select e.*from employees eintersect select ev.* from emp_v ev; 47.如何获取emp_v和employees有相同的数据no2020 年 5 月 18 日 18:19 题目描述将所有获取奖金的员工当前的薪水增加10%。create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL, PRIMARY KEY (emp_no,from_date)); update salaries set salary = salary * 1.1where emp_no in(select s.emp_nofrom salaries sinner join emp_bonus ebon s.emp_no = eb.emp_noand s.to_date = ‘9999- 01 - 01’); 48.将所有获取奖金的员工当前的薪水增加10%2020 年 5 月 18 日 18:19 题目描述针对库中的所有表生成select count(*)对应的SQL语句 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: cntsselect count() from employees;select count() from departments;select count() from dept_emp;select count() from dept_manager;select count() from salaries;select count() from titles;select count(*) from emp_bonus; select ‘select count(*) from ‘||name||’;’ cntsfrom sqlite_master where type = ‘table’; 49.针对库中的所有表生成select2020 年 5 月 18 日 18:19 题目描述将employees表中的所有员工的last_name和first_name通过(‘)连接起来。 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式: nameFacello’GeorgiSimmel’BezalelBamford’PartoKoblick’ChirstianMaliniak’KyoichiPreusig’AnnekeZielinski’TzvetanKalloufi’SaniyaPeac’SumantPiveteau’DuangkaewSluis’Mary select last_name||”‘“||first_name namefrom employees; 50.将employees表中的所有员工的last_name和first_name通过(‘)连接起来。2020 年 5 月 18 日 18:19 题目描述查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。 select (length(“10,A,B”) -length(replace(“10,A,B”,”,”,””)))/length(“,”) as cnt; 51.查找字符串’10,A,B’2020 年 5 月 18 日 18:19 题目描述获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式： first_nameChirstianTzvetanBezalelDuangkaewGeorgiKyoichiAnnekeSumantMaryPartoSaniya select first_namefrom employeesorder by substr(first_name,-2,2) asc; 52.获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列2020 年 5 月 18 日 18:19 题目描述按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及 连接出的结果employees CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); 输出格式: dept_no employeesd001 10001,10002d002 10006d003 10005d004 10003,10004d005 10007,10008,10010d006 10009,10010 select dept_no, group_concat(emp_no,”,”) employeesfrom dept_empgroup by dept_no; 53.按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employees2020 年 5 月 18 日 18:19 题目描述查找排除当前最大、最小salary之后的员工的平均工资avg_salary。 CREATE TABLE salaries ( emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: avg_salary69462.5555555556 select avg(salary) avg_salaryfrom salarieswhere to_date = ‘9999- 01 - 01’and salary not in(select max(salary)from salaries)and salary not in(select min(salary)from salaries); 54.查找排除当前最大、最小salary之后的员工的平均工资avg_salary2020 年 5 月 18 日 18:19 题目描述123456789分页查询employees表，每 5 行一页，返回第 2 页的数据CREATE TABLE &#96;employees&#96; (&#96;emp_no&#96; int(11) NOT NULL,&#96;birth_date&#96; date NOT NULL,&#96;first_name&#96; varchar(14) NOT NULL,&#96;last_name&#96; varchar(16) NOT NULL,&#96;gender&#96; char(1) NOT NULL,&#96;hire_date&#96; date NOT NULL,PRIMARY KEY (&#96;emp_no&#96;)); 1公式：limit (页数-1)*每一页的数量，每一页的数量 123select *from employeeslimit (2-1)*5,5; 55.分页查询employees表，每 5 行一页，返回第 2 页的数据2020 年 5 月 18 日 18:19 题目描述获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和received ，没有分配 具体的员工不显示 CREATE TABLE dept_emp ( emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE dept_manager (dept_no char(4) NOT NULL,emp_no int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date));create table emp_bonus(emp_no int not null,received datetime not null,btype smallint not null); 输出格式: e.emp_no dept_no btype received10001 d001 1 2010 - 01 - 0110002 d001 2 2010 - 10 - 0110003 d004 3 2011 - 12 - 0310004 d004 1 2010 - 01 - 0110005 d00310006 d00210007 d00510008 d00510009 d00610010 d00510010 d006 select e.emp_no,de.dept_no,eb.btype,eb.receviedfrom employees einner join dept_emp deon e.emp_no = de.emp_no 56.获取所有员工的emp_no2020 年 5 月 18 日 18:19 on e.emp_no = de.emp_noleft join emp_bonus ebon e.emp_no = eb.emp_no; 题目描述使用含有关键字exists查找未分配具体部门的员工的所有信息。 CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no)); 输出格式: emp_no birth_date first_name last_name genderhire_date10011 1953 - 11 - 07 Mary Sluis F 1990 - 01 - 22 select *from employees ewhere not exists(select *from dept_emp dewhere de.emp_no = e.emp_no); 57.使用含有关键字exists查找未分配具体部门的员工的所有信息。2020 年 5 月 18 日 18:19 题目描述存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。 输出格式: emp_no birth_date first_name last_name genderhire_date10006 1953 - 04 - 20 AnnekePreusigF 1989 - 06 - 0210007 1957 - 05 - 23 TzvetanZielinskiF 1989 - 02 - 1010008 1958 - 02 - 19 Saniya KalloufiM 1994 - 09 - 1510009 1952 - 04 - 19 SumantPeac F 1985 - 02 - 1810010 1963 - 06 - 01 Duangkaew Piveteau F 1989 - 08 - 2410011 1953 - 11 - 07 Mary Sluis F 1990 - 01 - 22 select * from emp_v; select e.*from employees e, emp_v evwhere e.emp_no = ev.emp_no; 58.获取employees中的行数据，且这些行也存在于emp_v中2020 年 5 月 18 日 18:19 题目描述获取有奖金的员工相关信息。CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no));CREATE TABLE dept_emp (emp_no int(11) NOT NULL,dept_no char(4) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,dept_no));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE salaries (emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL, PRIMARY KEY (emp_no,from_date)); 给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金 额bonus。bonus类型btype为 1 其奖金为薪水salary的10%，btype为 2 其奖金为薪水的20%，其他 类型均为薪水的30%。 当前薪水表示to_date=’9999- 01 - 01’ 输出格式: emp_no first_name last_name btype salary bonus10001 Georgi Facello 1 88958 8895.810002 BezalelSimmel 2 72527 14505.410003 Parto Bamford 3 43311 12993.310004 Chirstian Koblick 1 74057 7405.7 select e.emp_no, e.first_name, e.last_name, b.btype, s.salary,(case b.btypewhen 1 then s.salary0.1when 2 then s.salary0.2else s.salary*0.3end) bonusfrom employees einner join emp_bonus bon e.emp_no = b.emp_noinner join salaries son s.emp_no = e.emp_noand s.to_date=’9999- 01 - 01’; 59.获取有奖金的员工相关信息。2020 年 5 月 18 日 18:19 题目描述按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类 推。 具体结果如下Demo展示。。 CREATE TABLE salaries ( emp_no int(11) NOT NULL,salary int(11) NOT NULL,from_date date NOT NULL,to_date date NOT NULL,PRIMARY KEY (emp_no,from_date)); 输出格式: emp_no salary running_total10001 88958 8895810002 72527 16148510003 43311 20479610004 74057 27885310005 94692 37354510006 43311 41685610007 88070 50492610009 95409 60033510010 94409 69474410011 25828 720572 select s.emp_no, s.salary,(select sum(s2.salary)from salaries s2where s2.emp_no &lt;= s.emp_noand s2.to_date = ‘9999- 01 - 01’) running_totalfrom salaries swhere s.to_date = ‘9999- 01 - 01’order by s.emp_no asc; 60.统计salary的累计和running_total2020 年 5 月 18 日 18:19 题目描述对于employees表中，给出奇数行的first_name CREATE TABLE employees (emp_no int(11) NOT NULL,birth_date date NOT NULL,first_name varchar(14) NOT NULL,last_name varchar(16) NOT NULL,gender char(1) NOT NULL,hire_date date NOT NULL,PRIMARY KEY (emp_no)); 输出格式: first_nameGeorgiChirstianAnnekeTzvetanSaniyaMary 题目描述错误：更改为：对first_name 先排序 后给出奇数行 select e1.first_namefrom employees e1where(select count(*)from employees e2where e1.first_name &lt;= e2.first_name) % 2 = 1; 61.对于employees表中，给出奇数行的first_name2020 年 5 月 18 日 18:19 This is a offline tool, your data stays locally and is not send to any server!Feedback &amp; Bug Reports","categories":[{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://nlbyd1119.online/tags/sql/"}]},{"title":"fabric_1","slug":"fabric_1","date":"2020-07-31T02:51:17.000Z","updated":"2020-07-31T04:00:24.562Z","comments":true,"path":"2020/07/31/fabric_1/","link":"","permalink":"http://nlbyd1119.online/2020/07/31/fabric_1/","excerpt":"近几天根据一个新的教程重新过了一遍fabric的一些知识点，也是1.2版本的，想着试一试1.4版本的，而服务器上的环境不想破坏，于是就使用本机windows7环境进行实验，最终结果并未成功，但需要将过程中出现的问题进行记录。","text":"近几天根据一个新的教程重新过了一遍fabric的一些知识点，也是1.2版本的，想着试一试1.4版本的，而服务器上的环境不想破坏，于是就使用本机windows7环境进行实验，最终结果并未成功，但需要将过程中出现的问题进行记录。 安装docker的问题 一、安装参考 https://www.runoob.com/docker/windows-docker-install.html win7、win8 等需要利用 docker toolbox 来安装，国内可以使用阿里云的镜像来下载，下载地址：http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/ 选择其中最新的18以后的版本进行安装，基本上就是常规安装（注意版本一定要新）二、出现问题与解决方法 首先一定要让桌面出现quickstart的快捷方式，实际上这个快捷方式的作用是使用电脑里已有的git bash启动docker命令行，也就是实际上docker使用还是在linux命令行里的，运行的也是start.sh脚本。这样会出现问题：windows 正在查找bash.exe。如果想亲自查找文件，请点击“浏览”的问题，这是因为安装后默认寻找的git bash的位置和你自己安装的位置不同，只要在快捷方式的属性里进行更改就行了（参考 https://www.pianshen.com/article/79311778/） 然后启动docker命令行后，会提示找不到默认的boot2docker.iso，然后就去下载，然后因为访问不到就报错。该情况下应该事先在github上把相应文件下好，放在命令行提示的下载目录下（C盘用户目录的.docker文件夹下的相关文件夹下），有了就不会再下，自然不会报错。参考：https://blog.csdn.net/lililuni/article/details/83243062 一些基本配置与问题 一、首先便是配置docker的镜像源参考 https://www.cnblogs.com/111testing/p/9691730.html需要先进入default虚拟机，修改docker配置文件，再退出修改方式参考 https://blog.csdn.net/chenwenjie2580/article/details/103306623 123456789101112131415161718192021222324打开终端执行命令：docker-machine ssh修改配置文件：sudo vi /var/lib/boot2docker/profile在 --label provider=virtualbox 的下一行添加： --registry-mirror http://hub-mirror.c.163.com重启docker docker-machine.exe restart镜像地址：国内加速地址有：Docker中国区官方镜像： https://registry.docker-cn.com网易： http://hub-mirror.c.163.com中国科技大学：https://docker.mirrors.ustc.edu.cn阿里云容器 服务 需要登录获取账号专属镜像地址https://cr.console.aliyun.com/首页点击“创建我的容器镜像” 得到一个专属的镜像加速地址，类似于“https://abcd.mirror.aliyuncs.com” 二、几个需要注意但暂不明确的问题 修改这些配置是进入虚拟机的，但退出虚拟机后，使用docker命令，这些配置也有效 镜像是都下到了虚拟机相应的虚拟文件中（一个大文件） 虚拟机每重启一次，自己创建的文件就无了 各种命令行的关系 shell bash tty。。 什么的 三、由于需要下的镜像较多，而默认虚拟机相关文件会下在C盘，这样绝对不行，考虑如何修改配置参考 https://blog.csdn.net/yql_617540298/article/details/85284930迁移 mklink 1.4环境搭建与测试一、环境 1.4镜像参考 https://www.cnblogs.com/bjlhx/p/10648642.htmlhttps://www.cnblogs.com/cbkj-xd/p/11067790.html拉取还是很快的 1.4源码和测试源码在github上选择1.4的分支拉取即可，注意要拉取到gopath相应目录下 二、测试测试就是要跑一下samples里的first-network 首先什么也没管，直接跑了 提示没有 crytogen，这样就需要把那几个二进制文件放在gopath的bin下，让其可在全局进行使用。我先做的是，直接把服务器上的二进制文件下下来，结果不能用，查了之后发现是因为电脑架构不一样，当然在不同环境下编译生成的文件不能通用。1234567出现的报错 cryptogen tool not found. exitinglinux下cannot execute binary file: Exec format error参考 https://blog.csdn.net/owen7500/article/details/52397353/https://blog.csdn.net/lixuande19871015/article/details/98613711https://blog.csdn.net/lixuande19871015/article/details/90485929 于是要在windows上利用源码再进行编译第一个问题是git bash里是没有make命令的参考 https://blog.csdn.net/u013345641/article/details/83988195https://blog.csdn.net/z69183787/article/details/96290717下个文件包拷到相应目录下即可使用第二个问题是cc1.exe: sorry, unimplemented: 64-bit mode not compiled in参考 https://blog.csdn.net/qq1083062043/article/details/86638619https://blog.csdn.net/Lyon_Nee/article/details/102644674发现原因是64位电脑编译需要64位gcc，因此需要把gcc从32位换成64位。又gcc -v可以看到电脑里默认的gcc是我先前安装的devc++的32位版本，在下载64位并配置环境变量后，并未生效，需要将devc++强行移走，这样会生效，之后会立即还原。这样对peer等几个可以编译了，但在编译ca相关的两个又出现了问题 working directory is not part of a module编译不成功，我最初的想法是，考虑各种方式进行编译，包括使用go mod直接在对应源码上build等，但无效，参考 https://www.jianshu.com/p/fb9a947ac8f3https://blog.csdn.net/my_live_123/article/details/107347245发现应该是 go mod模式导致的，那么就需要先把go mod模式关掉，参考 https://goproxy.cn/ 关掉后编译成功附： fabric-ca相关https://www.jianshu.com/p/de04cbc4d3dchttps://www.cnblogs.com/cbkj-xd/p/12012009.html 这样几个执行文件就编译好了，可以运行脚本了运行后，卡死在报错 OCI runtime exec failed: exec failed: container_linux.go:348: starting container process caused &quot;exec: \\&quot;scripts/script.sh\\&quot;: stat scripts/script.sh: no such file or directory&quot;: unknown 没有解决 试过共享文件夹 更换命令 但就是找不到 进入容器命令行发现确实没有对应文件 具体原因不得而知参考https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=docker%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9&amp;oq=starting%2520container%2520process%2520caused%2520%2526quot%253Bexec%253A%2520%255C%2526quot%253Bscripts%252Fscript.sh%255C%2526quot%253B&amp;rsv_pq=9d62102d001213db&amp;rsv_t=56471W69%2F36NRITm4wVDlhPpM17Nd6h1G4UDtbjWmtQMUsAlnqYXeyqv%2B2w&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=13364&amp;rsv_sug3=62&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=14680https://blog.csdn.net/chenxi1900/article/details/80845503https://blog.csdn.net/q1177660557/article/details/78840338?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_paramhttps://ask.csdn.net/questions/1020897https://www.meiwen.com.cn/subject/vvslpftx.htmlhttps://stackoverflow.com/questions/62149143/starting-container-process-caused-exec-bin-sh-stat-bin-sh-no-such-filehttps://blog.csdn.net/tiny_lxf/article/details/82503877https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=docker%20exec%20cli%20scripts%2Fscript.sh%E6%8A%A5%E9%94%99&amp;oq=docker%2520exec%2520cli%2520scripts%252Fscript.sh&amp;rsv_pq=e4d92a4800160a40&amp;rsv_t=1541fdIIYXOZMWGQ%2BekLw5eFFeBJnKqO31ZqEE2W4xW9mfjkTaljSZlkwts&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=4545&amp;rsv_sug3=22&amp;rsv_sug1=2&amp;rsv_sug7=000&amp;rsv_sug2=0&amp;rsv_sug4=6375&amp;rsv_sug=1https://blog.csdn.net/s1070/article/details/52353339https://blog.csdn.net/zqq8015/article/details/97548096https://blog.csdn.net/learner198461/article/details/80783232?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_paramhttps://blog.csdn.net/Tan915730/article/details/86412831https://ask.csdn.net/questions/1020897https://blog.csdn.net/keke_kid/article/details/81058102https://www.cnblogs.com/xiaoxianxianxian/p/12667884.htmlhttps://www.cnblogs.com/163-4630227/p/10010089.html https://www.cnblogs.com/lwmp/p/6999742.htmlhttps://www.jianshu.com/p/7536bf93ec6dhttps://blog.csdn.net/zzq060143/article/details/91050203https://blog.csdn.net/weixin_34342207/article/details/886790754. 这个测试放弃了，又尝试了另外一个还是各种报错，首先依赖就产生了各种问题，放弃。。 总结 首先是windows上docker的基本使用是没什么问题了，1.4的环境也是有了，但实际运行就是会出现各种奇怪的问题，其实这种程序本该在linux上运行的 附 一、fabric-sdk-javahttps://github.com/hyperledger/fabric-sdk-javahttps://search.gitee.com/?q=fabric-sdk-java&amp;skin=rec&amp;type=repository&amp;pageno=1https://gitee.com/zsmszsms/fabric-network-builder?_from=gitee_searchhttps://gitee.com/zsmszsms/directory-chain?_from=gitee_searchhttps://gitee.com/jaemon/fabric-sdk-server?_from=gitee_searchhttps://gitee.com/wuhuaqiang/fabric-sdk-java?_from=gitee_searchhttps://gitee.com/acrowise/myfabric-demo-java-client/blob/master/src/main/java/litong/hyperledger/fabric/example/Demo.javahttps://gitee.com/round00/fabric-sdk-java?_from=gitee_searchhttps://gitee.com/likaiyuan9/fabric-sdk-java?_from=gitee_searchhttps://www.cnblogs.com/cbkj-xd/p/11067790.htmlhttps://blog.csdn.net/rejames/article/details/89877517https://www.jianshu.com/p/bfb081a96337https://www.cnblogs.com/adderhuang/p/12220611.html 二、linux使用相关的https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;tn=baidu&amp;wd=linux%E6%9F%A5%E7%9C%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE&amp;oq=linux%25E6%259F%25A5%25E7%259C%258B%25E8%25BD%25AF%25E4%25BB%25B6&amp;rsv_pq=b019f3e60021d38d&amp;rsv_t=7794Qu6BflvJCab%2B3tMtcrQmg787L9WwY7zAsv8r8XufUIE%2FUUPE9h5Hn90&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=ts_1&amp;rsv_btype=t&amp;rsv_sug3=95&amp;rsv_sug1=63&amp;rsv_sug7=100&amp;rsv_sug2=1&amp;prefixsug=linux%25E6%259F%25A5%25E7%259C%258B%25E8%25BD%25AF%25E4%25BB%25B6&amp;rsp=1&amp;rsv_sug4=3631https://www.fujieace.com/linux/software-location.htmlhttps://www.cnblogs.com/oddcat/articles/9706393.htmlhttps://www.cnblogs.com/zifeiy/p/11043218.htmlhttps://blog.csdn.net/sunhaobo1996/article/details/80340513","categories":[{"name":"fabric","slug":"fabric","permalink":"http://nlbyd1119.online/categories/fabric/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://nlbyd1119.online/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Go依赖管理与Iris项目运行示例 问题与解决","slug":"Go依赖管理与Iris项目运行示例-问题与解决","date":"2020-07-14T01:23:57.000Z","updated":"2020-07-14T02:41:36.075Z","comments":true,"path":"2020/07/14/Go依赖管理与Iris项目运行示例-问题与解决/","link":"","permalink":"http://nlbyd1119.online/2020/07/14/Go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8EIris%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/","excerpt":"本篇先就运行fabric demo时逐步查找确定的go依赖管理的问题与解决方案进行说明，然后就运行iris web demo过程中出现的问题进行记述。","text":"本篇先就运行fabric demo时逐步查找确定的go依赖管理的问题与解决方案进行说明，然后就运行iris web demo过程中出现的问题进行记述。 Go语言之依赖管理 Go语言的依赖管理随着版本的更迭正逐渐完善起来。 依赖管理为什么需要依赖管理最早的时候，Go所依赖的所有的第三方库都放在GOPATH这个目录下面。这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？ godepGo语言从v1.5开始开始引入vendor模式，如果项目目录下有vendor目录，那么go工具链会优先使用vendor内的包进行编译、测试等。 godep是一个通过vender模式实现的Go语言的第三方依赖管理工具，类似的还有由社区维护准官方包管理工具dep。 安装执行以下命令安装godep工具。 1go get github.com/tools/godep 基本命令安装好godep之后，在终端输入godep查看支持的所有命令。 12345678godep save 将依赖项输出并复制到Godeps.json文件中godep go 使用保存的依赖项运行go工具godep get 下载并安装具有指定依赖项的包godep path 打印依赖的GOPATH路径godep restore 在GOPATH中拉取依赖的版本godep update 更新选定的包或go版本godep diff 显示当前和以前保存的依赖项集之间的差异godep version 查看版本信息 使用godep help [command]可以看看具体命令的帮助信息。 使用godep在项目目录下执行godep save命令，会在当前项目中创建Godeps和vender两个文件夹。 其中Godeps文件夹下有一个Godeps.json的文件，里面记录了项目所依赖的包信息。 vender文件夹下是项目依赖的包的源代码文件。 vender机制Go1.5版本之后开始支持，能够控制Go语言程序编译时依赖包搜索路径的优先级。 例如查找项目的某个依赖包，首先会在项目根目录下的vender文件夹中查找，如果没有找到就会去$GOAPTH/src目录下查找。 godep开发流程 保证程序能够正常编译 执行godep save保存当前项目的所有第三方依赖的版本信息和代码 提交Godeps目录和vender目录到代码库。 如果要更新依赖的版本，可以直接修改Godeps.json文件中的对应项 go modulego module是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。 GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。 GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。 GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，开启模块支持。 简单来说，设置GO111MODULE=on之后就可以使用go module了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。 使用 go module 管理依赖后会在项目根目录下生成两个文件go.mod和go.sum。 GOPROXYGo1.11之后设置GOPROXY命令为： 1export GOPROXY=https://goproxy.cn Go1.13之后GOPROXY默认值为https://proxy.golang.org，在国内是无法访问的，所以十分建议大家设置GOPROXY，这里我推荐使用goproxy.cn。 1go env -w GOPROXY=https://goproxy.cn,direct go mod命令常用的go mod命令如下： 12345678go mod download 下载依赖的module到本地cache（默认为$GOPATH&#x2F;pkg&#x2F;mod目录）go mod edit 编辑go.mod文件go mod graph 打印模块依赖图go mod init 初始化当前文件夹, 创建go.mod文件go mod tidy 增加缺少的module，删除无用的modulego mod vendor 将依赖复制到vendor下go mod verify 校验依赖go mod why 解释为什么需要依赖 go.modgo.mod文件记录了项目所有的依赖信息，其结构大致如下： 123456789101112module github.com/Q1mi/studygo/bloggergo 1.12require ( github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586 github.com/gin-gonic/gin v1.4.0 github.com/go-sql-driver/mysql v1.4.1 github.com/jmoiron/sqlx v1.2.0 github.com/satori/go.uuid v1.2.0 google.golang.org/appengine v1.6.1 // indirect) 其中， module用来定义包名 require用来定义依赖包及版本 indirect表示间接引用 依赖的版本go mod支持语义化版本号，比如go get foo@v1.2.3，也可以跟git的分支或tag，比如go get foo@master，当然也可以跟git提交哈希，比如go get foo@e3702bed2。关于依赖的版本支持以下几种格式： 12345gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7gopkg.in/vmihailenco/msgpack.v2 v2.9.1gopkg.in/yaml.v2 &lt;=v2.2.1github.com/tatsushid/go-fastping v0.0.0-20160109021039-d7bb493dee3elatest replace在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。 12345replace ( golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac =&gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac golang.org/x/net v0.0.0-20180821023952-922f4815f713 =&gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d golang.org/x/text v0.3.0 =&gt; github.com/golang/text v0.3.0) go get在项目中执行go get命令可以下载依赖包，并且还可以指定下载的版本。 运行go get -u将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号) 运行go get -u=patch将会升级到最新的修订版本 运行go get package@version将会升级到指定的版本号version 如果下载所有依赖可以使用go mod download命令。 整理依赖我们在代码中删除依赖代码后，相关的依赖库并不会在go.mod文件中自动移除。这种情况下我们可以使用go mod tidy命令更新go.mod中的依赖关系。 go mod edit格式化因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令： 1go mod edit -fmt 添加依赖项1go mod edit -require=golang.org/x/text 移除依赖项如果只是想修改go.mod文件中的内容，那么可以运行go mod edit -droprequire=package path，比如要在go.mod中移除golang.org/x/text包，可以使用如下命令： 1go mod edit -droprequire=golang.org/x/text 关于go mod edit的更多用法可以通过go help mod edit查看。 在项目中使用go module既有项目如果需要对一个已经存在的项目启用go module，可以按照以下步骤操作： 在项目目录下执行go mod init，生成一个go.mod文件。 执行go get，查找并记录当前项目的依赖，同时生成一个go.sum记录每个依赖库的版本和哈希值。 运行fabirc demo的过程 开始，即7.11晚，认为不能解决go依赖的问题，其一go get的话，速度太慢还看不到进度；直接git clone的话，也是太慢，而且依赖总是不全完全看不到完全下完的希望；按demo的步骤，说是用dep命令，但那个实际和go get差不多，区别只是针对每个项目把依赖下到项目下而不是统一的地方，这个问题折磨了近一天，想想只能科学上网，但查找后发现也不可行，设置代理也不行。。如果不能解决依赖的下载问题，用go写项目根本不可能。后来发现go在1.13版本后的使用go mod进行依赖管理，无奈之下，只能把服务器上的1.10版本换成1.13以上，然后设置代理，用go mod init生成mod文件，再go get，很快就解决了。。这下，我真的意识到，七牛造福了go开发者，https://goproxy.cn/ 只要将下载源换成七牛的这个源，用go mod管理依赖，一般依赖的下载问题不会造成困扰。但其使用还需进一步测试。 go mod管理项目测试与Iris项目运行问题解决 一、测试关于go mod的说明是，不用再把项目放在go path下了，把项目建在任意目录下，用go mod管理依赖就行了，依赖会下在gopath下的pkg下，这就和maven很像了，这就真的很nb了。找了个只有main的iris的demo随便copy到了一个目录下，go mod init 自定义项目名（注意这个名称会在mod文件首行指定这个项目的根模块名，其他引包之类的可以根据这个模块名的路径引，这是后续在运行另一个项目时发现的，这点极其重要）然后 go get 再 go build，这样就可以有exe生成了，整个过程很简单。在码云上下了go版的若依，运行也很顺利。但在运行千锋iris教程的案例时，出现了不少问题。 二、运行iris案例问题与解决1.首先，按部就班，三步骤 init get build 但在build卡住了，看一下报错，main等找不到项目其他的自定义的包。细看确实，作者是按自己gopath src下的绝对路径引的包，和我的不一样，那我这样直接运行肯定报错，于是我就要把这些引入自定义包的语句都修改才行。但我想到，如果按绝对路径引，项目换个存放目录不是又要改吗，这样麻烦根本不现实，是不是可以使用相对路径导入呢。于是我用./表示同级包引入；../表示上级包引入这样的，在goland中是感觉可以引入的，go build了一下，有个no local的报错，以下还有问题，说找不到xorm logger等包，我当时认为是go mod init没有找全依赖的缘故，于是我决定先把这几个依赖添到mod中再get看行不行（事实证明这样引包确实不行）。2.先找xorm。到github上找，看不知道为啥，这个作者把项目迁到gitea上去了，那为了搞个新版本，就用https://gitea.com/xorm/xorm 中指定的 xorm.iox/xorm 引入。都改过来后，又解决了个mysql驱动的问题：但这个mysql驱动之后还会出问题，之后再说。然后又想要解决goed/logger这个依赖没有的问题，发现github上居然没这个库。。只能找了个其他的日志库引入 https://github.com/wonderivan/logger 解决问题。综上，发现 go mod init不能保证把所有需要的依赖都引入，以上的这三个如xorm是迁移了，logger那个是没这个库，也就是说如果都正常的话都可以导入，这些特殊情况就需要特殊处理了。3.暂时感觉依赖问题都解决了。于是再次build，还是有no local加没有找到包的问题出现，意识到按.相对导入的方法应该不可行，那么究竟导入呢。无奈之下，只能全部改成自己src下的绝对路径。但build时，居然往github上找自定义包了。。这机制把我搞糊涂了。。这样也不行，那我先前运行的那个go版本的若依也不是在开发者的地方跑的，为什么运行的那么顺利。于是我查看了一下它的导包方式，它的mod文件中指定了一个根包名，比如root，这样如果在main.go中导入service包就是root/service这样。但其实我之前把根包名设为cms，导入也这样试过了，为什么不行。我想了一下，是不是编译器没有开始就设置为go mod管理的项目。于是新建了个go mod项目（注意开始我设置的代理是direct，导致打开项目时一直加载 go list -m json all，依赖还一直都是红的，查了https://studygolang.com/articles/26923?fr=sidebar 之后才发现，那个代理设置应该设置成国内的 https://goproxy.cn 这样很快就导完了这样把go mod项目建在任意路径下都可以。4.这样依赖感觉又都没问题了，包括自定义包的引入。于是go build，没问题，但运行时又报错了。关于xorm的空指针，开始我自然地想到是不是新版本与旧版本不兼容导致的，我应该把版本切换成github上的版本，于是指定旧版本，但再go get时就又出问题了，报错 123456go: cms imports cms/datasource imports github.com/go-xorm/xorm imports github.com/go-xorm/core: github.com/go-xorm/core@v0.6.3: parsing go.mod: module declares its path as: xorm.io/core but was required as: github.com/go-xorm/core 查了issue https://github.com/henrylee2cn/faygo/issues/39 后发现，这是因为github上的xorm使用的迁移后的core导致的，开发者留言说已经解决这个问题。但是我下的0.5.6报错，在其仓库首页发现这是最新版本。。但打开release发现后，最新的已经到0.7.9了。。这告诉我首页的latest不可信。然后把版本换成0.7.9，发现go get是没问题了。5.go build生成exe，闪退。然后用go run main.go看报错，又是关于xorm的空指针，这样让我想到是不是创建数据库连接时出现了问题，看了下源码，根本没有对创建连接时的err进行处理。添了个输出，发现是没有找不到数据库驱动。。我之前运行时，命令行和编译器都提示mysql驱动引入都没有使用所以报错，于是我就注释掉了，现在又放开，果然还不行，那到底该怎样引入呢。。 12345import ( _ \"github.com/go-sql-driver/mysql\" //不能忘记导入 \"github.com/go-xorm/xorm\" \"cms/model\") 这样的方式，记住了。。 总结一下 实际开发时，新创建项目，用goland使用Go mod方式在任意目录下创建项目即可，注意代理一定设置正确。引自定义包时按自定义的根包引。若是导入别人的项目，尤其是那种没有mod的，注意可能是因为比较老了，有的依赖是不能自动添加的，可能就是找不到了，而有mod的应该一般没有问题。","categories":[{"name":"Web框架","slug":"Web框架","permalink":"http://nlbyd1119.online/categories/Web%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"七月上旬综合学习情况分析与安排","slug":"七月上旬综合学习情况分析与安排","date":"2020-07-10T09:02:49.000Z","updated":"2020-07-14T02:35:27.963Z","comments":true,"path":"2020/07/10/七月上旬综合学习情况分析与安排/","link":"","permalink":"http://nlbyd1119.online/2020/07/10/%E4%B8%83%E6%9C%88%E4%B8%8A%E6%97%AC%E7%BB%BC%E5%90%88%E5%AD%A6%E4%B9%A0%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%89%E6%8E%92/","excerpt":"搁了好几天，实际这篇是7.14写的。先总结下过去半个月的工作，然后对之后的工作进行梳理。","text":"搁了好几天，实际这篇是7.14写的。先总结下过去半个月的工作，然后对之后的工作进行梳理。 半月工作总结 7.1-7.5 零碎复习一天多 + go io并发 + fabric基础过一遍 + 项目相关权限还有初步整合 7.6 退出申请 7.7-7.10 整理java项目 权限 组件 特性等相关的资源，并看了一个后台的介绍教程并进行总结 7.11-7.12 软件杯yolo资料查找与文档编写 go项目依赖问题解决 sql练习 7.13-7.14 go iris学习 项目管理测试 + 学习内容整理 整体来说，效率有些过低了。有些迷茫，有些逃避。 后续工作梳理 首要是复习，八月前，必须彻底完整地好好过一般，这个首要要花大功夫。 然后是java 新特性 项目进阶 组件 算法这些都要学和练 fabric 要结合 go 想出设计方案 算法刷题 sql练习 大体来说，最优先的就这些事，但要注意，务必全力以赴，不要让不相干的事互相干扰，切忌徘徊不定，浪费时间。","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://nlbyd1119.online/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"关于java后端学习提升路线的思考与总结","slug":"关于java后端学习提升路线的思考与总结","date":"2020-07-10T08:57:36.000Z","updated":"2020-07-10T16:06:58.482Z","comments":true,"path":"2020/07/10/关于java后端学习提升路线的思考与总结/","link":"","permalink":"http://nlbyd1119.online/2020/07/10/%E5%85%B3%E4%BA%8Ejava%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87%E8%B7%AF%E7%BA%BF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/","excerpt":"写这篇总结的原因","text":"写这篇总结的原因 在一个多月前六月初的时候，正值学校课程基本结束，课设也基本完成。课设中使用ssm、springboot写了几个最简单的后台系统，当时感觉做一个基本的后台系统很容易，想找些项目参考进一步学习却找不到合适的，当时也受困于如何不仅仅只写一个后台网站的问题。那时时间充裕，就暂时放下这些，学了一下python相关的一些技术，后来又学go。到6月20日，也就是20天前，接手了一个学院科研信息系统的项目，当时看着需要的技术栈并不复杂，在后端开发方面只要再学一下Nosql的操作方式和与前端vue的对接方式就可以了。但事实证明，我对一个后台系统的理解确实过于浅薄了。先前我写的，仅仅是一些最简单的crud而已，页面也用的jsp，其实基本没有技术含量，业务逻辑也基本没有什么，系统功能完全不能满足一个正常后台的需求。接下来，我先记述一下，我是如何逐步意识到自己的能力确实不足以完成一个一般后台的开发的： 数据操作的问题。项目要求数据源使用mongodb，实现数据库操作使用spring data那一套的，而我先前用的基本都是mysql + mybatis。之前总结过，mybatis和spring data基本是两套操作方式，所以我从jpa学起，再重新认识spring data mongodb，然后系统基本实现的话，还要考虑解决多表操作和分页查询等的实现问题。此外，在数据方面，如何加入redis缓存，或是配置双数据源（双sql或sql+nosql）等，这些都是我想要了解或需要了解的。 视图的问题。开始定的vue，但先前和这几天没有整理之前，一直搞不清这些前端框架间的关系，有的只知其名不知其使用场景，而对那些模板引擎也只是一知半解，根本没用过，这样我controller也不知道怎么写，怎样写restful的controller也是问题。后来找了一套后台模板，看了一个demo，又学了一下beetl，但还是没怎么用过。到底这些东西的区别是什么，选择哪个，怎么用，这些问题困扰了我不仅仅是这二十天，应该是从四月第一次知道freemarker这东西以来就一直让我很迷惑。 一些工具的问题。在最近二十天看别人的源码时，第一次了解mybatis-plus、lombok、swagger这些东西，感觉很神奇。总想着一开始学习开发就能按通用简洁的方式进行就好了，所以这几天又在查这些东西是怎么用的。 权限管理实现的问题。之前也写过一个spring security实现的权限系统，在那个系统中权限表实际只起描述作用。在这次的项目开发中，开始我认为实现基本的需求是简单的，但由于使用场景和几个关键细节的区别，使过程并不顺利。其一，数据源是nosql；其二，若使用vue，就是前后端完全分离，我并不了解这种情形下怎样实现和jsp类似的权限控制方式；其三，是参考其他项目时，我了解到的鉴权使用的JWT的方式，还有OAuth第三方登录等方式，这些表明实际的权限控制应当更为复杂。先前正是见的少，理解浅，致使我所做的基于自己浅薄经验的系统设计绝对是完全的不完善的。在权限控制上存在的严重问题，使我意识到自己需要先多看一看别人的通用的实现是如何的，需要使用哪些技术，绝对不能故自坐井观天。 总结一下，说到底，见的项目太少，印象里的实现过于简单，导致自己想的也太简单了。事实上，不管是一个后台系统，或是其他类型的网站，其功能性需求和非功能性需求都必须满足，系统设计必须是严谨的，采用过于简单的方式实现绝对存在严重的缺陷。因此，我进一步学习必须要做的，是参考别人通用的实现，拓展自己的认识，明白别人都在用什么，为什么用，如何用，然后逐点突破，自己测试使用，并能够融入到自己的开发中。就是这样，故自开发是很危险的，现在更应该参考别人扩充眼界。 现在，说一说这几天看了一些项目和教程后的理解 经过先前的过程，我需要理顺一下自己需要解决哪些方面的问题：一、视图对于后台系统开发，使用什么模板，使用什么前端框架（ui/js），是前后端分离使用异步请求交互还是使用模板引擎，前后端分离采用怎样的技术选型，模板引擎选用哪种；开发其他类型网站，没有模板的话，对于布局，选用何种开发方式，flex伸缩布局、流式布局还是响应式布局。而controller相应的接口又该如何设计，按照何种标准。这些问题困扰了我相当长时间。从最开始的jsp+el+jstl+jquery，到后来的模板引擎freemarker、thymeleaf、beetl，再到前后端完全分离的vue+elementui，以及其他的layui、easyui、bootstrap等框架。在参考其他项目时，这些概念逐渐进入我的视野，也使我越来越迷惑，这些东西都有什么区别，到底选哪种比较合适。我先来说一说参考后的一些简单理解 几个模板引擎和jsp都是类似的，都是前后端不分离的，可以数据和视图一起返回 vue是一个js框架，和jquery进行区分，vue操作虚拟dom，jquery操作实际dom。vue和js是一级的东西 elementui layui easyui都是前端ui框架，其中第一个可以和vue结合，而后两个都是基于jquery的 如此，如果做前后端完全分离的实现，可以有两套 vue+elementui+axios(vue推荐异步请求技术) 或是 layui/easyui+ajax。其中layui是近几年诞生的国产框架，easyui诞生较早。 显然，layui和easyui也可以直接放在后端代码中，与模板引擎结合进行开发https://gitee.com/sentsin/layui layui源码 一些参考https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=layui%E5%92%8Cvue&amp;fenlei=256&amp;oq=easyui%25E5%2592%258Clayui&amp;rsv_pq=cdfffb8100077d3a&amp;rsv_t=91e6EYl1Z9IkusNuRzbahclBaj%2FRiliadJmtiTs%2BNKXjUCe0AIZdc727b3Y&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=13&amp;rsv_sug1=11&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=t&amp;inputT=3820&amp;rsv_sug4=5300https://blog.csdn.net/qq_45174759/article/details/93634846https://bbs.csdn.net/topics/392565977https://www.zhihu.com/question/346660680 参考https://zhidao.baidu.com/question/1952982575172825628.htmlhttps://zhidao.baidu.com/question/558004864349929612.html?qbl=relate_question_4&amp;word=layui%BA%CDvue 二、数据前几篇中有相关框架总结，需要考虑的是多数据源的配置。 三、权限关于权限的概念与教程，查了很多1.JWT Json web tokenhttps://www.jianshu.com/p/576dbf44b2aehttps://www.jianshu.com/p/99a458c62aa42.OAuth2https://www.jianshu.com/p/4f5fcddb41063.RBAC 基于角色的访问控制https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=RBAC&amp;fenlei=256&amp;oq=pbft%25E7%259A%2584%25E7%25BC%25BA%25E7%2582%25B9&amp;rsv_pq=d3d78e0700280686&amp;rsv_t=34b7Km8mLHZEhHr7T8Uv9n5phA0np5%2BNF21gH2kZuUK0ramPfz0EK3XPeXc&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=1720&amp;rsv_sug3=105&amp;rsv_sug1=65&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=3330https://www.cnblogs.com/niuli1987/p/9871182.html4.Spring Security Oauthhttps://www.jianshu.com/p/f6b73cd23114以我看来一方面是基于安全框架和JWT的token认证基本实现，一方面是基于安全框架和OAuth2规范的第三方登录实现。具体实现参考下面提到的两个后台系统，如何学习也在后面分析。 四、中间件之前了解了一些中间件，如redis、nginx等等，渐渐的就产生疑惑，什么是中间件，目前常见的中间件有哪些，各有什么使用场景。查了一些，并没有专门的博客介绍，只能根据一个教程https://www.bilibili.com/video/BV1XZ4y1x7FW?from=search&amp;seid=16936818641223030662 的内容分析。消息中间件rabbitmqhttps://baike.baidu.com/item/rabbitmq/9372144?fr=aladdinkafkahttps://baike.baidu.com/item/Kafka/17930165?fr=aladdin负载均衡 nginx缓存redis数据库中间件 mycat分布式相关dubbo 开源分布式服务框架https://baike.baidu.com/item/Dubbo/18907815?fr=aladdinfastdfs 轻量级分布式文件系统https://www.jianshu.com/p/b7c330a87855https://baike.baidu.com/item/fastdfs/5609710?fr=aladdinzookeeperhttps://baike.baidu.com/item/zookeeper/4836397?fr=aladdin搜索相关 分析一下两个后台系统 security 和 ruoyi这两个系统作为后台系统，基本功能是差不多的，但在具体实现技术、项目结构等上都有区别，不过有一些功能的实现是类似的。 SpringBoot Spring Security JWT redis Swagger 整合这个系统让我初次意识到一个springboot开发的后台系统需要哪些功能，实际的权限控制应该如何实现，这个项目的代码虽然有些繁琐，但解决了我先前的不少问题，且是用spring security实现安全控制的，也比较符合我的需求，因此先把这个项目的实现要点看了一遍，以下进行总结。 结合spring security和JWT实现的token机制，可选择性地将token存入redis或mysql中。其中JWT的构造和过期与刷新机制需要注意。 关于ajax请求，全局配置与跨域请求配置。 关于页面，使用layui框架。表单校验使用bootstrapValidator.min.js插件，分页使用datatables分页插件，菜单显示要注意分级关系的实现，给角色赋权的页面使用了ztree菜单树，日期laydate，弹出框layer。 字典管理。即系统中一些常量的配置。使用场景：表单中的下拉选择内容，列表的一些属性显示。 文件上传：注意springboot的jar打包决定了系统保存文件的路径必须是一个绝对路径，不能是项目的相对路径。而想要访问上传的文件，就需要给这个硬盘绝对路径配置一个url的映射。在上传文件前，先根据文件md5加密后的值与文件表中的id（文件md5后其对应记录id）进行比对，判断是否已存在决定是否再上传。 富文本：实现的一个关键点是，需要同时上传文件。公告管理中，统计公告的已读人员，显示用户未读公告数目的逻辑需要注意。 日志：一方面是日志记录，即保存系统的运行日志在文件中，一方面是系统的日志管理功能，该功能主要是查看某个用户在某个时间进行了某个模块的操作。这样的功能是通过自定义注解进行AOP拦截实现的，比较巧妙。 定时任务：首先数据库表中以qrtz开头的都是需要的默认表。新增一个定时任务，需要指定其cron表达式来确定执行规则，在系统中的bean所有的方法中进行选择定时执行。 邮件：注意配置以及富文本邮件的发送。 excel导出：依赖poi，根据select查询系统数据，获取指定字段的数据记录进行导出，注意验证sql正确性和生成excel的逻辑。 代码生成：一个看起来强大但也限制明显的功能。可以根据数据库表自动生成对应实体类、各层类甚至crud界面，可以直接copy进代码，再通过添加菜单将相关功能添到系统中。限制是暂时只能是单表操作，但也足够强大。实现的关键是使用模板进行替换。 swagger接口：三个依赖，在类、方法、参数等级别上添加注解分别指定其含义，这样系统就可以自动生成对应的接口文档。https://www.jianshu.com/p/349e130e40d5 若依若依的功能其实和上面这个后台功能差不多，但近两三年开发出来后，生态造的太好了，各种文档、拓展都有，美中不足是若依的权限管理使用的是shiro。 总结看了上面这两个后台系统的功能后，我认识到我先前认知的后台有些过于简单了，不能应付实际需求，因此还应参考这两个系统的设计思想。 相关资料 第一个系统，只有bilibili的视频和github源码，并没有详细的文档。教程 https://www.bilibili.com/video/av795700580源码 https://github.com/freeMak/boot-security.git 若依，是码云开源的项目，文档、拓展丰富，视频得花钱买。。bi7.6还有，现在7.10就没了，幸亏下载下来了文档 http://doc.ruoyi.vip/ruoyi/document/xmjs.html#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84源码 https://gitee.com/y_project/RuoYi 接下来就整理一下需要学哪些方面和如何进行吧 一、权限控制首先是需要搞清JWT和OAuth那些如何结合spring security实现，然后再根据需要学学shiro。1.spring security相关的参考黑马的教程https://www.bilibili.com/video/BV1WJ411W7wT/?spm_id_from=333.788.videocard.3https://www.bilibili.com/video/BV1VE411h7aL/?spm_id_from=333.788.videocard.4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465UP黑马程序员置顶完整的JAVA中级程序员全面学习路线教程爱学习的小伙伴们加油了！欢迎评论 点赞 转发！Java基础：av80585971数据库Mysql：av68811608Oracle：av81386804JDBC：av68736927C3P0：av73840600前端技术HTML、CSS、Javascript：av73840600jQuery-：av37976701Ajax：av15657082 av15866060Vue：av76249419微信小程序：av73342655 av40455083动态网页：av73840600编程强化JVM优化：av70549061数据结构算法：av83826038 av78639604软件项目管理Maven： av52364221SVN：av73840600 av7959491Git：av75718460Jenkins：av83089670热门技术框架SSM：av7770852Mybatis-Plus ：av69233006Spring Data：av71980390Spring：av70828462分布式架构Dubbo、Zookeeper：av74933720SpringCloud：av77085442 av89898642Eureka：av74127911Skywalking：av80349807服务器中间件RocketMQ：av66702383Kafka：av71991051Sharding-JDBC：av68736927Redis：av76235738MongoDB：av80450883服务器技术Tomcat：av67233983Linux系统：av73840600CentOS、Virtualbox：av23360560Ubuntu、Vmware：av14184325容器技术Docker：av69121091业务解决方案（实战项目）Elasticsearch：av66600360Lucene：av77895717Quartz：av36062910Elastic-Job：av74128695SpringSecurity：av74851468Activiti：av7670054 字母哥的教程和书https://www.bilibili.com/video/BV16J41127jq/?spm_id_from=333.788.videocard.1https://github.com/hanxt/bootsecuritybasichttps://www.kancloud.cn/hanxt/springsecurity 需要买。。系列博客https://blog.csdn.net/yuanlaijike/category_9283872.html2.如果需要学shiro 看up编程不良人的 二、java新特性黑马https://www.bilibili.com/video/bv1kt4y1y7d1/字母哥https://www.bilibili.com/video/BV1sE411P7C1 三、项目十次方https://www.bilibili.com/video/BV1HE411M7G8/?spm_id_from=333.788.videocard.5 未下载租房https://www.bilibili.com/video/BV11J411C7HY?from=search&amp;seid=14421220897827985663 四、前端（优先分离，再模板引擎）vue就参照百知了教程 https://space.bilibili.com/352224540 https://www.bilibili.com/video/BV1SE411H7CY https://www.bilibili.com/video/BV1p54y1B7Aa https://www.bilibili.com/video/BV1NK4y187XH https://www.bilibili.com/video/BV1Nt4y127Jh资料 http://www.baizhiedu.xin/front/index#/main目的是先学会vue与后端结合开发的基本用法 五、工具与组件1.lombokhttps://www.bilibili.com/video/BV1gg4y1v7Mi2.swaggerhttps://www.bilibili.com/video/BV1BA411v7BT3.mybatis-plushttps://www.bilibili.com/video/BV1pK411W7Hu4.redishttps://www.bilibili.com/video/BV1jD4y1Q7tU5.nginx6.RabbitMQhttps://www.bilibili.com/video/BV1dE411K7MG7.Lucenehttps://www.bilibili.com/video/BV1PE41157NT8.elasticsearchhttps://www.bilibili.com/video/BV1FK4y1x7Dr 六、mysql练习与强化主要是sql语句、表关系、特性等。牛客练习sqlhttps://www.bilibili.com/video/BV175411s7yr/?spm_id_from=333.788.videocard.2在线练习：https://www.nowcoder.com/ta/sqlgithub：https://github.com/ljz756245026/sql-test-niukewang其他教程https://www.bilibili.com/video/BV1DE411n7fU/?spm_id_from=333.788.videocard.0https://www.bilibili.com/video/BV1H5411475W文字音频材料必知必会实战45讲 七、goweb与区块链1.iris框架2.fabric相关教程华为云https://www.bilibili.com/video/BV1pE411Y7DJ?p=2孔壹学院https://www.bilibili.com/video/BV13E411u7Pjhttps://www.bilibili.com/video/BV1a4411X7Z1如何运行github上面的学籍项目https://www.bilibili.com/video/BV1V7411t79W?from=search&amp;seid=275682470572440048Hyperledger Fabric 1.4-关键概念https://www.bilibili.com/video/BV1a4411P7fC?from=search&amp;seid=275682470572440048学历征信系统https://www.bilibili.com/video/BV1pE411t7KH?p=123.仓库https://gitee.com/thats_not_all_right/kongyixueyuan?_from=gitee_searchhttps://gitee.com/dddkyi/Education?_from=gitee_search4.主要参考百度云下载的资料。。","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://nlbyd1119.online/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"go-study-5","slug":"go-study-5","date":"2020-07-02T15:38:16.000Z","updated":"2020-07-14T02:35:32.807Z","comments":true,"path":"2020/07/02/go-study-5/","link":"","permalink":"http://nlbyd1119.online/2020/07/02/go-study-5/","excerpt":"Go基础学习其五","text":"Go基础学习其五 2020.6.30-7.1 学习了go的time包和文件操作相关的内容。 笔记 time包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package mainimport ( \"time\" \"fmt\" \"math/rand\")func main() &#123; /* time包： 1年=365天，day 1天=24小时，hour 1小时=60分钟，minute 1分钟=60秒，second 1秒钟=1000毫秒，millisecond 1毫秒=1000微秒，microsecond--&gt;μs 1微秒=1000纳秒，nanosecond--&gt;ns 1纳秒=1000皮秒，picosecond--&gt;ps */ //1.获取当前的时间 t1 := time.Now() fmt.Printf(\"%T\\n\",t1) fmt.Println(t1) //2019-06-26 10:46:40.349196 +0800 CST m=+0.000495846 //2.获取指定的时间 t2 := time.Date(2008,7,15,16,30,28,0,time.Local) fmt.Println(t2) //2008-07-15 16:30:28 +0800 CST //3.time--&gt;string之间的转换 /* t1.Format(\"格式模板\")--&gt;string 模板的日期必须是固定：06-1-2-3-4-5 */ s1 := t1.Format(\"2006-1-2 15:04:05\") fmt.Println(s1) s2 := t1.Format(\"2006/01/02\") fmt.Println(s2) //string--&gt;time /* time.Parse(\"模板\",str)--&gt;time,err */ s3 := \"1999年10月10日\"//string t3 ,err := time.Parse(\"2006年01月02日\",s3) if err != nil&#123; fmt.Println(\"err:\",err) &#125; fmt.Println(t3) fmt.Printf(\"%T\\n\",t3) fmt.Println(t1.String()) //4.根据当前时间，获取指定的内容 year,month,day := t1.Date() //年，月，日 fmt.Println(year,month,day) hour,min,sec := t1.Clock() fmt.Println(hour,min,sec) //时，分，秒 year2 := t1.Year() fmt.Println(\"年：\",year2) fmt.Println(t1.YearDay()) month2 := t1.Month() fmt.Println(\"月：\",month2) fmt.Println(\"日：\",t1.Day()) fmt.Println(\"时：\",t1.Hour()) fmt.Println(\"分钟：\",t1.Minute()) fmt.Println(\"秒：\",t1.Second()) fmt.Println(\"纳秒：\",t1.Nanosecond()) fmt.Println(t1.Weekday()) //Wednesday //5.时间戳：指定的日期，距离1970年1月1日0点0时0分0秒的时间差值：秒，纳秒 t4 := time.Date(1970,1,1,1,0,0,0,time.UTC) timeStamp1:=t4.Unix() //秒的差值 fmt.Println(timeStamp1) timeStamp2 := t1.Unix() fmt.Println(timeStamp2) timeStamp3 := t4.UnixNano() fmt.Println(timeStamp3) //3600 000 000 000 timeStamp4 := t1.UnixNano() fmt.Println(timeStamp4) //6.时间间隔 t5 := t1.Add(time.Minute) fmt.Println(t1) fmt.Println(t5) fmt.Println(t1.Add(24 * time.Hour)) t6 := t1.AddDate(1,0,0) fmt.Println(t6) d1 := t5.Sub(t1) fmt.Println(d1) //7.睡眠 time.Sleep(3 *time.Second) //让当前的程序进入睡眠状态 fmt.Println(\"main。。。over。。。。。\") //睡眠[1-10]的随机秒数 rand.Seed(time.Now().UnixNano()) randNum := rand.Intn(10) + 1 //int fmt.Println(randNum) time.Sleep(time.Duration(randNum)*time.Second) fmt.Println(\"睡醒了。。\")&#125; 一、File文件操作首先，file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。 1、FileInfo接口FileInfo接口中定义了File信息相关的方法。 12345678type FileInfo interface &#123; Name() string // base name of the file 文件名.扩展名 aa.txt Size() int64 // 文件大小，字节数 12540 Mode() FileMode // 文件权限 -rw-rw-rw- ModTime() time.Time // 修改时间 2018-04-13 16:30:53 +0800 CST IsDir() bool // 是否文件夹 Sys() interface&#123;&#125; // 基础数据源接口(can return nil)&#125; 2、权限至于操作权限perm，除非创建文件时才需要指定，不需要创建新文件时可以将其设定为０。虽然go语言给perm权限设定了很多的常量，但是习惯上也可以直接使用数字，如0666(具体含义和Unix系统的一致)。 权限控制： 123456789101112131415161718192021linux 下有2种文件权限表示方式，即“符号表示”和“八进制表示”。（1）符号表示方式:- --- --- ---type owner group others文件的权限是这样子分配的 读 写 可执行 分别对应的是 r w x 如果没有那一个权限，用 - 代替(-文件 d目录 |连接符号)例如：-rwxr-xr-x（2）八进制表示方式： r ——&gt; 004w ——&gt; 002x ——&gt; 001- ——&gt; 00007550777055504440666 3、打开模式文件打开模式： 12345678910const ( O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件 O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件 O_RDWR int = syscall.O_RDWR // 读写模式打开文件 O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部 O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件 O_EXCL int = syscall.O_EXCL // 和O_CREATE配合使用，文件必须不存在 O_SYNC int = syscall.O_SYNC // 打开文件用于同步I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件) 4、File操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type File//File代表一个打开的文件对象。func Create(name string) (file *File, err error)//Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。func Open(name string) (file *File, err error)//Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。func OpenFile(name string, flag int, perm FileMode) (file *File, err error)//OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。func NewFile(fd uintptr, name string) *File//NewFile使用给出的Unix文件描述符和名称创建一个文件。func Pipe() (r *File, w *File, err error)//Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。func (f *File) Name() string//Name方法返回（提供给Open/Create等方法的）文件名称。func (f *File) Stat() (fi FileInfo, err error)//Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。func (f *File) Fd() uintptr//Fd返回与文件f对应的整数类型的Unix文件描述符。func (f *File) Chdir() error//Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。func (f *File) Chmod(mode FileMode) error//Chmod修改文件的模式。如果出错，错误底层类型是*PathError。func (f *File) Chown(uid, gid int) error//Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。func (f *File) Close() error//Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。func (f *File) Readdir(n int) (fi []FileInfo, err error)//Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。func (f *File) Readdirnames(n int) (names []string, err error)//Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。如果n&gt;0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。如果n&lt;=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。func (f *File) Truncate(size int64) error//Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。 5、示例代码文件信息：FileInfo 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"os\" \"fmt\")func main() &#123; /* FileInfo：文件信息 interface Name()，文件名 Size()，文件大小，字节为单位 IsDir()，是否是目录 ModTime()，修改时间 Mode()，权限 */ fileInfo,err := os.Stat(\"/Users/ruby/Documents/pro/a/aa.txt\") if err != nil&#123; fmt.Println(\"err :\",err) return &#125; fmt.Printf(\"%T\\n\",fileInfo) //文件名 fmt.Println(fileInfo.Name()) //文件大小 fmt.Println(fileInfo.Size()) //是否是目录 fmt.Println(fileInfo.IsDir()) //IsDirectory //修改时间 fmt.Println(fileInfo.ModTime()) //权限 fmt.Println(fileInfo.Mode()) //-rw-r--r--&#125; 运行结果： 文件操作实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package mainimport ( \"fmt\" \"path/filepath\" \"path\" \"os\")func main() &#123; /* 文件操作： 1.路径： 相对路径：relative ab.txt 相对于当前工程 绝对路径：absolute /Users/ruby/Documents/pro/a/aa.txt .当前目录 ..上一层 2.创建文件夹，如果文件夹存在，创建失败 os.MkDir()，创建一层 os.MkDirAll()，可以创建多层 3.创建文件，Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件） os.Create()，创建文件 4.打开文件：让当前的程序，和指定的文件之间建立一个连接 os.Open(filename) os.OpenFile(filename,mode,perm) 5.关闭文件：程序和文件之间的链接断开。 file.Close() 5.删除文件或目录：慎用，慎用，再慎用 os.Remove()，删除文件和空目录 os.RemoveAll()，删除所有 */ //1.路径 fileName1:=\"/Users/ruby/Documents/pro/a/aa.txt\" fileName2:=\"bb.txt\" fmt.Println(filepath.IsAbs(fileName1)) //true fmt.Println(filepath.IsAbs(fileName2)) //false fmt.Println(filepath.Abs(fileName1)) fmt.Println(filepath.Abs(fileName2)) // /Users/ruby/go/src/l_file/bb.txt fmt.Println(\"获取父目录：\",path.Join(fileName1,\"..\")) //2.创建目录 //err := os.Mkdir(\"/Users/ruby/Documents/pro/a/bb\",os.ModePerm) //if err != nil&#123; // fmt.Println(\"err:\",err) // return //&#125; //fmt.Println(\"文件夹创建成功。。\") //err :=os.MkdirAll(\"/Users/ruby/Documents/pro/a/cc/dd/ee\",os.ModePerm) //if err != nil&#123; // fmt.Println(\"err:\",err) // return //&#125; //fmt.Println(\"多层文件夹创建成功\") //3.创建文件:Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件） //file1,err :=os.Create(\"/Users/ruby/Documents/pro/a/ab.txt\") //if err != nil&#123; // fmt.Println(\"err：\",err) // return //&#125; //fmt.Println(file1) //file2,err := os.Create(fileName2)//创建相对路径的文件，是以当前工程为参照的 //if err != nil&#123; // fmt.Println(\"err :\",err) // return //&#125; //fmt.Println(file2) //4.打开文件： //file3 ,err := os.Open(fileName1) //只读的 //if err != nil&#123; // fmt.Println(\"err:\",err) // return //&#125; //fmt.Println(file3) /* 第一个参数：文件名称 第二个参数：文件的打开方式 const ( // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified. O_RDONLY int = syscall.O_RDONLY // open the file read-only. O_WRONLY int = syscall.O_WRONLY // open the file write-only. O_RDWR int = syscall.O_RDWR // open the file read-write. // The remaining values may be or'ed in to control behavior. O_APPEND int = syscall.O_APPEND // append data to the file when writing. O_CREATE int = syscall.O_CREAT // create a new file if none exists. O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist. O_SYNC int = syscall.O_SYNC // open for synchronous I/O. O_TRUNC int = syscall.O_TRUNC // truncate regular writable file when opened. ) 第三个参数：文件的权限：文件不存在创建文件，需要指定权限 */ //file4,err := os.OpenFile(fileName1,os.O_RDONLY|os.O_WRONLY,os.ModePerm) //if err != nil&#123; // fmt.Println(\"err:\",err) // return //&#125; //fmt.Println(file4) //5关闭文件， //file4.Close() //6.删除文件或文件夹： //删除文件 //err := os.Remove(\"/Users/ruby/Documents/pro/a/aa.txt\") //if err != nil&#123; // fmt.Println(\"err:\",err) // return //&#125; //fmt.Println(\"删除文件成功。。\") //删除目录 err := os.RemoveAll(\"/Users/ruby/Documents/pro/a/cc\") if err != nil&#123; fmt.Println(\"err:\",err) return &#125; fmt.Println(\"删除目录成功。。\")&#125; 二、I/O操作I/O操作也叫输入输出操作。其中I是指Input，O是指Output，用于读或者写数据的，有些语言中也叫流操作，是指数据通信的通道。 Golang 标准库对 IO 的抽象非常精巧，各个组件可以随意组合，可以作为接口设计的典范。 1、io包io包中提供I/O原始操作的一系列接口。它主要包装了一些已有的实现，如 os 包中的那些，并将这些抽象成为实用性的功能和一些其他相关的接口。 由于这些接口和原始的操作以不同的实现包装了低级操作，客户不应假定它们对于并行执行是安全的。 在io包中最重要的是两个接口：Reader和Writer接口，首先来介绍这两个接口． Reader接口的定义，Read()方法用于读取数据。 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 1234567Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的错误。即使 Read 返回的 n &lt; len(p)，它也会在调用过程中使用 p的全部作为暂存空间。若一些数据可用但不到 len(p) 个字节，Read 会照例返回可用的东西，而不是等待更多。当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF 情况，它就会返回读取的字节数。它会从相同的调用中返回（非nil的）错误或从随后的调用中返回错误（和 n &#x3D;&#x3D; 0）。这种一般情况的一个例子就是 Reader 在输入流结束时会返回一个非零的字节数，可能的返回不是 err &#x3D;&#x3D; EOF 就是 err &#x3D;&#x3D; nil。无论如何，下一个 Read 都应当返回 0, EOF。调用者应当总在考虑到错误 err 前处理 n &gt; 0 的字节。这样做可以在读取一些字节，以及允许的 EOF 行为后正确地处理I&#x2F;O错误。Read 的实现会阻止返回零字节的计数和一个 nil 错误，调用者应将这种情况视作空操作。 Writer接口的定义，Write()方法用于写出数据。 123type Writer interface &#123; Write(p []byte) (n int, err error)&#125; 1Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数n（0 &lt;&#x3D; n &lt;&#x3D; len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的n &lt; len(p)，它就必须返回一个非nil的错误。Write 不能修改此切片的数据，即便它是临时的。 Seeker接口的定义，封装了基本的 Seek 方法。 123type Seeker interface &#123; Seek(offset int64, whence int) (int64, error)&#125; 12345678Seeker 用来移动数据的读写指针Seek 设置下一次读写操作的指针位置，每次的读写操作都是从指针位置开始的whence 的含义： 如果 whence 为 0：表示从数据的开头开始移动指针 如果 whence 为 1：表示从数据的当前指针位置开始移动指针 如果 whence 为 2：表示从数据的尾部开始移动指针offset 是指针移动的偏移量 返回移动后的指针位置和移动过程中遇到的任何错误 ReaderFrom接口的定义，封装了基本的 ReadFrom 方法。 123type ReaderFrom interface &#123; ReadFrom(r Reader) (n int64, err error)&#125; 1234ReadFrom 从 r 中读取数据到对象的数据流中 直到 r 返回 EOF 或 r 出现读取错误为止 返回值 n 是读取的字节数 返回值 err 就是 r 的返回值 err WriterTo接口的定义，封装了基本的 WriteTo 方法。 123type WriterTo interface &#123; WriteTo(w Writer) (n int64, err error)&#125; 1234WriterTo 将对象的数据流写入到 w 中 直到对象的数据流全部写入完毕或遇到写入错误为止 返回值 n 是写入的字节数 返回值 err 就是 w 的返回值 err 定义ReaderAt接口，ReaderAt 接口封装了基本的 ReadAt 方法 123type ReaderAt interface &#123; ReadAt(p []byte, off int64) (n int, err error)&#125; 12345678910111213ReadAt 从对象数据流的 off 处读出数据到 p 中 忽略数据的读写指针，从数据的起始位置偏移 off 处开始读取 如果对象的数据流只有部分可用，不足以填满 p 则 ReadAt 将等待所有数据可用之后，继续向 p 中写入 直到将 p 填满后再返回 在这点上 ReadAt 要比 Read 更严格 返回读取的字节数 n 和读取时遇到的错误 如果 n &lt; len(p)，则需要返回一个 err 值来说明 为什么没有将 p 填满（比如 EOF） 如果 n &#x3D; len(p)，而且对象的数据没有全部读完，则 err 将返回 nil 如果 n &#x3D; len(p)，而且对象的数据刚好全部读完，则 err 将返回 EOF 或者 nil（不确定） 定义WriterAt接口，WriterAt 接口封装了基本的 WriteAt 方法 123type WriterAt interface &#123; WriteAt(p []byte, off int64) (n int, err error)&#125; 12345WriteAt 将 p 中的数据写入到对象数据流的 off 处 忽略数据的读写指针，从数据的起始位置偏移 off 处开始写入 返回写入的字节数和写入时遇到的错误 如果 n &lt; len(p)，则必须返回一个 err 值来说明 为什么没有将 p 完全写入 其他。。。 2、文件读写file类是在os包中的，封装了底层的文件描述符和相关信息，同时封装了Read和Write的实现。 1234567891011121314151617181920func (f *File) Read(b []byte) (n int, err error)//Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。func (f *File) ReadAt(b []byte, off int64) (n int, err error)//ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n&lt;len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。func (f *File) Write(b []byte) (n int, err error)//Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。func (f *File) WriteString(s string) (ret int, err error)//WriteString类似Write，但接受一个字符串参数。func (f *File) WriteAt(b []byte, off int64) (n int, err error)//WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。func (f *File) Seek(offset int64, whence int) (ret int64, err error)//Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。func (f *File) Sync() (err error)//Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。 3、实例代码读取文件中的数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"os\" \"fmt\" \"io\")func main() &#123; /* 读取数据： Reader接口： Read(p []byte)(n int, error) */ //读取本地aa.txt文件中的数据 //step1：打开文件 fileName := \"/Users/ruby/Documents/pro/a/aa.txt\" file,err := os.Open(fileName) if err != nil&#123; fmt.Println(\"err:\",err) return &#125; //step3：关闭文件 defer file.Close() //step2：读取数据 bs := make([]byte,4,4) /* //第一次读取 n,err :=file.Read(bs) fmt.Println(err) //&lt;nil&gt; fmt.Println(n) //4 fmt.Println(bs) //[97 98 99 100] fmt.Println(string(bs)) //abcd //第二次读取 n,err = file.Read(bs) fmt.Println(err)//&lt;nil&gt; fmt.Println(n)//4 fmt.Println(bs) //[101 102 103 104] fmt.Println(string(bs)) //efgh //第三次读取 n,err = file.Read(bs) fmt.Println(err) //&lt;nil&gt; fmt.Println(n) //2 fmt.Println(bs) //[105 106 103 104] fmt.Println(string(bs)) //ijgh //第四次读取 n,err = file.Read(bs) fmt.Println(err) //EOF fmt.Println(n) //0 */ n := -1 for&#123; n,err = file.Read(bs) if n == 0 || err == io.EOF&#123; fmt.Println(\"读取到了文件的末尾，结束读取操作。。\") break &#125; fmt.Println(string(bs[:n])) &#125;&#125; 写出数据到本地文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( \"os\" \"fmt\" \"log\")func main() &#123; /* 写出数据： */ fileName := \"/Users/ruby/Documents/pro/a/ab.txt\" //step1：打开文件 //step2：写出数据 //step3：关闭文件 //file,err := os.Open(fileName) file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY|os.O_APPEND,os.ModePerm) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() //写出数据 //bs :=[]byte&#123;65,66,67,68,69,70&#125;//A,B,C,D,E,F bs :=[] byte&#123;97,98,99,100&#125; //a,b,c,d //n,err := file.Write(bs) n,err := file.Write(bs[:2]) fmt.Println(n) HandleErr(err) file.WriteString(\"\\n\") //直接写出字符串 n,err = file.WriteString(\"HelloWorld\") fmt.Println(n) HandleErr(err) file.WriteString(\"\\n\") n,err =file.Write([]byte(\"today\")) fmt.Println(n) HandleErr(err)&#125;func HandleErr(err error)&#123; if err != nil&#123; log.Fatal(err) &#125;&#125; 三、文件复制在io包中主要是操作流的一些方法，今天主要学习一下copy。就是把一个文件复制到另一个目录下。 它的原理就是通过程序，从源文件读取文件中的数据，在写出到目标文件里。 1、方法一：io包下的Read()和Write()方法实现我们可以通过io包下的Read()和Write()方法，边读边写，就能够实现文件的复制。这个方法是按块读取文件，块的大小也会影响到程序的性能。 12345678910111213141516171819202122232425262728293031323334&#125;/*该函数的功能：实现文件的拷贝，返回值是拷贝的总数量(字节),错误 */func copyFile1(srcFile,destFile string)(int,error)&#123; file1,err:=os.Open(srcFile) if err != nil&#123; return 0,err &#125; file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm) if err !=nil&#123; return 0,err &#125; defer file1.Close() defer file2.Close() //拷贝数据 bs := make([]byte,1024,1024) n :=-1//读取的数据量 total := 0 for &#123; n,err = file1.Read(bs) if err == io.EOF || n == 0&#123; fmt.Println(\"拷贝完毕。。\") break &#125;else if err !=nil&#123; fmt.Println(\"报错了。。。\") return total,err &#125; total += n file2.Write(bs[:n]) &#125; return total,nil&#125; 2、方法二：io包下的Copy()方法实现我们也可以直接使用io包下的Copy()方法。 示例代码如下： 1234567891011121314func copyFile2(srcFile, destFile string)(int64,error)&#123; file1,err:=os.Open(srcFile) if err != nil&#123; return 0,err &#125; file2,err:=os.OpenFile(destFile,os.O_WRONLY|os.O_CREATE,os.ModePerm) if err !=nil&#123; return 0,err &#125; defer file1.Close() defer file2.Close() return io.Copy(file2,file1)&#125; 扩展内容：在io包（golang 版本 1.12）中，不止提供了Copy()方法，还有另外2个公开的copy方法：CopyN()，CopyBuffer()。 12345Copy（dst,src） 为复制src 全部到 dst 中。CopyN(dst,src,n) 为复制src 中 n 个字节到 dst。CopyBuffer（dst,src,buf）为指定一个buf缓存区，以这个大小完全复制。 他们的关系如下： (图片来自网络) 从图可以看出，无论是哪个copy方法最终都是由copyBuffer（）这个私有方法实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) &#123; // If the reader has a WriteTo method, use it to do the copy. // Avoids an allocation and a copy. if wt, ok := src.(WriterTo); ok &#123; return wt.WriteTo(dst) &#125; // Similarly, if the writer has a ReadFrom method, use it to do the copy. if rt, ok := dst.(ReaderFrom); ok &#123; return rt.ReadFrom(src) &#125; if buf == nil &#123; size := 32 * 1024 if l, ok := src.(*LimitedReader); ok &amp;&amp; int64(size) &gt; l.N &#123; if l.N &lt; 1 &#123; size = 1 &#125; else &#123; size = int(l.N) &#125; &#125; buf = make([]byte, size) &#125; for &#123; nr, er := src.Read(buf) if nr &gt; 0 &#123; nw, ew := dst.Write(buf[0:nr]) if nw &gt; 0 &#123; written += int64(nw) &#125; if ew != nil &#123; err = ew break &#125; if nr != nw &#123; err = ErrShortWrite break &#125; &#125; if er != nil &#123; if er != EOF &#123; err = er &#125; break &#125; &#125; return written, err&#125; 从这部分代码可以看出，复制主要分为3种。 1.如果被复制的Reader（src）会尝试能否断言成writerTo，如果可以则直接调用下面的writerTo方法 2.如果 Writer（dst） 会尝试能否断言成ReadFrom ，如果可以则直接调用下面的readfrom方法 3.如果都木有实现，则调用底层read实现复制。 其中，有这么一段代码： 1234567891011if buf == nil &#123; size := 32 * 1024 if l, ok := src.(*LimitedReader); ok &amp;&amp; int64(size) &gt; l.N &#123; if l.N &lt; 1 &#123; size = 1 &#125; else &#123; size = int(l.N) &#125; &#125; buf = make([]byte, size) &#125; 这部分主要是实现了对Copy和CopyN的处理。通过上面的调用关系图，我们看出CopyN在调用后，会把Reader转成LimiteReader。 区别是如果Copy，直接建立一个缓存区默认大小为 32* 1024 的buf，如果是CopyN 会先判断 要复制的字节数，如果小于默认大小，会创建一个等于要复制字节数的buf。 3、方法三：ioutil包第三种方法是使用ioutil包中的 ioutil.WriteFile()和 ioutil.ReadFile()，但由于使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出。 示例代码： 12345678910111213141516func copyFile3(srcFile, destFile string)(int,error)&#123; input, err := ioutil.ReadFile(srcFile) if err != nil &#123; fmt.Println(err) return 0,err &#125; err = ioutil.WriteFile(destFile, input, 0644) if err != nil &#123; fmt.Println(\"操作失败：\", destFile) fmt.Println(err) return 0,err &#125; return len(input),nil&#125; 4、总结最后，我们来测试一下这3种拷贝需要花费时间，拷贝的文件都是一样的一个mp4文件(400M)， 代码： 1234567891011121314func main() &#123; /* 复制文件： */ //srcFile := \"/home/ruby/文档/pro/aa.txt\" //destFile := \"/home/ruby/文档/aa.txt\" srcFile :=\"/Users/ruby/Documents/pro/a/001_小程序入门.mp4\" destFile:=\"001_小程序入门.mp4\" total,err:=copyFile1(srcFile,destFile) fmt.Println(err) fmt.Println(total)&#125; 第一种：io包下Read()和Write()直接读写：我们自己创建读取数据的切片的大小，直接影响性能。 12345678localhost:l_file ruby$ time go run demo05_copy.go 拷贝完毕。。&lt;nil&gt;401386819real 0m7.911suser 0m2.900ssys 0m7.661s 第二种：io包下Copy()方法： 1234567localhost:l_file ruby$ time go run demo05_copy.go &lt;nil&gt;401386819real 0m1.594suser 0m0.533ssys 0m1.136s 第三种：ioutil包 1234567localhost:l_file ruby$ time go run demo05_copy.go &lt;nil&gt;401386819real 0m1.515suser 0m0.339ssys 0m0.625s 运行结果： 这3种方式，在性能上，不管是还是io.Copy()还是ioutil包，性能都是还不错的。 四、断点续传1、Seeker接口Seeker是包装基本Seek方法的接口。 123type Seeker interface &#123; Seek(offset int64, whence int) (int64, error)&#125; seek(offset,whence),设置指针光标的位置，随机读写文件： 第一个参数：偏移量 第二个参数：如何设置 0：seekStart表示相对于文件开始， 1：seekCurrent表示相对于当前偏移量， 2：seek end表示相对于结束。12345const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end) 示例代码： 我们要读取本地/Users/ruby/Documents/pro/a 目录下的aa.txt文件，文件中的内容是：abcdefghij这几个字符。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"os\" \"fmt\" \"io\")func main() &#123; /* seek(offset,whence),设置指针光标的位置 第一个参数：偏移量 第二个参数：如何设置 0：seekStart表示相对于文件开始， 1：seekCurrent表示相对于当前偏移量， 2：seek end表示相对于结束。 const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end) 随机读取文件： 可以设置指针光标的位置 */ file,_:=os.OpenFile(\"/Users/ruby/Documents/pro/a/aa.txt\",os.O_RDWR,0) defer file.Close() bs :=[]byte&#123;0&#125; file.Read(bs) fmt.Println(string(bs)) file.Seek(4,io.SeekStart) file.Read(bs) fmt.Println(string(bs)) file.Seek(2,0) //也是SeekStart file.Read(bs) fmt.Println(string(bs)) file.Seek(3,io.SeekCurrent) file.Read(bs) fmt.Println(string(bs)) file.Seek(0,io.SeekEnd) file.WriteString(\"ABC\")&#125; 运行结果： 本地文件： 2、断点续传首先思考几个问题Q1：如果你要传的文件，比较大，那么是否有方法可以缩短耗时？Q2：如果在文件传递过程中，程序因各种原因被迫中断了，那么下次再重启时，文件是否还需要重头开始？Q3：传递文件的时候，支持暂停和恢复么？即使这两个操作分布在程序进程被杀前后。 通过断点续传可以实现，不同的语言有不同的实现方式。我们看看Go语言中，通过Seek()方法如何实现： 先说一下思路：想实现断点续传，主要就是记住上一次已经传递了多少数据，那我们可以创建一个临时文件，记录已经传递的数据量，当恢复传递的时候，先从临时文件中读取上次已经传递的数据量，然后通过Seek()方法，设置到该读和该写的位置，再继续传递数据。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport ( \"fmt\" \"os\" \"strconv\" \"io\")func main() &#123; /* 断点续传： 文件传递：文件复制 /Users/ruby/Documents/pro/a/guliang.jpeg 复制到 guliang4.jpeg 思路： 边复制，边记录复制的总量 */ srcFile:=\"/Users/ruby/Documents/pro/a/guliang.jpeg\" destFile:=\"guliang4.jpeg\" tempFile:=destFile+\"temp.txt\" //fmt.Println(tempFile) file1,_:=os.Open(srcFile) file2,_:=os.OpenFile(destFile,os.O_CREATE|os.O_WRONLY,os.ModePerm) file3,_:=os.OpenFile(tempFile,os.O_CREATE|os.O_RDWR,os.ModePerm) defer file1.Close() defer file2.Close() //1.读取临时文件中的数据，根据seek file3.Seek(0,io.SeekStart) bs:=make([]byte,100,100) n1,err:=file3.Read(bs) fmt.Println(n1) countStr:=string(bs[:n1]) fmt.Println(countStr) //count,_:=strconv.Atoi(countStr) count,_:=strconv.ParseInt(countStr,10,64) fmt.Println(count) //2. 设置读，写的偏移量 file1.Seek(count,0) file2.Seek(count,0) data:=make([]byte,1024,1024) n2:=-1// 读取的数据量 n3:=-1//写出的数据量 total :=int(count)//读取的总量 for&#123; //3.读取数据 n2,err=file1.Read(data) if err ==io.EOF&#123; fmt.Println(\"文件复制完毕。。\") file3.Close() os.Remove(tempFile) break &#125; //将数据写入到目标文件 n3,_=file2.Write(data[:n2]) total += n3 //将复制总量，存储到临时文件中 file3.Seek(0,io.SeekStart) file3.WriteString(strconv.Itoa(total)) //假装断电 //if total&gt;8000&#123; // panic(\"假装断电了。。。，假装的。。。\") //&#125; &#125;&#125; 五、bufio包 @author：韩茹版权所有：北京千锋互联科技有限公司 生命不止，继续Go go go。。 Go语言在io操作中，还提供了一个bufio的包，使用这个包可以大幅提高文件读写的效率。 1、bufio包原理bufio 是通过缓冲来提高效率。 io操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以bufio就提供了缓冲区(分配一块内存)，读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。 简单的说就是，把文件读取进缓冲（内存）之后再读取的时候就可以避免文件系统的io 从而提高速度。同理，在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。看完以上解释有人可能会表示困惑了，直接把 内容-&gt;文件 和 内容-&gt;缓冲-&gt;文件相比， 缓冲区好像没有起到作用嘛。其实缓冲区的设计是为了存储多次的写入，最后一口气把缓冲区内容写入文件。 bufio 封装了io.Reader或io.Writer接口对象，并创建另一个也实现了该接口的对象。 io.Reader或io.Writer 接口实现read() 和 write() 方法，对于实现这个接口的对象都是可以使用这两个方法的。 Reader对象 bufio.Reader 是bufio中对io.Reader 的封装 123456789// Reader implements buffering for an io.Reader object.type Reader struct &#123; buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid&#125; bufio.Read(p []byte) 相当于读取大小len(p)的内容，思路如下： 当缓存区有内容的时，将缓存区内容全部填入p并清空缓存区 当缓存区没有内容的时候且len(p)&gt;len(buf),即要读取的内容比缓存区还要大，直接去文件读取即可 当缓存区没有内容的时候且len(p)&lt;len(buf),即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将p填满（此时缓存区有剩余内容） 以后再次读取时缓存区有内容，将缓存区内容全部填入p并清空缓存区（此时和情况1一样） 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Read reads data into p.// It returns the number of bytes read into p.// The bytes are taken from at most one Read on the underlying Reader,// hence n may be less than len(p).// To read exactly len(p) bytes, use io.ReadFull(b, p).// At EOF, the count will be zero and err will be io.EOF.func (b *Reader) Read(p []byte) (n int, err error) &#123; n = len(p) if n == 0 &#123; return 0, b.readErr() &#125; if b.r == b.w &#123; if b.err != nil &#123; return 0, b.readErr() &#125; if len(p) &gt;= len(b.buf) &#123; // Large read, empty buffer. // Read directly into p to avoid copy. n, b.err = b.rd.Read(p) if n &lt; 0 &#123; panic(errNegativeRead) &#125; if n &gt; 0 &#123; b.lastByte = int(p[n-1]) b.lastRuneSize = -1 &#125; return n, b.readErr() &#125; // One read. // Do not use b.fill, which will loop. b.r = 0 b.w = 0 n, b.err = b.rd.Read(b.buf) if n &lt; 0 &#123; panic(errNegativeRead) &#125; if n == 0 &#123; return 0, b.readErr() &#125; b.w += n &#125; // copy as much as we can n = copy(p, b.buf[b.r:b.w]) b.r += n b.lastByte = int(b.buf[b.r-1]) b.lastRuneSize = -1 return n, nil&#125; 说明： reader内部通过维护一个r, w 即读入和写入的位置索引来判断是否缓存区内容被全部读出。 Writer对象 bufio.Writer 是bufio中对io.Writer 的封装 123456789101112// Writer implements buffering for an io.Writer object.// If an error occurs writing to a Writer, no more data will be// accepted and all subsequent writes, and Flush, will return the error.// After all data has been written, the client should call the// Flush method to guarantee all data has been forwarded to// the underlying io.Writer.type Writer struct &#123; err error buf []byte n int wr io.Writer&#125; bufio.Write(p []byte) 的思路如下 判断buf中可用容量是否可以放下 p 如果能放下，直接把p拼接到buf后面，即把内容放到缓冲区 如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把p写入文件即可 如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用p把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区 判断p的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤1情况一样）则把内容放到缓冲区 如果p的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤3一样）则把p的剩余内容直接写入文件 以下是源码 123456789101112131415161718192021222324252627// Write writes the contents of p into the buffer.// It returns the number of bytes written.// If nn &lt; len(p), it also returns an error explaining// why the write is short.func (b *Writer) Write(p []byte) (nn int, err error) &#123; for len(p) &gt; b.Available() &amp;&amp; b.err == nil &#123; var n int if b.Buffered() == 0 &#123; // Large write, empty buffer. // Write directly from p to avoid copy. n, b.err = b.wr.Write(p) &#125; else &#123; n = copy(b.buf[b.n:], p) b.n += n b.Flush() &#125; nn += n p = p[n:] &#125; if b.err != nil &#123; return nn, b.err &#125; n := copy(b.buf[b.n:], p) b.n += n nn += n return nn, nil&#125; 说明： b.wr 存储的是一个io.writer对象，实现了Write()的接口，所以可以使用b.wr.Write(p) 将p的内容写入文件。 b.flush() 会将缓存区内容写入文件，当所有写入完成后，因为缓存区会存储内容，所以需要手动flush()到文件。 b.Available() 为buf可用容量，等于len(buf) - n。 下图解释的是其中一种情况，即缓存区有内容，剩余p大于缓存区 2、bufio包bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，创建另一个也实现了该接口，且同时还提供了缓冲和一些文本I/O的帮助函数的对象。 bufio.Reader： bufio.Reader 实现了如下接口： io.Reader io.WriterTo io.ByteScanner io.RuneScanner 12345678910111213141516171819202122232425262728293031323334// NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，// 缓存大小由 size 指定（如果小于 16 则会被设置为 16）。// 如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将// rd 转换为基类型返回。func NewReaderSize(rd io.Reader, size int) *Reader// NewReader 相当于 NewReaderSize(rd, 4096)func NewReader(rd io.Reader) *Reader// Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，// 该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之// 前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。// 如果 n 大于缓存的总大小，则返回 ErrBufferFull。func (b *Reader) Peek(n int) ([]byte, error)// Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。// 如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader// 中提取数据，如果缓存为空，则：// 1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读// 出到 p 中。// 2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存// 中，再从缓存读取到 p 中。func (b *Reader) Read(p []byte) (n int, err error)// Buffered 返回缓存中未读取的数据的长度。func (b *Reader) Buffered() int// ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。func (b *Reader) ReadBytes(delim byte) (line []byte, err error)// ReadString 功能同 ReadBytes，只不过返回的是字符串。func (b *Reader) ReadString(delim byte) (line string, err error)... bufio.Writer： bufio.Writer 实现了如下接口： io.Writer io.ReaderFrom io.ByteWriter 1234567891011121314151617181920212223242526272829// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将// wr 转换为基类型返回。func NewWriterSize(wr io.Writer, size int) *Writer// NewWriter 相当于 NewWriterSize(wr, 4096)func NewWriter(wr io.Writer) *Writer// WriteString 功能同 Write，只不过写入的是字符串func (b *Writer) WriteString(s string) (int, error)// WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。func (b *Writer) WriteRune(r rune) (size int, err error)// Flush 将缓存中的数据提交到底层的 io.Writer 中func (b *Writer) Flush() error// Available 返回缓存中未使用的空间的长度func (b *Writer) Available() int// Buffered 返回缓存中未提交的数据的长度func (b *Writer) Buffered() int// Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位// 所有标记和错误信息。相当于创建了一个新的 bufio.Writer。func (b *Writer) Reset(w io.Writer)... 3、实例代码读取数据： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( \"os\" \"fmt\" \"bufio\")func main() &#123; /* bufio:高效io读写 buffer缓存 io：input/output 将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率 ReadBytes() ReadString() ReadLine() */ fileName:=\"/Users/ruby/Documents/pro/a/english.txt\" file,err := os.Open(fileName) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() //创建Reader对象 //b1 := bufio.NewReader(file) //1.Read()，高效读取 //p := make([]byte,1024) //n1,err := b1.Read(p) //fmt.Println(n1) //fmt.Println(string(p[:n1])) //2.ReadLine() //data,flag,err := b1.ReadLine() //fmt.Println(flag) //fmt.Println(err) //fmt.Println(data) //fmt.Println(string(data)) //3.ReadString() // s1,err :=b1.ReadString('\\n') // fmt.Println(err) // fmt.Println(s1) // // s1,err = b1.ReadString('\\n') // fmt.Println(err) // fmt.Println(s1) // //s1,err = b1.ReadString('\\n') //fmt.Println(err) //fmt.Println(s1) // //for&#123; // s1,err := b1.ReadString('\\n') // if err == io.EOF&#123; // fmt.Println(\"读取完毕。。\") // break // &#125; // fmt.Println(s1) //&#125; //4.ReadBytes() //data,err :=b1.ReadBytes('\\n') //fmt.Println(err) //fmt.Println(string(data)) //Scanner //s2 := \"\" //fmt.Scanln(&amp;s2) //fmt.Println(s2) b2 := bufio.NewReader(os.Stdin) s2, _ := b2.ReadString('\\n') fmt.Println(s2)&#125; 本地文件：english.txt文件内容： 写数据示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"os\" \"fmt\" \"bufio\")func main() &#123; /* bufio:高效io读写 buffer缓存 io：input/output 将io包下的Reader，Write对象进行包装，带缓存的包装，提高读写的效率 func (b *Writer) Write(p []byte) (nn int, err error) func (b *Writer) WriteByte(c byte) error func (b *Writer) WriteRune(r rune) (size int, err error) func (b *Writer) WriteString(s string) (int, error) */ fileName := \"/Users/ruby/Documents/pro/a/cc.txt\" file,err := os.OpenFile(fileName,os.O_CREATE|os.O_WRONLY,os.ModePerm) if err != nil&#123; fmt.Println(err) return &#125; defer file.Close() w1 := bufio.NewWriter(file) //n,err := w1.WriteString(\"helloworld\") //fmt.Println(err) //fmt.Println(n) //w1.Flush() //刷新缓冲区 for i:=1;i&lt;=1000;i++&#123; w1.WriteString(fmt.Sprintf(\"%d:hello\",i)) &#125; w1.Flush()&#125; 六、ioutil包除了io包可以读写数据，Go语言中还提供了一个辅助的工具包就是ioutil，里面的方法虽然不多，但是都还蛮好用的。 1import \"io/ioutil\" 该包的介绍只有一句话：Package ioutil implements some I/O utility functions。 1、ioutil包的方法下面我们来看一下里面的方法： 12345678910111213141516171819202122232425262728293031323334// Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情// 并且始终成功返回。var Discard io.Writer = devNull(0)// ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。// 如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取// 所有数据，所以不会把 EOF 当做错误处理。func ReadAll(r io.Reader) ([]byte, error)// ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。// 如果读取成功，则 err 返回 nil，而不是 EOFfunc ReadFile(filename string) ([]byte, error)// WriteFile 向文件中写入数据，写入前会清空文件。// 如果文件不存在，则会以指定的权限创建该文件。// 返回遇到的错误。func WriteFile(filename string, data []byte, perm os.FileMode) error// ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。// 返回读取到的文件信息列表和遇到的错误，列表是经过排序的。func ReadDir(dirname string) ([]os.FileInfo, error)// NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。func NopCloser(r io.Reader) io.ReadCloser// TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读// 写模式打开。返回创建的文件对象和遇到的错误。// 如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次// 调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。// 调用本函数所创建的临时文件，应该由调用者自己删除。func TempFile(dir, prefix string) (f *os.File, err error)// TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。func TempDir(dir, prefix string) (name string, err error) 2、示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport ( \"io/ioutil\" \"fmt\" \"os\")func main() &#123; /* ioutil包： ReadFile() WriteFile() ReadDir() .. */ //1.读取文件中的所有的数据 //fileName1 := \"/Users/ruby/Documents/pro/a/aa.txt\" //data, err := ioutil.ReadFile(fileName1) //fmt.Println(err) //fmt.Println(string(data)) //2.写出数据 //fileName2:=\"/Users/ruby/Documents/pro/a/bbb.txt\" //s1:=\"helloworld面朝大海春暖花开\" //err:=ioutil.WriteFile(fileName2,[]byte(s1),0777) //fmt.Println(err) //3. //s2:=\"qwertyuiopsdfghjklzxcvbnm\" //r1:=strings.NewReader(s2) //data,_:=ioutil.ReadAll(r1) //fmt.Println(data) //4.ReadDir(),读取一个目录下的子内容：子文件和子目录，但是仅有一层 //dirName:=\"/Users/ruby/Documents/pro/a\" //fileInfos,_:=ioutil.ReadDir(dirName) //fmt.Println(len(fileInfos)) //for i:=0;i&lt;len(fileInfos);i++&#123; // //fmt.Printf(\"%T\\n\",fileInfos[i]) // fmt.Println(i,fileInfos[i].Name(),fileInfos[i].IsDir()) // //&#125; // 5.创建临时目录 dir, err := ioutil.TempDir(\"/Users/ruby/Documents/pro/a\", \"Test\") if err != nil &#123; fmt.Println(err) &#125; defer os.Remove(dir) // 用完删除 fmt.Printf(\"%s\\n\", dir) // 创建临时文件 f, err := ioutil.TempFile(dir, \"Test\") if err != nil &#123; fmt.Println(err) &#125; defer os.Remove(f.Name()) // 用完删除 fmt.Printf(\"%s\\n\", f.Name())&#125; 七、遍历文件夹学习io之后，尤其是文件操作，我们就可以遍历给定的目录文件夹了。可以使用ioutil包下的readDir()方法，这个方法可以获取指定目录下的内容，返回文件和子目录。 因为文件夹下还有子文件夹，而ioutil包的ReadDir()只能获取一层目录，所以我们需要自己去设计算法来实现，最容易实现的思路就是使用递归。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"io/ioutil\" \"fmt\" \"log\")func main() &#123; /** 遍历文件夹： */ dirname := \"/Users/ruby/Documents/pro\" listFiles(dirname, 0)&#125;func listFiles(dirname string, level int) &#123; // level用来记录当前递归的层次 // 生成有层次感的空格 s := \"|--\" for i := 0; i &lt; level; i++ &#123; s = \"| \" + s &#125; fileInfos, err := ioutil.ReadDir(dirname) if err != nil&#123; log.Fatal(err) &#125; for _, fi := range fileInfos &#123; filename := dirname + \"/\" + fi.Name() fmt.Printf(\"%s%s\\n\", s, filename) if fi.IsDir() &#123; //继续遍历fi这个目录 listFiles(filename, level+1) &#125; &#125;&#125; 运行结果：","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"Linux基本命令","slug":"Linux基本命令","date":"2020-07-01T15:43:44.000Z","updated":"2020-07-01T15:49:47.895Z","comments":true,"path":"2020/07/01/Linux基本命令/","link":"","permalink":"http://nlbyd1119.online/2020/07/01/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"inux命令是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。","text":"inux命令是对Linux系统进行管理的命令。对于Linux系统来说，无论是中央处理器、内存、磁盘驱动器、键盘、鼠标，还是用户等都是文件，Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。linux命令在系统中有两种类型：内置Shell命令和Linux命令。 命令 功能说明 线上查询及帮助命令 (2 个) man 查看命令帮助，命令的词典，更复杂的还有 info，但不常用。 help 查看 Linux 内置命令的帮助，比如 cd 命令。 件和目录操作命令 (18 个) ls 全拼 list，功能是列出目录的内容及其内容属性信息。 cd 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。 cp 全拼 copy，其功能为复制文件或目录。 find 查找的意思，用于查找目录及目录下的文件。 mkdir 全拼 make directories，其功能是创建目录。 mv 全拼 move，其功能是移动或重命名文件。 pwd 全拼 print working directory，其功能是显示当前工作目录的绝对路径。 rename 用于重命名文件。 rm 全拼 remove，其功能是删除一个或多个文件或目录。 rmdir 全拼 remove empty directories，功能是删除空目录。 touch 创建新的空文件，改变已有文件的时间戳属性。 tree 功能是以树形结构显示目录下的内容。 basename 显示文件名或目录名。 dirname 显示文件或目录路径。 chattr 改变文件的扩展属性。 lsattr 查看文件扩展属性。 file 显示文件的类型。 md5sum 计算和校验文件的 MD5 值。 查看文件及内容处理命令（21 个） cat 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。 tac tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。 more 分页显示文件内容。 less 分页显示文件内容，more 命令的相反用法。 head 显示文件内容的头部。 tail 显示文件内容的尾部。 cut 将文件的每一行按指定分隔符分割并输出。 split 分割文件为不同的小片段。 paste 按行合并文件内容。 sort 对文件的文本内容排序。 uniq 去除重复行。oldboy wc 统计文件的行数、单词数或字节数。 iconv 转换文件的编码格式。 dos2unix 将 DOS 格式文件转换成 UNIX 格式。 diff 全拼 difference，比较文件的差异，常用于文本文件。 vimdiff 命令行可视化文件比较工具，常用于文本文件。 rev 反向输出文件内容。 grep/egrep 过滤字符串，三剑客老三。 join 按两个文件的相同字段合并。 tr 替换或删除字符。 vi/vim 命令行文本编辑器。 文件压缩及解压缩命令（4 个） tar 打包压缩。oldboy unzip 解压文件。 gzip gzip 压缩工具。 zip 压缩工具。 信息显示命令（11 个） uname 显示操作系统相关信息的命令。 hostname 显示或者设置当前系统的主机名。 dmesg 显示开机信息，用于诊断系统故障。 uptime 显示系统运行时间及负载。 stat 显示文件或文件系统的状态。 du 计算磁盘空间使用情况。 df 报告文件系统磁盘空间的使用情况。 top 实时显示系统资源使用情况。 free 查看系统内存。 date 显示与设置系统时间。 cal 查看日历等时间信息。 搜索文件命令（4 个） which 查找二进制命令，按环境变量 PATH 路径查找。 find 从磁盘遍历查找文件或目录。 whereis 查找二进制命令，按环境变量 PATH 路径查找。 locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。 用户管理命令（10 个） useradd 添加用户。 usermod 修改系统已经存在的用户属性。 userdel 删除用户。 groupadd 添加用户组。 passwd 修改用户密码。 chage 修改用户密码有效期限。 id 查看用户的 uid,gid 及归属的用户组。 su 切换用户身份。 visudo 编辑 / etc/sudoers 文件的专属命令。 sudo 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。 基础网络操作命令（11 个） telnet 使用 TELNET 协议远程登录。 ssh 使用 SSH 加密协议远程登录。 scp 全拼 secure copy，用于不同主机之间复制文件。 wget 命令行下载文件。 ping 测试主机之间网络的连通性。 route 显示和设置 linux 系统的路由表。 ifconfig 查看、配置、启用或禁用网络接口的命令。 ifup 启动网卡。 ifdown 关闭网卡。 netstat 查看网络状态。 ss 查看网络状态。 深入网络操作命令（9 个） nmap 网络扫描命令。 lsof 全名 list open files，也就是列举系统中已经被打开的文件。 mail 发送和接收邮件。 mutt 邮件管理命令。 nslookup 交互式查询互联网 DNS 服务器的命令。 dig 查找 DNS 解析过程。 host 查询 DNS 的命令。 traceroute 追踪数据传输路由状况。 tcpdump 命令行的抓包工具。 有关磁盘与文件系统的命令（16 个） mount 挂载文件系统。 umount 卸载文件系统。 fsck 检查并修复 Linux 文件系统。 dd 转换或复制文件。 dumpe2fs 导出 ext2/ext3/ext4 文件系统信息。 dump ext2/3/4 文件系统备份工具。 fdisk 磁盘分区命令，适用于 2TB 以下磁盘分区。 parted 磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。 mkfs 格式化创建 Linux 文件系统。 partprobe 更新内核的硬盘分区表信息。 e2fsck 检查 ext2/ext3/ext4 类型文件系统。 mkswap 创建 Linux 交换分区。 swapon 启用交换分区。 swapoff 关闭交换分区。 sync 将内存缓冲区内的数据写入磁盘。 resize2fs 调整 ext2/ext3/ext4 文件系统大小。 系统权限及用户授权相关命令（4 个） chmod 改变文件或目录权限。 chown 改变文件或目录的属主和属组。 chgrp 更改文件用户组。 umask 显示或设置权限掩码。 查看系统用户登陆信息的命令（7 个） whoami 显示当前有效的用户名称，相当于执行 id -un 命令。 who 显示目前登录系统的用户信息。 w 显示已经登陆系统的用户列表，并显示用户正在执行的指令。 last 显示登入系统的用户。 lastlog 显示系统中所有用户最近一次登录信息。 users 显示当前登录系统的所有用户的用户列表。 finger 查找并显示用户信息。 内置命令及其它（19 个） echo 打印变量，或直接输出指定的字符串 printf 将结果格式化输出到标准输出。 rpm 管理 rpm 包的命令。 yum 自动化简单化地管理 rpm 包的命令。 watch 周期性的执行给定的命令，并将命令的输出以全屏方式显示。 alias 设置系统别名。 unalias 取消系统别名。 date 查看或设置系统时间。 clear 清除屏幕，简称清屏。 history 查看命令执行的历史纪录。 eject 弹出光驱。 time 计算命令执行时间。 nc 功能强大的网络工具。 xargs 将标准输入转换成命令行参数。 exec 调用并执行指令的命令。 export 设置或者显示环境变量。 unset 删除变量或函数。 type 用于判断另外一个命令是否是内置命令。 bc 命令行科学计算器 系统管理与性能监视命令 (9 个) chkconfig 管理 Linux 系统开机启动项。 vmstat 虚拟内存统计。 mpstat 显示各个可用 CPU 的状态统计。 iostat 统计系统 IO。 sar 全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。 ipcs 用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 ipcrm 用来删除一个或更多的消息队列、信号量集或者共享内存标识。 strace 用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ltrace 命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。 关机 / 重启 / 注销和查看系统信息的命令（6 个） shutdown 关机。 halt 关机。 poweroff 关闭电源。 logout 退出当前登录的 Shell。 exit 退出当前登录的 Shell。 Ctrl+d 退出当前登录的 Shell 的快捷键。 进程管理相关命令（15 个） bg 将一个在后台暂停的命令，变成继续执行 （在后台执行）。 fg 将后台中的命令调至前台继续运行。 jobs 查看当前有多少在后台运行的命令。 kill 终止进程。 killall 通过进程名终止进程。 pkill 通过进程名终止进程。 crontab 定时任务命令。 ps 显示进程的快照。 pstree 树形显示进程。 nice/renice 调整程序运行的优先级。 nohup 忽略挂起信号运行指定的命令。 pgrep 查找匹配条件的进程。 runlevel 查看系统当前运行级别。 init 切换运行级别。 service 启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。","categories":[{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"科研信息系统实现基本点","slug":"科研信息系统实现基本点","date":"2020-06-30T13:08:35.000Z","updated":"2020-07-10T08:56:52.905Z","comments":true,"path":"2020/06/30/科研信息系统实现基本点/","link":"","permalink":"http://nlbyd1119.online/2020/06/30/%E7%A7%91%E7%A0%94%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%82%B9/","excerpt":"数据库基本操作 spring data mongodb","text":"数据库基本操作 spring data mongodb 三种方式实现数据库操作 MongoRepository接口中的基础方法1234567891011121314countcountdeletedeleteAlldeleteByIdexistsexistsByIdfindAllfindAllByIdfindByIdfindOneinsertsavesaveAll 方法命名规则查询参考Spring Data JPA篇 提供了更复杂的查询方式 MongoTemplate 以上三种方式，第一种通过继承接口实现，第二种在自定义接口中按规则定义方法实现，第三种直接将MongoTemplate注入service实现，具体参考文档。 响应界面 ajax 多表关联操作实现参考 原本以为和关系型数据库类似，但实际操作起来区别比较大。目的是要实现用户和角色的多对多操作，但一个问题是，如何实现实体类的关联，另一个问题是基本操作+复杂查询如何实现。前者是使用@DBRef注解，后者参考多篇博文，没有通用的方法，了解到Aggregation、$lookup、@Query等写法，但很难与实际需求相吻合，不过也可以参考。 spring data mongodb原生语句查询https://www.jianshu.com/p/189aae776fdfhttps://blog.csdn.net/dark_horse_lk/article/details/100563960 Spring Data Mongodb多表关联查询https://blog.csdn.net/zhang135123/article/details/85273957 重点参考https://blog.csdn.net/lchq1995/article/details/102586243 重点参考https://blog.csdn.net/seesun2012/article/details/105165495 重点参考https://blog.csdn.net/Mr_EvanChen/article/details/92993026 $lookuphttps://blog.csdn.net/WaterSprite_ct/article/details/78500997https://blog.csdn.net/tornadowp/article/details/7196764?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase spring data mongodb多对多https://m.656463.com/wenda/SpringDataMongoDBdddgxcj_99 Spring Data Mongodb注解https://blog.csdn.net/wuhenzhangxing/article/details/80308352https://blog.csdn.net/Amethyst128/article/details/102467473?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecasehttps://blog.csdn.net/qq_25113569/article/details/88527412https://blog.csdn.net/justdoit_potato/article/details/81007008 双数据源配置https://www.baidu.com/s?wd=mybatis%E9%9B%86%E6%88%90mongodb&amp;rsv_spt=1&amp;rsv_iqid=0x817da525000577bf&amp;issp=1&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ts_0&amp;rsv_sug3=16&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_t=a10cvmSrxCZvHMMZiuTMVPQdI8vCGnxj7YG9dJQfPmpT8hvlnvyjs%2FIqVYJyXyhVQCE3&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=mybatis%25E9%259B%2586%25E6%2588%2590m&amp;rsp=0&amp;inputT=6773&amp;rsv_sug4=6774https://www.cnblogs.com/moris5013/p/11156398.htmlhttps://www.jianshu.com/p/1c85b21d3a84https://www.jb51.net/article/130228.htmhttps://blog.csdn.net/lan876571557/article/details/102623596https://www.baidu.com/s?wd=%E5%8F%8C%E6%95%B0%E6%8D%AE%E6%BA%90Mybatis%2BMongoDB%E9%85%8D%E7%BD%AE&amp;rsv_spt=1&amp;rsv_iqid=0xd9458e3200011253&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_sug3=2&amp;rsv_sug1=1&amp;rsv_sug7=001&amp;rsv_n=2&amp;rsv_btype=i&amp;inputT=1378&amp;rsv_sug4=13462&amp;rsv_sug=9https://blog.csdn.net/you_ran_jian/article/details/102820145https://blog.csdn.net/weixin_39300480/article/details/97284517https://blog.csdn.net/qq_31150503/article/details/103746456 @DBRefhttps://blog.csdn.net/Paranoia_ZK/article/details/84103080https://blog.csdn.net/coolcaosj/article/details/22915455 参考https://blog.csdn.net/itmyhome/article/details/52240919 参考https://blog.csdn.net/weixin_44530530/article/details/91901631 参考https://blog.csdn.net/qq_21454973/article/details/91856617 参考 spring data mongo实现多对多https://blog.csdn.net/Justinjiang1314/article/details/80771449https://blog.csdn.net/PyNinja/article/details/98601365 参考https://blog.csdn.net/terry_water/article/details/40875627 ObjectIdhttps://mongoing.com/archives/docs/mongodb%e5%88%9d%e5%ad%a6%e8%80%85%e6%95%99%e7%a8%8b/mongodb%e4%b8%bb%e9%94%ae%ef%bc%9a%e4%bd%bf%e7%94%a8objectid%ef%bc%88%ef%bc%89%e8%ae%be%e7%bd%ae_id%e5%ad%97%e6%ae%b5 基本操作 重点参考https://juejin.im/post/5afb9de8518825426c690307 mongodb保证不插入重复记录https://www.baidu.com/s?wd=mongodb%E4%BF%9D%E8%AF%81%E4%B8%8D%E6%8F%92%E5%85%A5%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95&amp;rsv_spt=1&amp;rsv_iqid=0xe4fc9fa200203d47&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=35&amp;rsv_sug1=15&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=12213&amp;rsv_sug4=12937https://recomm.cnblogs.com/blogpost/12622893https://www.jianshu.com/p/adedee065c28https://www.baidu.com/s?wd=%40Indexed(unique%20%3D%20true)&amp;rsv_spt=1&amp;rsv_iqid=0xfe3192d50044e86d&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_sug3=2&amp;rsv_sug1=1&amp;rsv_sug7=001&amp;rsv_n=2&amp;rsv_btype=i&amp;prefixsug=%2540Indexed(unique%2520%253D%2520true)&amp;rsp=7&amp;rsv_sug9=es_0_1&amp;inputT=1249&amp;rsv_sug4=1808&amp;rsv_sug=9https://segmentfault.com/a/1190000018626992 多对多栈溢出https://www.baidu.com/s?wd=org.springframework.dao.DuplicateKeyException%3A%20E11000%20duplicate%20key%20error%20co&amp;rsv_spt=1&amp;rsv_iqid=0xefbe92fb0000ac4e&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_n=2&amp;rsv_sug3=1&amp;rsv_t=d3c9wwReEedVAvbOHm0UCZg1p7jUHMFTiai1Vl6%2BCV0cuxuNeoLjKhYyG4JMN1L6ihGg&amp;rsv_btype=i&amp;inputT=1682&amp;rsv_sug4=1682https://www.cnblogs.com/linzhanfly/p/9760821.htmlhttps://blog.csdn.net/mhs624014469/article/details/78029699https://www.baidu.com/s?wd=mongodb%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2%E6%A0%88%E6%BA%A2%E5%87%BA&amp;rsv_spt=1&amp;rsv_iqid=0x80ef88430001a08a&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=0&amp;rsv_dl=tb&amp;rsv_t=6188FOMtIpoqxznSHnaad%2FV%2FfixyA%2FY3bPqO7SRSQB8avpFRWtKkNRJVxFp9ZIhsQaJ1&amp;oq=at%2520com.mongodb.internal.connection.%2526lt%253BoncurrentPool.acquirePermit&amp;rsv_btype=t&amp;inputT=14755&amp;rsv_pq=b816812e00069063&amp;rsv_sug3=79&amp;rsv_sug1=19&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=16260https://www.cnblogs.com/zengda/p/4540670.html 抽取出用户角色操作后测试注意点 自定义sprig security中的规则先后顺序是有影响的用户状态值需要注意，若为0，则具有角色也无法登录","categories":[{"name":"框架使用","slug":"框架使用","permalink":"http://nlbyd1119.online/categories/%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"springboot集成时的一些参考","slug":"springboot集成时的一些参考","date":"2020-06-29T15:35:06.000Z","updated":"2020-07-01T15:49:51.974Z","comments":true,"path":"2020/06/29/springboot集成时的一些参考/","link":"","permalink":"http://nlbyd1119.online/2020/06/29/springboot%E9%9B%86%E6%88%90%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83/","excerpt":"对2020.6.27-6.29整合springboot与安全框架、orm框架过程中参考的一些网站进行记录","text":"对2020.6.27-6.29整合springboot与安全框架、orm框架过程中参考的一些网站进行记录 springboot配置spring securityhttps://www.jianshu.com/p/6a7dcef02bd5https://www.cnblogs.com/xifengxiaoma/p/11106220.htmlhttps://gitee.com/nlby/spring-boot-demo/tree/master/Spring%20Boot%EF%BC%9A%E6%95%B4%E5%90%88Spring%20Security/demohttps://blog.csdn.net/u013435893/article/details/79596628swaggerhttps://www.jianshu.com/p/349e130e40d5https://www.jianshu.com/p/a0caf58b3653https://www.jianshu.com/p/f4fb5e9899fcspringboot配置详解https://yidashi.blog.csdn.net/article/details/82630650https://blog.csdn.net/tang430524/article/details/78911556https://blog.csdn.net/qq_36429929/article/details/94431242yml的spring security配置https://www.cnblogs.com/xuwenjin/p/9645896.htmlhttps://blog.csdn.net/MarcoAsensio/article/details/104573094https://www.jianshu.com/p/bf990755b35espringboot spring security 数据库https://www.jianshu.com/p/3295cb74481eSpring Data MongoDB 文档https://docs.spring.io/spring-data/mongodb/docs/3.0.1.RELEASE/api/","categories":[{"name":"环境","slug":"环境","permalink":"http://nlbyd1119.online/categories/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"SpringMVC其三 | Restful","slug":"SpringMVC其三-Restful","date":"2020-06-25T15:57:05.000Z","updated":"2020-06-25T15:57:44.392Z","comments":true,"path":"2020/06/25/SpringMVC其三-Restful/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/SpringMVC%E5%85%B6%E4%B8%89-Restful/","excerpt":"","text":"","categories":[{"name":"控制器","slug":"控制器","permalink":"http://nlbyd1119.online/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"SpringMVC其二 | SpringBoot配置分析","slug":"SpringMVC其二-SpringBoot配置分析","date":"2020-06-25T15:56:38.000Z","updated":"2020-06-25T15:57:02.365Z","comments":true,"path":"2020/06/25/SpringMVC其二-SpringBoot配置分析/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/SpringMVC%E5%85%B6%E4%BA%8C-SpringBoot%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"控制器","slug":"控制器","permalink":"http://nlbyd1119.online/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"SpringMVC其一 | SSM配置分析","slug":"SpringMVC其一-SSM配置分析","date":"2020-06-25T15:54:41.000Z","updated":"2020-06-25T15:56:26.848Z","comments":true,"path":"2020/06/25/SpringMVC其一-SSM配置分析/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/SpringMVC%E5%85%B6%E4%B8%80-SSM%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"控制器","slug":"控制器","permalink":"http://nlbyd1119.online/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java日志其一 | 日志框架","slug":"Java日志其一-日志框架","date":"2020-06-25T15:53:52.000Z","updated":"2020-06-25T15:54:38.344Z","comments":true,"path":"2020/06/25/Java日志其一-日志框架/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%97%A5%E5%BF%97%E5%85%B6%E4%B8%80-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","excerpt":"","text":"","categories":[{"name":"日志","slug":"日志","permalink":"http://nlbyd1119.online/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java模板其三 | Freemarker","slug":"Java模板其三-Freemarker","date":"2020-06-25T15:52:43.000Z","updated":"2020-06-25T15:53:49.012Z","comments":true,"path":"2020/06/25/Java模板其三-Freemarker/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%A8%A1%E6%9D%BF%E5%85%B6%E4%B8%89-Freemarker/","excerpt":"","text":"","categories":[{"name":"模板","slug":"模板","permalink":"http://nlbyd1119.online/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java模板其二 | Thymeleaf","slug":"Java模板其二-Thymeleaf","date":"2020-06-25T15:51:43.000Z","updated":"2020-06-25T15:52:40.498Z","comments":true,"path":"2020/06/25/Java模板其二-Thymeleaf/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%A8%A1%E6%9D%BF%E5%85%B6%E4%BA%8C-Thymeleaf/","excerpt":"","text":"","categories":[{"name":"模板","slug":"模板","permalink":"http://nlbyd1119.online/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java模板其一 | JSP EL/JSTL","slug":"Java模板其一-JSP-EL-JSTL","date":"2020-06-25T15:51:12.000Z","updated":"2020-06-25T15:51:38.982Z","comments":true,"path":"2020/06/25/Java模板其一-JSP-EL-JSTL/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%A8%A1%E6%9D%BF%E5%85%B6%E4%B8%80-JSP-EL-JSTL/","excerpt":"","text":"","categories":[{"name":"模板","slug":"模板","permalink":"http://nlbyd1119.online/categories/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java安全框架其四 | Shiro","slug":"Java安全框架其四-Shiro","date":"2020-06-25T15:50:40.000Z","updated":"2020-06-25T15:51:08.480Z","comments":true,"path":"2020/06/25/Java安全框架其四-Shiro/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E5%9B%9B-Shiro/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"http://nlbyd1119.online/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java安全框架其三 | SpringBoot 配置 Spring Security","slug":"Java安全框架其三-SpringBoot-配置-Spring-Security","date":"2020-06-25T15:49:14.000Z","updated":"2020-06-28T14:15:21.776Z","comments":true,"path":"2020/06/25/Java安全框架其三-SpringBoot-配置-Spring-Security/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%89-SpringBoot-%E9%85%8D%E7%BD%AE-Spring-Security/","excerpt":"本篇先就基本集成方式进行记述（不涉及数据库），然后就迁移测试的结果给出一个可行的配置方案，若测试不成功，则参考网上的方案进行测试配置（2020.6.27)","text":"本篇先就基本集成方式进行记述（不涉及数据库），然后就迁移测试的结果给出一个可行的配置方案，若测试不成功，则参考网上的方案进行测试配置（2020.6.27) 基本配置与问题 一、基本配置：登录认证、访问授权、登出记住引导类 123456789101112131415161718192021222324252627282930313233package com.n.security;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 1、引入SpringSecurity； * 2、编写SpringSecurity的配置类； * @EnableWebSecurity extends WebSecurityConfigurerAdapter * 3、控制请求的访问权限： * configure(HttpSecurity http) &#123; * http.authorizeRequests().antMatchers(\"/\").permitAll() * .antMatchers(\"/level1/**\").hasRole(\"VIP1\") * &#125; * 4、定义认证规则： * configure(AuthenticationManagerBuilder auth)&#123; * auth.inMemoryAuthentication() * .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\",\"VIP2\") * &#125; * 5、开启自动配置的登陆功能： * configure(HttpSecurity http)&#123; * http.formLogin(); * &#125; * 6、注销：http.logout(); * 7、记住我：Remeberme()； */@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class, args); &#125;&#125; 自定义配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.n.security.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 //开启自动配置的注销功能。 http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； //开启记住我功能 http.rememberMe().rememberMeParameter(\"remeber\"); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication().passwordEncoder(new MyPasswordEncoder()) .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\",\"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\",\"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\",\"VIP3\"); &#125;&#125; 依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.n&lt;/groupId&gt; &lt;artifactId&gt;security&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;--&gt;&lt;!-- &lt;thymeleaf-layout-dialect.version&gt;2.3.0&lt;/thymeleaf-layout-dialect.version&gt;--&gt;&lt;!-- &lt;thymeleaf-extras-springsecurity4.version&gt;3.0.4.RELEASE&lt;/thymeleaf-extras-springsecurity4.version&gt;--&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 二、问题与解决 解决java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”参考 https://blog.csdn.net/weixin_39220472/article/details/80865411自定义PasswordEncorder的实现类12345678910111213141516package com.n.security.config;import org.springframework.context.annotation.Bean;import org.springframework.security.crypto.password.PasswordEncoder;public class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 在thymeleaf测试时发现相关标签失效参考 https://blog.csdn.net/qq_34729698/article/details/86760219在pom.xml中添加如下依赖解决123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 通过迁移证书信息系统对springboot集成spring security的配置进行测试 开始，浪费了数个小时时间在使用传统xml配置上，一直希望仅加载原来配置过的文件就实现集成，但在这个过程中出现了各种各样的问题，最终还有一个问题尝试过很多方法都无法解决：An Authentication object was not found in the SecurityContext，最后无奈放弃，再尝试自定义配置类的方式，幸运的是，参考了一篇合适的博客，本身配置也不太负责，在解决了几个小问题后配置基本测试成功了。以下就我整个过程中的想法、遇到的问题和尝试的解决方法以及最终配置进行详细记述。一、迁移前与迁移初的疑虑第一个问题是，先前我使用ssm集成过spring security，使用xml可以进行详细直观地配置。而本项目要求使用springboot。该框架虽然都说其使用简便，但在学习过程中集成不同框架时需要写的各种配置类，以及我先前实现时遇到的种种不便，使我感觉这个框架过于鸡肋。原有的xml配置我可以自定义较详细的配置，但springboot会自动配置好很多配置，这样造成的问题就是你自己想定义的配置和默认的配置存在冲突，而想要自定义，要么自定义配置类（这个我还很不熟），要么使用@ImportResource加载传统xml文件（实践证明可能出现很多冲突和不可知的问题）。因此在集成之前，我对最终是否能做成实在缺乏信心。即便集成成功，项目要求前端vue，也就是前后端完全分离，而我之前实现的访问控制很大程度上借助与相关的标签，这就需要绝对不能分离，因此这个需求我也不知道怎么实现。总之就是只能摸着石头过河。二、传统xml配置过程1.首先，我的做法是jar包方式下，把java类、配置文件等都copy到对应目录下，依赖选择性复制。然后调整copy过来的三个传统xml配置文件：spring、springmvc、spring security的。spring中留存数据源 + 分页的，其他基本不作处理，同时把yml配置中重复的部分注释掉（但有一个很大的隐患，就是springboot的自动配置配了很多东西，是否有多配置的引起冲突我无法预估）2.那么，接下来应该考虑的是，怎么让传统xml配置生效。参考https://blog.csdn.net/qq_16504067/article/details/53924180https://blog.csdn.net/lovelovelovelovelo/article/details/88615261使用@ImportResource可以加载xml配置，但是否生效暂时无法验证。 123456789@Configuration@ImportResource(locations = &#123;\"classpath:applicationContext.xml\", \"classpath:spring-security.xml\"&#125;)@EnableWebSecuritypublic class MyConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; super.configure(http); &#125;&#125; 以上其实为我经过一些报错并解决后才写成的配置，即便如此，还有问题无法解决。org.springframework.security.config.annotation.ObjectPostProcessor这个问题我在加了@EnableWebSecurity后解决，但不一定要加（说不清，这些配置互相影响）error creating bean with name &#39;org.springframework.aop.config.internalAutoProxyCreator&#39;参考 https://blog.csdn.net/deer_sheep/article/details/103668983 添加依赖解决 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; 然后就是卡死我的问题org.springframework.security.authentication.AuthenticationCredentialsNotFoundException:An Authentication object was not found in the SecurityContext这个问题我在参考了很多网站，结合https://blog.csdn.net/m0_37834471/article/details/81210429 等我认定（其实不是）是框架默认的过滤链没有注册成功，而这个过滤器的配置是在web.xml中的（当然springboot自动配置也有且加载早于web.xml，这样才保证了即使web.xml中有重复的关于mvc的配置不会冲突，当然这是后话），我意识到web.xml配置有影响时，我就开始计划使其生效，先参考一些链接使webapp成为web模块，且保证web.xml被扫描到，但没用，于是我就想直接建成web项目是不是更好，于是我下一步就是迁移为web项目。3.迁移后，发现先前的一些报错的配置正常了，但关于安全框架的这个问题还是无法解决。我就在想是不是springboot的自动配置与我的传统xml配置存在冲突而导致失效，那么我是不是该把关于安全框架的所有配置都自行处理。那么如何取消掉springboot关于安全框架的自动配置呢。我先想的策略是更换依赖，换为单独的安全框架依赖，无效；又在启动类上添注解排除相关配置，自己添过滤链配置，无效，还会报重复注册的错误；使用@Order提升加载优先级，无效。。。总之，花了四五个小时时间，这个问题始终解决不了，我只能无奈放弃，转为使用自定义配置类的方式。三、自定义配置类1.之前为什么不用一是我有现成的xml配置文件，其中配置有些复杂；而是我实在不想用不太熟悉的自定义配置类的方式进行配置，但在上述情形下只能自定义了。首先是迁移项目，还是web。然后关于spring和springmvc的配置可以用自己的，但要注意要解决BeanDefinitionOverrideException的问题，当时报错的意思是，springmvc已经有些自动配置了，使用xml做了重复的配置，解决方法是在yml中添加 123spring: main: allow-bean-definition-overriding: true 这样配置类可以直接加载相关xml 1234@Configuration@ImportResource(locations = &#123;\"classpath:applicationContext.xml\", \"classpath:spring-mvc.xml\"&#125;)public class MyConfig &#123;&#125; 2.自定义配置类参考 https://www.jianshu.com/p/3295cb74481e整个配置类的配置与xml基本是一致的，但测试时出现了两个问题，以下记述。注意，该配置类为最终版本，记述的错误是未修改前的配置错误造成的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.n.config;import com.n.service.IUserInfoService;import com.n.service.impl.UserInfoServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired UserInfoServiceImpl userInfoService; /** * 指定userService * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/**\").hasRole(\"USER\") .antMatchers(\"/**\").hasRole(\"ADMIN\") .antMatchers(\"/face_back/css/**\").permitAll() .antMatchers(\"/face_back/img/**\").permitAll() .antMatchers(\"/face_back/plugins/**\").permitAll() .antMatchers(\"/face_back/pages/**\").permitAll() .antMatchers(\"/face_back/**\").permitAll() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); http.formLogin().usernameParameter(\"username\").passwordParameter(\"password\") .loginPage(\"/login.jsp\").successForwardUrl(\"/pages/main.jsp\") .loginProcessingUrl(\"/face_back/login.do\").failureForwardUrl(\"/failer.jsp\"); &#125;&#125; 3.配置完成后，可显示登录页。但点击登录后，出现错误No qualifying bean of type &#39;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&#39;，尽管已经使用了@Bean，但实际没有注入，因此我直接在spring的xml中将其注入 1&lt;bean id=\"passwordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"/&gt; 注入后，再运行，报错There is no PasswordEncoder mapped for the id &quot;null&quot;，意识到这个密码编码根本没用 12345# 错误配置auth.userDetailsService(userInfoService)；# 修改后auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); 解决后，再运行又报错The absolute uri: [http://www.springframework.org/security/tags] cannot be resolved in either web.xml or the jar files deployed with this application结合其他参考与jsp中约束标签的报错情况，推断为缺少相关依赖，查找后添加，解决问题 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-taglibs --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;5.3.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 四、可行方案最终发现，实际配置类还是比较简单的，而使用xml配置也是可行的。因测试迁移项目中其他依赖过多，就对关键点作出说明。1.引导类这个没有测试，但我也不想测试了，是否需要排除这个自动配置，直接排除得了，虽然根据@EnableWebSecurity的作用https://blog.csdn.net/weixin_42849689/article/details/89953107 发现似乎不用排除，但写上也没影响 12345678910@MapperScan(\"com.n.dao\")//@SpringBootApplication@SpringBootApplication(exclude=&#123;SecurityAutoConfiguration.class, SecurityFilterAutoConfiguration.class&#125;)public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; 2.自定义配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.n.config;import com.n.service.IUserInfoService;import com.n.service.impl.UserInfoServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired UserInfoServiceImpl userInfoService; /** * 指定userService * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userInfoService).passwordEncoder(passwordEncoder()); &#125; @Bean PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/**\").hasRole(\"USER\") .antMatchers(\"/**\").hasRole(\"ADMIN\") .antMatchers(\"/face_back/css/**\").permitAll() .antMatchers(\"/face_back/img/**\").permitAll() .antMatchers(\"/face_back/plugins/**\").permitAll() .antMatchers(\"/face_back/pages/**\").permitAll() .antMatchers(\"/face_back/**\").permitAll() .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); http.formLogin().usernameParameter(\"username\").passwordParameter(\"password\") .loginPage(\"/login.jsp\").successForwardUrl(\"/pages/main.jsp\") .loginProcessingUrl(\"/face_back/login.do\").failureForwardUrl(\"/failer.jsp\"); &#125;&#125; 3.密码编码bean注入4.依赖完整五、收获1.传统xml配置加载确实可行2.初步实现了springboot+安全框架的集成（数据库）","categories":[{"name":"安全","slug":"安全","permalink":"http://nlbyd1119.online/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java安全框架其二 | SSM 配置 Spring Security","slug":"Java安全框架其二-SSM-配置-Spring-Security","date":"2020-06-25T15:48:46.000Z","updated":"2020-06-25T15:49:11.440Z","comments":true,"path":"2020/06/25/Java安全框架其二-SSM-配置-Spring-Security/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%8C-SSM-%E9%85%8D%E7%BD%AE-Spring-Security/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"http://nlbyd1119.online/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java安全框架其一 | Spring Security","slug":"Java安全框架其一-Spring-Security","date":"2020-06-25T15:47:49.000Z","updated":"2020-06-25T15:48:34.252Z","comments":true,"path":"2020/06/25/Java安全框架其一-Spring-Security/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%80-Spring-Security/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"http://nlbyd1119.online/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其七 | Mybatis与JPA对比","slug":"Java数据访问框架其七-Mybatis与JPA对比","date":"2020-06-25T15:41:29.000Z","updated":"2020-06-27T15:03:01.860Z","comments":true,"path":"2020/06/25/Java数据访问框架其七-Mybatis与JPA对比/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%83-Mybatis%E4%B8%8EJPA%E5%AF%B9%E6%AF%94/","excerpt":"本篇是对ORM框架进行总结，记录一些mybatis与jpa框架的对比的文章。简单地说，mybatis优势在于多表和sql优化，jpa优势在于移植性。","text":"本篇是对ORM框架进行总结，记录一些mybatis与jpa框架的对比的文章。简单地说，mybatis优势在于多表和sql优化，jpa优势在于移植性。 Spring Data项目https://spring.io/projects/spring-data Spring Data 项目的目的是为了简化构建基于Spring 框架应用的数据访问技术，包括非关系数据库、Map-Reduce 框架、云数据服务等等；另外也包含对关系数据库的访问支持。• Spring Data 包含多个子项目：– Spring Data Commons– Spring Data JPA– Spring Data KeyValue– Spring Data LDAP– Spring Data MongoDB– Spring Data Gemfire– Spring Data REST– Spring Data Redis– Spring Data for Apache Cassandra– Spring Data for Apache Solr– Spring Data Couchbase (community module)– Spring Data Elasticsearch (community module)– Spring Data Neo4j (community module) mybatis与jpa对比 https://www.baidu.com/s?wd=mybatis%E4%B8%8Ejpa&amp;rsv_spt=1&amp;rsv_iqid=0xccdc7fcb001e5769&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=17&amp;rsv_sug1=18&amp;rsv_sug7=101&amp;rsv_t=db289xARc8fGqE4zpbBCcvjoCZAR7TNFhtsF8rARNoL8hdMYLNMOAn3Ec%2FS%2ByPjFpKEr&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=13263&amp;rsv_sug4=14448https://www.cnblogs.com/llywy/p/10103136.htmlhttps://www.jianshu.com/p/32ce87c163d6https://www.cnblogs.com/ymstars/p/10629285.htmlhttps://blog.csdn.net/sinolover/article/details/96966213https://blog.csdn.net/RAVEEE/article/details/89951468https://www.jianshu.com/p/1fb00955302ahttps://www.zhihu.com/question/356307466","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其六 | SpringBoot 集成 Mybatis","slug":"Java数据访问框架其六-SpringBoot-集成-Mybatis","date":"2020-06-25T15:41:10.000Z","updated":"2020-06-27T14:52:18.815Z","comments":true,"path":"2020/06/25/Java数据访问框架其六-SpringBoot-集成-Mybatis/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E5%85%AD-SpringBoot-%E9%9B%86%E6%88%90-Mybatis/","excerpt":"本篇的主要内容为SpringBoot集成Mybatis的配置（根据mybatis实现有两种，可结合），此外还有Driud数据库连接池的配置。在记述这些配置之前，首先要进行一些概念的剖析。","text":"本篇的主要内容为SpringBoot集成Mybatis的配置（根据mybatis实现有两种，可结合），此外还有Driud数据库连接池的配置。在记述这些配置之前，首先要进行一些概念的剖析。 概念 一、druid与jdbcJDBC与Druid简单介绍及Druid与MyBatis连接数据库https://www.cnblogs.com/knowledgesea/p/11202918.html从JDBC到Druid，谈谈datasource的发展与druid使用https://blog.csdn.net/a3427603/article/details/86449198Druid 介绍和应用https://www.jianshu.com/p/221f795ff462二、druid与c3p0c3p0、dbcp、druid三大连接池对比https://blog.csdn.net/wawa3338/article/details/81380662druid和c3p0连接池https://blog.csdn.net/weixin_41417585/article/details/87633470c3p0，dbcp与druid 三大连接池的区别https://www.cnblogs.com/starliang/p/11736868.html三、数据源与数据库连接池数据源 与数据库连接池的 关系https://blog.csdn.net/u013065023/article/details/54973770?utm_source=blogxgwz8数据库、数据源和数据库连接池https://www.cnblogs.com/echola/p/10997587.html总结一下，druid就是一种最好的数据库连接池。 环境配置mybatis实现有注解和映射两种方式，也可结合，因此也有对应的集成配置方式，但也有一些相同的部分，如依赖和数据库连接池的配置，先列出相同的配置，再就分别的需要注意的点进行说明。 一、依赖pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--引入druid--&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 二、数据库连接池配置application.yml 12345678910111213141516171819202122232425262728293031323334353637spring: datasource:# 数据源基本配置 username: root password: 6774258 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/senior type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# 在初次运行项目时，可以根据以下配置创建表 注意相关sql文件已经存放在resources/sql目录下# schema:# - classpath:sql/department.sql# - classpath:sql/employee.sqlmybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean Druid配置类config.DruidConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.n.mybatis.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 三、注解配置可能老版本引导类添加scan后相关包的类不需注入，但现在除了扫描以外，必须用@Component或@Repository将dao层接口注入。引导类@Mapper 12345678@SpringBootApplication@MapperScan(\"com.n.mybatis.mapper\")public class MybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisApplication.class, args); &#125;&#125; dao层接口注入 1234567@Componentpublic interface EmployeeMapper &#123; public Employee getEmpById(Integer id); public void insertEmp(Employee employee);&#125; 四、映射配置在resources下mapper目录下创建映射文件，并在application.yml中指明。 1234567mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean 五、下划线转驼峰命名参考 https://blog.csdn.net/weixin_43908647/article/details/104464261实现方式一：mybatis配置类 1234567891011121314151617181920package com.n.mybatis.config;import org.apache.ibatis.session.Configuration;import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;import org.springframework.context.annotation.Bean;@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 实现方式二：mybatis配置文件+yml中指明mybatis-config.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; application.yml 1234567mybatis: # 指定全局配置文件位置 config-location: classpath:mybatis/mybatis-config.xml # 指定sql映射文件位置 mapper-locations: classpath:mybatis/mapper/*.xml # 指明实体类位置 type-aliases-package: com.n.mybatis.bean 小结据我对springboot集成orm、安全等框架的方法的观察分析，发现事实上，对单个框架的详细配置，既可以在yml中写明（可能有限），也可以在单独配置文件中写出，如ssm那样，再在yml中指明位置（这个需要参考资料），还能单独写配置类实现（这个个人认为比较麻烦）。","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其五 | Mybatis","slug":"Java数据访问框架其五-Mybatis","date":"2020-06-25T15:40:32.000Z","updated":"2020-06-27T14:03:46.804Z","comments":true,"path":"2020/06/25/Java数据访问框架其五-Mybatis/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%94-Mybatis/","excerpt":"关于mybatis的使用（基本crud和多表操作）已基本熟悉，本篇是就其原理和注解与映射两种实现方式进行总结回顾。","text":"关于mybatis的使用（基本crud和多表操作）已基本熟悉，本篇是就其原理和注解与映射两种实现方式进行总结回顾。","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其四 | SpringBoot 集成 SpringData JPA","slug":"Java数据访问框架其四-SpringBoot-集成-SpringData-JPA","date":"2020-06-25T15:40:07.000Z","updated":"2020-06-27T13:42:48.174Z","comments":true,"path":"2020/06/25/Java数据访问框架其四-SpringBoot-集成-SpringData-JPA/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E5%9B%9B-SpringBoot-%E9%9B%86%E6%88%90-SpringData-JPA/","excerpt":"本篇以一个简单的用户操作为例，介绍springboot集成springdata jpa的配置。与SpringBoot集成，不需要再向先前那样考虑jdk版本等问题，只要保证数据库配置正确，就能正常操作，同样可以忽略实体类注解的红线。但有一个需要注意的地方是，新版本的springdata jpa中的某些api可能发生变化了，如findOne-&gt;findById.get","text":"本篇以一个简单的用户操作为例，介绍springboot集成springdata jpa的配置。与SpringBoot集成，不需要再向先前那样考虑jdk版本等问题，只要保证数据库配置正确，就能正常操作，同样可以忽略实体类注解的红线。但有一个需要注意的地方是，新版本的springdata jpa中的某些api可能发生变化了，如findOne-&gt;findById.get 环境 pom.xml注意因为本地mysql版本较低的缘故，可见此处springboot为较新版本，相应的mysql驱动版本也较新，因此连接时可能出现乱码问题，需要手动将mysql驱动版本改为较低的。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; application.yml注意数据库连接配置一定要正确 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/senior?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true 实例 实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.n.jpa.entity;import javax.persistence.*;//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125;&#125; dao层接口 123456789package com.n.jpa.repository;import com.n.jpa.entity.User;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;&#125; controller层测试 1234567891011121314151617181920212223242526272829package com.n.jpa.controller;import com.n.jpa.entity.User;import com.n.jpa.repository.UserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @Autowired UserRepository userRepository; @GetMapping(\"/user/&#123;id&#125;\") public User getUser(@PathVariable(\"id\")Integer id)&#123; User user = userRepository.findById(id).get(); return user; &#125; @GetMapping(\"/user\") public User insertUser(User user)&#123; User save = userRepository.save(user); return save; &#125;&#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其三 | SpringData JPA","slug":"Java数据访问框架其三-SpringData-JPA","date":"2020-06-25T15:39:37.000Z","updated":"2020-06-27T13:21:31.494Z","comments":true,"path":"2020/06/25/Java数据访问框架其三-SpringData-JPA/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%89-SpringData-JPA/","excerpt":"本篇从SpingData JPA的介绍出发，依次介绍该框架的配置、基本CRUD、多种查询方式、动态查询和多表操作、对象导航查询。","text":"本篇从SpingData JPA的介绍出发，依次介绍该框架的配置、基本CRUD、多种查询方式、动态查询和多表操作、对象导航查询。 概述 一、概述Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现,在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。SpringData Jpa 极大简化了数据库访问层代码。 如何简化的呢？ 使用了SpringDataJpa，我们的dao层中只需要写接口，就自动具有了增删改查、分页查询等方法。二、Spring Data JPA 与 JPA和hibernate之间的关系JPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。 springdata jpa 配置配置过程中出现的问题与解决方法和jpa测试类似，都是保证数据库配置正确的前提下，添加依赖 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;springdatajpa&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring对orm框架的支持包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- hibernate beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate end --&gt; &lt;!-- c3p0 beg --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 end --&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring data jpa 的坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el beg 使用spring data jpa 必须引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el end --&gt; &lt;!-- 解决因jdk版本等原因造成的java.lang.ClassNotFoundException: javax.xml.bind.JAXBException问题 --&gt; &lt;!-- 参考 https://blog.csdn.net/w405722907/article/details/80523790 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; resources/applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt; &lt;!--spring 和 spring data jpa的配置--&gt; &lt;!-- 1.创建entityManagerFactory对象交给spring容器管理--&gt; &lt;bean id=\"entityManagerFactoty\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!--配置的扫描的包（实体类所在的包） --&gt; &lt;property name=\"packagesToScan\" value=\"cn.itcast.domain\" /&gt; &lt;!-- jpa的实现厂家 --&gt; &lt;property name=\"persistenceProvider\"&gt; &lt;bean class=\"org.hibernate.jpa.HibernatePersistenceProvider\"/&gt; &lt;/property&gt; &lt;!--jpa的供应商适配器 --&gt; &lt;property name=\"jpaVendorAdapter\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"&gt; &lt;!--配置是否自动创建数据库表 --&gt; &lt;property name=\"generateDdl\" value=\"false\" /&gt; &lt;!--指定数据库类型 --&gt; &lt;property name=\"database\" value=\"MYSQL\" /&gt; &lt;!--数据库方言：支持的特有语法 --&gt; &lt;property name=\"databasePlatform\" value=\"org.hibernate.dialect.MySQLDialect\" /&gt; &lt;!--是否显示sql --&gt; &lt;property name=\"showSql\" value=\"true\" /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--jpa的方言 ：高级的特性 --&gt; &lt;property name=\"jpaDialect\" &gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaDialect\" /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--2.创建数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///senior\" &gt;&lt;/property&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--3.整合spring dataJpa--&gt; &lt;jpa:repositories base-package=\"cn.itcast.dao\" transaction-manager-ref=\"transactionManager\" entity-manager-factory-ref=\"entityManagerFactoty\" &gt;&lt;/jpa:repositories&gt; &lt;!--4.配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"&gt; &lt;property name=\"entityManagerFactory\" ref=\"entityManagerFactoty\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 4.txAdvice--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 5.aop--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* cn.itcast.service.*.*(..))\" /&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\" /&gt; &lt;/aop:config&gt; &lt;!--5.声明式事务 --&gt; &lt;!-- 6. 配置包扫描--&gt; &lt;context:component-scan base-package=\"cn.itcast\" &gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 基本操作注意在新版本中，该框架已无findOne方法，而是用findById().get()取代 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980编写符合Spring Data JPA规范的Dao层接口Spring Data JPA是spring提供的一款对于数据访问层（Dao层）的框架，使用Spring Data JPA，只需要按照框架的规范提供dao接口，不需要实现类就可以完成数据库的增删改查、分页查询等方法的定义，极大的简化了我们的开发过程。在Spring Data JPA中，对于定义符合规范的Dao层接口，我们只需要遵循以下几点就可以了：1.创建一个Dao层接口，并实现JpaRepository和JpaSpecificationExecutor2.提供相应的泛型package cn.itcast.dao;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import cn.itcast.entity.Customer;/** * JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作 * JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作） */public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;&#125;这样我们就定义好了一个符合Spring Data JPA规范的Dao层接口完成基本CRUD操作完成了Spring Data JPA的环境搭建，并且编写了符合Spring Data JPA 规范的Dao层接口之后，就可以使用定义好的Dao层接口进行客户的基本CRUD操作@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=\"classpath:applicationContext.xml\")public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 保存客户：调用save(obj)方法 */ @Test public void testSave() &#123; Customer c = new Customer(); c.setCustName(\"传智播客\"); customerDao.save(c); &#125; /** * 修改客户：调用save(obj)方法 * 对于save方法的解释：如果执行此方法是对象中存在id属性，即为更新操作会先根据id查询，再更新 * 如果执行此方法中对象中不存在id属性，即为保存操作 * */ @Test public void testUpdate() &#123; //根据id查询id为1的客户 Customer customer = customerDao.findOne(1l); //修改客户名称 customer.setCustName(\"传智播客顺义校区\"); //更新 customerDao.save(customer); &#125; /** * 根据id删除：调用delete(id)方法 */ @Test public void testDelete() &#123; customerDao.delete(1l); &#125; /** * 根据id查询：调用findOne(id)方法 */ @Test public void testFindById() &#123; Customer customer = customerDao.findOne(2l); System.out.println(customer); &#125;&#125; 四种查询方式 一、使用Spring Data JPA中接口定义的方法进行查询在继承JpaRepository和JpaSpecificationExecutor接口后,我们就可以使用接口中定义的方法进行查询，前者中定义的方法用于基本crud，后者中定义的方法用于动态查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class) //声明spring提供的单元测试环境@ContextConfiguration(locations = \"classpath:applicationContext.xml\")//指定spring容器的配置信息public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 根据id查询 */ @Test public void testFindOne() &#123; Customer customer = customerDao.findOne(4l); System.out.println(customer); &#125; /** * save : 保存或者更新 * 根据传递的对象是否存在主键id， * 如果没有id主键属性：保存 * 存在id主键属性，根据id查询数据，更新数据 */ @Test public void testSave() &#123; Customer customer = new Customer(); customer.setCustName(\"黑马程序员\"); customer.setCustLevel(\"vip\"); customer.setCustIndustry(\"it教育\"); customerDao.save(customer); &#125; @Test public void testUpdate() &#123; Customer customer = new Customer(); customer.setCustId(4l); customer.setCustName(\"黑马程序员很厉害\"); customerDao.save(customer); &#125; @Test public void testDelete () &#123; customerDao.delete(3l); &#125; /** * 查询所有 */ @Test public void testFindAll() &#123; List&lt;Customer&gt; list = customerDao.findAll(); for(Customer customer : list) &#123; System.out.println(customer); &#125; &#125; /** * 测试统计查询：查询客户的总数量 * count:统计总条数 */ @Test public void testCount() &#123; long count = customerDao.count();//查询全部的客户数量 System.out.println(count); &#125; /** * 测试：判断id为4的客户是否存在 * 1. 可以查询以下id为4的客户 * 如果值为空，代表不存在，如果不为空，代表存在 * 2. 判断数据库中id为4的客户的数量 * 如果数量为0，代表不存在，如果大于0，代表存在 */ @Test public void testExists() &#123; boolean exists = customerDao.exists(4l); System.out.println(\"id为4的客户 是否存在：\"+exists); &#125; /** * 根据id从数据库查询 * @Transactional : 保证getOne正常运行 * * findOne： * em.find() :立即加载 * getOne： * em.getReference :延迟加载 * * 返回的是一个客户的动态代理对象 * * 什么时候用，什么时候查询 */ @Test @Transactional public void testGetOne() &#123; Customer customer = customerDao.getOne(4l); System.out.println(customer); &#125;&#125; 二、使用JPQL的方式查询 1234567891011121314151617181920使用Spring Data JPA提供的查询方法已经可以解决大部分的应用场景，但是对于某些业务来说，我们还需要灵活的构造查询条件，这时就可以使用@Query注解，结合JPQL的语句方式完成查询@Query 注解的使用非常简单，只需在方法上面标注该注解，同时提供一个JPQL查询语句即可public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;,JpaSpecificationExecutor&lt;Customer&gt; &#123; //@Query 使用jpql的方式查询。 @Query(value=\"from Customer\") public List&lt;Customer&gt; findAllCustomer(); //@Query 使用jpql的方式查询。?1代表参数的占位符，其中1对应方法中的参数索引 @Query(value=\"from Customer where custName = ?1\") public Customer findCustomer(String custName);&#125;此外，也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询 @Query(value=\"update Customer set custName = ?1 where custId = ?2\") @Modifying public void updateCustomer(String custName,Long custId); 三、使用SQL语句查询 1234567Spring Data JPA同样也支持sql语句的查询，如下：/** * nativeQuery : 使用本地sql的方式查询 */@Query(value=\"select * from cst_customer\",nativeQuery=true)public void findSql(); 四、方法命名规则查询 123456顾名思义，方法命名规则查询就是根据方法的名字，就能创建查询。只需要按照Spring Data JPA提供的方法命名规则定义方法的名称，就可以完成查询工作。Spring Data JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询按照Spring Data JPA 定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。//方法命名方式查询（根据客户名称查询客户）public Customer findByCustName(String custName); Keyword Sample JPQL And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstnameIs, findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age ⇐ ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true FALSE findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 后三种查询方法测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197dao层package cn.itcast.dao;import cn.itcast.domain.Customer;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import java.util.List;/** * 符合SpringDataJpa的dao层接口规范 * JpaRepository&lt;操作的实体类类型，实体类中主键属性的类型&gt; * * 封装了基本CRUD操作 * JpaSpecificationExecutor&lt;操作的实体类类型&gt; * * 封装了复杂查询（分页） */public interface CustomerDao extends JpaRepository&lt;Customer,Long&gt; ,JpaSpecificationExecutor&lt;Customer&gt; &#123; /** * 案例：根据客户名称查询客户 * 使用jpql的形式查询 * jpql：from Customer where custName = ? * * 配置jpql语句，使用的@Query注解 */ @Query(value=\"from Customer where custName = ?\") public Customer findJpql(String custName); /** * 案例：根据客户名称和客户id查询客户 * jpql： from Customer where custName = ? and custId = ? * * 对于多个占位符参数 * 赋值的时候，默认的情况下，占位符的位置需要和方法参数中的位置保持一致 * * 可以指定占位符参数的位置 * ? 索引的方式，指定此占位的取值来源 */ @Query(value = \"from Customer where custName = ?2 and custId = ?1\") public Customer findCustNameAndId(Long id,String name); /** * 使用jpql完成更新操作 * 案例 ： 根据id更新，客户的名称 * 更新4号客户的名称，将名称改为“黑马程序员” * * sql ：update cst_customer set cust_name = ? where cust_id = ? * jpql : update Customer set custName = ? where custId = ? * * @Query : 代表的是进行查询 * * 声明此方法是用来进行更新操作 * @Modifying * * 当前执行的是一个更新操作 * */ @Query(value = \" update Customer set custName = ?2 where custId = ?1 \") @Modifying public void updateCustomer(long custId,String custName); /** * 使用sql的形式查询： * 查询全部的客户 * sql ： select * from cst_customer; * Query : 配置sql查询 * value ： sql语句 * nativeQuery ： 查询方式 * true ： sql查询 * false：jpql查询 * */ //@Query(value = \" select * from cst_customer\" ,nativeQuery = true) @Query(value=\"select * from cst_customer where cust_name like ?1\",nativeQuery = true) public List&lt;Object [] &gt; findSql(String name); /** * 方法名的约定： * findBy : 查询 * 对象中的属性名（首字母大写） ： 查询的条件 * CustName * * 默认情况 ： 使用 等于的方式查询 * 特殊的查询方式 * * findByCustName -- 根据客户名称查询 * * 再springdataJpa的运行阶段 * 会根据方法名称进行解析 findBy from xxx(实体类) * 属性名称 where custName = * * 1.findBy + 属性名称 （根据属性名称进行完成匹配的查询=） * 2.findBy + 属性名称 + “查询方式（Like | isnull）” * findByCustNameLike * 3.多条件查询 * findBy + 属性名 + “查询方式” + “多条件的连接符（and|or）” + 属性名 + “查询方式” */ public Customer findByCustName(String custName); public List&lt;Customer&gt; findByCustNameLike(String custName); //使用客户名称模糊匹配和客户所属行业精准匹配的查询 public Customer findByCustNameLikeAndCustIndustry(String custName,String custIndustry);&#125;测试package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.jpa.repository.Query;import org.springframework.test.annotation.Rollback;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import java.util.Arrays;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class) //声明spring提供的单元测试环境@ContextConfiguration(locations = \"classpath:applicationContext.xml\")//指定spring容器的配置信息public class JpqlTest &#123; @Autowired private CustomerDao customerDao; @Test public void testFindJPQL() &#123; Customer customer = customerDao.findJpql(\"传智播客\"); System.out.println(customer); &#125; @Test public void testFindCustNameAndId() &#123; // Customer customer = customerDao.findCustNameAndId(\"传智播客\",1l); Customer customer = customerDao.findCustNameAndId(1l,\"传智播客\"); System.out.println(customer); &#125; /** * 测试jpql的更新操作 * * springDataJpa中使用jpql完成 更新/删除操作 * * 需要手动添加事务的支持 * * 默认会执行结束之后，回滚事务 * @Rollback : 设置是否自动回滚 * false | true */ @Test @Transactional //添加事务的支持 @Rollback(value = false) public void testUpdateCustomer() &#123; customerDao.updateCustomer(4l,\"黑马程序员\"); &#125; //测试sql查询 @Test public void testFindSql() &#123; List&lt;Object[]&gt; list = customerDao.findSql(\"传智播客%\"); for(Object [] obj : list) &#123; System.out.println(Arrays.toString(obj)); &#125; &#125; //测试方法命名规则的查询 @Test public void testNaming() &#123; Customer customer = customerDao.findByCustName(\"传智播客\"); System.out.println(customer); &#125; //测试方法命名规则的查询 @Test public void testFindByCustNameLike() &#123; List&lt;Customer&gt; list = customerDao.findByCustNameLike(\"传智播客%\"); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; //测试方法命名规则的查询 @Test public void testFindByCustNameLikeAndCustIndustry() &#123; Customer customer = customerDao.findByCustNameLikeAndCustIndustry(\"传智播客1%\", \"it教育\"); System.out.println(customer); &#125;&#125; Specifications动态查询有时我们在查询某个实体的时候，给定的条件是不固定的，这时就需要动态构建相应的查询语句，在Spring Data JPA中可以通过JpaSpecificationExecutor接口查询。相比JPQL,其优势是类型安全,更加的面向对象。 12345678910111213141516171819202122import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;/** * JpaSpecificationExecutor中定义的方法 **/ public interface JpaSpecificationExecutor&lt;T&gt; &#123; //根据条件查询一个对象 T findOne(Specification&lt;T&gt; spec); //根据条件查询集合 List&lt;T&gt; findAll(Specification&lt;T&gt; spec); //根据条件分页查询 Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable); //排序查询查询 List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort); //统计查询 long count(Specification&lt;T&gt; spec);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package cn.itcast.test;import cn.itcast.dao.CustomerDao;import cn.itcast.domain.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.persistence.criteria.*;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class SpecTest &#123; @Autowired private CustomerDao customerDao; /** * 根据条件，查询单个对象 * */ @Test public void testSpec() &#123; //匿名内部类 /** * 自定义查询条件 * 1.实现Specification接口（提供泛型：查询的对象类型） * 2.实现toPredicate方法（构造查询条件） * 3.需要借助方法参数中的两个参数（ * root：获取需要查询的对象属性 * CriteriaBuilder：构造查询条件的，内部封装了很多的查询条件（模糊匹配，精准匹配） * ） * 案例：根据客户名称查询，查询客户名为传智播客的客户 * 查询条件 * 1.查询方式 * cb对象 * 2.比较的属性名称 * root对象 * */ Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //1.获取比较的属性 Path&lt;Object&gt; custName = root.get(\"custId\"); //2.构造查询条件 ： select * from cst_customer where cust_name = '传智播客' /** * 第一个参数：需要比较的属性（path对象） * 第二个参数：当前需要比较的取值 */ Predicate predicate = cb.equal(custName, \"传智播客\");//进行精准的匹配 （比较的属性，比较的属性的取值） return predicate; &#125; &#125;; Customer customer = customerDao.findOne(spec); System.out.println(customer); &#125; /** * 多条件查询 * 案例：根据客户名（传智播客）和客户所属行业查询（it教育） * */ @Test public void testSpec1() &#123; /** * root:获取属性 * 客户名 * 所属行业 * cb：构造查询 * 1.构造客户名的精准匹配查询 * 2.构造所属行业的精准匹配查询 * 3.将以上两个查询联系起来 */ Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; Path&lt;Object&gt; custName = root.get(\"custName\");//客户名 Path&lt;Object&gt; custIndustry = root.get(\"custIndustry\");//所属行业 //构造查询 //1.构造客户名的精准匹配查询 Predicate p1 = cb.equal(custName, \"传智播客\");//第一个参数，path（属性），第二个参数，属性的取值 //2..构造所属行业的精准匹配查询 Predicate p2 = cb.equal(custIndustry, \"it教育\"); //3.将多个查询条件组合到一起：组合（满足条件一并且满足条件二：与关系，满足条件一或满足条件二即可：或关系） Predicate and = cb.and(p1, p2);//以与的形式拼接多个查询条件 // cb.or();//以或的形式拼接多个查询条件 return and; &#125; &#125;; Customer customer = customerDao.findOne(spec); System.out.println(customer); &#125; /** * 案例：完成根据客户名称的模糊匹配，返回客户列表 * 客户名称以 ’传智播客‘ 开头 * * equal ：直接的到path对象（属性），然后进行比较即可 * gt，lt,ge,le,like : 得到path对象，根据path指定比较的参数类型，再去进行比较 * 指定参数类型：path.as(类型的字节码对象) */ @Test public void testSpec3() &#123; //构造查询条件 Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123; @Override public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //查询属性：客户名 Path&lt;Object&gt; custName = root.get(\"custName\"); //查询方式：模糊匹配 Predicate like = cb.like(custName.as(String.class), \"传智播客%\"); return like; &#125; &#125;;// List&lt;Customer&gt; list = customerDao.findAll(spec);// for (Customer customer : list) &#123;// System.out.println(customer);// &#125; //添加排序 //创建排序对象,需要调用构造方法实例化sort对象 //第一个参数：排序的顺序（倒序，正序） // Sort.Direction.DESC:倒序 // Sort.Direction.ASC ： 升序 //第二个参数：排序的属性名称 Sort sort = new Sort(Sort.Direction.DESC,\"custId\"); List&lt;Customer&gt; list = customerDao.findAll(spec, sort); for (Customer customer : list) &#123; System.out.println(customer); &#125; &#125; /** * 分页查询 * Specification: 查询条件 * Pageable：分页参数 * 分页参数：查询的页码，每页查询的条数 * findAll(Specification,Pageable)：带有条件的分页 * findAll(Pageable)：没有条件的分页 * 返回：Page（springDataJpa为我们封装好的pageBean对象，数据列表，共条数） */ @Test public void testSpec4() &#123; Specification spec = null; //PageRequest对象是Pageable接口的实现类 /** * 创建PageRequest的过程中，需要调用他的构造方法传入两个参数 * 第一个参数：当前查询的页数（从0开始） * 第二个参数：每页查询的数量 */ Pageable pageable = new PageRequest(0,2); //分页查询 Page&lt;Customer&gt; page = customerDao.findAll(null, pageable); System.out.println(page.getContent()); //得到数据集合列表 System.out.println(page.getTotalElements());//得到总条数 System.out.println(page.getTotalPages());//得到总页数 &#125;&#125; 一对多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473.1 示例分析 我们采用的示例为客户和联系人。 客户：指的是一家公司，我们记为A。 联系人：指的是A公司中的员工。 在不考虑兼职的情况下，公司和员工的关系即为一对多。3.2 表关系建立在一对多关系中，我们习惯把一的一方称之为主表，把多的一方称之为从表。在数据库中建立一对多的关系，需要使用数据库的外键约束。什么是外键？指的是从表中有一列，取值参照主表的主键，这一列就是外键。一对多数据库关系的建立，如下图所示 3.3 实体类关系建立以及映射配置在实体类中，由于客户是少的一方，它应该包含多个联系人，所以实体类要体现出客户中有多个联系人的信息，代码如下：/** * 客户的实体类 * 明确使用的注解都是JPA规范的 * 所以导包都要导入javax.persistence包下的 */@Entity//表示当前类是一个实体类@Table(name=\"cst_customer\")//建立当前实体类和表之间的对应关系public class Customer implements Serializable &#123; @Id//表明当前私有属性是主键 @GeneratedValue(strategy=GenerationType.IDENTITY)//指定主键的生成策略 @Column(name=\"cust_id\")//指定和数据库表中的cust_id列对应 private Long custId; @Column(name=\"cust_name\")//指定和数据库表中的cust_name列对应 private String custName; @Column(name=\"cust_source\")//指定和数据库表中的cust_source列对应 private String custSource; @Column(name=\"cust_industry\")//指定和数据库表中的cust_industry列对应 private String custIndustry; @Column(name=\"cust_level\")//指定和数据库表中的cust_level列对应 private String custLevel; @Column(name=\"cust_address\")//指定和数据库表中的cust_address列对应 private String custAddress; @Column(name=\"cust_phone\")//指定和数据库表中的cust_phone列对应 private String custPhone; //配置客户和联系人的一对多关系 @OneToMany(targetEntity=LinkMan.class) @JoinColumn(name=\"lkm_cust_id\",referencedColumnName=\"cust_id\") private Set&lt;LinkMan&gt; linkmans = new HashSet&lt;LinkMan&gt;(0); public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125; public Set&lt;LinkMan&gt; getLinkmans() &#123; return linkmans; &#125; public void setLinkmans(Set&lt;LinkMan&gt; linkmans) &#123; this.linkmans = linkmans; &#125; @Override public String toString() &#123; return \"Customer [custId=\" + custId + \", custName=\" + custName + \", custSource=\" + custSource + \", custIndustry=\" + custIndustry + \", custLevel=\" + custLevel + \", custAddress=\" + custAddress + \", custPhone=\" + custPhone + \"]\"; &#125;&#125;由于联系人是多的一方，在实体类中要体现出，每个联系人只能对应一个客户，代码如下：/** * 联系人的实体类（数据模型） */@Entity@Table(name=\"cst_linkman\")public class LinkMan implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"lkm_id\") private Long lkmId; @Column(name=\"lkm_name\") private String lkmName; @Column(name=\"lkm_gender\") private String lkmGender; @Column(name=\"lkm_phone\") private String lkmPhone; @Column(name=\"lkm_mobile\") private String lkmMobile; @Column(name=\"lkm_email\") private String lkmEmail; @Column(name=\"lkm_position\") private String lkmPosition; @Column(name=\"lkm_memo\") private String lkmMemo; //多对一关系映射：多个联系人对应客户 @ManyToOne(targetEntity=Customer.class) @JoinColumn(name=\"lkm_cust_id\",referencedColumnName=\"cust_id\") private Customer customer;//用它的主键，对应联系人表中的外键 public Long getLkmId() &#123; return lkmId; &#125; public void setLkmId(Long lkmId) &#123; this.lkmId = lkmId; &#125; public String getLkmName() &#123; return lkmName; &#125; public void setLkmName(String lkmName) &#123; this.lkmName = lkmName; &#125; public String getLkmGender() &#123; return lkmGender; &#125; public void setLkmGender(String lkmGender) &#123; this.lkmGender = lkmGender; &#125; public String getLkmPhone() &#123; return lkmPhone; &#125; public void setLkmPhone(String lkmPhone) &#123; this.lkmPhone = lkmPhone; &#125; public String getLkmMobile() &#123; return lkmMobile; &#125; public void setLkmMobile(String lkmMobile) &#123; this.lkmMobile = lkmMobile; &#125; public String getLkmEmail() &#123; return lkmEmail; &#125; public void setLkmEmail(String lkmEmail) &#123; this.lkmEmail = lkmEmail; &#125; public String getLkmPosition() &#123; return lkmPosition; &#125; public void setLkmPosition(String lkmPosition) &#123; this.lkmPosition = lkmPosition; &#125; public String getLkmMemo() &#123; return lkmMemo; &#125; public void setLkmMemo(String lkmMemo) &#123; this.lkmMemo = lkmMemo; &#125; public Customer getCustomer() &#123; return customer; &#125; public void setCustomer(Customer customer) &#123; this.customer = customer; &#125; @Override public String toString() &#123; return \"LinkMan [lkmId=\" + lkmId + \", lkmName=\" + lkmName + \", lkmGender=\" + lkmGender + \", lkmPhone=\" + lkmPhone + \", lkmMobile=\" + lkmMobile + \", lkmEmail=\" + lkmEmail + \", lkmPosition=\" + lkmPosition + \", lkmMemo=\" + lkmMemo + \"]\"; &#125;&#125;3.4 映射的注解说明@OneToMany: 作用：建立一对多的关系映射 属性： targetEntityClass：指定多的多方的类的字节码 mappedBy：指定从表实体类中引用主表对象的名称。 cascade：指定要使用的级联操作 fetch：指定是否采用延迟加载 orphanRemoval：是否使用孤儿删除@ManyToOne 作用：建立多对一的关系 属性： targetEntityClass：指定一的一方实体类字节码 cascade：指定要使用的级联操作 fetch：指定是否采用延迟加载 optional：关联是否可选。如果设置为false，则必须始终存在非空关系。@JoinColumn 作用：用于定义主键字段和外键字段的对应关系。 属性： name：指定外键字段的名称 referencedColumnName：指定引用主表的主键字段名称 unique：是否唯一。默认值不唯一 nullable：是否允许为空。默认值允许。 insertable：是否允许插入。默认值允许。 updatable：是否允许更新。默认值允许。 columnDefinition：列的定义信息。3.5 一对多的操作3.5.1 添加@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=\"classpath:applicationContext.xml\")public class OneToManyTest &#123; @Autowired private CustomerDao customerDao; @Autowired private LinkManDao linkManDao; /** * 保存操作 * 需求: * 保存一个客户和一个联系人 * 要求： * 创建一个客户对象和一个联系人对象 * 建立客户和联系人之间关联关系（双向一对多的关联关系） * 先保存客户，再保存联系人 * 问题： * 当我们建立了双向的关联关系之后，先保存主表，再保存从表时： * 会产生2条insert和1条update. * 而实际开发中我们只需要2条insert。 * */ @Test @Transactional //开启事务 @Rollback(false)//设置为不回滚 public void testAdd() &#123; Customer c = new Customer(); c.setCustName(\"TBD云集中心\"); c.setCustLevel(\"VIP客户\"); c.setCustSource(\"网络\"); c.setCustIndustry(\"商业办公\"); c.setCustAddress(\"昌平区北七家镇\"); c.setCustPhone(\"010-84389340\"); LinkMan l = new LinkMan(); l.setLkmName(\"TBD联系人\"); l.setLkmGender(\"male\"); l.setLkmMobile(\"13811111111\"); l.setLkmPhone(\"010-34785348\"); l.setLkmEmail(\"98354834@qq.com\"); l.setLkmPosition(\"老师\"); l.setLkmMemo(\"还行吧\"); c.getLinkMans().add(l); l.setCustomer(c); customerDao.save(c); linkManDao.save(l); &#125;&#125;通过保存的案例，我们可以发现在设置了双向关系之后，会发送两条insert语句，一条多余的update语句，那我们的解决是思路很简单，就是一的一方放弃维护权 /** *放弃外键维护权的配置将如下配置改为 */ //@OneToMany(targetEntity=LinkMan.class)//@JoinColumn(name=\"lkm_cust_id\",referencedColumnName=\"cust_id\") //设置为 @OneToMany(mappedBy=\"customer\")3.5.2 删除 @Autowired private CustomerDao customerDao; @Test @Transactional @Rollback(false)//设置为不回滚 public void testDelete() &#123; customerDao.delete(1l); &#125;删除操作的说明如下：删除从表数据：可以随时任意删除。删除主表数据： 有从表数据 1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表 结构上，外键字段有非空约束，默认情况就会报错了。 2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null， 没有关系）因为在删除时，它根本不会去更新从表的外键字段了。 3、如果还想删除，使用级联删除引用 没有从表数据引用：随便删在实际开发中，级联删除请慎用！(在一对多的情况下)3.5.3 级联操作级联操作：指操作一个对象同时操作它的关联对象使用方法：只需要在操作主体的注解上配置cascade /** * cascade:配置级联操作 * CascadeType.MERGE 级联更新 * CascadeType.PERSIST 级联保存： * CascadeType.REFRESH 级联刷新： * CascadeType.REMOVE 级联删除： * CascadeType.ALL 包含所有 */ @OneToMany(mappedBy=\"customer\",cascade=CascadeType.ALL) 多对多 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412424.1 示例分析 我们采用的示例为用户和角色。 用户：指的是咱们班的每一个同学。 角色：指的是咱们班同学的身份信息。 比如A同学，它是我的学生，其中有个身份就是学生，还是家里的孩子，那么他还有个身份是子女。 同时B同学，它也具有学生和子女的身份。 那么任何一个同学都可能具有多个身份。同时学生这个身份可以被多个同学所具有。 所以我们说，用户和角色之间的关系是多对多。4.2 表关系建立多对多的表关系建立靠的是中间表，其中用户表和中间表的关系是一对多，角色表和中间表的关系也是一对多，如下图所示： 4.3 实体类关系建立以及映射配置一个用户可以具有多个角色，所以在用户实体类中应该包含多个角色的信息，代码如下：/** * 用户的数据模型 */@Entity@Table(name=\"sys_user\")public class SysUser implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"user_id\") private Long userId; @Column(name=\"user_code\") private String userCode; @Column(name=\"user_name\") private String userName; @Column(name=\"user_password\") private String userPassword; @Column(name=\"user_state\") private String userState; //多对多关系映射 @ManyToMany(mappedBy=\"users\") private Set&lt;SysRole&gt; roles = new HashSet&lt;SysRole&gt;(0); public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public String getUserCode() &#123; return userCode; &#125; public void setUserCode(String userCode) &#123; this.userCode = userCode; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPassword() &#123; return userPassword; &#125; public void setUserPassword(String userPassword) &#123; this.userPassword = userPassword; &#125; public String getUserState() &#123; return userState; &#125; public void setUserState(String userState) &#123; this.userState = userState; &#125; public Set&lt;SysRole&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;SysRole&gt; roles) &#123; this.roles = roles; &#125; @Override public String toString() &#123; return \"SysUser [userId=\" + userId + \", userCode=\" + userCode + \", userName=\" + userName + \", userPassword=\" + userPassword + \", userState=\" + userState + \"]\"; &#125;&#125;一个角色可以赋予多个用户，所以在角色实体类中应该包含多个用户的信息，代码如下：/** * 角色的数据模型 */@Entity@Table(name=\"sys_role\")public class SysRole implements Serializable &#123; @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"role_id\") private Long roleId; @Column(name=\"role_name\") private String roleName; @Column(name=\"role_memo\") private String roleMemo; //多对多关系映射 @ManyToMany @JoinTable(name=\"user_role_rel\",//中间表的名称 //中间表user_role_rel字段关联sys_role表的主键字段role_id joinColumns=&#123;@JoinColumn(name=\"role_id\",referencedColumnName=\"role_id\")&#125;, //中间表user_role_rel的字段关联sys_user表的主键user_id inverseJoinColumns=&#123;@JoinColumn(name=\"user_id\",referencedColumnName=\"user_id\")&#125; ) private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0); public Long getRoleId() &#123; return roleId; &#125; public void setRoleId(Long roleId) &#123; this.roleId = roleId; &#125; public String getRoleName() &#123; return roleName; &#125; public void setRoleName(String roleName) &#123; this.roleName = roleName; &#125; public String getRoleMemo() &#123; return roleMemo; &#125; public void setRoleMemo(String roleMemo) &#123; this.roleMemo = roleMemo; &#125; public Set&lt;SysUser&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;SysUser&gt; users) &#123; this.users = users; &#125; @Override public String toString() &#123; return \"SysRole [roleId=\" + roleId + \", roleName=\" + roleName + \", roleMemo=\" + roleMemo + \"]\"; &#125;&#125;4.4 映射的注解说明@ManyToMany 作用：用于映射多对多关系 属性： cascade：配置级联操作。 fetch：配置是否采用延迟加载。 targetEntity：配置目标的实体类。映射多对多的时候不用写。@JoinTable 作用：针对中间表的配置 属性： nam：配置中间表的名称 joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段 inverseJoinColumn：中间表的外键字段关联对方表的主键字段 @JoinColumn 作用：用于定义主键字段和外键字段的对应关系。 属性： name：指定外键字段的名称 referencedColumnName：指定引用主表的主键字段名称 unique：是否唯一。默认值不唯一 nullable：是否允许为空。默认值允许。 insertable：是否允许插入。默认值允许。 updatable：是否允许更新。默认值允许。 columnDefinition：列的定义信息。4.5 多对多的操作4.5.1 保存 @Autowired private UserDao userDao; @Autowired private RoleDao roleDao; /** * 需求： * 保存用户和角色 * 要求： * 创建2个用户和3个角色 * 让1号用户具有1号和2号角色(双向的) * 让2号用户具有2号和3号角色(双向的) * 保存用户和角色 * 问题： * 在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。 * 解决办法： * 让任意一方放弃维护关联关系的权利 */ @Test @Transactional //开启事务 @Rollback(false)//设置为不回滚 public void test1()&#123; //创建对象 SysUser u1 = new SysUser(); u1.setUserName(\"用户1\"); SysRole r1 = new SysRole(); r1.setRoleName(\"角色1\"); //建立关联关系 u1.getRoles().add(r1); r1.getUsers().add(u1); //保存 roleDao.save(r1); userDao.save(u1); &#125;在多对多（保存）中，如果双向都设置关系，意味着双方都维护中间表，都会往中间表插入数据，中间表的2个字段又作为联合主键，所以报错，主键重复，解决保存失败的问题：只需要在任意一方放弃对中间表的维护权即可，推荐在被动的一方放弃，配置如下： //放弃对中间表的维护权，解决保存中主键冲突的问题 @ManyToMany(mappedBy=\"roles\") private Set&lt;SysUser&gt; users = new HashSet&lt;SysUser&gt;(0);4.5.2 删除 @Autowired private UserDao userDao; /** * 删除操作 * 在多对多的删除时，双向级联删除根本不能配置 * 禁用 * 如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据 */ @Test @Transactional @Rollback(false)//设置为不回滚 public void testDelete() &#123; userDao.delete(1l); &#125; 对象导航查询 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192935.1 对象导航查询对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。例如：我们通过ID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。查询一个客户，获取该客户下的所有联系人 @Autowired private CustomerDao customerDao; @Test //由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中 @Transactional public void testFind() &#123; Customer customer = customerDao.findOne(5l); Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();//对象导航查询 for(LinkMan linkMan : linkMans) &#123; System.out.println(linkMan); &#125; &#125;查询一个联系人，获取该联系人的所有客户 @Autowired private LinkManDao linkManDao; @Test public void testFind() &#123; LinkMan linkMan = linkManDao.findOne(4l); Customer customer = linkMan.getCustomer(); //对象导航查询 System.out.println(customer); &#125;对象导航查询的问题分析问题1：我们查询客户时，要不要把联系人查询出来？分析：如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的，不使用时又会白白的浪费了服务器内存。解决：采用延迟加载的思想。通过配置的方式来设定当我们在需要使用时，发起真正的查询。配置方式： /** * 在客户对象的@OneToMany注解中添加fetch属性 * FetchType.EAGER ：立即加载 * FetchType.LAZY ：延迟加载 */ @OneToMany(mappedBy=\"customer\",fetch=FetchType.EAGER) private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;&gt;(0);问题2：我们查询联系人时，要不要把客户查询出来？分析：例如：查询联系人详情时，肯定会看看该联系人的所属客户。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且多数情况下我们都是要使用的。解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来配置方式 /** * 在联系人对象的@ManyToOne注解中添加fetch属性 * FetchType.EAGER ：立即加载 * FetchType.LAZY ：延迟加载 */ @ManyToOne(targetEntity=Customer.class,fetch=FetchType.EAGER) @JoinColumn(name=\"cst_lkm_id\",referencedColumnName=\"cust_id\") private Customer customer;5.2 使用Specification查询 /** * Specification的多表查询 */ @Test public void testFind() &#123; Specification&lt;LinkMan&gt; spec = new Specification&lt;LinkMan&gt;() &#123; public Predicate toPredicate(Root&lt;LinkMan&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; //Join代表链接查询，通过root对象获取 //创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left，inner，right） //JoinType.LEFT : 左外连接,JoinType.INNER：内连接,JoinType.RIGHT：右外连接 Join&lt;LinkMan, Customer&gt; join = root.join(\"customer\",JoinType.INNER); return cb.like(join.get(\"custName\").as(String.class),\"传智播客1\"); &#125; &#125;; List&lt;LinkMan&gt; list = linkManDao.findAll(spec); for (LinkMan linkMan : list) &#123; System.out.println(linkMan); &#125; &#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其二 | JPA规范与基本操作","slug":"Java数据访问框架其二-JPA规范与基本操作","date":"2020-06-25T15:35:48.000Z","updated":"2020-06-27T12:35:50.756Z","comments":true,"path":"2020/06/25/Java数据访问框架其二-JPA规范与基本操作/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%BA%8C-JPA%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"本篇从简介Hibernate框架出发，详细介绍JPA规范与接口。个人理解，JPA规范–Hibernate框架/Toplink框架–JDBC规范–JDBC驱动，层层抽象封装，但JPA作为一种规范，类似与JDBC的，其接口必然还可进一步作出封装，这就是后续会介绍的SpringData JPA实现的。","text":"本篇从简介Hibernate框架出发，详细介绍JPA规范与接口。个人理解，JPA规范–Hibernate框架/Toplink框架–JDBC规范–JDBC驱动，层层抽象封装，但JPA作为一种规范，类似与JDBC的，其接口必然还可进一步作出封装，这就是后续会介绍的SpringData JPA实现的。 先记述相关的笔记，然后为代码和配置的环境及过程中出现的问题与解决方法。 hibernate与JPA规范 一、hibernate概述Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 二、JPA概述JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。 JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。 三、JPA的优势 12345678910111213141. 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。2. 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。3. 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成4. 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。5. 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 四、JPA与hibernate的关系JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。 JPA API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061jpa操作的操作步骤 1.加载配置文件创建实体管理器工厂 Persisitence：静态方法（根据持久化单元名称创建实体管理器工厂） createEntityMnagerFactory（持久化单元名称） 作用：创建实体管理器工厂 2.根据实体管理器工厂，创建实体管理器 EntityManagerFactory ：获取EntityManager对象 方法：createEntityManager * 内部维护的很多的内容 内部维护了数据库信息， 维护了缓存信息 维护了所有的实体管理器对象 再创建EntityManagerFactory的过程中会根据配置创建数据库表 * EntityManagerFactory的创建过程比较浪费资源 特点：线程安全的对象 多个线程访问同一个EntityManagerFactory不会有线程安全问题 * 如何解决EntityManagerFactory的创建过程浪费资源（耗时）的问题？ 思路：创建一个公共的EntityManagerFactory的对象 * 静态代码块的形式创建EntityManagerFactory 3.创建事务对象，开启事务 EntityManager对象：实体类管理器 beginTransaction : 创建事务对象 presist ： 保存 merge ： 更新 remove ： 删除 find/getRefrence ： 根据id查询 Transaction 对象 ： 事务 begin：开启事务 commit：提交事务 rollback：回滚 4.增删改查操作 5.提交事务 6.释放资源i.搭建环境的过程 1.创建maven工程导入坐标 2.需要配置jpa的核心配置文件 *位置：配置到类路径下的一个叫做 META-INF 的文件夹下 *命名：persistence.xml 3.编写客户的实体类 4.配置实体类和表，类中属性和表中字段的映射关系 5.保存客户到数据库中ii.完成基本CRUD案例 persist ： 保存 merge ： 更新 remove ： 删除 find/getRefrence ： 根据id查询 iii.jpql查询 sql：查询的是表和表中的字段 jpql：查询的是实体类和类中的属性 * jpql和sql语句的语法相似 1.查询全部 2.分页查询 3.统计查询 4.条件查询 5.排序 一、核心对象 Persistence对象Persistence对象主要作用是用于获取EntityManagerFactory对象的 。通过调用该类的createEntityManagerFactory静态方法，根据配置文件中持久化单元名称创建EntityManagerFactory。1234//1. 创建 EntitymanagerFactory@TestString unitName = \"myJpa\";EntityManagerFactory factory= Persistence.createEntityManagerFactory(unitName); EntityManagerFactoryEntityManagerFactory 接口主要用来创建 EntityManager 实例由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可12//创建实体管理类EntityManager em = factory.createEntityManager(); EntityManager在 JPA 规范中, EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作方法说明：12345getTransaction : 获取事务对象persist ： 保存操作merge ： 更新操作remove ： 删除操作find/getReference ： 根据id查询 EntityTransaction在 JPA 规范中, EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的java代码中承接的功能比较简单123begin：开启事务commit：提交事务rollback：回滚事务 二、基本增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package cn.itcast.test;import cn.itcast.domain.Customer;import cn.itcast.utils.JpaUtils;import org.junit.Test;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;import javax.persistence.EntityTransaction;import javax.persistence.Persistence;public class JpaTest &#123; /** * 测试jpa的保存 * 案例：保存一个客户到数据库中 * Jpa的操作步骤 * 1.加载配置文件创建工厂（实体管理器工厂）对象 * 2.通过实体管理器工厂获取实体管理器 * 3.获取事务对象，开启事务 * 4.完成增删改查操作 * 5.提交事务（回滚事务） * 6.释放资源 */ @Test public void testSave() &#123;// //1.加载配置文件创建工厂（实体管理器工厂）对象// EntityManagerFactory factory = Persistence.createEntityManagerFactory(\"myJpa\");// //2.通过实体管理器工厂获取实体管理器// EntityManager em = factory.createEntityManager(); EntityManager em = JpaUtils.getEntityManager(); //3.获取事务对象，开启事务 EntityTransaction tx = em.getTransaction(); //获取事务对象 tx.begin();//开启事务 //4.完成增删改查操作：保存一个客户到数据库中 Customer customer = new Customer(); customer.setCustName(\"传智播客\"); customer.setCustIndustry(\"教育\"); //保存， em.persist(customer); //保存操作 //5.提交事务 tx.commit(); //6.释放资源 em.close(); // factory.close(); &#125; /** * 根据id查询客户 * 使用find方法查询： * 1.查询的对象就是当前客户对象本身 * 2.在调用find方法的时候，就会发送sql语句查询数据库 * * 立即加载 * * */ @Test public void testFind() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * find : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.find(Customer.class, 1l); // System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 根据id查询客户 * getReference方法 * 1.获取的对象是一个动态代理对象 * 2.调用getReference方法不会立即发送sql语句查询数据库 * * 当调用查询结果对象的时候，才会发送查询的sql语句：什么时候用，什么时候发送sql语句查询数据库 * * 延迟加载（懒加载） * * 得到的是一个动态代理对象 * * 什么时候用，什么使用才会查询 */ @Test public void testReference() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 根据id查询客户 /** * getReference : 根据id查询数据 * class：查询数据的结果需要包装的实体类类型的字节码 * id：查询的主键的取值 */ Customer customer = entityManager.getReference(Customer.class, 1l); System.out.print(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 删除客户的案例 * */ @Test public void testRemove() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 删除客户 //i 根据id查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 调用remove方法完成删除操作 entityManager.remove(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125; /** * 更新客户的操作 * merge(Object) */ @Test public void testUpdate() &#123; //1.通过工具类获取entityManager EntityManager entityManager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = entityManager.getTransaction(); tx.begin(); //3.增删改查 -- 更新操作 //i 查询客户 Customer customer = entityManager.find(Customer.class,1l); //ii 更新客户 customer.setCustIndustry(\"it教育\"); entityManager.merge(customer); //4.提交事务 tx.commit(); //5.释放资源 entityManager.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921 保存 /** * 保存一个实体 */ @Test public void testAdd() &#123; // 定义对象 Customer c = new Customer(); c.setCustName(\"传智学院\"); c.setCustLevel(\"VIP客户\"); c.setCustSource(\"网络\"); c.setCustIndustry(\"IT教育\"); c.setCustAddress(\"昌平区北七家镇\"); c.setCustPhone(\"010-84389340\"); EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 em.persist(c); // 提交事务 tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;2 修改 @Test public void testMerge()&#123; //定义对象 EntityManager em=null; EntityTransaction tx=null; try&#123; //获取实体管理对象 em=JPAUtil.getEntityManager(); //获取事务对象 tx=em.getTransaction(); //开启事务 tx.begin(); //执行操作 Customer c1 = em.find(Customer.class, 6L); c1.setCustName(\"江苏传智学院\"); em.clear();//把c1对象从缓存中清除出去 em.merge(c1); //提交事务 tx.commit(); &#125;catch(Exception e)&#123; //回滚事务 tx.rollback(); e.printStackTrace(); &#125;finally&#123; //释放资源 em.close(); &#125; &#125;3 删除 /** * 删除 */ @Test public void testRemove() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 6L); em.remove(c1); // 提交事务 tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;4 根据id查询 /** * 查询一个： 使用立即加载的策略 */ @Test public void testGetOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 1L); // 提交事务 tx.commit(); System.out.println(c1); // 输出查询对象 &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; // 查询实体的缓存问题 @Test public void testGetOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.find(Customer.class, 1L); Customer c2 = em.find(Customer.class, 1L); System.out.println(c1 == c2);// 输出结果是true，EntityManager也有缓存 // 提交事务 tx.commit(); System.out.println(c1); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; // 延迟加载策略的方法： /** * 查询一个： 使用延迟加载策略 */ @Test public void testLoadOne() &#123; // 定义对象 EntityManager em = null; EntityTransaction tx = null; try &#123; // 获取实体管理对象 em = JPAUtil.getEntityManager(); // 获取事务对象 tx = em.getTransaction(); // 开启事务 tx.begin(); // 执行操作 Customer c1 = em.getReference(Customer.class, 1L); // 提交事务 tx.commit(); System.out.println(c1); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; 三、Jpql查询JPQL全称Java Persistence Query Language 基于首次在EJB2.0中引入的EJB查询语言(EJB QL),Java持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将SQL语法和简单查询语义绑定在一起·使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的SQL。 其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package cn.itcast.test;import cn.itcast.domain.Customer;import cn.itcast.utils.JpaUtils;import org.junit.Test;import javax.persistence.EntityManager;import javax.persistence.EntityTransaction;import javax.persistence.Query;import java.util.List;/** * 测试jqpl查询 */public class JpqlTest &#123; /** * 查询全部 * jqpl：from cn.itcast.domain.Customer * sql：SELECT * FROM cst_customer */ @Test public void testFindAll() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = \"from Customer \"; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) &#123; System.out.print(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 排序查询： 倒序查询全部客户（根据id倒序） * sql：SELECT * FROM cst_customer ORDER BY cust_id DESC * jpql：from Customer order by custId desc * * 进行jpql查询 * 1.创建query查询对象 * 2.对参数进行赋值 * 3.查询，并得到返回结果 */ @Test public void testOrders() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 String jpql = \"from Customer order by custId desc\"; Query query = em.createQuery(jpql);//创建Query查询对象，query对象才是执行jqpl的对象 //发送查询，并封装结果集 List list = query.getResultList(); for (Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 使用jpql查询，统计客户的总数 * sql：SELECT COUNT(cust_id) FROM cst_customer * jpql：select count(custId) from Customer */ @Test public void testCount() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \"select count(custId) from Customer\"; Query query = em.createQuery(jpql); //ii.对参数赋值 //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ Object result = query.getSingleResult(); System.out.println(result); //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 分页查询 * sql：select * from cst_customer limit 0,2 * jqpl : from Customer */ @Test public void testPaged() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \"from Customer\"; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 分页参数 //起始索引 query.setFirstResult(0); //每页查询的条数 query.setMaxResults(2); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125; /** * 条件查询 * 案例：查询客户名称以‘传智播客’开头的客户 * sql：SELECT * FROM cst_customer WHERE cust_name LIKE ? * jpql : from Customer where custName like ? */ @Test public void testCondition() &#123; //1.获取entityManager对象 EntityManager em = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction tx = em.getTransaction(); tx.begin(); //3.查询全部 //i.根据jpql语句创建Query查询对象 String jpql = \"from Customer where custName like ? \"; Query query = em.createQuery(jpql); //ii.对参数赋值 -- 占位符参数 //第一个参数：占位符的索引位置（从1开始），第二个参数：取值 query.setParameter(1,\"传智播客%\"); //iii.发送查询，并封装结果 /** * getResultList ： 直接将查询结果封装为list集合 * getSingleResult : 得到唯一的结果集 */ List list = query.getResultList(); for(Object obj : list) &#123; System.out.println(obj); &#125; //4.提交事务 tx.commit(); //5.释放资源 em.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631 查询全部 //查询所有客户 @Test public void findAll() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 创建query对象 String jpql = \"from Customer\"; Query query = em.createQuery(jpql); // 查询并得到返回结果 List list = query.getResultList(); // 得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;2 分页查询 //分页查询客户 @Test public void findPaged () &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); //创建query对象 String jpql = \"from Customer\"; Query query = em.createQuery(jpql); //起始索引 query.setFirstResult(0); //每页显示条数 query.setMaxResults(2); //查询并得到返回结果 List list = query.getResultList(); //得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;3 条件查询 //条件查询 @Test public void findCondition () &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); //创建query对象 String jpql = \"from Customer where custName like ? \"; Query query = em.createQuery(jpql); //对占位符赋值，从1开始 query.setParameter(1, \"传智播客%\"); //查询并得到返回结果 Object object = query.getSingleResult(); //得到唯一的结果集对象 System.out.println(object); tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;4 排序查询 //根据客户id倒序查询所有客户 //查询所有客户 @Test public void testOrder() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 创建query对象 String jpql = \"from Customer order by custId desc\"; Query query = em.createQuery(jpql); // 查询并得到返回结果 List list = query.getResultList(); // 得到集合返回类型 for (Object object : list) &#123; System.out.println(object); &#125; tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125;5 统计查询 //统计查询 @Test public void findCount() &#123; EntityManager em = null; EntityTransaction tx = null; try &#123; //获取实体管理对象 em = JPAUtil.getEntityManager(); //获取事务对象 tx = em.getTransaction(); tx.begin(); // 查询全部客户 // 1.创建query对象 String jpql = \"select count(custId) from Customer\"; Query query = em.createQuery(jpql); // 2.查询并得到返回结果 Object count = query.getSingleResult(); // 得到集合返回类型 System.out.println(count); tx.commit(); &#125; catch (Exception e) &#123; // 回滚事务 tx.rollback(); e.printStackTrace(); &#125; finally &#123; // 释放资源 em.close(); &#125; &#125; JPA测试配置首先在这里写一下我在配置JPA和SpringData JPA过程中遇到数个错误采取多种措施之后解决所得的结论：第一，JPA实体类中@Table等注解有红线，其实不用管，当然我查了很多赋予数据源的设置，也尝试过，使红线消失了，但对问题的解决没有帮助，该报错还是报错。因此我得出了编译器中这个红线不用管的结论，当然也可以配置，在下面我会给出方法。第二，说是JPA，其实实现多半都是Hibernate相关的额一些配置，因此相关的版本和依赖是根本问题。说一下我发现的几点：其一是单用JPA测试或SpringData JPA测试最好用jdk1.8，当然jdk11行不行没测试过，但有一个地方必须配，必须添几个依赖，不然就算1.8也会不错，在下面会贴出来；其二是若用springboot整合springdata jpa的话就不用在意这个问题，当然也许实体类注解也会有红线，但只要yml文件中数据库配置正确，就毫无影响。 下面贴一下可以正确运行的相关配置pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;jpa&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;!-- hibernate对jpa的支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mysql驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解决因jdk版本等原因造成的java.lang.ClassNotFoundException: javax.xml.bind.JAXBException问题 --&gt; &lt;!-- 参考 https://blog.csdn.net/w405722907/article/details/80523790 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; resources/META-INF/persistence.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"2.0\"&gt; &lt;!--需要配置persistence-unit节点 持久化单元： name：持久化单元名称 transaction-type：事务管理的方式 JTA：分布式事务管理 RESOURCE_LOCAL：本地事务管理 --&gt; &lt;persistence-unit name=\"myJpa\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;!--jpa的实现方式 --&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;!--可选配置：配置jpa实现方的配置信息--&gt; &lt;properties&gt; &lt;!-- 数据库信息 用户名，javax.persistence.jdbc.user 密码， javax.persistence.jdbc.password 驱动， javax.persistence.jdbc.driver 数据库地址 javax.persistence.jdbc.url --&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"root\"/&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"123456\"/&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql:///senior\"/&gt; &lt;!--配置jpa实现方(hibernate)的配置信息 显示sql ： false|true 自动创建数据库表 ： hibernate.hbm2ddl.auto create : 程序运行时创建数据库表（如果有表，先删除表再创建） update ：程序运行时创建表（如果有表，不会创建表） none ：不会创建表 --&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\" /&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\" /&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 附：JPA数据源设置https://blog.csdn.net/w405722907/article/details/84643906mysql时区https://www.cnblogs.com/mengw/p/12213093.htmljdbc:mysql://localhost/blog?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC 附：实体类映射示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package cn.itcast.domain;import org.hibernate.annotations.Proxy;import javax.persistence.*;/** * 客户的实体类 * 配置映射关系 * * * 1.实体类和表的映射关系 * @Entity:声明实体类 * @Table : 配置实体类和表的映射关系 * name : 配置数据库表的名称 * 2.实体类中属性和表中字段的映射关系 * * */@Entity@Table(name = \"cst_customer\")public class Customer &#123; /** * @Id：声明主键的配置 * @GeneratedValue:配置主键的生成策略 * strategy * GenerationType.IDENTITY ：自增，mysql * * 底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增） * GenerationType.SEQUENCE : 序列，oracle * * 底层数据库必须支持序列 * GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增 * GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略 * @Column:配置属性和字段的映射关系 * name：数据库表中字段的名称 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"cust_id\") private Long custId; //客户的主键 @Column(name = \"cust_name\") private String custName;//客户名称 @Column(name=\"cust_source\") private String custSource;//客户来源 @Column(name=\"cust_level\") private String custLevel;//客户级别 @Column(name=\"cust_industry\") private String custIndustry;//客户所属行业 @Column(name=\"cust_phone\") private String custPhone;//客户的联系方式 @Column(name=\"cust_address\") private String custAddress;//客户地址 public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustPhone() &#123; return custPhone; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; @Override public String toString() &#123; return \"Customer&#123;\" + \"custId=\" + custId + \", custName='\" + custName + '\\'' + \", custSource='\" + custSource + '\\'' + \", custLevel='\" + custLevel + '\\'' + \", custIndustry='\" + custIndustry + '\\'' + \", custPhone='\" + custPhone + '\\'' + \", custAddress='\" + custAddress + '\\'' + '&#125;'; &#125;&#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"Java数据访问框架其一 | 概述","slug":"Java数据访问框架其一-概述","date":"2020-06-25T15:07:41.000Z","updated":"2020-06-26T15:17:23.599Z","comments":true,"path":"2020/06/25/Java数据访问框架其一-概述/","link":"","permalink":"http://nlbyd1119.online/2020/06/25/Java%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%A1%86%E6%9E%B6%E5%85%B6%E4%B8%80-%E6%A6%82%E8%BF%B0/","excerpt":"写作目的","text":"写作目的 自年初以来，陆续学习了ssm、springboot、springdata jpa、spring security等框架以及相关的一些基础技术，如restful风格、前端模板引擎等，此外还为一些其他的需要学习过java爬虫相关框架和python的web框架等。经过该阶段的学习，我认识到需要对已经了解到的内容进行简单归类总结。对于一个框架，认识其核心原理+功能+配置是最关键的，而要掌握的第一步就是有一个可行的环境。在这些框架中，有些功能类似但原理有所差异，因此在该系列篇章中，我会就ORM、安全、模板、日志、控制器等方面就JavaWeb相关的框架及一些技术进行简单介绍和归纳整理。突出介绍其原理、基本使用和环境配置，保证环境切实可用。 ORM框架概述 ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射 简单的说：ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。 为什么使用ORM 当实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存数据、修改数据、删除数据，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。 常见ORM框架 常见的orm框架：Mybatis（ibatis）、Hibernate、Jpa orm思想 1234567主要目的：操作实体类就相当于操作数据库表建立两个映射关系： 实体类和表的映射关系 实体类中属性和表中字段的映射关系不再重点关注：sql语句实现了ORM思想的框架：mybatis，hibernate 接下来的几篇，会从JPA规范写起，技术JPA接口、SpringData JPA接口与集成、Mybatis集成以及两种ORM的对比。","categories":[{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"github 参考","slug":"github-参考","date":"2020-06-23T13:18:53.000Z","updated":"2020-06-23T13:20:38.377Z","comments":true,"path":"2020/06/23/github-参考/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/github-%E5%8F%82%E8%80%83/","excerpt":"记录一些学习参考用的github仓库","text":"记录一些学习参考用的github仓库 一、spring相关框架 spring集成mongodbhttps://github.com/JMCuixy/SpringDataMongoDB","categories":[{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"springboot使用的一些细节","slug":"springboot使用的一些细节","date":"2020-06-23T13:01:10.000Z","updated":"2020-06-23T13:20:40.414Z","comments":true,"path":"2020/06/23/springboot使用的一些细节/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/springboot%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/","excerpt":"本篇就springboot框架使用时需要注意的一些细节作出说明。","text":"本篇就springboot框架使用时需要注意的一些细节作出说明。 一、配置文件yml 一定注意缩进问题（必须统一），否则配置失效，编译器中有暗黄色阴影即很可能有问题。 静态资源的配置，虽然默认可以访问static、templates目录下的文件，但其子目录是访问不到的，需要在yml中进行配置。","categories":[{"name":"框架使用","slug":"框架使用","permalink":"http://nlbyd1119.online/categories/%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"工具网站","slug":"工具网站","date":"2020-06-23T12:59:53.000Z","updated":"2020-06-26T15:02:19.767Z","comments":true,"path":"2020/06/23/工具网站/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99/","excerpt":"一、文件转换类","text":"一、文件转换类 pdf转mdhttps://pdf2md.morethan.io/ word转mdhttps://word2md.com/","categories":[{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"华为云ECS配置","slug":"华为云ECS配置","date":"2020-06-23T12:45:45.000Z","updated":"2020-06-23T13:20:44.360Z","comments":true,"path":"2020/06/23/华为云ECS配置/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/%E5%8D%8E%E4%B8%BA%E4%BA%91ECS%E9%85%8D%E7%BD%AE/","excerpt":"2020.6.21 在华为云上购买了三年的1v 2g 1m的HECS，操作系统为ubuntu18.04，作部署测试用，该篇记述一下相关的问题。","text":"2020.6.21 在华为云上购买了三年的1v 2g 1m的HECS，操作系统为ubuntu18.04，作部署测试用，该篇记述一下相关的问题。 一、ubuntu镜像源的更换参考 https://support.huaweicloud.com/ecs_faq/ecs_faq_1005.html 1wget -O /etc/apt/sources.list http://mirrors.myhuaweicloud.com/repo/sources.list.bionic 二、图形化界面安装参考 https://support.huaweicloud.com/ecs_faq/ecs_faq_0710.html 123456789101112131415161718192021222324登录弹性云服务器，运行如下命令安装图形化桌面。执行如下命令，更新软件库。# apt-get update执行如下命令，安装Ubuntu图形化桌面。# apt-get install xubuntu-desktop运行过程中需要手动两次确认，请选择Y。执行以下命令，编辑root/.profile文件。# vi /root/.profile修改末尾行mesg n || true为tty -s &amp;&amp; mesg n || true，修改后该文件内容如下：# ~/.profile: executed by Bourne-compatible login shells. if [ \"$BASH\" ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fifitty -s &amp;&amp; mesg n || truereboot 三、ubuntu、centos命令的一些区别https://console.huaweicloud.com/lcs/?region=cn-east-3#/lcs/manager/vmListhttps://cn-east-3-console.huaweicloud.com/vnc/pod06.cn-east-3a/vnc_auto.html?token=ea3d2c78-3215-4ef2-87fc-e0911e939cc9&amp;lang=EN&amp;name=hecs-x_medium_2_linux-20200621101112&amp;uuid=9dd95bbb-38ed-4d92-97b9-af1a067ebe7e&amp;osType=Linuxhttps://console.huaweicloud.com/vpc/?region=cn-east-3#/secGroups/SGDetail?instanceId=0f1ecf91-ac1d-452e-acda-9c7547ae4e4fhttps://console.huaweicloud.com/ecm/?agencyId=082f21989980258b1f3ac0039c7558cb&amp;region=cn-east-3&amp;locale=zh-cn#/ecs/manager/vmListhttps://www.baidu.com/s?wd=ubuntu%E5%AE%89%E8%A3%85docker%E7%9B%AE%E5%BD%95&amp;rsv_spt=1&amp;rsv_iqid=0xbcade733000250ed&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;oq=ubuntu%25E5%25AE%2589%25E8%25A3%2585docker%25E4%25BD%258D%25E7%25BD%25AE&amp;rsv_t=52adiEMO%2Fy6p2VizqhPXvmtZIfutKSRVSBzbHPJ0aoW3%2BtdCa1zCBJrUa%2BCdKXfgjKLx&amp;rsv_btype=t&amp;inputT=2604&amp;rsv_pq=b4779478001de369&amp;rsv_sug3=33&amp;rsv_sug1=13&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=3311https://zhidao.baidu.com/question/877380477345533812.htmlhttps://blog.csdn.net/b9567/article/details/105027440/https://www.runoob.com/docker/ubuntu-docker-install.htmlhttps://www.baidu.com/s?wd=ubuntu%E6%9C%89yum%E5%90%97&amp;rsv_spt=1&amp;rsv_iqid=0xc7a4ded8000e54dd&amp;issp=1&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ts_0&amp;rsv_sug3=11&amp;rsv_sug1=8&amp;rsv_sug7=100&amp;rsv_t=a9c9rxl7sFzcIqpZzbs0yXPQEAWRgaDHUACe5ZFt3t7LCCpubevhQ4SkuBrt9FRX38h6&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=ubuntu%25E6%259C%2589y&amp;rsp=0&amp;inputT=6565&amp;rsv_sug4=6565https://www.baidu.com/s?wd=sudo%20apt%20yum&amp;rsv_spt=1&amp;rsv_iqid=0xb8710b71000223ca&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=13&amp;rsv_sug1=11&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=5492&amp;rsv_sug4=6154https://blog.csdn.net/yimenglin/article/details/88365485https://www.baidu.com/s?wd=sudo%E4%B8%8Esystemctl&amp;rsv_spt=1&amp;rsv_iqid=0xe746ca18001cd98b&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;oq=sudo%25E4%25B8%258Esystemctl&amp;rsv_btype=t&amp;inputT=779&amp;rsv_t=f79fUMT%2BuI7wekfW8deK9xB7wdS1eAe%2Fej5X4Ts%2F4MJfKdP2B0TgqePwp3bRT1iLGdvp&amp;rsv_sug3=24&amp;rsv_pq=8359d7b7000e9749&amp;rsv_sug2=0&amp;rsv_sug4=1576","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://nlbyd1119.online/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"mongodb","slug":"mongodb","date":"2020-06-23T11:28:13.000Z","updated":"2020-06-23T12:39:00.162Z","comments":true,"path":"2020/06/23/mongodb/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/mongodb/","excerpt":"MongoDB","text":"MongoDB 12345理解MongoDB的业务场景、熟悉MongoDB的简介、特点和体系结构、数据类型等。能够在Windows和Linux下安装和启动MongoDB、图形化管理界面Compass的安装使用掌握MongoDB基本常用命令实现数据的CRUD掌握MongoDB的索引类型、索引管理、执行计划。使用Spring Data MongoDB完成文章评论业务的开发 1 MongoDB相关概念1.1 业务应用场景传统的关系型数据库（如MySQL），在数据操作的“三高”需求以及应对Web2.0的网站需求面前，显得力不从心。解释：“三高”需求： High performance - 对数据库高并发读写的需求。 Huge Storage - 对海量数据的高效率存储和访问的需求。 High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求。而MongoDB可应对“三高”需求。 具体的应用场景如：1 ）社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能。2 ）游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、高效率存储和访问。3 ）物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来。4 ）物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析。5 ）视频直播，使用 MongoDB 存储用户信息、点赞互动信息等。 这些应用场景中，数据操作方面的共同特点是：（ 1 ）数据量大（ 2 ）写入操作频繁（读写都很频繁）（ 3 ）价值较低的数据，对事务性要求不高对于这样的数据，我们更适合使用MongoDB来实现数据的存储。什么时候选择MongoDB在架构选型上，除了上述的三个特点外，如果你还犹豫是否要选择它？可以考虑以下的一些问题：应用不需要事务及复杂 join 支持新应用，需求会变，数据模型无法确定，想快速迭代开发应用需要2000-3000以上的读写QPS（更高也可以）应用需要TB甚至 PB 级别数据存储应用发展迅速，需要能快速水平扩展应用要求存储的数据不丢失应用需要99.999%高可用应用需要大量的地理位置查询、文本查询如果上述有 1 个符合，可以考虑 MongoDB， 2 个及以上的符合，选择 MongoDB 绝不会后悔。 思考：如果用MySQL呢？答：相对MySQL，可以以更低的成本解决问题（包括学习、开发、运维等成本） 1.2 MongoDB简介123456789SQL术语&#x2F;概念 MongoDB术语&#x2F;概念 解释&#x2F;说明database database 数据库table collection 数据库表&#x2F;集合row document 数据记录行&#x2F;文档column field 数据字段&#x2F;域index index 索引table joins 表连接,MongoDB不支持嵌入文档 MongoDB通过嵌入式文档来替代多表连接primary key primary key 主键,MongoDB自动将_id字段设置为主键 MongoDB是一个开源、高性能、无模式的文档型数据库，当初的设计就是用于简化开发和方便扩展，是NoSQL数据库产品中的一种。是最像关系型数据库（MySQL）的非关系型数据库。它支持的数据结构非常松散，是一种类似于 JSON 的 格式叫BSON，所以它既可以存储比较复杂的数据类型，又相当的灵活。MongoDB中的记录是一个文档，它是一个由字段和值对（field:value）组成的数据结构。MongoDB文档类似于JSON对象，即一个文档认为就是一个对象。字段的数据类型是字符型，它的值除了使用基本的一些类型外，还可以包括其他文档、普通数组和文档数组。 1.3 体系结构MySQL和MongoDB对比 1.4 数据模型MongoDB的最小存储单位就是文档(document)对象。文档(document)对象对应于关系型数据库的行。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。BSON采用了类似于 C 语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression 和code。每一个驱动都以特定语言的方式实现了这些类型，查看你的驱动的文档来获取详细信息。BSON数据类型参考列表： 数据类型 描述 举例12345字符串 UTF-8字符串都可表示为字符串类型的数据 &#123;&quot;x&quot; : &quot;foobar&quot;&#125;对象id 对象id是文档的 12 字节的唯一 ID &#123;&quot;X&quot; :ObjectId() &#125;布尔值 真或者假：true或者false &#123;&quot;x&quot;:true&#125;+数组 值的集合或者列表可以表示成数组 &#123;&quot;x&quot; ： [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#125;32 位整数 类型不可用。自动转换。 JavaScript仅支持^64 位浮点数，所以^32 位整数会被 shell位浮点数是不支持该类型的，shell中默认会转换成^64 1234567891064 位整数 不支持这个类型。整数 shell会使用一个特殊的内嵌文档来显示^64 位 shell位浮点数是不支持该类型的，shell中默认会转换成^6464 位浮点数 shell中的数字就是这一种类型 &#123;&quot;x&quot;：3.14159，&quot;y&quot;：3&#125;null 表示空值或者未定义的对象 &#123;&quot;x&quot;:null&#125;undefined 文档中也可以使用未定义类型 &#123;&quot;x&quot;:undefined&#125;符号 shell字符串不支持，shell会将数据库中的符号类型的数据自动转换成正则表达式 文档中可以包含正则表达式，采用JavaScript的正则表达式语法 &#123;&quot;x&quot; ： &#x2F;foobar&#x2F;i&#125;代码 文档中还可以包含JavaScript代码 &#123;&quot;x&quot; ： function() &#123; &#x2F;* ...... *&#x2F; &#125;&#125;二进制数据 二进制数据可以由任意字节的串组成，不过shell中无法使用最大值&#x2F;最小值 12BSON包括一个特殊类型，表示可能的最大值。shell中没有这个类型。^ 提示：shell默认使用 64 位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（ 4 字节符号整数）或NumberLong（ 8 字节符号整数），{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)} 1.5 MongoDB的特点MongoDB主要有如下特点：（ 1 ）高性能：MongoDB提供高性能的数据持久性。特别是,对嵌入式数据模型的支持减少了数据库系统上的I/O活动。索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种 O2O 应用）mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足各种场景需求。Gridfs解决文件存储的需求。（ 2 ）高可用性：MongoDB的复制工具称为副本集（replica set），它可提供自动故障转移和数据冗余。（ 3 ）高扩展性：MongoDB提供了水平可扩展性作为其核心功能的一部分。分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）从3.4开始，MongoDB支持基于片键创建数据区域。在一个平衡的集群中，MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。（ 4 ）丰富的查询支持：MongoDB支持丰富的查询语言，支持读和写操作(CRUD)，比如数据聚合、文本搜索和地理空间查询等。（ 5 ）其他特点：如无模式（动态模式）、灵活的文档模型、 2 单机部署2.1 Windows系统中的安装启动第一步：下载安装包MongoDB 提供了可用于 32 位和 64 位系统的预编译二进制包，你可以从MongoDB官网下载安装，MongoDB 预编译二进制包下载地址：https://www.mongodb.com/download-center#community 根据上图所示下载zip包。提示：版本的选择：MongoDB的版本命名规范如：x.y.z；y为奇数时表示当前版本为开发版，如：1.5.2、4.1.13；y为偶数时表示当前版本为稳定版，如：1.6.3、4.0.10；z是修正版本号，数字越大越好。详情：http://docs.mongodb.org/manual/release-notes/#release-version-numbers 第二步：解压安装启动将压缩包解压到一个目录中。在解压目录中，手动建立一个目录用于存放数据文件，如data/db 方式 1 ：命令行参数方式启动服务在bin目录中打开命令行提示符，输入如下命令： 我们在启动信息中可以看到，mongoDB的默认端口是 27017 ，如果我们想改变默认的启动端口，可以通过–port来指定端口。为了方便我们每次启动，可以将安装目录的bin目录设置到环境变量的path中，bin目录下是一些常用命令，比如mongod启动服务用的，mongo客户端连接服务用的。 方式 2 ：配置文件方式启动服务在解压目录中新建config文件夹，该文件夹中新建配置文件mongod.conf，内如参考如下： 详细配置项内容可以参考官方文档：https://docs.mongodb.com/manual/reference/configuration-options/【注意】1 ）配置文件中如果使用双引号，比如路径地址，自动会将双引号的内容转义。如果不转义，则会报错： 解决：a. 对\\换成/或\\b. 如果路径中没有空格，则无需加引号。2 ）配置文件中不能以Tab分割字段 1mongod - -dbpath&#x3D;..\\data\\db 123storage:#The directory where the mongod instance stores its data.Default Value is &quot;\\data\\db&quot; on Windows.dbPath: D:\\ 02 _Server\\DBServer\\mongodb-win 32 - x 86 _ 64 - 2008 plus-ssl- 4. 0. 1 \\data 1error-parsing-yaml-config-file-yaml-cpp-error-at-line- 3 - column- 15 - unknown-escape-character-d 解决：将其转换成空格。启动方式：更多参数配置：2.2 Shell连接(mongo命令)在命令提示符输入以下shell命令即可完成登陆 查看已经有的数据库退出mongodb 更多参数可以通过帮助查看：提示：MongoDB javascript shell是一个基于javascript的解释器，故是支持js程序的。 2.3 Compass-图形化界面客户端到MongoDB官网下载MongoDB Compass，地址：https://www.mongodb.com/download-center/v2/compass?initial=true如果是下载安装版，则按照步骤安装；如果是下载加压缩版，直接解压，执行里面的MongoDBCompassCommunity.exe文件即可。在打开的界面中，输入主机地址、端口等相关信息，点击连接： 123mongod - f ..&#x2F;config&#x2F;mongod.conf或mongod - -config ..&#x2F;config&#x2F;mongod.conf 123456789101112131415systemLog:destination: file#The path of the log file to which mongod or mongos should send all diagnostic logging informationpath: &quot;D:&#x2F; 02 _Server&#x2F;DBServer&#x2F;mongodb-win 32 - x 86 _ 64 - 2008 plus-ssl- 4. 0. 1 &#x2F;log&#x2F;mongod.log&quot;logAppend: truestorage:journal:enabled: true#The directory where the mongod instance stores its data.Default Value is &quot;&#x2F;data&#x2F;db&quot;.dbPath: &quot;D:&#x2F; 02 _Server&#x2F;DBServer&#x2F;mongodb-win 32 - x 86 _ 64 - 2008 plus-ssl- 4. 0. 1 &#x2F;data&quot;net:#bindIp: 127. 0. 0. 1port: 27017setParameter:enableLocalhostAuthBypass: false 123mongo或mongo - -host&#x3D; 127. 0. 0. 1 - -port&#x3D; 27017 1&gt;show databases 1exit 1mongo - -help 2.4 Linux系统中的安装启动和连接目标：在Linux中部署一个单机的MongoDB，作为生产环境下使用。提示：和Windows下操作差不多。步骤如下：（ 1 ）先到官网下载压缩包mongod-linux-x 86 _ 64 - 4. 0. 10 .tgz。（ 2 ）上传压缩包到Linux中，解压到当前目录： （ 3 ）移动解压后的文件夹到指定的目录中：（ 4 ）新建几个目录，分别用来存储数据和日志：（ 5 ）新建并修改配置文件配置文件的内容如下：1tar - xvf mongodb-linux-x 86 _ 64 - 4. 0. 10 .tgz 1mv mongodb-linux-x 86 _ 64 - 4. 0. 10 &#x2F;usr&#x2F;local&#x2F;mongodb #数据存储目录123mkdir - p &#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db#日志存储目录mkdir - p &#x2F;mongodb&#x2F;single&#x2F;log 1vi &#x2F;mongodb&#x2F;single&#x2F;mongod.conf 123456789101112131415161718192021systemLog:#MongoDB发送所有日志输出的目标指定为文件# #The path of the log file to which mongod or mongos should send all diagnostic logging informationdestination: file#mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径path: &quot;&#x2F;mongodb&#x2F;single&#x2F;log&#x2F;mongod.log&quot;#当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。logAppend: truestorage:#mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。##The directory where the mongod instance stores its data.Default Value is &quot;&#x2F;data&#x2F;db&quot;.dbPath: &quot;&#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db&quot;journal:#启用或禁用持久性日志以确保数据文件保持有效和可恢复。enabled: trueprocessManagement:#启用在后台运行mongos或mongod进程的守护进程模式。fork: truenet:#服务实例绑定的IP，默认是localhostbindIp: localhost, 192. 168. 0. 2 （ 6 ）启动MongoDB服务 注意：如果启动后不是successfully，则是启动失败了。原因基本上就是配置文件有问题。 通过进程来查看服务是否启动了：（ 7 ）分别使用mongo命令和compass工具来连接测试。提示：如果远程连接不上，需要配置防火墙放行，或直接关闭linux防火墙 （ 8 ）停止关闭服务停止服务的方式有两种：快速关闭和标准关闭，下面依次说明：（一）快速关闭方法（快速，简单，数据可能会出错）目标：通过系统的kill命令直接杀死进程：杀完要检查一下，避免有的没有杀掉。 【补充】如果一旦是因为数据损坏，则需要进行如下操作（了解）：1 ）删除lock文件： 2 ）修复数据：（二）标准的关闭方法（数据不容易出错，但麻烦）：目标：通过mongo客户端中的shutdownServer命令来关闭服务主要的操作步骤参考如下： 3 基本常用命令123#bindIp#绑定的端口，默认是 27017port: 27017 1234[root@bobohost single]# &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod - f &#x2F;mongodb&#x2F;single&#x2F;mongod.confabout to fork child process, waiting until server is ready for connections.forked process: 90384child process started successfully, parent exiting 12[root@bobohost single]# ps - ef |grep mongodroot 90384 1 0 8 月 26? 00 : 02 : 13 &#x2F;usr&#x2F;local&#x2F;mongdb&#x2F;bin&#x2F;mongod - f &#x2F;mongodb&#x2F;single&#x2F;mongod.conf #查看防火墙状态12345systemctl status firewalld#临时关闭防火墙systemctl stop firewalld#开机禁止启动防火墙systemctl disable firewalld #通过进程编号关闭节点1kill - 2 54410 1rm - f &#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db&#x2F;*.lock 1&#x2F;usr&#x2F;local&#x2F;mongdb&#x2F;bin&#x2F;mongod - -repair - -dbpath&#x3D;&#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db 123456&#x2F;&#x2F;客户端登录服务，注意，这里通过localhost登录，如果需要远程登录，必须先登录认证才行。mongo - -port 27017&#x2F;&#x2F;#切换到admin库use admin&#x2F;&#x2F;关闭服务db.shutdownServer() 123456789101112专栏文章评论 comment字段名称 字段含义 字段类型 备注_id ID ObjectId或String Mongo的主键的字段articleid 文章ID Stringcontent 评论内容 Stringuserid 评论人ID Stringnickname 评论人昵称 Stringcreatedatetime 评论的日期时间 Datelikenum 点赞数 Intreplynum 回复数 Intstate 状态 String 0 ：不可见； 1 ：可见；parentid 上级ID String 如果为 0 表示文章的顶级评论 3.1 案例需求存放文章评论的数据存放到MongoDB中，数据结构参考如下：数据库：articledb 3.2 数据库操作3.2.1 选择和创建数据库选择和创建数据库的语法格式：如果数据库不存在则自动创建，例如，以下语句创建spitdb数据库： 查看有权限查看的所有的数据库命令1注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 查看当前正在使用的数据库命令MongoDB 中默认的数据库为 test，如果你没有选择数据库，集合将存放在 test 数据库中。 另外：数据库名可以是满足以下条件的任意UTF-8字符串。不能是空字符串（””)。不得含有’ ‘（空格)、.、$、/、\\和\\0 (空字符)。应全部小写。最多 64 字节。有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 3.2.2 数据库的删除MongoDB 删除数据库的语法格式如下： 1use 数据库名称 1use articledb 123show dbs或show databases 1db 1db.dropDatabase() 提示：主要用来删除已经持久化的数据库3.3 集合操作集合，类似关系型数据库中的表。可以显示的创建，也可以隐式的创建。3.3.1 集合的显式创建（了解）基本语法格式：参数说明：1name: 要创建的集合名称 例如：创建一个名为mycollection的普通集合。 查看当前库中的表：show tables命令 集合的命名规范：集合名不能是空字符串””。集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。123集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。 3.3.2 集合的隐式创建当向一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。详见文档的插入章节。提示：通常我们使用隐式创建文档即可。3.3.3 集合的删除集合删除语法格式如下：返回值如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。例如：要删除mycollection集合 3.4 文档基本CRUD文档（document）的数据结构和 JSON 基本一样。所有存储在集合中的数据都是 BSON 格式。 3.4.1 文档的插入（ 1 ）单个文档插入使用insert() 或 save() 方法向集合中插入文档，语法如下： 1db.createCollection(name) 1db.createCollection(&quot;mycollection&quot;) 123show collections或show tables 123db.collection.drop()或db.集合.drop() 1db.mycollection.drop() 12Parameter Type Descriptiondocument documentor array 要插入到集合中的文档或文档数组。（(json格式） 1writeConcern document 123Optional. A document expressing the write concern. Omit to use the default write concern.See Write Concern.Do not explicitly set the write concern for the operation if run in atransaction. To use write concern with transactions, see Transactions and Write Concern. 1ordered boolean 123可选。如果为真，则按顺序插入数组中的文档，如果其中一个文档出现错误，MongoDB将返回而不处理数组中的其余文档。如果为假，则执行无序插入，如果其中一个文档出现错误，则继续处理数组中的主文档。在版本2.6+中默认为true 参数：【示例】要向comment的集合(表)中插入一条测试数据： 提示：1 ）comment集合如果不存在，则会隐式创建2 ）mongo中的数字，默认情况下是double类型，如果要存整型，必须使用函数NumberInt(整型数字)，否则取出来就有问题了。3 ）插入当前日期使用new Date()4 ）插入的数据没有指定_id，会自动生成主键值5 ）如果某字段没值，可以赋值为null，或不写该字段。 执行后，如下，说明插入一个数据成功了。 注意：1. 文档中的键/值对是有序的。2. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分类型和大小写。 MongoDB的文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。文档键命名规范：键不能含有\\0 (空字符)。这个字符用来表示键的结尾。.和$有特别的意义，只有在特定环境下才能使用。以下划线”_”开头的键是保留的(不是严格要求的)。 （ 2 ）批量插入语法： 参数：1234567db.collection.insert(&lt;document or array of documents&gt;,&#123;writeConcern: &lt;document&gt;,ordered: &lt;boolean&gt;&#125;) 12db.comment.insert(&#123;&quot;articleid&quot;:&quot; 100000 &quot;,&quot;content&quot;:&quot;今天天气真好，阳光明媚&quot;,&quot;userid&quot;:&quot; 1001 &quot;,&quot;nickname&quot;:&quot;Rose&quot;,&quot;createdatetime&quot;:new Date(),&quot;likenum&quot;:NumberInt( 10 ),&quot;state&quot;:null&#125;) 1WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;) 1234567db.collection.insertMany([ &lt;document 1 &gt; , &lt;document 2 &gt;, ... ],&#123;writeConcern: &lt;document&gt;,ordered: &lt;boolean&gt;&#125;) 12Parameter Type Descriptiondocument document 要插入到集合中的文档或文档数组。（(json格式） 1writeConcern document 1234Optional. A document expressing the write concern. Omit to use the default writeconcern.Do not explicitly set the write concern for the operation if run in a transaction. Touse write concern with transactions, see Transactions and Write Concern.ordered boolean 可选。一个布尔值，指定Mongod实例应执行有序插入还是无序插入。默认为true。 12Parameter Type Descriptionquery document 可选。使用查询运算符指定选择筛选器。若要返回集合中的所有文档，请省略此参数或传递空文档(&#123;&#125;)。 1projection document 可选。指定要在与查询筛选器匹配的文档中返回的字段（投影）。若要返回匹配文档中的所有字段，请省略此参数。 【示例】批量插入多条文章评论：提示：插入时指定了_id，则主键就是该值。如果某条数据插入失败，将会终止插入，但已经插入成功的数据不会回滚掉。因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理，测试的时候可以不处理。如（了解）： 3.4.2 文档的基本查询查询数据的语法格式如下：参数：1234567891011121314db.comment.insertMany([&#123;&quot;_id&quot;:&quot; 1 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot; 1002 &quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 -05 T 22 : 08 : 15. 522 Z&quot;),&quot;likenum&quot;:NumberInt( 1000 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 2 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot; 1005 &quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 05 T 23 : 58 : 51. 485 Z&quot;),&quot;likenum&quot;:NumberInt( 888 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 3 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot; 1004 &quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 06 T 01 : 05 : 06. 321 Z&quot;),&quot;likenum&quot;:NumberInt( 666 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 4 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot; 1003 &quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 06 T 08 : 18 : 35. 288 Z&quot;),&quot;likenum&quot;:NumberInt( 2000 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 5 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫嘴。&quot;,&quot;userid&quot;:&quot; 1003 &quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 -06 T 11 : 01 : 02. 521 Z&quot;),&quot;likenum&quot;:NumberInt( 3000 ),&quot;state&quot;:&quot; 1 &quot;&#125;]); 123456789101112131415161718try &#123;db.comment.insertMany([&#123;&quot;_id&quot;:&quot; 1 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我们不应该把清晨浪费在手机上，健康很重要，一杯温水幸福你我他。&quot;,&quot;userid&quot;:&quot; 1002 &quot;,&quot;nickname&quot;:&quot;相忘于江湖&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 -05 T 22 : 08 : 15. 522 Z&quot;),&quot;likenum&quot;:NumberInt( 1000 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 2 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我夏天空腹喝凉开水，冬天喝温开水&quot;,&quot;userid&quot;:&quot; 1005 &quot;,&quot;nickname&quot;:&quot;伊人憔悴&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 05 T 23 : 58 : 51. 485 Z&quot;),&quot;likenum&quot;:NumberInt( 888 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 3 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;我一直喝凉开水，冬天夏天都喝。&quot;,&quot;userid&quot;:&quot; 1004 &quot;,&quot;nickname&quot;:&quot;杰克船长&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 06 T 01 : 05 : 06. 321 Z&quot;),&quot;likenum&quot;:NumberInt( 666 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 4 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;专家说不能空腹吃饭，影响健康。&quot;,&quot;userid&quot;:&quot; 1003 &quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 - 06 T 08 : 18 : 35. 288 Z&quot;),&quot;likenum&quot;:NumberInt( 2000 ),&quot;state&quot;:&quot; 1 &quot;&#125;,&#123;&quot;_id&quot;:&quot; 5 &quot;,&quot;articleid&quot;:&quot; 100001 &quot;,&quot;content&quot;:&quot;研究表明，刚烧开的水千万不能喝，因为烫嘴。&quot;,&quot;userid&quot;:&quot; 1003 &quot;,&quot;nickname&quot;:&quot;凯撒&quot;,&quot;createdatetime&quot;:new Date(&quot; 2019 - 08 -06 T 11 : 01 : 02. 521 Z&quot;),&quot;likenum&quot;:NumberInt( 3000 ),&quot;state&quot;:&quot; 1 &quot;&#125;]);&#125; catch (e) &#123;print (e);&#125; 1db.collection.find(&lt;query&gt;, [projection]) 【示例】（ 1 ）查询所有如果我们要查询spit集合的所有文档，我们输入以下命令 这里你会发现每条文档会有一个叫_id的字段，这个相当于我们原来关系数据库中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。如果我们在插入文档记录时指定该字段也可以，其类型可以是ObjectID类型，也可以是MongoDB支持的任意类型。 如果我想按一定条件来查询，比如我想查询userid为 1003 的记录，怎么办？很简单！只 要在find()中添加参数即可，参数也是json格式，如下： 如果你只需要返回符合条件的第一条数据，我们可以使用findOne命令来实现，语法和find一样。如：查询用户编号是 1003 的记录，但只最多返回符合条件的第一条记录： （ 2 ）投影查询（Projection Query）：如果要查询结果返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）。如：查询结果只显示_id、userid、nickname: 默认_id会显示。如：查询结果只显示、userid、nickname，不显示_id： 再例如：查询所有数据，但只显示_id、userid、nickname: 3.4.3 文档的更新更新文档的语法：参数：123db.comment.find()或db.comment.find(&#123;&#125;) 1db.comment.find(&#123;userid:&#39; 1003 &#39;&#125;) 1db.comment.findOne(&#123;userid:&#39; 1003 &#39;&#125;) 123&gt;db.comment.find(&#123;userid:&quot; 1003 &quot;&#125;,&#123;userid: 1 ,nickname: 1 &#125;)&#123; &quot;_id&quot; : &quot; 4 &quot;, &quot;userid&quot; : &quot; 1003 &quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;&#123; &quot;_id&quot; : &quot; 5 &quot;, &quot;userid&quot; : &quot; 1003 &quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 123&gt;db.comment.find(&#123;userid:&quot; 1003 &quot;&#125;,&#123;userid: 1 ,nickname: 1 ,_id: 0 &#125;)&#123; &quot;userid&quot; : &quot; 1003 &quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125;&#123; &quot;userid&quot; : &quot; 1003 &quot;, &quot;nickname&quot; : &quot;凯撒&quot; &#125; 1&gt;db.comment.find(&#123;&#125;,&#123;userid: 1 ,nickname: 1 &#125;) 1234567891011121314db.collection.update(query, update, options)&#x2F;&#x2F;或db.collection.update(&lt;query&gt;,&lt;update&gt;,&#123;upsert: &lt;boolean&gt;,multi: &lt;boolean&gt;,writeConcern: &lt;document&gt;,collation: &lt;document&gt;,arrayFilters: [ &lt;filterdocument 1 &gt;, ... ],hint: &lt;document|string&gt; &#x2F;&#x2F; Available starting in MongoDB 4. 2&#125;) 1234Parqueryameter Tdocumentype Description更新的选择条件。可以使用与find（）方法中相同的查询选择器，类似sql update查询内where后面的。。在3.0版中进行了更改：当使用upsert:true执行update（）时，如果查询使用点表示法在_id字段上指定条件，则MongoDB将拒绝插入新文档。update documentorpipeline 要应用的修改。该值可以是：包含更新运算符表达式的文档，或仅包含：对的替换文档，或在MongoDB 4.2中启动聚合管道。管道可以由以下阶段组成： 其别名set 其别名unset 其别名replaceWith。换句话说：它是update的对象和一些更新的操作符（如inc...）等，也可以理解为upsertmulti booleanboolean 可选。如果设置为可选。如果设置为truetrue，则在没有与查询条件匹配的文档时创建新文档。默认值为，则更新符合查询条件的多个文档。如果设置为false，则更新一个文档。默认值为false，如果找不到匹配项，则不会插入新文档。false。writeConcerndocument可选。表示写问题的文档。抛出异常的级别。 1collation document 可选。指定要用于操作的校对规则。 (^)校对规则允许用户为字符串比较指定特定于语言的规则，例如字母大小写和重音标记的规则。校对规则选项具有以下语法：校对规则：区域设置：{， (^)caseLecaseFirst:vel:，，强度：numericor， (^) dering:，替代：最大变量：， (^) ，向后：}指定校对规则时，区域设置字段是必需的；所有其他校对规则字段都是可选的。有关字段的说明，请参阅校对规则文档。如果未指定校对规则，但集合具有默认校对规则（请参见db.createCollection（）），则该操作将使用为集合指定的校对规则。 (^)如果没有为集合或操作指定校对规则，3.4版新增。 MongoDB将使用以前版本中使用的简单二进制比较进行字符串比较。不能为一个操作指定多个校对规则。例如，不能为每个字段指定不同的校对规则，或者如果使用排序执行查找，则不能将一个校对规则用于查找，另一个校对规则用于排序。arrayFiltersarray 可选。一个筛选文档数组，用于确定要为数组字段上的更新操作修改哪些数组元素。在更新文档中，使用[标识符（]）都必须指定一个对应的数组筛选器文档。也就是说，不能为同一标识符指定多个数组筛选器文档。[3.6版+ 筛选的运算符来义标识符，然后在组过滤档中用。如果标识符未在更档中，则不有标识符的组筛选档。注， 必须小开头，并且只hint Documentor string 可选。指定用于支持查询谓词的索引的文档或字符串。该选项可以采用索引规范文档或索引名称字符串。如果指定的索引不存在，则说明操作错误。例如，请参阅版本 4 中的“为更新操作指定提示。提示：主要关注前四个参数即可。【示例】（ 1 ）覆盖的修改如果我们想修改_id为 1 的记录，点赞量为 1001 ，输入以下语句：执行后，我们会发现，这条文档除了likenum字段其它字段都不见了，（ 2 ）局部修改为了解决这个问题，我们需要使用修改器$set来实现，命令如下：我们想修改_id为 2 的记录，浏览量为 889 ，输入以下语句： 这样就OK啦。（ 3 ）批量的修改更新所有用户为 1003 的用户的昵称为凯撒大帝。提示：如果不加后面的参数，则只更新符合条件的第一条记录（ 3 ）列值增长的修改如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现。需求：对 3 号数据的点赞数，每次递增 1 3.4.4 删除文档删除文档的语法结构：以下语句可以将数据全部删除，请慎用如果删除_id=1的记录，输入以下语句 3.5 文档的分页查询3.5.1 统计查询1db.comment.update(&#123;_id:&quot; 1 &quot;&#125;,&#123;likenum:NumberInt( 1001 )&#125;) 1db.comment.update(&#123;_id:&quot; 2 &quot;&#125;,&#123;$set:&#123;likenum:NumberInt( 889 )&#125;&#125;) //默认只修改第一条数据123db.comment.update(&#123;userid:&quot; 1003 &quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒 2 &quot;&#125;&#125;)&#x2F;&#x2F;修改所有符合条件的数据db.comment.update(&#123;userid:&quot; 1003 &quot;&#125;,&#123;$set:&#123;nickname:&quot;凯撒大帝&quot;&#125;&#125;,&#123;multi:true&#125;) 1db.comment.update(&#123;_id:&quot; 3 &quot;&#125;,&#123;$inc:&#123;likenum:NumberInt( 1 )&#125;&#125;) 1db.集合名称.remove(条件) 1db.comment.remove(&#123;&#125;) 1db.comment.remove(&#123;_id:&quot; 1 &quot;&#125;) 123Parameter Type Descriptionquery document 查询选择条件。options document 可选。用于修改计数的额外选项。 统计查询使用count()方法，语法如下： 参数：提示：可选项暂时不使用。【示例】（ 1 ）统计所有记录数：统计comment集合的所有的记录数： （ 2 ）按条件统计记录数：例如：统计userid为 1003 的记录条数 提示：默认情况下count()方法返回符合条件的全部记录条数。 3.5.2 分页列表查询可以使用limit()方法来读取指定数量的数据，使用skip()方法来跳过指定数量的数据。基本语法如下所示： 如果你想返回指定条数的记录，可以在find方法后调用limit来返回结果(TopN)，默认值 20 ，例如： skip方法同样接受一个数字参数作为跳过的记录条数。（前N个不要）,默认值是 0 分页查询：需求：每页 2 个，第二页开始：跳过前两条数据，接着值显示 3 和 4 条数据3.5.3 排序查询sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。语法如下所示： 例如：对userid降序排列，并对访问量进行升序排列 1db.collection.count(query, options) 1db.comment.count() 1db.comment.count(&#123;userid:&quot; 1003 &quot;&#125;) 1&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 1db.comment.find().limit( 3 ) 1db.comment.find().skip( 3 ) //第一页12345db.comment.find().skip( 0 ).limit( 2 )&#x2F;&#x2F;第二页db.comment.find().skip( 2 ).limit( 2 )&#x2F;&#x2F;第三页db.comment.find().skip( 4 ).limit( 2 ) 123db.COLLECTION_NAME.find().sort(&#123;KEY: 1 &#125;)或db.集合名称.find().sort(排序方式) 提示：skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()，和命令编写顺序无关。 3.6 文档的更多查询3.6.1 正则的复杂条件查询MongoDB的模糊查询是通过正则表达式的方式实现的。格式为： 提示：正则表达式是js的语法，直接量的写法。例如，我要查询评论内容包含“开水”的所有文档，代码如下： 如果要查询评论的内容中以“专家”开头的，代码如下：3.6.2 比较查询&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下:示例：查询评论点赞数量大于 700 的记录3.6.3 包含查询包含使用$in操作符。 示例：查询评论的集合中userid字段包含 1003 或 1004 的文档 不包含使用$nin操作符。 示例：查询评论集合中userid字段不包含 1003 和 1004 的文档 3.6.4 条件连接查询我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相 当于SQL的and） 格式为： 示例：查询评论集合中likenum大于等于 700 并且小于 2000 的文档： 如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面 and的使用方式相同 格式为： 示例：查询评论集合中userid为 1003 ，或者点赞数小于 1000 的文档记录 1db.comment.find().sort(&#123;userid:- 1 ,likenum: 1 &#125;) 123db.collection.find(&#123;field:&#x2F;正则表达式&#x2F;&#125;)或db.集合.find(&#123;字段:&#x2F;正则表达式&#x2F;&#125;) 1db.comment.find(&#123;content:&#x2F;开水&#x2F;&#125;) 1db.comment.find(&#123;content:&#x2F;^专家&#x2F;&#125;) 12345db.集合名称.find(&#123; &quot;field&quot; : &#123; $gt: value &#125;&#125;) &#x2F;&#x2F; 大于: field &gt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lt: value &#125;&#125;) &#x2F;&#x2F; 小于: field &lt; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $gte: value &#125;&#125;) &#x2F;&#x2F; 大于等于: field &gt;&#x3D; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $lte: value &#125;&#125;) &#x2F;&#x2F; 小于等于: field &lt;&#x3D; valuedb.集合名称.find(&#123; &quot;field&quot; : &#123; $ne: value &#125;&#125;) &#x2F;&#x2F; 不等于: field !&#x3D; value 1db.comment.find(&#123;likenum:&#123;$gt:NumberInt( 700 )&#125;&#125;) 1db.comment.find(&#123;userid:&#123;$in:[&quot; 1003 &quot;,&quot; 1004 &quot;]&#125;&#125;) 1db.comment.find(&#123;userid:&#123;$nin:[&quot; 1003 &quot;,&quot; 1004 &quot;]&#125;&#125;) 1$and:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 1db.comment.find(&#123;$and:[&#123;likenum:&#123;$gte:NumberInt( 700 )&#125;&#125;,&#123;likenum:&#123;$lt:NumberInt( 2000 )&#125;&#125;]&#125;) 1$or:[ &#123; &#125;,&#123; &#125;,&#123; &#125; ] 1db.comment.find(&#123;$or:[ &#123;userid:&quot; 1003 &quot;&#125; ,&#123;likenum:&#123;$lt: 1000 &#125; &#125;]&#125;) 3.7 常用命令小结4 索引-Index4.1 概述索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档，以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或一组字段的值，按字段值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB还可以使用索引中的排序返回排序结果。官网文档：https://docs.mongodb.com/manual/indexes/了解：MongoDB索引使用B树数据结构（确切的说是B-Tree，MySQL是B+Tree） 4.2 索引的类型4.2.1 单字段索引MongoDB支持在文档的单个字段上创建用户定义的升序/降序索引，称为单字段索引（Single Field Index）。对于单个字段索引和排序操作，索引键的排序顺序（即升序或降序）并不重要，因为MongoDB可以在任何方向上遍历索引。 4.2.2 复合索引MongoDB还支持多个字段的用户定义索引，即复合索引（Compound Index）。复合索引中列出的字段顺序具有重要意义。例如，如果复合索引由{ userid: 1 , score: - 1 }组成，则索引首先按userid正序排序，然后在每个userid的值内，再在按score倒序排序。 123456789101112131415选择切换数据库：use articledb插入数据：db.comment.insert(&#123;bson数据&#125;)查询所有数据：db.comment.find();条件查询数据：db.comment.find(&#123;条件&#125;)查询符合条件的第一条记录：db.comment.findOne(&#123;条件&#125;)查询符合条件的前几条记录：db.comment.find(&#123;条件&#125;).limit(条数)查询符合条件的跳过的记录：db.comment.find(&#123;条件&#125;).skip(条数)修改数据：db.comment.update(&#123;条件&#125;,&#123;修改后的数据&#125;) 或db.comment.update(&#123;条件&#125;,&#123;$set:&#123;要修改部分的字段:数据&#125;)修改数据并自增某字段值：db.comment.update(&#123;条件&#125;,&#123;$inc:&#123;自增的字段:步进值&#125;&#125;)删除数据：db.comment.remove(&#123;条件&#125;)统计查询：db.comment.count(&#123;条件&#125;)模糊查询：db.comment.find(&#123;字段名:&#x2F;正则表达式&#x2F;&#125;)条件比较运算：db.comment.find(&#123;字段名:&#123;$gt:值&#125;&#125;)包含查询：db.comment.find(&#123;字段名:&#123;$in:[值 1 ，值 2 ]&#125;&#125;)或db.comment.find(&#123;字段名:&#123;$nin:[值 1 ，值 2 ]&#125;&#125;)条件连接查询：db.comment.find(&#123;$and:[&#123;条件 1 &#125;,&#123;条件 2 &#125;]&#125;)或db.comment.find(&#123;$or:[&#123;条件 1 &#125;,&#123;条件 2 &#125;]&#125;) 4.2.3 其他索引地理空间索引（Geospatial Index）、文本索引（Text Indexes）、哈希索引（Hashed Indexes）。 地理空间索引（Geospatial Index）为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引。文本索引（Text Indexes）MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”），而将集合中的词作为词干，只存储根词。哈希索引（Hashed Indexes）为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支持相等匹配，不支持基于范围的查询。 4.3 索引的管理操作4.3.1 索引的查看说明：返回一个集合中的所有索引的数组。语法：提示：该语法命令运行要求是MongoDB 3.0+【示例】查看comment集合中所有的索引情况 结果中显示的是默认_id索引。默认_id索引：MongoDB在创建集合的过程中，在_id字段上创建一个唯一的索引，默认名字为_id_，该索引可防止客户端插入两个具有相同值的文档，您不能在_id字段上删除此索引。注意：该索引是唯一索引，因此值不能重复，即_id值不能重复的。在分片集群中，通常使用_id作为片键。 4.3.2 索引的创建说明：在集合上创建索引。语法：1db.collection.getIndexes() 1234567891011&gt; db.comment.getIndexes()[&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;_id&quot; : 1&#125;,&quot;name&quot; : &quot;_id_&quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;] 1db.collection.createIndex(keys, options) 1Parameter Type Description 1keys document 包含字段和值对的文档，其中字段是索引键，值描述该字段的索引类型。对于字段上的升序索引，请指定值 1 ；对于降序索引，请指定值-1。比如：{字段: 1 或- 1 }，其中 1 为指定按升序创建索引，如果你123想按降序来创建索引指定为 -1 即可。另外，MongoDB支持几种不同的索引类型，包括文本、地理空间和哈希索引。options document 可选。包含一组控制索引创建的选项的文档。有关详细信息，请参见选项详情列表。 1234Parameter Type Descriptionbackground Boolean 建索引过程会阻塞其它数据库操作，&quot;background&quot; 可选参数。 &quot;background&quot; backgr默认值为ound可指定以后台方式创建索引，即增加false。unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false.name string 索引的名称。如果未指定，称。 MongoDB的通过连接索引的字段名和排序顺序生成一个索引名 1dropDups Boolean 3.0+false版本已废弃。. 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 123456sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为引字段中不会查询出不包含对应字段的文档.。默认值为 false. true的话，在索expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。v indeversionx 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language. language，默认值为 参数：options（更多选项）列表： 提示：注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex()还能用，但只是 createIndex()的别名。 【示例】（ 1 ）单字段索引示例：对userid字段建立索引： 参数 1 ：按升序创建索引可以查看一下：1234567&gt; db.comment.createIndex(&#123;userid: 1 &#125;)&#123;&quot;createdCollectionAutomatically&quot; : false,&quot;numIndexesBefore&quot; : 1 ,&quot;numIndexesAfter&quot; : 2 ,&quot;ok&quot; : 1&#125; 12345678910111213141516171819&gt; db.comment.getIndexes()[&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;_id&quot; : 1&#125;,&quot;name&quot; : &quot;_id_&quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;,&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;userid&quot; : 1&#125;,&quot;name&quot; : &quot;userid_ 1 &quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;] 12Parameter Type Descriptionindex string ordocument 指定要删除的索引。可以通过索引名称或索引规范文档指定索引。若要删除文本索引，请指定索引名称。 索引名字为`userid_compass查看： `（ 2 ）复合索引：对userid和nickname同时建立复合（Compound）索引： 查看一下索引：compass中： 4.3.3 索引的移除说明：可以移除指定的索引，或移除所有索引一、指定索引的移除语法：参数：【示例】删除comment集合中userid字段上的升序索引： 1234567&gt; db.comment.createIndex(&#123;userid: 1 ,nickname:- 1 &#125;)&#123;&quot;createdCollectionAutomatically&quot; : false,&quot;numIndexesBefore&quot; : 2 ,&quot;numIndexesAfter&quot; : 3 ,&quot;ok&quot; : 1&#125; 12345678910111213141516171819202122232425262728&gt; db.comment.getIndexes()[&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;_id&quot; : 1&#125;,&quot;name&quot; : &quot;_id_&quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;,&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;userid&quot; : 1&#125;,&quot;name&quot; : &quot;userid_ 1 &quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;,&#123;&quot;v&quot; : 2 ,&quot;key&quot; : &#123;&quot;userid&quot; : 1 ,&quot;nickname&quot; : - 1&#125;,&quot;name&quot; : &quot;userid_ 1 _nickname_- 1 &quot;,&quot;ns&quot; : &quot;articledb.comment&quot;&#125;] 1db.collection.dropIndex(index) 12&gt; db.comment.dropIndex(&#123;userid: 1 &#125;)&#123; &quot;nIndexesWas&quot; : 3 , &quot;ok&quot; : 1 &#125; 查看已经删除了。二、所有索引的移除语法：【示例】删除spit集合中所有索引。 提示：_id的字段的索引是无法删除的，只能删除非_id字段的索引。 4.4 索引的使用^4.4.1 执行计划分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如查询耗费的时间、是否基于索引查询等。那么，通常，我们想知道，建立的索引是否有效，效果如何，都需要通过执行计划查看。语法： 【示例】查看根据userid查询数据的情况： 关键点看：”stage” : “COLLSCAN”,表示全集合扫描 1db.collection.dropIndexes() 123456&gt; db.comment.dropIndexes()&#123;&quot;nIndexesWas&quot; : 2 ,&quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,&quot;ok&quot; : 1&#125; 1db.collection.find(query,options).explain(options) 123456789101112131415161718192021222324252627282930&gt; db.comment.find(&#123;userid:&quot; 1003 &quot;&#125;).explain()&#123;&quot;queryPlanner&quot; : &#123;&quot;plannerVersion&quot; : 1 ,&quot;namespace&quot; : &quot;articledb.comment&quot;,&quot;indexFilterSet&quot; : false,&quot;parsedQuery&quot; : &#123;&quot;userid&quot; : &#123;&quot;$eq&quot; : &quot; 1003 &quot;&#125;&#125;,&quot;winningPlan&quot; : &#123;&quot;stage&quot; : &quot;COLLSCAN&quot;,&quot;filter&quot; : &#123;&quot;userid&quot; : &#123;&quot;$eq&quot; : &quot; 1003 &quot;&#125;&#125;,&quot;direction&quot; : &quot;forward&quot;&#125;,&quot;rejectedPlans&quot; : [ ]&#125;,&quot;serverInfo&quot; : &#123;&quot;host&quot; : &quot; 9 ef 3740277 ad&quot;,&quot;port&quot; : 27017 ,&quot;version&quot; : &quot; 4. 0. 10 &quot;,&quot;gitVersion&quot; : &quot;c 389 e 7 f 69 f 637 f 7 a 1 ac 3 cc 9 fae 843 b 635 f 20 b 766 &quot;&#125;,&quot;ok&quot; : 1&#125; 下面对userid建立索引 再次查看执行计划：关键点看：”stage” : “IXSCAN”,基于索引的扫描compass查看： 1234567&gt; db.comment.createIndex(&#123;userid: 1 &#125;)&#123;&quot;createdCollectionAutomatically&quot; : false,&quot;numIndexesBefore&quot; : 1 ,&quot;numIndexesAfter&quot; : 2 ,&quot;ok&quot; : 1&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt; db.comment.find(&#123;userid:&quot; 1013 &quot;&#125;).explain()&#123;&quot;queryPlanner&quot; : &#123;&quot;plannerVersion&quot; : 1 ,&quot;namespace&quot; : &quot;articledb.comment&quot;,&quot;indexFilterSet&quot; : false,&quot;parsedQuery&quot; : &#123;&quot;userid&quot; : &#123;&quot;$eq&quot; : &quot; 1013 &quot;&#125;&#125;,&quot;winningPlan&quot; : &#123;&quot;stage&quot; : &quot;FETCH&quot;,&quot;inputStage&quot; : &#123;&quot;stage&quot; : &quot;IXSCAN&quot;,&quot;keyPattern&quot; : &#123;&quot;userid&quot; : 1&#125;,&quot;indexName&quot; : &quot;userid_ 1 &quot;,&quot;isMultiKey&quot; : false,&quot;multiKeyPaths&quot; : &#123;&quot;userid&quot; : [ ]&#125;,&quot;isUnique&quot; : false,&quot;isSparse&quot; : false,&quot;isPartial&quot; : false,&quot;indexVersion&quot; : 2 ,&quot;direction&quot; : &quot;forward&quot;,&quot;indexBounds&quot; : &#123;&quot;userid&quot; : [&quot;[\\&quot; 1013 \\&quot;, \\&quot; 1013 \\&quot;]&quot;]&#125;&#125;&#125;,&quot;rejectedPlans&quot; : [ ]&#125;,&quot;serverInfo&quot; : &#123;&quot;host&quot; : &quot; 9 ef 3740277 ad&quot;,&quot;port&quot; : 27017 ,&quot;version&quot; : &quot; 4. 0. 10 &quot;,&quot;gitVersion&quot; : &quot;c 389 e 7 f 69 f 637 f 7 a 1 ac 3 cc 9 fae 843 b 635 f 20 b 766 &quot;&#125;,&quot;ok&quot; : 1&#125; 4.4.2 涵盖的查询Covered Queries当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效。 更多：https://docs.mongodb.com/manual/core/query-optimization/#read-operations-covered-query【示例】 1234567891011121314151617181920212223&gt; db.comment.find(&#123;userid:&quot; 1003 &quot;&#125;,&#123;userid: 1 ,_id: 0 &#125;)&#123; &quot;userid&quot; : &quot; 1003 &quot; &#125;&#123; &quot;userid&quot; : &quot; 1003 &quot; &#125;&gt; db.comment.find(&#123;userid:&quot; 1003 &quot;&#125;,&#123;userid: 1 ,_id: 0 &#125;).explain()&#123;&quot;queryPlanner&quot; : &#123;&quot;plannerVersion&quot; : 1 ,&quot;namespace&quot; : &quot;articledb.comment&quot;,&quot;indexFilterSet&quot; : false,&quot;parsedQuery&quot; : &#123;&quot;userid&quot; : &#123;&quot;$eq&quot; : &quot; 1003 &quot;&#125;&#125;,&quot;winningPlan&quot; : &#123;&quot;stage&quot; : &quot;PROJECTION&quot;,&quot;transformBy&quot; : &#123;&quot;userid&quot; : 1 ,&quot;_id&quot; : 0&#125;,&quot;inputStage&quot; : &#123;&quot;stage&quot; : &quot;IXSCAN&quot;,&quot;keyPattern&quot; : &#123; Compass中： 5 文章评论5.1 需求分析某头条的文章评论业务如下：1234567891011121314151617181920212223242526272829&quot;userid&quot; : 1&#125;,&quot;indexName&quot; : &quot;userid_ 1 &quot;,&quot;isMultiKey&quot; : false,&quot;multiKeyPaths&quot; : &#123;&quot;userid&quot; : [ ]&#125;,&quot;isUnique&quot; : false,&quot;isSparse&quot; : false,&quot;isPartial&quot; : false,&quot;indexVersion&quot; : 2 ,&quot;direction&quot; : &quot;forward&quot;,&quot;indexBounds&quot; : &#123;&quot;userid&quot; : [&quot;[\\&quot; 1003 \\&quot;, \\&quot; 1003 \\&quot;]&quot;]&#125;&#125;&#125;,&quot;rejectedPlans&quot; : [ ]&#125;,&quot;serverInfo&quot; : &#123;&quot;host&quot; : &quot;bobohost.localdomain&quot;,&quot;port&quot; : 27017 ,&quot;version&quot; : &quot; 4. 0. 10 &quot;,&quot;gitVersion&quot; : &quot;c 389 e 7 f 69 f 637 f 7 a 1 ac 3 cc 9 fae 843 b 635 f 20 b 766 &quot;&#125;,&quot;ok&quot; : 1&#125; 123456789101112专栏文章评论 comment字段名称 字段含义 字段类型 备注_id ID ObjectId或String Mongo的主键的字段articleid 文章ID Stringcontent 评论内容 Stringuserid 评论人ID Stringnickname 评论人昵称 Stringcreatedatetime 评论的日期时间 Datelikenum 点赞数 Int32replynum 回复数 Int32state 状态 String 0 ：不可见； 1 ：可见；parentid 上级ID String 如果为 0 表示文章的顶级评论 文章示例参考：早晨空腹喝水，是对还是错？https://www.toutiao.com/a6721476546088927748/需要实现以下功能：1 ）基本增删改查API2 ）根据文章id查询评论3 ）评论点赞 5.2 表结构分析数据库：articledb 5.3 技术选型5.3.1 mongodb-driver（了解）mongodb-driver是mongo官方推出的java连接mongoDB的驱动包，相当于JDBC驱动。我们通过一个入门的案例来了解mongodb-driver的基本使用。官方驱动说明和下载：http://mongodb.github.io/mongo-java-driver/官方驱动示例文档：http://mongodb.github.io/mongo-java-driver/3.8/driver/getting-started/quick-start/ 5.3.2 SpringDataMongoDBSpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。官网主页： https://projects.spring.io/spring-data-mongodb/我们十次方项目的吐槽微服务就采用SpringDataMongoDB框架。 5.4 文章微服务模块搭建（ 1 ）搭建项目工程article，pom.xml引入依赖： 123456789101112131415&lt;?xml version&#x3D;&quot; 1. 0 &quot; encoding&#x3D;&quot;UTF- 8 &quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F; 4. 0. 0 &quot;xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w 3 .org&#x2F; 2001 &#x2F;XMLSchema-instance&quot;xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F; 4. 0. 0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven- 4. 0. 0 .xsd&quot;&gt;&lt;modelVersion&gt; 4. 0. 0 &lt;&#x2F;modelVersion&gt;&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;&lt;version&gt; 2. 1. 6 .RELEASE&lt;&#x2F;version&gt;&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository - -&gt;&lt;&#x2F;parent&gt;&lt;groupId&gt;cn.itcast&lt;&#x2F;groupId&gt;&lt;artifactId&gt;article&lt;&#x2F;artifactId&gt;&lt;version&gt; 1. 0 - SNAPSHOT&lt;&#x2F;version&gt;&lt;dependencies&gt; （ 2 ）创建application.yml （ 3 ）创建启动类cn.itcast.article.ArticleApplication （ 4 ）启动项目，看是否能正常启动，控制台没有错误。5.5 文章评论实体类的编写创建实体类 创建包cn.itcast.article，包下建包po用于存放实体类，创建实体类cn.itcast.article.po.Comment 1234567891011&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; 123456789101112spring:#数据源配置data:mongodb:# 主机地址host: 192. 168. 40. 141# 数据库database: articledb# 默认端口是 27017port: 27017#也可以使用uri连接#uri: mongodb:&#x2F;&#x2F; 192. 168. 40. 134 : 27017 &#x2F;articledb 123456789package cn.itcast.article;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ArticleApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(ArticleApplication.class, args);&#125;&#125; 123456789101112131415161718192021222324package cn.itcast.article.po;import org.springframework.data.annotation.Id;import org.springframework.data.mongodb.core.index.Indexed;import org.springframework.data.mongodb.core.mapping.Document;import org.springframework.data.mongodb.core.mapping.Field;import java.io.Serializable;import java.time.LocalDateTime;import java.util.Date;&#x2F;*** 文章评论实体类*&#x2F;&#x2F;&#x2F;把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。&#x2F;&#x2F;@Document(collection&#x3D;&quot;mongodb 对应 collection 名&quot;)&#x2F;&#x2F; 若未加 @Document ，该 bean save 到 mongo 的 comment collection&#x2F;&#x2F; 若添加 @Document ，则 save 到 comment collection@Document(collection&#x3D;&quot;comment&quot;)&#x2F;&#x2F;可以省略，如果省略，则默认使用类名小写映射集合&#x2F;&#x2F;复合索引&#x2F;&#x2F; @CompoundIndex( def &#x3D; &quot;&#123;&#39;userid&#39;: 1 , &#39;nickname&#39;: - 1 &#125;&quot;)public class Comment implements Serializable &#123;&#x2F;&#x2F;主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写@Idprivate String id;&#x2F;&#x2F;主键&#x2F;&#x2F;该属性对应mongodb的字段的名字，如果一致，则无需该注解@Field(&quot;content&quot;) private String content;//吐槽内容private Date publishtime;//发布日期//添加了一个单字段的索引@Indexedprivate String userid;//发布人IDprivate String nickname;//昵称private LocalDateTime createdatetime;//评论的日期时间private Integer likenum;//点赞数private Integer replynum;//回复数private String state;//状态private String parentid;//上级IDprivate String articleid;//getter and setter….. public String getId() {return id;} public void setId(String id) {this.id = id;} public String getContent() {return content;} public void setContent(String content) {this.content = content;} public Date getPublishtime() {return publishtime;} public void setPublishtime(Date publishtime) {this.publishtime = publishtime;} public String getUserid() {return userid;} public void setUserid(String userid) {this.userid = userid;} public String getNickname() {return nickname;} public void setNickname(String nickname) {this.nickname = nickname;} public LocalDateTime getCreatedatetime() {return createdatetime;} public void setCreatedatetime(LocalDateTime createdatetime) {this.createdatetime = createdatetime;} public Integer getLikenum() {return likenum;} public void setLikenum(Integer likenum) {this.likenum = likenum;} public Integer getReplynum() {return replynum;} public void setReplynum(Integer replynum) {this.replynum = replynum;} public String getState() {return state;} public void setState(String state) {this.state = state;} public String getParentid() { 说明：索引可以大大提升查询效率，一般在查询字段上添加索引，索引的添加可以通过Mongo的命令来添加，也可以在Java的实体类中通过注解添加。 1 ）单字段索引注解@Indexedorg.springframework.data.mongodb.core.index.Indexed.class声明该字段需要索引，建索引可以大大的提高查询效率。Mongo命令参考： 2 ）复合索引注解@CompoundIndexorg.springframework.data.mongodb.core.index.CompoundIndex.class复合索引的声明，建复合索引可以有效地提高多字段的查询效率。Mongo命令参考： 5.6 文章评论的基本增删改查（ 1 ）创建数据访问接口 cn.itcast.article包下创建dao包，包下创建接口cn.itcast.article.dao.CommentRepository （ 2 ）创建业务逻辑类 cn.itcast.article包下创建service包，包下创建类cn.itcast.article.service.CommentService 12345678910111213141516171819202122232425262728return parentid;&#125;public void setParentid(String parentid) &#123;this.parentid &#x3D; parentid;&#125;public String getArticleid() &#123;return articleid;&#125;public void setArticleid(String articleid) &#123;this.articleid &#x3D; articleid;&#125;@Overridepublic String toString() &#123;return &quot;Comment&#123;&quot; +&quot;id&#x3D;&#39;&quot; + id + &#39;\\&#39;&#39; +&quot;, content&#x3D;&#39;&quot; + content + &#39;\\&#39;&#39; +&quot;, publishtime&#x3D;&quot; + publishtime +&quot;, userid&#x3D;&#39;&quot; + userid + &#39;\\&#39;&#39; +&quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\\&#39;&#39; +&quot;, createdatetime&#x3D;&quot; + createdatetime +&quot;, likenum&#x3D;&quot; + likenum +&quot;, replynum&#x3D;&quot; + replynum +&quot;, state&#x3D;&#39;&quot; + state + &#39;\\&#39;&#39; +&quot;, parentid&#x3D;&#39;&quot; + parentid + &#39;\\&#39;&#39; +&quot;, articleid&#x3D;&#39;&quot; + articleid + &#39;\\&#39;&#39; +&#39;&#125;&#39;;&#125;&#125; 1db.comment.createIndex(&#123;&quot;userid&quot;: 1 &#125;) 1db.comment.createIndex(&#123;&quot;userid&quot;: 1 ,&quot;nickname&quot;:- 1 &#125;) 12345678package cn.itcast.article.dao;import cn.itcast.article.po.Comment;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.mongodb.repository.MongoRepository;&#x2F;&#x2F;评论的持久层接口public interface CommentRepository extends MongoRepository&lt;Comment,String&gt; &#123;&#125; 12package cn.itcast.article.service;import cn.itcast.article.dao.CommentRepository; （ 3 ）新建Junit测试类，测试保存和查询所有：cn.itcast.article.service.CommentServiceTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import cn.itcast.article.po.Comment;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;&#x2F;&#x2F;评论的业务层@Servicepublic class CommentService &#123;&#x2F;&#x2F;注入dao@Autowiredprivate CommentRepository commentRepository;&#x2F;*** 保存一个评论* @param comment*&#x2F;public void saveComment(Comment comment)&#123;&#x2F;&#x2F;如果需要自定义主键，可以在这里指定主键；如果不指定主键，MongoDB会自动生成主键&#x2F;&#x2F;设置一些默认初始值。。。&#x2F;&#x2F;调用daocommentRepository.save(comment);&#125;&#x2F;*** 更新评论* @param comment*&#x2F;public void updateComment(Comment comment)&#123;&#x2F;&#x2F;调用daocommentRepository.save(comment);&#125;&#x2F;*** 根据id删除评论* @param id*&#x2F;public void deleteCommentById(String id)&#123;&#x2F;&#x2F;调用daocommentRepository.deleteById(id);&#125;&#x2F;*** 查询所有评论* @return*&#x2F;public List&lt;Comment&gt; findCommentList()&#123;&#x2F;&#x2F;调用daoreturn commentRepository.findAll();&#125;&#x2F;*** 根据id查询评论* @param id* @return*&#x2F;public Comment findCommentById(String id)&#123;&#x2F;&#x2F;调用daoreturn commentRepository.findById(id).get();&#125; }123456789101112package cn.itcast.article.service;import cn.itcast.article.ArticleApplication;import cn.itcast.article.po.Comment;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.test.context.junit 4 .SpringRunner;import java.time.LocalDateTime;import java.util.List;&#x2F;&#x2F;测试评论的业务层 添加结果：5.7 根据上级ID查询文章评论的分页列表（ 1 ）CommentRepository新增方法定义 （ 2 ）CommentService新增方法 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;SpringBoot的Junit集成测试@RunWith(SpringRunner.class)&#x2F;&#x2F;SpringBoot的测试环境初始化，参数：启动类@SpringBootTest(classes &#x3D; ArticleApplication.class)public class CommentServiceTest &#123;&#x2F;&#x2F;注入Service@Autowiredprivate CommentService commentService;&#x2F;*** 保存一个评论*&#x2F;@Testpublic void testSaveComment()&#123;Comment comment&#x3D;new Comment();comment.setArticleid(&quot; 100000 &quot;);comment.setContent(&quot;测试添加的数据&quot;);comment.setCreatedatetime(LocalDateTime.now());comment.setUserid(&quot; 1003 &quot;);comment.setNickname(&quot;凯撒大帝&quot;);comment.setState(&quot; 1 &quot;);comment.setLikenum( 0 );comment.setReplynum( 0 );commentService.saveComment(comment);&#125;&#x2F;*** 查询所有数据*&#x2F;@Testpublic void testFindAll()&#123;List&lt;Comment&gt; list &#x3D; commentService.findCommentList();System.out.println(list);&#125;&#x2F;*** 测试根据id查询*&#x2F;@Testpublic void testFindCommentById()&#123;Comment comment &#x3D; commentService.findCommentById(&quot; 5 d 6 a 27 b 81 b 8 d 374798 cf 0 b 41 &quot;);System.out.println(comment);&#125; 1&#125; 12&#x2F;&#x2F;根据父id，查询子评论的分页列表Page&lt;Comment&gt; findByParentid(String parentid, Pageable pageable); （ 3 ）junit测试用例：cn.itcast.article.service.CommentServiceTest （ 4 ）测试使用compass快速插入一条测试数据，数据的内容是对 3 号评论内容进行评论。 执行测试，结果：5.8 MongoTemplate实现评论点赞我们看一下以下点赞的临时示例代码： CommentService 新增updateThumbup方法 以上方法虽然实现起来比较简单，但是执行效率并不高，因为我只需要将点赞数加 1 就可以了，没必要查询出所有字段修改后再更新所有字段。(蝴蝶效应)我们可以使用MongoTemplate类来实现对某列的操作。 （ 1 ）修改CommentService /**123456789* 根据父id查询分页列表* @param parentid* @param page* @param size* @return*&#x2F;public Page&lt;Comment&gt; findCommentListPageByParentid(String parentid,int page ,int size)&#123;return commentRepository.findByParentid(parentid, PageRequest.of(page- 1 ,size));&#125; /**12345678* 测试根据父id查询子评论的分页列表*&#x2F;@Testpublic void testFindCommentListPageByParentid()&#123;Page&lt;Comment&gt; pageResponse &#x3D; commentService.findCommentListPageByParentid(&quot; 3 &quot;, 1 , 2 );System.out.println(&quot;----总记录数：&quot;+pageResponse.getTotalElements());System.out.println(&quot;----当前页数据：&quot;+pageResponse.getContent());&#125; - —总记录数： 1 —当前页数据：[Comment{id=’ 33 ‘, content=’你年轻，火力大’, publishtime=null, userid=’ 1003 ‘, nickname=’凯撒大帝’,createdatetime=null, likenum=null, replynum=null, state=’null’, parentid=’ 3 ‘, articleid=’ 100001 ‘}] /*** 点赞-效率低1234567* @param id*&#x2F;public void updateCommentThumbupToIncrementingOld(String id)&#123;Comment comment &#x3D; CommentRepository.findById(id).get();comment.setLikenum(comment.getLikenum()+ 1 );CommentRepository.save(comment);&#125; 123&#x2F;&#x2F;注入MongoTemplate@Autowiredprivate MongoTemplate mongoTemplate; （ 2 ）测试用例：cn.itcast.article.service.CommentServiceTest 执行测试用例后，发现点赞数+1了：/*** 点赞数+ 11234567891011121314151617* @param id*&#x2F;public void updateCommentLikenum(String id)&#123;&#x2F;&#x2F;查询对象Query query&#x3D;Query.query(Criteria.where(&quot;_id&quot;).is(id));&#x2F;&#x2F;更新对象Update update&#x3D;new Update();&#x2F;&#x2F;局部更新，相当于$set&#x2F;&#x2F; update.set(key,value)&#x2F;&#x2F;递增$inc&#x2F;&#x2F; update.inc(&quot;likenum&quot;, 1 );update.inc(&quot;likenum&quot;);&#x2F;&#x2F;参数 1 ：查询对象&#x2F;&#x2F;参数 2 ：更新对象&#x2F;&#x2F;参数 3 ：集合的名字或实体类的类型Comment.classmongoTemplate.updateFirst(query,update,&quot;comment&quot;);&#125; /*** 点赞数+ 1*/12345@Testpublic void testUpdateCommentLikenum()&#123;&#x2F;&#x2F;对 3 号文档的点赞数+ 1commentService.updateCommentLikenum(&quot; 3 &quot;);&#125;","categories":[{"name":"NoSql","slug":"NoSql","permalink":"http://nlbyd1119.online/categories/NoSql/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"docker","slug":"docker","date":"2020-06-23T10:46:53.000Z","updated":"2020-06-23T13:20:49.290Z","comments":true,"path":"2020/06/23/docker/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/docker/","excerpt":"该篇记述一下docker的安装，基本命令与tomcat、mysql的配置。","text":"该篇记述一下docker的安装，基本命令与tomcat、mysql的配置。 一、docker安装参考 https://blog.csdn.net/b9567/article/details/105027440/ 1234567891011121314151617181920212223# 安装需要的包sudo apt-get update# 安装 apt 依赖包，用于通过HTTPS来获取仓库sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common # 添加 Docker 的官方 GPG 密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 设置稳定版仓库sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\"# 安装 Docker-cesudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io 修改docker镜像参考 https://blog.csdn.net/jixuju/article/details/80158493 12345678910111213docker默认的源为国外官方源，下载速度较慢，可改为国内，加速方案一修改或新增 /etc/docker/daemon.jsonvi /etc/docker/daemon.json&#123;\"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]&#125;systemctl restart docker.service其余参考 https://blog.csdn.net/whatday/article/details/86770609https://blog.csdn.net/niukaoying6674/article/details/87788282 二、docker基本命令https://hub.docker.com/ 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run ‐‐name mytomcat ‐d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps ‐a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run ‐d ‐p 8888:8080 tomcat‐d：后台运行‐p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口 10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container‐name/container‐id 更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 三、实例以下均为下载镜像后，启动容器运行实例的命令。 tomcat1docker run --name tomcat -d -p 8080:8080 -v /root/tomcat:/usr/local/tomcat/webapps tomcat mysql1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=password -d mysql:5.5.62 四、配置过程中存在的问题与参考 高版本tomcat无法访问默认页面https://blog.csdn.net/weixin_42970847/article/details/104534764https://blog.csdn.net/weixin_43309946/article/details/103223091https://blog.csdn.net/LZJSTUDY/article/details/81097534 docker的挂载目录https://www.baidu.com/s?wd=docker%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%9B%AE%E5%BD%95&amp;rsv_spt=1&amp;rsv_iqid=0xcc387ff200244ee5&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=20&amp;rsv_sug1=10&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=5030&amp;rsv_sug4=5029https://www.cnblogs.com/douh/p/12560439.htmlhttp://www.manongjc.com/article/148684.htmlhttps://www.jianshu.com/p/806485990aeahttps://blog.csdn.net/one_chao/article/details/98671330https://blog.csdn.net/wywinstonwy/article/details/106612226https://blog.csdn.net/i042416/article/details/82900177","categories":[{"name":"容器","slug":"容器","permalink":"http://nlbyd1119.online/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"go-study-4","slug":"go-study-4","date":"2020-06-23T07:13:57.000Z","updated":"2020-06-25T15:31:52.584Z","comments":true,"path":"2020/06/23/go-study-4/","link":"","permalink":"http://nlbyd1119.online/2020/06/23/go-study-4/","excerpt":"Go基础学习其四","text":"Go基础学习其四 2020.6.20-21 学习了go复合类型中的指针、结构体类型，还有通过方法、接口等实现模拟OOP的语法，type关键字的使用，错误处理、包的管理等概念。先记录一下我在学习时觉得需要注意的点，然后copy千锋的笔记和代码。个人笔记一、首先是一个问题，go是面向过程的还是面向对象的参考 https://www.zhihu.com/question/315995798/answer/623870413https://www.cnblogs.com/wangerhu/p/11397479.html一个答主的结论：严格来讲，Go不是OOP的语言，但是又允许有OOP的编程风格。Go中没有class等。但可以结合结构体、方法、接口实现OOP式的编程。二、指针 指针的语法和c类似 声明 var var_name *var_type 三、结构体 四种创建方式。成员变量首字母大写公有，小写私有。这对Go中一切变量、函数等的定义都是相同的。 通过new(T)返回结构体T类型的指针 go的结构体指针和结构体都是用.取成员变量的，不像c结构体指针是用-&gt;的。 匿名字段 四、OOP 结构体类型的匿名字段可以模拟继承关系，不匿名的就是模拟聚合 提升字段 五、方法method 与函数的区别在于指明了调用者 func (t Type) name()(){}，实际上t指明了结构体类型，则该方法就相当于此结构体的成员方法。 method继承 六、接口 go的接口是非侵入式的，这是它的一个显著特征。不需要指明接口，只需要指明接口中的方法，但必须实现所有的方法。 只要一个结构体实现了接口中的方法，就是实现了该接口，在传参时就可作为该接口的类型。 多态：一个函数如果接受接口类型作为参数，那么实际上可以传入该接口的任意实现类型对象作为参数；定义一个类型为接口类型，实际上可以赋值为任意实现类的对象。 空接口(interface{}) 不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。以空接口为参数表示可接收任意类型的参数。这样可定义接收任意类型参数的函数，存储任意类型的切片、数组、集合。 接口嵌套 接口断言：在以接口类型为参数的函数中获取其实际类型，就是根据断言判断其类型。 七、type关键字type关键字：定义类型、类型别名、注意两种使用方式的区别。 八、错误处理 go和java中都区分错误和异常，但定义和处理方式都有很大区别。参考：javahttps://www.jb51.net/article/92115.htmhttps://www.cnblogs.com/cyydmlrs520/p/11350047.htmlhttps://blog.csdn.net/qq_42350107/article/details/82588228https://www.cnblogs.com/prayjourney/p/11099388.htmlgohttps://www.jianshu.com/p/2ce9cc81712bhttps://www.jianshu.com/p/40cbeb02520f go中的错误error：error类型、创建error的方法、定义返回error的函数。 自定义error：定义结构体，表示错误类型，实现error接口 实现Error()方法。 panic和recover实现异常处理。 九、包的管理 目录的名字和包的名字不一定一致，但最好一致 同一目录下的package相同 导包，绝对路径（src起）和相对路径 init函数 go的变量定义不使用 包导入而未使用其中的函数或定义的变量等 都会报错 如果只想导入包中的init 那么可用 _ 注意导包是以包为单位 可有多个go文件在一个包中，导入时不区分哪个文件 第三方包通过 go get 下到gopath的 src下 笔记 一、指针 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 指针的概念指针是存储另一个变量的内存地址的变量。 我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。 一个指针变量可以指向任何一个值的内存地址它指向那个值的内存地址。 在上面的图中，变量b的值为156，存储在内存地址0x1040a124。变量a持有b的地址，现在a被认为指向b。 1.2 获取变量的地址Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。 123456789package mainimport \"fmt\"func main() &#123; var a int = 10 fmt.Printf(\"变量的地址: %x\\n\", &amp;a )&#125; 运行结果： 1变量的地址: 20818a220 1.3 声明指针声明指针，*T是指针变量的类型，它指向T类型的值。 1var var_name *var-type var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。 12var ip *int /* 指向整型*/var fp *float32 /* 指向浮点型 */ 示例代码： 123456789101112131415161718package mainimport \"fmt\"func main() &#123; var a int= 20 /* 声明实际变量 */ var ip *int /* 声明指针变量 */ ip = &amp;a /* 指针变量的存储地址 */ fmt.Printf(\"a 变量的地址是: %x\\n\", &amp;a ) /* 指针变量的存储地址 */ fmt.Printf(\"ip 变量的存储地址: %x\\n\", ip ) /* 使用指针访问值 */ fmt.Printf(\"*ip 变量的值: %d\\n\", *ip )&#125; 运行结果： 123a 变量的地址是: 20818a220ip 变量的存储地址: 20818a220*ip 变量的值: 20 示例代码： 1234567891011121314151617package mainimport \"fmt\"type name int8type first struct &#123; a int b bool name&#125;func main() &#123; a := new(first) a.a = 1 a.name = 11 fmt.Println(a.b, a.a, a.name)&#125; 运行结果： 1false 1 11 未初始化的变量自动赋上初始值 12345678910111213141516package mainimport \"fmt\"type name int8type first struct &#123; a int b bool name&#125;func main() &#123; var a = first&#123;1, false, 2&#125; var b *first = &amp;a fmt.Println(a.b, a.a, a.name, &amp;a, b.a, &amp;b, (*b).a)&#125; 运行结果： 1false 1 2 &amp;&#123;1 false 2&#125; 1 0xc042068018 1 获取指针地址在指针变量前加&amp;的方式 1.4 空指针Go 空指针当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。一个指针变量通常缩写为 ptr。 空指针判断： 12if(ptr != nil) /* ptr 不是空指针 */if(ptr == nil) /* ptr 是空指针 */ 1.5 获取指针的值获取一个指针意味着访问指针指向的变量的值。语法是：*a 示例代码： 1234567891011package main import ( \"fmt\")func main() &#123; b := 255 a := &amp;b fmt.Println(\"address of b is\", a) fmt.Println(\"value of b is\", *a)&#125; 1.6 操作指针改变变量的数值示例代码： 1234567891011121314package mainimport ( \"fmt\")func main() &#123; b := 255 a := &amp;b fmt.Println(\"address of b is\", a) fmt.Println(\"value of b is\", *a) *a++ fmt.Println(\"new value of b is\", b)&#125; 运行结果 123address of b is 0x1040a124 value of b is 255 new value of b is 256 1.7 使用指针传递函数的参数示例代码 12345678910111213141516package mainimport ( \"fmt\")func change(val *int) &#123; *val = 55&#125;func main() &#123; a := 58 fmt.Println(\"value of a before function call is\",a) b := &amp;a change(b) fmt.Println(\"value of a after function call is\", a)&#125; 运行结果 12value of a before function call is 58 value of a after function call is 55 不要将一个指向数组的指针传递给函数。使用切片。 假设我们想对函数内的数组进行一些修改，并且对调用者可以看到函数内的数组所做的更改。一种方法是将一个指向数组的指针传递给函数。 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; (*arr)[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 运行结果 1[90 90 91] 示例代码： 123456789101112131415package mainimport ( \"fmt\")func modify(arr *[3]int) &#123; arr[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(&amp;a) fmt.Println(a)&#125; 运行结果 1[90 90 91] 虽然将指针传递给一个数组作为函数的参数并对其进行修改，但这并不是实现这一目标的惯用方法。我们有切片。 示例代码： 123456789101112131415package mainimport ( \"fmt\")func modify(sls []int) &#123; sls[0] = 90&#125;func main() &#123; a := [3]int&#123;89, 90, 91&#125; modify(a[:]) fmt.Println(a)&#125; 运行结果： 1[90 90 91] Go不支持指针算法。 package main func main() {b := […]int{109, 110, 111}p := &amp;bp++} nvalid operation: p++ (non-numeric type *[3]int) 指针数组 123456789101112131415package mainimport \"fmt\"const MAX int = 3func main() &#123; a := []int&#123;10,100,200&#125; var i int for i = 0; i &lt; MAX; i++ &#123; fmt.Printf(\"a[%d] = %d\\n\", i, a[i] ) &#125;&#125; 结果 123a[0] = 10a[1] = 100a[2] = 200 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。 12345678910111213141516171819package mainimport \"fmt\"const MAX int = 3func main() &#123; a := []int&#123;10,100,200&#125; var i int var ptr [MAX]*int; for i = 0; i &lt; MAX; i++ &#123; ptr[i] = &amp;a[i] /* 整数地址赋值给指针数组 */ &#125; for i = 0; i &lt; MAX; i++ &#123; fmt.Printf(\"a[%d] = %d\\n\", i,*ptr[i] ) &#125;&#125; 结果 123a[0] = 10a[1] = 100a[2] = 200 1.8 指针的指针指针的指针 如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。 1var ptr **int; 1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; var a int var ptr *int var pptr **int a = 3000 /* 指针 ptr 地址 */ ptr = &amp;a /* 指向指针 ptr 地址 */ pptr = &amp;ptr /* 获取 pptr 的值 */ fmt.Printf(\"变量 a = %d\\n\", a ) fmt.Printf(\"指针变量 *ptr = %d\\n\", *ptr ) fmt.Printf(\"指向指针的指针变量 **pptr = %d\\n\", **pptr)&#125; 结果 123变量 a = 3000指针变量 *ptr = 3000指向指针的指针变量 **pptr = 3000 指针作为函数参数 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func main() &#123; /* 定义局部变量 */ var a int = 100 var b int= 200 fmt.Printf(\"交换前 a 的值 : %d\\n\", a ) fmt.Printf(\"交换前 b 的值 : %d\\n\", b ) /* 调用函数用于交换值 * &amp;a 指向 a 变量的地址 * &amp;b 指向 b 变量的地址 */ swap(&amp;a, &amp;b); fmt.Printf(\"交换后 a 的值 : %d\\n\", a ) fmt.Printf(\"交换后 b 的值 : %d\\n\", b )&#125;func swap(x *int, y *int) &#123; var temp int temp = *x /* 保存 x 地址的值 */ *x = *y /* 将 y 赋值给 x */ *y = temp /* 将 temp 赋值给 y */&#125; 结果 1234交换前 a 的值 : 100交换前 b 的值 : 200交换后 a 的值 : 200交换后 b 的值 : 100 一、结构体 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是结构体Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 1.2 结构体的定义和初始化123456type struct_variable_type struct &#123; member definition; member definition; ... member definition;&#125; 一旦定义了结构体类型，它就能用于变量的声明 1variable_name := structure_variable_type &#123;value1, value2...valuen&#125; 初始化结构体 1234567// 1.按照顺序提供初始化值P := person&#123;\"Tom\", 25&#125;// 2.通过field:value的方式初始化，这样可以任意顺序P := person&#123;age:24, name:\"Tom\"&#125;// 3.new方式,未设置初始值的，会赋予类型的默认初始值p := new(person)p.age=24 1.3 结构体的访问访问结构体成员(访问结构的各个字段) 通过点.操作符用于访问结构的各个字段。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* 声明 Book1 为 Books 类型 */ var Book2 Books /* 声明 Book2 为 Books 类型 */ /* book 1 描述 */ Book1.title = \"Go 语言\" Book1.author = \"www.runoob.com\" Book1.subject = \"Go 语言教程\" Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = \"Python 教程\" Book2.author = \"www.runoob.com\" Book2.subject = \"Python 语言教程\" Book2.book_id = 6495700 /* 打印 Book1 信息 */ fmt.Printf( \"Book 1 title : %s\\n\", Book1.title) fmt.Printf( \"Book 1 author : %s\\n\", Book1.author) fmt.Printf( \"Book 1 subject : %s\\n\", Book1.subject) fmt.Printf( \"Book 1 book_id : %d\\n\", Book1.book_id) /* 打印 Book2 信息 */ fmt.Printf( \"Book 2 title : %s\\n\", Book2.title) fmt.Printf( \"Book 2 author : %s\\n\", Book2.author) fmt.Printf( \"Book 2 subject : %s\\n\", Book2.subject) fmt.Printf( \"Book 2 book_id : %d\\n\", Book2.book_id)&#125; 运行结果： 12345678Book 1 title : Go 语言Book 1 author : www.runoob.comBook 1 subject : Go 语言教程Book 1 book_id : 6495407Book 2 title : Python 教程Book 2 author : www.runoob.comBook 2 subject : Python 语言教程Book 2 book_id : 6495700 1.4 结构体指针指针指向一个结构体也可以创建指向结构的指针。 结构体指针 1var struct_pointer *Books 以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前 1struct_pointer = &amp;Book1; 使用结构体指针访问结构体成员，使用 “.” 操作符 1struct_pointer.title; 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* Declare Book1 of type Book */ var Book2 Books /* Declare Book2 of type Book */ /* book 1 描述 */ Book1.title = \"Go 语言\" Book1.author = \"www.runoob.com\" Book1.subject = \"Go 语言教程\" Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = \"Python 教程\" Book2.author = \"www.runoob.com\" Book2.subject = \"Python 语言教程\" Book2.book_id = 6495700 /* 打印 Book1 信息 */ printBook(&amp;Book1) /* 打印 Book2 信息 */ printBook(&amp;Book2)&#125;func printBook( book *Books ) &#123; fmt.Printf( \"Book title : %s\\n\", book.title); fmt.Printf( \"Book author : %s\\n\", book.author); fmt.Printf( \"Book subject : %s\\n\", book.subject); fmt.Printf( \"Book book_id : %d\\n\", book.book_id);&#125; 结构体实例化也可以是这样的 12345678910111213package mainimport \"fmt\"type Books struct &#123;&#125;func (s Books) String() string &#123; return \"data\"&#125;func main() &#123; fmt.Printf(\"%v\\n\", Books&#123;&#125;)&#125; 1.5 结构体的匿名字段结构体的匿名字段 可以用字段来创建结构，这些字段只包含一个没有字段名的类型。这些字段被称为匿名字段。 在类型中，使用不写字段名的方式，使用另一个类型 123456789101112131415161718192021222324252627282930type Human struct &#123; name string age int weight int&#125; type Student struct &#123; Human // 匿名字段，那么默认Student就包含了Human的所有字段 speciality string&#125; func main() &#123; // 我们初始化一个学生 mark := Student&#123;Human&#123;\"Mark\", 25, 120&#125;, \"Computer Science\"&#125; // 我们访问相应的字段 fmt.Println(\"His name is \", mark.name) fmt.Println(\"His age is \", mark.age) fmt.Println(\"His weight is \", mark.weight) fmt.Println(\"His speciality is \", mark.speciality) // 修改对应的备注信息 mark.speciality = \"AI\" fmt.Println(\"Mark changed his speciality\") fmt.Println(\"His speciality is \", mark.speciality) // 修改他的年龄信息 fmt.Println(\"Mark become old\") mark.age = 46 fmt.Println(\"His age is\", mark.age) // 修改他的体重信息 fmt.Println(\"Mark is not an athlet anymore\") mark.weight += 60 fmt.Println(\"His weight is\", mark.weight)&#125; 可以使用”.”的方式进行调用匿名字段中的属性值 实际就是字段的继承 其中可以将匿名字段理解为字段名和字段类型都是同一个 基于上面的理解，所以可以mark.Human = Human{&quot;Marcus&quot;, 55, 220}和mark.Human.age -= 1 若存在匿名字段中的字段与非匿名字段名字相同，则最外层的优先访问，就近原则 通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。 1.6 结构体嵌套嵌套的结构体一个结构体可能包含一个字段，而这个字段反过来就是一个结构体。这些结构被称为嵌套结构。 示例代码： 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\")type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int address Address&#125;func main() &#123; var p Person p.name = \"Naveen\" p.age = 50 p.address = Address &#123; city: \"Chicago\", state: \"Illinois\", &#125; fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\",p.age) fmt.Println(\"City:\",p.address.city) fmt.Println(\"State:\",p.address.state)&#125; 1.7 提升字段在结构体中属于匿名结构体的字段称为提升字段，因为它们可以被访问，就好像它们属于拥有匿名结构字段的结构一样。理解这个定义是相当复杂的。 示例代码： 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\")type Address struct &#123; city, state string&#125;type Person struct &#123; name string age int Address&#125;func main() &#123; var p Person p.name = \"Naveen\" p.age = 50 p.Address = Address&#123; city: \"Chicago\", state: \"Illinois\", &#125; fmt.Println(\"Name:\", p.name) fmt.Println(\"Age:\", p.age) fmt.Println(\"City:\", p.city) //city is promoted field fmt.Println(\"State:\", p.state) //state is promoted field&#125; 运行结果 1234Name: Naveen Age: 50 City: Chicago State: Illinois 1.8 导出结构体和字段如果结构体类型以大写字母开头，那么它是一个导出类型，可以从其他包访问它。类似地，如果结构体的字段以大写开头，则可以从其他包访问它们。 示例代码： 1.在computer目录下，创建文件spec.go 1234567package computertype Spec struct &#123; //exported struct Maker string //exported field model string //unexported field Price int //exported field&#125; 2.创建main.go 文件 1234567891011package mainimport \"structs/computer\" import \"fmt\"func main() &#123; var spec computer.Spec spec.Maker = \"apple\" spec.Price = 50000 fmt.Println(\"Spec:\", spec)&#125; 目录结构如下： src structs computer spec.go main.go 1.9 结构体比较结构体是值类型，如果每个字段具有可比性，则是可比较的。如果它们对应的字段相等，则认为两个结构体变量是相等的。 示例代码： 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\")type name struct &#123; firstName string lastName string&#125;func main() &#123; name1 := name&#123;\"Steve\", \"Jobs\"&#125; name2 := name&#123;\"Steve\", \"Jobs\"&#125; if name1 == name2 &#123; fmt.Println(\"name1 and name2 are equal\") &#125; else &#123; fmt.Println(\"name1 and name2 are not equal\") &#125; name3 := name&#123;firstName:\"Steve\", lastName:\"Jobs\"&#125; name4 := name&#123;&#125; name4.firstName = \"Steve\" if name3 == name4 &#123; fmt.Println(\"name3 and name4 are equal\") &#125; else &#123; fmt.Println(\"name3 and name4 are not equal\") &#125;&#125; 运行结果 12name1 and name2 are equal name3 and name4 are not equal 如果结构变量包含的字段是不可比较的，那么结构变量是不可比较的 示例代码： 123456789101112131415161718192021package mainimport ( \"fmt\")type image struct &#123; data map[int]int&#125;func main() &#123; image1 := image&#123;data: map[int]int&#123; 0: 155, &#125;&#125; image2 := image&#123;data: map[int]int&#123; 0: 155, &#125;&#125; if image1 == image2 &#123; fmt.Println(\"image1 and image2 are equal\") &#125;&#125; 2.0 结构体作为函数的参数结构体作为函数参数使用 12345678910111213141516171819202122232425262728293031323334353637383940ackage mainimport \"fmt\"type Books struct &#123; title string author string subject string book_id int&#125;func main() &#123; var Book1 Books /* 声明 Book1 为 Books 类型 */ var Book2 Books /* 声明 Book2 为 Books 类型 */ /* book 1 描述 */ Book1.title = \"Go 语言\" Book1.author = \"www.runoob.com\" Book1.subject = \"Go 语言教程\" Book1.book_id = 6495407 /* book 2 描述 */ Book2.title = \"Python 教程\" Book2.author = \"www.runoob.com\" Book2.subject = \"Python 语言教程\" Book2.book_id = 6495700 /* 打印 Book1 信息 */ printBook(Book1) /* 打印 Book2 信息 */ printBook(Book2)&#125;func printBook( book Books ) &#123; fmt.Printf( \"Book title : %s\\n\", book.title); fmt.Printf( \"Book author : %s\\n\", book.author); fmt.Printf( \"Book subject : %s\\n\", book.subject); fmt.Printf( \"Book book_id : %d\\n\", book.book_id);&#125; make、new操作 make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：new返回指针 内建函数make(T, args)与new(T)有着不同的功能，make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是*T。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个slice，是一个包含指向数据（内部array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice为nil。对于slice、map和channel来说，make初始化了内部的数据结构，填充适当的值。 make返回初始化后的（非零）值。 方法 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是方法Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集 方法只是一个函数，它带有一个特殊的接收器类型，它是在func关键字和方法名之间编写的。接收器可以是struct类型或非struct类型。接收方可以在方法内部访问。 方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。 在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。 也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。 1.2 方法的语法定义方法的语法 123456func (t Type) methodName(parameter list)(return list) &#123; &#125;func funcName(parameter list)(return list)&#123; &#125; 实例代码： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")type Employee struct &#123; name string salary int currency string&#125;/* displaySalary() method has Employee as the receiver type*/func (e Employee) displaySalary() &#123; fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee &#123; name: \"Sam Adolf\", salary: 5000, currency: \"$\", &#125; emp1.displaySalary() //Calling displaySalary() method of Employee type&#125; 可以定义相同的方法名 示例代码： 1234567891011121314151617181920212223242526272829303132package mainimport ( \"fmt\" \"math\")type Rectangle struct &#123; width, height float64&#125;type Circle struct &#123; radius float64&#125;func (r Rectangle) area() float64 &#123; return r.width * r.height&#125;//该 method 属于 Circle 类型对象中的方法func (c Circle) area() float64 &#123; return c.radius * c.radius * math.Pi&#125;func main() &#123; r1 := Rectangle&#123;12, 2&#125; r2 := Rectangle&#123;9, 4&#125; c1 := Circle&#123;10&#125; c2 := Circle&#123;25&#125; fmt.Println(\"Area of r1 is: \", r1.area()) fmt.Println(\"Area of r2 is: \", r2.area()) fmt.Println(\"Area of c1 is: \", c1.area()) fmt.Println(\"Area of c2 is: \", c2.area())&#125; 运行结果 1234Area of r1 is: 24Area of r2 is: 36Area of c1 is: 314.1592653589793Area of c2 is: 1963.4954084936207 虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样 method里面可以访问接收者的字段 调用method通过.访问，就像struct里面访问字段一样 1.3 方法和函数既然我们已经有了函数，为什么还要使用方法？ 示例代码： 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")type Employee struct &#123; name string salary int currency string&#125;/* displaySalary() method converted to function with Employee as parameter*/func displaySalary(e Employee) &#123; fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)&#125;func main() &#123; emp1 := Employee&#123; name: \"Sam Adolf\", salary: 5000, currency: \"$\", &#125; displaySalary(emp1)&#125; 在上面的程序中，displaySalary方法被转换为一个函数，而Employee struct作为参数传递给它。这个程序也产生了相同的输出：Salary of Sam Adolf is $5000.。 为什么我们可以用函数来写相同的程序呢?有以下几个原因 Go不是一种纯粹面向对象的编程语言，它不支持类。因此，类型的方法是一种实现类似于类的行为的方法。 相同名称的方法可以在不同的类型上定义，而具有相同名称的函数是不允许的。假设我们有一个正方形和圆形的结构。可以在正方形和圆形上定义一个名为Area的方法。这是在下面的程序中完成的。 1.4 变量作用域作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。 Go 语言中变量可以在三个地方声明： 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，首字母大写全局变量可以在整个包甚至外部包（被导出后）使用。 12345678910111213141516171819package mainimport \"fmt\"/* 声明全局变量 */var g intfunc main() &#123; /* 声明局部变量 */ var a, b int /* 初始化参数 */ a = 10 b = 20 g = a + b fmt.Printf(\"结果： a = %d, b = %d and g = %d\\n\", a, b, g)&#125; 结果 1结果： a = 10, b = 20 and g = 30 形式参数 形式参数会作为函数的局部变量来使用 指针作为接收者 若不是以指针作为接收者，实际只是获取了一个copy，而不能真正改变接收者的中的数据 123func (b *Box) SetColor(c Color) &#123; b.color = c&#125; 示例代码 1234567891011121314151617181920package mainimport ( \"fmt\")type Rectangle struct &#123; width, height int&#125;func (r *Rectangle) setVal() &#123; r.height = 20&#125;func main() &#123; p := Rectangle&#123;1, 2&#125; s := p p.setVal() fmt.Println(p.height, s.height)&#125; 结果 120 2 如果没有那个*，则值就是2 2 1.5 method继承method是可以继承的，如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method 123456789101112131415161718192021222324252627package mainimport \"fmt\"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;func (h *Human) SayHi() &#123; fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)&#125;func main() &#123; mark := Student&#123;Human&#123;\"Mark\", 25, \"222-222-YYYY\"&#125;, \"MIT\"&#125; sam := Employee&#123;Human&#123;\"Sam\", 45, \"111-888-XXXX\"&#125;, \"Golang Inc\"&#125; mark.SayHi() sam.SayHi()&#125; 运行结果： 12Hi, I am Mark you can call me on 222-222-YYYYHi, I am Sam you can call me on 111-888-XXXX 1.6 method重写12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string&#125;type Employee struct &#123; Human //匿名字段 company string&#125;//Human定义methodfunc (h *Human) SayHi() &#123; fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)&#125;//Employee的method重写Human的methodfunc (e *Employee) SayHi() &#123; fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name, e.company, e.phone) //Yes you can split into 2 lines here.&#125;func main() &#123; mark := Student&#123;Human&#123;\"Mark\", 25, \"222-222-YYYY\"&#125;, \"MIT\"&#125; sam := Employee&#123;Human&#123;\"Sam\", 45, \"111-888-XXXX\"&#125;, \"Golang Inc\"&#125; mark.SayHi() sam.SayHi()&#125; 运行结果： 12Hi, I am Mark you can call me on 222-222-YYYYHi, I am Sam, I work at Golang Inc. Call me on 111-888-XXXX 方法是可以继承和重写的 存在继承关系时，按照就近原则，进行调用 接口 @author：韩茹版权所有：北京千锋互联科技有限公司 1.1 什么是接口?面向对象世界中的接口的一般定义是“接口定义对象的行为”。它表示让指定对象应该做什么。实现这种行为的方法(实现细节)是针对对象的。 在Go中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与OOP非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。 它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。 1.2 接口的定义语法定义接口 12345678910111213141516171819202122/* 定义接口 */type interface_name interface &#123; method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123; /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123; /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123; /* 方法实现*/&#125; 示例代码： 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\")type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(\"I am Nokia, I can call you!\")&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(\"I am iPhone, I can call you!\")&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 运行结果： 12I am Nokia, I can call you!I am iPhone, I can call you! interface可以被任意的对象实现 一个对象可以实现任意多个interface 任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface 1.3 interface值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport \"fmt\"type Human struct &#123; name string age int phone string&#125;type Student struct &#123; Human //匿名字段 school string loan float32&#125;type Employee struct &#123; Human //匿名字段 company string money float32&#125; //Human实现Sayhi方法func (h Human) SayHi() &#123; fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone)&#125; //Human实现Sing方法func (h Human) Sing(lyrics string) &#123; fmt.Println(\"La la la la...\", lyrics)&#125; //Employee重写Human的SayHi方法func (e Employee) SayHi() &#123; fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name, e.company, e.phone) //Yes you can split into 2 lines here.&#125;// Interface Men被Human,Student和Employee实现// 因为这三个类型都实现了这两个方法type Men interface &#123; SayHi() Sing(lyrics string)&#125;func main() &#123; mike := Student&#123;Human&#123;\"Mike\", 25, \"222-222-XXX\"&#125;, \"MIT\", 0.00&#125; paul := Student&#123;Human&#123;\"Paul\", 26, \"111-222-XXX\"&#125;, \"Harvard\", 100&#125; sam := Employee&#123;Human&#123;\"Sam\", 36, \"444-222-XXX\"&#125;, \"Golang Inc.\", 1000&#125; Tom := Employee&#123;Human&#123;\"Sam\", 36, \"444-222-XXX\"&#125;, \"Things Ltd.\", 5000&#125; //定义Men类型的变量i var i Men //i能存储Student i = mike fmt.Println(\"This is Mike, a Student:\") i.SayHi() i.Sing(\"November rain\") //i也能存储Employee i = Tom fmt.Println(\"This is Tom, an Employee:\") i.SayHi() i.Sing(\"Born to be wild\") //定义了slice Men fmt.Println(\"Let's use a slice of Men and see what happens\") x := make([]Men, 3) //T这三个都是不同类型的元素，但是他们实现了interface同一个接口 x[0], x[1], x[2] = paul, sam, mike for _, value := range x &#123; value.SayHi() &#125;&#125; 运行结果： 12345678910This is Mike, a Student:Hi, I am Mike you can call me on 222-222-XXXLa la la la... November rainThis is Tom, an Employee:Hi, I am Sam, I work at Things Ltd.. Call me on 444-222-XXXLa la la la... Born to be wildLet's use a slice of Men and see what happensHi, I am Paul you can call me on 111-222-XXXHi, I am Sam, I work at Golang Inc.. Call me on 444-222-XXXHi, I am Mike you can call me on 222-222-XXX 那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值 当然，使用指针的方式，也是可以的 但是，接口对象不能调用实现对象的属性 interface函数参数 interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数 嵌入interface 12345678910111213141516171819202122package mainimport \"fmt\"type Human interface &#123; Len()&#125;type Student interface &#123; Human&#125;type Test struct &#123;&#125;func (h *Test) Len() &#123; fmt.Println(\"成功\")&#125;func main() &#123; var s Student s = new(Test) s.Len()&#125; 示例代码： 12345678910111213141516171819202122package testimport ( \"fmt\")type Controller struct &#123; M int32&#125;type Something interface &#123; Get() Post()&#125;func (c *Controller) Get() &#123; fmt.Print(\"GET\")&#125;func (c *Controller) Post() &#123; fmt.Print(\"POST\")&#125; 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"test\")type T struct &#123; test.Controller&#125;func (t *T) Get() &#123; //new(test.Controller).Get() fmt.Print(\"T\")&#125;func (t *T) Post() &#123; fmt.Print(\"T\")&#125;func main() &#123; var something test.Something something = new(T) var t T t.M = 1 // t.Controller.M = 1 something.Get()&#125; Controller实现了所有的Something接口方法，当结构体T中调用Controller结构体的时候，T就相当于Java中的继承，T继承了Controller，因此，T可以不用重写所有的Something接口中的方法，因为父构造器已经实现了接口。 如果Controller没有实现Something接口方法，则T要调用Something中方法，就要实现其所有方法。 如果something = new(test.Controller)则调用的是Controller中的Get方法。 T可以使用Controller结构体中定义的变量 1.4 接口的类型接口与鸭子类型： 先直接来看维基百科里的定义： If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。 Duck Typing，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。Go 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。 而在静态语言如 Java, C++ 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方。如果你在程序中调用某个数，却传入了一个根本就没有实现另一个的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。 动态语言和静态语言的差别在此就有所体现。静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错。当然，静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 python 的同学比较清楚。 Go 语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常 Happy 的。Go 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。 总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定。Go 作为一种静态语言，通过接口实现了鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。 Go语言的多态性： Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。 任何定义接口所有方法的类型都被称为隐式地实现该接口。 类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。 1.5 接口断言前面说过，因为空接口 interface{}没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 语法格式： 1234567// 安全类型断言&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )//非安全类型断言&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 ) 示例代码： 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; var i1 interface&#123;&#125; = new (Student) s := i1.(Student) //不安全，如果断言失败，会直接panic fmt.Println(s) var i2 interface&#123;&#125; = new(Student) s, ok := i2.(Student) //安全，断言失败，也不会panic，只是ok的值为false if ok &#123; fmt.Println(s) &#125;&#125;type Student struct &#123;&#125; 断言其实还有另一种形式，就是用在利用 switch语句判断接口的类型。每一个case会被顺序地考虑。当命中一个case 时，就会执行 case 中的语句，因此 case 语句的顺序是很重要的，因为很有可能会有多个 case匹配的情况。 示例代码： 12345678switch ins:=s.(type) &#123; case Triangle: fmt.Println(\"三角形。。。\",ins.a,ins.b,ins.c) case Circle: fmt.Println(\"圆形。。。。\",ins.radius) case int: fmt.Println(\"整型数据。。\") &#125; 面向对象(OOP) @author：韩茹版权所有：北京千锋互联科技有限公司 go并不是一个纯面向对象的编程语言。在go中的面向对象，结构体替换了类。 Go并没有提供类class，但是它提供了结构体struct，方法method，可以在结构体上添加。提供了捆绑数据和方法的行为，这些数据和方法与类类似。 1.1 定义结构体和方法通过以下代码来更好的理解，首先在src目录下创建一个package命名为oop，在oop目录下，再创建一个子目录命名为employee，在该目录下创建一个go文件命名为employee.go。 目录结构：oop -&gt; employee -&gt; employee.go 在employee.go文件中保存以下代码： 12345678910111213141516package employeeimport ( \"fmt\")type Employee struct &#123; FirstName string LastName string TotalLeaves int LeavesTaken int&#125;func (e Employee) LeavesRemaining() &#123; fmt.Printf(\"%s %s has %d leaves remaining\", e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))&#125; 然后在oop目录下，创建文件并命名为main.go，并保存以下内容 12345678910111213package mainimport \"oop/employee\"func main() &#123; e := employee.Employee &#123; FirstName: \"Sam\", LastName: \"Adolf\", TotalLeaves: 30, LeavesTaken: 20, &#125; e.LeavesRemaining()&#125; 运行结果： 1Sam Adolf has 10 leaves remaining 1.2 New()函数替代了构造函数我们上面写的程序看起来不错，但是里面有一个微妙的问题。让我们看看当我们用0值定义employee struct时会发生什么。更改main的内容。转到下面的代码， 12345678package mainimport \"oop/employee\"func main() &#123; var e employee.Employee e.LeavesRemaining()&#125; 运行结果： 1has 0 leaves remaining 通过运行结果可以知道，使用Employee的零值创建的变量是不可用的。它没有有效的名、姓，也没有有效的保留细节。在其他的OOP语言中，比如java，这个问题可以通过使用构造函数来解决。使用参数化构造函数可以创建一个有效的对象。 go不支持构造函数。如果某个类型的零值不可用，则程序员的任务是不导出该类型以防止其他包的访问，并提供一个名为NewT(parameters)的函数，该函数初始化类型T和所需的值。在go中，它是一个命名一个函数的约定，它创建了一个T类型的值给NewT(parameters)。这就像一个构造函数。如果包只定义了一个类型，那么它的一个约定就是将这个函数命名为New(parameters)而不是NewT(parameters)。 更改employee.go的代码： 首先修改employee结构体为非导出，并创建一个函数New()，它将创建一个新Employee。代码如下： 123456789101112131415161718192021package employeeimport ( \"fmt\")type employee struct &#123; firstName string lastName string totalLeaves int leavesTaken int&#125;func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee &#123; e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125; return e&#125;func (e employee) LeavesRemaining() &#123; fmt.Printf(\"%s %s has %d leaves remaining\", e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))&#125; 我们在这里做了一些重要的改变。我们已经将Employee struct的起始字母e设置为小写，即我们已经将类型Employee struct更改为type Employee struct。通过这样做，我们成功地导出了employee结构并阻止了其他包的访问。将未导出的结构的所有字段都导出为未导出的方法是很好的做法，除非有特定的需要导出它们。由于我们不需要在包之外的任何地方使用employee struct的字段，所以我们也没有导出所有字段。 由于employee是未导出的，所以不可能从其他包中创建类型employee的值。因此，我们提供了一个输出的新函数。将所需的参数作为输入并返回新创建的employee。 这个程序还需要做一些修改，让它能够工作，但是让我们运行这个程序来了解到目前为止变化的效果。如果这个程序运行，它将会失败，有以下编译错误， 1go&#x2F;src&#x2F;constructor&#x2F;main.go:6: undefined: employee.Employee 这是因为我们有未导出的Employee，因此编译器抛出错误，该类型在main中没有定义。完美的。正是我们想要的。现在没有其他的包能够创建一个零值的员工。我们成功地防止了一个无法使用的员工结构价值被创建。现在创建员工的唯一方法是使用新功能。 修改main.go代码 12345678package main import \"oop/employee\"func main() &#123; e := employee.New(\"Sam\", \"Adolf\", 30, 20) e.LeavesRemaining()&#125; 运行结果： 1Sam Adolf has 10 leaves remaining 因此，我们可以明白，虽然Go不支持类，但是结构体可以有效地使用，在使用构造函数的位置，使用New(parameters)的方法即可。 1.3组成(Composition )替代了继承(Inheritance)Go不支持继承，但它支持组合。组合的一般定义是“放在一起”。构图的一个例子就是汽车。汽车是由轮子、发动机和其他各种部件组成的。 博客文章就是一个完美的组合例子。每个博客都有标题、内容和作者信息。这可以用组合完美地表示出来。 1.3.1 通过嵌入结构体实现组成可以通过将一个struct类型嵌入到另一个结构中实现。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"fmt\")/*我们创建了一个author struct，它包含字段名、lastName和bio。我们还添加了一个方法fullName()，将作者作为接收者类型，这将返回作者的全名。*/type author struct &#123; firstName string lastName string bio string&#125;func (a author) fullName() string &#123; return fmt.Sprintf(\"%s %s\", a.firstName, a.lastName)&#125;/*post struct有字段标题、内容。它还有一个嵌入式匿名字段作者。这个字段表示post struct是由author组成的。现在post struct可以访问作者结构的所有字段和方法。我们还在post struct中添加了details()方法，它打印出作者的标题、内容、全名和bio。*/type post struct &#123; title string content string author&#125;func (p post) details() &#123; fmt.Println(\"Title: \", p.title) fmt.Println(\"Content: \", p.content) fmt.Println(\"Author: \", p.author.fullName()) fmt.Println(\"Bio: \", p.author.bio)&#125;func main() &#123; author1 := author&#123; \"Naveen\", \"Ramanathan\", \"Golang Enthusiast\", &#125; post1 := post&#123; \"Inheritance in Go\", \"Go supports composition instead of inheritance\", author1, &#125; post1.details()&#125; 运行结果： 1234Title: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang Enthusiast 嵌入结构体的切片 在以上程序的main函数下增加以下代码，并运行 12345678910type website struct &#123; []post&#125;func (w website) contents() &#123; fmt.Println(\"Contents of Website\\n\") for _, v := range w.posts &#123; v.details() fmt.Println() &#125;&#125; 运行报错： 1main.go:31:9: syntax error: unexpected [, expecting field name or embedded type 这个错误指向structs []post的嵌入部分。原因是不可能匿名嵌入一片。需要一个字段名。我们来修正这个错误，让编译器通过。 123type website struct &#123; posts []post&#125; 现在让我们修改的main函数,为我们的新的website创建几个posts。修改完完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"fmt\")type author struct &#123; firstName string lastName string bio string&#125;func (a author) fullName() string &#123; return fmt.Sprintf(\"%s %s\", a.firstName, a.lastName)&#125;type post struct &#123; title string content string author&#125;func (p post) details() &#123; fmt.Println(\"Title: \", p.title) fmt.Println(\"Content: \", p.content) fmt.Println(\"Author: \", p.fullName()) fmt.Println(\"Bio: \", p.bio)&#125;type website struct &#123; posts []post&#125;func (w website) contents() &#123; fmt.Println(\"Contents of Website\\n\") for _, v := range w.posts &#123; v.details() fmt.Println() &#125;&#125;func main() &#123; author1 := author&#123; \"Naveen\", \"Ramanathan\", \"Golang Enthusiast\", &#125; post1 := post&#123; \"Inheritance in Go\", \"Go supports composition instead of inheritance\", author1, &#125; post2 := post&#123; \"Struct instead of Classes in Go\", \"Go does not support classes but methods can be added to structs\", author1, &#125; post3 := post&#123; \"Concurrency\", \"Go is a concurrent language and not a parallel one\", author1, &#125; w := website&#123; posts: []post&#123;post1, post2, post3&#125;, &#125; w.contents()&#125; 运行结果： 12345678910111213141516Contents of WebsiteTitle: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang EnthusiastTitle: Struct instead of Classes in Go Content: Go does not support classes but methods can be added to structs Author: Naveen Ramanathan Bio: Golang EnthusiastTitle: Concurrency Content: Go is a concurrent language and not a parallel one Author: Naveen Ramanathan Bio: Golang Enthusiast 1.4 多态性(Polymorphism)Go中的多态性是在接口的帮助下实现的。正如我们已经讨论过的，接口可以在Go中隐式地实现。如果类型为接口中声明的所有方法提供了定义，则实现一个接口。让我们看看在接口的帮助下如何实现多态。 任何定义接口所有方法的类型都被称为隐式地实现该接口。 类型接口的变量可以保存实现接口的任何值。接口的这个属性用于实现Go中的多态性。 举个例子，一个虚构的组织有两种项目的收入:固定的账单和时间和材料。组织的净收入是由这些项目的收入之和计算出来的。为了保持本教程的简单，我们假设货币是美元，我们不会处理美分。它将使用整数来表示。 首先我们定义一个接口：Income 1234type Income interface &#123; calculate() int source() string&#125; 接下来，定义两个结构体：FixedBilling和TimeAndMaterial 1234type FixedBilling struct &#123; projectName string biddedAmount int&#125; 12345type TimeAndMaterial struct &#123; projectName string noOfHours int hourlyRate int&#125; 下一步是定义这些结构体类型的方法，计算并返回实际收入和收入来源。 123456789101112131415func (fb FixedBilling) calculate() int &#123; return fb.biddedAmount&#125;func (fb FixedBilling) source() string &#123; return fb.projectName&#125;func (tm TimeAndMaterial) calculate() int &#123; return tm.noOfHours * tm.hourlyRate&#125;func (tm TimeAndMaterial) source() string &#123; return tm.projectName&#125; 接下来，我们来声明一下计算和打印总收入的calculateNetIncome函数。 12345678func calculateNetIncome(ic []Income) &#123; var netincome int = 0 for _, income := range ic &#123; fmt.Printf(\"Income From %s = $%d\\n\", income.source(), income.calculate()) netincome += income.calculate() &#125; fmt.Printf(\"Net income of organisation = $%d\", netincome)&#125; 上面的calculateNetIncome函数接受一部分Income接口作为参数。它通过遍历切片和调用calculate()方法来计算总收入。它还通过调用source()方法来显示收入来源。根据收入接口的具体类型，将调用不同的calculate()和source()方法。因此，我们在calculateNetIncome函数中实现了多态。 在未来，如果组织增加了一种新的收入来源，这个函数仍然可以正确地计算总收入，而没有一行代码更改。 最后我们写以下主函数： 1234567func main() &#123; project1 := FixedBilling&#123;projectName: \"Project 1\", biddedAmount: 5000&#125; project2 := FixedBilling&#123;projectName: \"Project 2\", biddedAmount: 10000&#125; project3 := TimeAndMaterial&#123;projectName: \"Project 3\", noOfHours: 160, hourlyRate: 25&#125; incomeStreams := []Income&#123;project1, project2, project3&#125; calculateNetIncome(incomeStreams)&#125; 运行结果： 1234Income From Project 1 &#x3D; $5000 Income From Project 2 &#x3D; $10000 Income From Project 3 &#x3D; $4000 Net income of organisation &#x3D; $19000 假设该组织通过广告找到了新的收入来源。让我们看看如何简单地添加新的收入方式和计算总收入，而不用对calculateNetIncome函数做任何更改。由于多态性，这样是可行的。 首先让我们定义Advertisement类型和calculate()和source()方法。 12345678910111213type Advertisement struct &#123; adName string CPC int noOfClicks int&#125;func (a Advertisement) calculate() int &#123; return a.CPC * a.noOfClicks&#125;func (a Advertisement) source() string &#123; return a.adName&#125; 广告类型有三个字段adName, CPC(cost per click)和noof点击数(cost per click)。广告的总收入是CPC和noOfClicks的产品。 修改主函数： 123456789func main() &#123; project1 := FixedBilling&#123;projectName: \"Project 1\", biddedAmount: 5000&#125; project2 := FixedBilling&#123;projectName: \"Project 2\", biddedAmount: 10000&#125; project3 := TimeAndMaterial&#123;projectName: \"Project 3\", noOfHours: 160, hourlyRate: 25&#125; bannerAd := Advertisement&#123;adName: \"Banner Ad\", CPC: 2, noOfClicks: 500&#125; popupAd := Advertisement&#123;adName: \"Popup Ad\", CPC: 5, noOfClicks: 750&#125; incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125; calculateNetIncome(incomeStreams)&#125; 运行结果： 123456Income From Project 1 &#x3D; $5000 Income From Project 2 &#x3D; $10000 Income From Project 3 &#x3D; $4000 Income From Banner Ad &#x3D; $1000 Income From Popup Ad &#x3D; $3750 Net income of organisation &#x3D; $23750 综上，我们没有对calculateNetIncome函数做任何更改，尽管我们添加了新的收入方式。它只是因为多态性而起作用。由于新的Advertisement类型也实现了Income接口，我们可以将它添加到incomeStreams切片中。calculateNetIncome函数也在没有任何更改的情况下工作，因为它可以调用Advertisement类型的calculate()和source()方法。 type关键字 @author：韩茹版权所有：北京千锋互联科技有限公司 type是go语法里的重要而且常用的关键字，type绝不只是对应于C/C++中的typedef。搞清楚type的使用，就容易理解go语言中的核心概念struct、interface、函数等的使用。 一、类型定义1.1 定义结构体使用type 可以定义结构体类型： 123456//1、定义结构体//结构体定义type person struct &#123; name string //注意后面不能有逗号 age int&#125; 1.2 定义接口使用type 可以定义接口类型： 1234type USB interface &#123; start() end()&#125; 1.3 定义其他的新类型使用type，还可以定义新类型。 语法： 1type 类型名 Type 示例代码： 123456789101112131415161718192021222324package mainimport \"fmt\"type myint inttype mystr stringfunc main() &#123; var i1 myint var i2 = 100 i1 = 100 fmt.Println(i1) //i1 = i2 //cannot use i2 (type int) as type myint in assignment fmt.Println(i1,i2) var name mystr name = \"王二狗\" var s1 string s1 = \"李小花\" fmt.Println(name) fmt.Println(s1) name = s1 //cannot use s1 (type string) as type mystr in assignment&#125; 1.4 定义函数的类型Go语言支持函数式编程，可以使用高阶编程语法。一个函数可以作为另一个函数的参数，也可以作为另一个函数的返回值，那么在定义这个高阶函数的时候，如果函数的类型比较复杂，我们可以使用type来定义这个函数的类型： 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"strconv\")func main() &#123; res1 := fun1() fmt.Println(res1(10,20))&#125;type my_fun func (int,int)(string)//fun1()函数的返回值是my_func类型func fun1 () my_fun&#123; fun := func(a,b int) string &#123; s := strconv.Itoa(a) + strconv.Itoa(b) return s &#125; return fun&#125; 二、类型别名类型别名的写法为： 1type 别名 = Type 类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。 类型别名是 Go 1.9 版本添加的新功能。主要用于代码升级、迁移中类型的兼容性问题。在 C/C++语言中，代码重构升级可以使用宏快速定义新的一段代码。Go 语言中没有选择加入宏，而是将解决重构中最麻烦的类型名变更问题。 在 Go 1.9 版本之前的内建类型定义的代码是这样写的： 12type byte uint8type rune int32 而在 Go 1.9 版本之后变为： 12type byte = uint8type rune = int32 这个修改就是配合类型别名而进行的修改。 示例代码： 12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; var i1 myint var i2 = 100 i1 = 100 fmt.Println(i1) //i1 = i2 //cannot use i2 (type int) as type myint in assignment fmt.Println(i1,i2) var i3 myint2 i3 = i2 fmt.Println(i1,i2,i3)&#125;type myint inttype myint2 = int //不是重新定义类型，只是给int起别名 三、非本地类型不能定义方法能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法？ 1234567891011package mainimport ( \"time\")// 定义time.Duration的别名为MyDurationtype MyDuration = time.Duration// 为MyDuration添加一个函数func (m MyDuration) EasySet(a string) &#123; //cannot define new methods on non-local type time.Duration&#125;func main() &#123;&#125; 以上代码报错。报错信息：cannot define new methods on non-local type time.Duration 编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法。非本地方法指的就是使用 time.Duration 的代码所在的包，也就是 main 包。因为 time.Duration 是在 time 包中定义的，在 main 包中使用。time.Duration 包与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。 解决这个问题有下面两种方法： 将类型别名改为类型定义： type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型。 将 MyDuration 的别名定义放在 time 包中。 四、在结构体成员嵌入时使用别名当类型别名作为结构体嵌入的成员时会发生什么情况？ 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"fmt\")type Person struct &#123; name string&#125;func (p Person) Show() &#123; fmt.Println(\"Person--&gt;\",p.name)&#125;//类型别名type People = Persontype Student struct &#123; // 嵌入两个结构 Person People&#125;func (p People) Show2()&#123; fmt.Println(\"People------&gt;\",p.name)&#125;func main() &#123; // var s Student //s.name = \"王二狗\" //ambiguous selector s.name s.People.name = \"李小花\" s.Person.name = \"王二狗\" //s.Show() //ambiguous selector s.Show s.Person.Show() s.People.Show2() fmt.Printf(\"%T,%T\\n\",s.Person,s.People) //main.Person,main.Person&#125; 在通过s直接访问name的时候，或者s直接调用Show()方法，因为两个类型都有 name字段和Show() 方法，会发生歧义，证明People 的本质确实是Person 类型。 部分内容引自：http://c.biancheng.net/view/25.html 错误处理 @author：韩茹 版权所有：北京千锋互联科技有限公司 在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go语言没有提供像Java、C#语言中的try...catch异常处理方式，而是通过函数返回值逐层往上抛。这种设计，鼓励工程师在代码中显式的检查错误，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让代码啰嗦。 1.1 什么是错误错误是什么? 错误指的是可能出现问题的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中 。 而异常指的是不应该出现问题的地方出现了问题。比如引用了空指针，这种情况在人们的意料之外。可见，错误是业务过程的一部分，而异常不是 。 Go中的错误也是一种类型。错误用内置的error 类型表示。就像其他类型的，如int，float64，。错误值可以存储在变量中，从函数中返回，等等。 1.2 演示错误让我们从一个示例程序开始，这个程序尝试打开一个不存在的文件。 示例代码： 12345678910111213141516package mainimport ( \"fmt\" \"os\")func main() &#123; f, err := os.Open(\"/test.txt\") if err != nil &#123; fmt.Println(err) return &#125; //根据f进行文件的读或写 fmt.Println(f.Name(), \"opened successfully\")&#125; 在os包中有打开文件的功能函数： ​ func Open(name string) (file *File, err error) 如果文件已经成功打开，那么Open函数将返回文件处理。如果在打开文件时出现错误，将返回一个非nil错误。 ​ 如果一个函数或方法返回一个错误，那么按照惯例，它必须是函数返回的最后一个值。因此，Open 函数返回的值是最后一个值。 处理错误的惯用方法是将返回的错误与nil进行比较。nil值表示没有发生错误，而非nil值表示出现错误。在我们的例子中，我们检查错误是否为nil。如果它不是nil，我们只需打印错误并从主函数返回。 运行结果： 1open &#x2F;test.txt: No such file or directory 我们得到一个错误，说明该文件不存在。 1.3 错误类型表示Go 语言通过内置的错误接口提供了非常简单的错误处理机制。 让我们再深入一点，看看如何定义错误类型的构建。错误是一个带有以下定义的接口类型， 123type error interface &#123; Error() string&#125; 它包含一个带有Error（）字符串的方法。任何实现这个接口的类型都可以作为一个错误使用。这个方法提供了对错误的描述。 当打印错误时，fmt.Println函数在内部调用Error() 方法来获取错误的描述。这就是错误描述是如何在一行中打印出来的。 从错误中提取更多信息的不同方法 既然我们知道错误是一种接口类型，那么让我们看看如何提取更多关于错误的信息。 在上面的例子中，我们仅仅是打印了错误的描述。如果我们想要的是导致错误的文件的实际路径。一种可能的方法是解析错误字符串。这是我们程序的输出， 1open &#x2F;test.txt: No such file or directory 我们可以解析这个错误消息并从中获取文件路径”/test.txt”。但这是一个糟糕的方法。在新版本的语言中，错误描述可以随时更改，我们的代码将会中断。 是否有办法可靠地获取文件名？答案是肯定的，它可以做到，标准Go库使用不同的方式提供更多关于错误的信息。让我们一看一看。 1.断言底层结构类型并从结构字段获取更多信息 如果仔细阅读打开函数的文档，可以看到它返回的是PathError类型的错误。PathError是一个struct类型，它在标准库中的实现如下， 1234567type PathError struct &#123; Op string Path string Err error&#125;func (e *PathError) Error() string &#123; return e.Op + \" \" + e.Path + \": \" + e.Err.Error() &#125; 从上面的代码中，您可以理解PathError通过声明Error()string方法实现了错误接口。该方法连接操作、路径和实际错误并返回它。这样我们就得到了错误信息， 1open &#x2F;test.txt: No such file or directory PathError结构的路径字段包含导致错误的文件的路径。让我们修改上面写的程序，并打印出路径。 修改代码： 123456789101112131415package mainimport ( \"fmt\" \"os\")func main() &#123; f, err := os.Open(\"/test.txt\") if err, ok := err.(*os.PathError); ok &#123; fmt.Println(\"File at path\", err.Path, \"failed to open\") return &#125; fmt.Println(f.Name(), \"opened successfully\")&#125; 在上面的程序中，我们使用类型断言获得错误接口的基本值。然后我们用错误来打印路径.这个程序输出, 1File at path &#x2F;test.txt failed to open 断言底层结构类型，并使用方法获取更多信息 获得更多信息的第二种方法是断言底层类型，并通过调用struct类型的方法获取更多信息。 示例代码： 12345678910111213type DNSError struct &#123; ...&#125;func (e *DNSError) Error() string &#123; ...&#125;func (e *DNSError) Timeout() bool &#123; ... &#125;func (e *DNSError) Temporary() bool &#123; ... &#125; 从上面的代码中可以看到，DNSError struct有两个方法Timeout() bool和Temporary() bool，它们返回一个布尔值，表示错误是由于超时还是临时的。 让我们编写一个断言*DNSError类型的程序，并调用这些方法来确定错误是临时的还是超时的。 123456789101112131415161718192021package mainimport ( \"fmt\" \"net\")func main() &#123; addr, err := net.LookupHost(\"golangbot123.com\") if err, ok := err.(*net.DNSError); ok &#123; if err.Timeout() &#123; fmt.Println(\"operation timed out\") &#125; else if err.Temporary() &#123; fmt.Println(\"temporary error\") &#125; else &#123; fmt.Println(\"generic error: \", err) &#125; return &#125; fmt.Println(addr)&#125; 在上面的程序中，我们正在尝试获取一个无效域名的ip地址，这是一个无效的域名。golangbot123.com。我们通过声明它来输入*net.DNSError来获得错误的潜在价值。 在我们的例子中，错误既不是暂时的，也不是由于超时，因此程序会打印出来， 1generic error: lookup golangbot123.com: no such host 如果错误是临时的或超时的，那么相应的If语句就会执行，我们可以适当地处理它。 3.直接比较 获得更多关于错误的详细信息的第三种方法是直接与类型错误的变量进行比较。让我们通过一个例子来理解这个问题。 filepath包的Glob函数用于返回与模式匹配的所有文件的名称。当模式出现错误时，该函数将返回一个错误ErrBadPattern。 在filepath包中定义了ErrBadPattern，如下所述： 1var ErrBadPattern = errors.New(\"syntax error in pattern\") errors.New()用于创建新的错误。 当模式出现错误时，由Glob函数返回ErrBadPattern。 让我们写一个小程序来检查这个错误： 123456789101112131415package mainimport ( \"fmt\" \"path/filepath\")func main() &#123; files, error := filepath.Glob(\"[\") if error != nil &amp;&amp; error == filepath.ErrBadPattern &#123; fmt.Println(error) return &#125; fmt.Println(\"matched files\", files)&#125; 运行结果： 1syntax error in pattern 不要忽略错误 永远不要忽略一个错误。忽视错误会招致麻烦。让我重新编写一个示例，该示例列出了与模式匹配的所有文件的名称，而忽略了错误处理代码。 1234567891011package mainimport ( \"fmt\" \"path/filepath\")func main() &#123; files, _ := filepath.Glob(\"[\") fmt.Println(\"matched files\", files)&#125; 我们从前面的例子中已经知道模式是无效的。我忽略了Glob函数返回的错误，方法是使用行号中的空白标识符。 1matched files [] 由于我们忽略了这个错误，输出看起来好像没有文件匹配这个模式，但是实际上这个模式本身是畸形的。所以不要忽略错误。 1.4 自定义错误创建自定义错误可以使用errors包下的New()函数，以及fmt包下的：Errorf()函数。 12345//errors包：func New(text string) error &#123;&#125;//fmt包：func Errorf(format string, a ...interface&#123;&#125;) error &#123;&#125; 在使用New()函数创建自定义错误之前，让我们了解它是如何实现的。下面提供了错误包中的新功能的实现。 12345678910111213141516// Package errors implements functions to manipulate errors. package errors // New returns an error that formats as the given text. func New(text string) error &#123; return &amp;errorString&#123;text&#125; &#125; // errorString is a trivial implementation of error. type errorString struct &#123; s string &#125; func (e *errorString) Error() string &#123; return e.s &#125; 既然我们知道了New()函数是如何工作的，那么就让我们在自己的程序中使用它来创建一个自定义错误。 我们将创建一个简单的程序，计算一个圆的面积，如果半径为负，将返回一个错误。 123456789101112131415161718192021222324package mainimport ( \"errors\" \"fmt\" \"math\")func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, errors.New(\"Area calculation failed, radius is less than zero\") &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"Area of circle %0.2f\", area)&#125; 运行结果： 1Area calculation failed, radius is less than zero 使用Errorf向错误添加更多信息 上面的程序运行得很好，但是如果我们打印出导致错误的实际半径，那就不好了。这就是fmt包的Errorf函数的用武之地。这个函数根据一个格式说明器格式化错误，并返回一个字符串作为值来满足错误。 使用Errorf函数，修改程序。 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"math\")func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, fmt.Errorf(\"Area calculation failed, radius %0.2f is less than zero\", radius) &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(\"Area of circle %0.2f\", area)&#125; 运行结果： 1Area calculation failed, radius -20.00 is less than zero 使用struct类型和字段提供关于错误的更多信息 还可以使用将错误接口实现为错误的struct类型。这给我们提供了更多的错误处理的灵活性。在我们的示例中，如果我们想要访问导致错误的半径，那么现在唯一的方法是解析错误描述区域计算失败，半径-20.00小于零。这不是一种正确的方法，因为如果描述发生了变化，我们的代码就会中断。 我们将使用在前面的教程中解释的标准库的策略，在“断言底层结构类型并从struct字段获取更多信息”，并使用struct字段来提供对导致错误的半径的访问。我们将创建一个实现错误接口的struct类型，并使用它的字段来提供关于错误的更多信息。 第一步是创建一个struct类型来表示错误。错误类型的命名约定是，名称应该以文本Error结束。让我们把struct类型命名为areaError 1234type areaError struct &#123; err string radius float64&#125; 上面的struct类型有一个字段半径，它存储了为错误负责的半径的值，并且错误字段存储了实际的错误消息。 下一步，是实现error 接口 123func (e *areaError) Error() string &#123; return fmt.Sprintf(\"radius %0.2f: %s\", e.radius, e.err)&#125; 在上面的代码片段中，我们使用一个指针接收器区域错误来实现错误接口的Error() string方法。这个方法打印出半径和错误描述。 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\" \"math\")type areaError struct &#123; err string radius float64&#125;func (e *areaError) Error() string &#123; return fmt.Sprintf(\"radius %0.2f: %s\", e.radius, e.err)&#125;func circleArea(radius float64) (float64, error) &#123; if radius &lt; 0 &#123; return 0, &amp;areaError&#123;\"radius is negative\", radius&#125; &#125; return math.Pi * radius * radius, nil&#125;func main() &#123; radius := -20.0 area, err := circleArea(radius) if err != nil &#123; if err, ok := err.(*areaError); ok &#123; fmt.Printf(\"Radius %0.2f is less than zero\", err.radius) return &#125; fmt.Println(err) return &#125; fmt.Printf(\"Area of circle %0.2f\", area)&#125; 程序输出： 1Radius -20.00 is less than zero 使用结构类型的方法提供关于错误的更多信息 在本节中，我们将编写一个程序来计算矩形的面积。如果长度或宽度小于0，这个程序将输出一个错误。 第一步是创建一个结构来表示错误。 12345type areaError struct &#123; err string //error description length float64 //length which caused the error width float64 //width which caused the error&#125; 上面的错误结构类型包含一个错误描述字段，以及导致错误的长度和宽度。 现在我们有了错误类型，让我们实现错误接口，并在错误类型上添加一些方法来提供关于错误的更多信息。 1234567891011func (e *areaError) Error() string &#123; return e.err&#125;func (e *areaError) lengthNegative() bool &#123; return e.length &lt; 0&#125;func (e *areaError) widthNegative() bool &#123; return e.width &lt; 0&#125; 在上面的代码片段中，我们返回Error() string 方法的错误描述。当长度小于0时，lengthNegative() bool方法返回true;当宽度小于0时，widthNegative() bool方法返回true。这两种方法提供了更多关于误差的信息，在这种情况下，他们说面积计算是否失败，因为长度是负的，还是宽度为负的。因此，我们使用了struct错误类型的方法来提供更多关于错误的信息。 下一步是写出面积计算函数。 1234567891011121314151617func rectArea(length, width float64) (float64, error) &#123; err := \"\" if length &lt; 0 &#123; err += \"length is less than zero\" &#125; if width &lt; 0 &#123; if err == \"\" &#123; err = \"width is less than zero\" &#125; else &#123; err += \", width is less than zero\" &#125; &#125; if err != \"\" &#123; return 0, &amp;areaError&#123;err, length, width&#125; &#125; return length * width, nil&#125; 上面的rectArea函数检查长度或宽度是否小于0，如果它返回一个错误消息，则返回矩形的面积为nil。 主函数： 12345678910111213141516171819func main() &#123; length, width := -5.0, -9.0 area, err := rectArea(length, width) if err != nil &#123; if err, ok := err.(*areaError); ok &#123; if err.lengthNegative() &#123; fmt.Printf(\"error: length %0.2f is less than zero\\n\", err.length) &#125; if err.widthNegative() &#123; fmt.Printf(\"error: width %0.2f is less than zero\\n\", err.width) &#125; &#125; fmt.Println(err) return &#125; fmt.Println(\"area of rect\", area)&#125; 运行结果： 12error: length -5.00 is less than zero error: width -9.00 is less than zero 1.5 panic()和recover()Golang中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。一直等到包含defer语句的函数执行完毕时，延迟函数（defer后的函数）才会被执行，而不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数。调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程，包括主协程（类似于C语言中的主线程，该协程ID为1）。 panic： 1、内建函数 2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行，这里的defer 有点类似 try-catch-finally 中的 finally 4、直到goroutine整个退出，并报告错误 recover： 1、内建函数 2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 3、一般的调用建议 a). 在defer函数中，通过recever来终止一个gojroutine的panicking过程，从而恢复正常代码的执行 b). 可以获取通过panic传递的error 简单来讲：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。 错误和异常从Golang机制上讲，就是error和panic的区别。很多其他语言也一样，比如C++/Java，没有error但有errno，没有panic但有throw。 Golang错误和异常是可以互相转换的： 错误转异常，比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试完第三次还不成功的话，失败就被提升为异常了。 异常转错误，比如panic触发的异常被recover恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程。 什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。 以下给出异常处理的作用域（场景）： 空指针引用 下标越界 除数为0 不应该出现的分支，比如default 输入不应该引起函数错误 其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。 说明： Golang错误处理方式一直是很多人诟病的地方，有些人吐槽说一半的代码都是”if err != nil { / 打印 &amp;&amp; 错误处理 / }”，严重影响正常的处理逻辑。当我们区分错误和异常，根据规则设计函数，就会大大提高可读性和可维护性。 1.6 错误处理的正确姿势姿势一：失败的原因只有一个时，不使用error 我们看一个案例： 123456789func (self *AgentContext) CheckHostType(host_type string) error &#123; switch host_type &#123; case \"virtual_machine\": return nil case \"bare_metal\": return nil &#125; return errors.New(\"CheckHostType ERROR:\" + host_type)&#125; 我们可以看出，该函数失败的原因只有一个，所以返回值的类型应该为bool，而不是error，重构一下代码： 123func (self *AgentContext) IsValidHostType(hostType string) bool &#123; return hostType == \"virtual_machine\" || hostType == \"bare_metal\"&#125; 说明：大多数情况，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息，这时的返回值类型不再是简单的bool，而是error。 姿势二：没有失败时，不使用error error在Golang中是如此的流行，以至于很多人设计函数时不管三七二十一都使用error，即使没有一个失败原因。我们看一下示例代码： 1234func (self *CniParam) setTenantId() error &#123; self.TenantId = self.PodNs return nil&#125; 对于上面的函数设计，就会有下面的调用代码： 123456err := self.setTenantId()if err != nil &#123; // log // free resource return errors.New(...)&#125; 根据我们的正确姿势，重构一下代码： 123func (self *CniParam) setTenantId() &#123; self.TenantId = self.PodNs&#125; 于是调用代码变为： 1self.setTenantId() 姿势三：error应放在返回值类型列表的最后 对于返回值类型error，用来传递错误信息，在Golang中通常放在最后一个。 1234resp, err := http.Get(url)if err != nil &#123; return nill, err&#125; bool作为返回值类型时也一样。 1234value, ok := cache.Lookup(key) if !ok &#123; // ...cache[key] does not exist… &#125; 姿势四：错误值统一定义，而不是跟着感觉走 很多人写代码时，到处return errors.New(value)，而错误value在表达同一个含义时也可能形式不同，比如“记录不存在”的错误value可能为： “record is not existed.” “record is not exist!” “###record is not existed！！！” … 这使得相同的错误value撒在一大片代码里，当上层函数要对特定错误value进行统一处理时，需要漫游所有下层代码，以保证错误value统一，不幸的是有时会有漏网之鱼，而且这种方式严重阻碍了错误value的重构。 于是，我们可以参考C/C++的错误码定义文件，在Golang的每个包中增加一个错误对象定义文件，如下所示： 123456var ERR_EOF = errors.New(\"EOF\")var ERR_CLOSED_PIPE = errors.New(\"io: read/write on closed pipe\")var ERR_NO_PROGRESS = errors.New(\"multiple Read calls return no data or error\")var ERR_SHORT_BUFFER = errors.New(\"short buffer\")var ERR_SHORT_WRITE = errors.New(\"short write\")var ERR_UNEXPECTED_EOF = errors.New(\"unexpected EOF\") 姿势五：错误逐层传递时，层层都加日志 层层都加日志非常方便故障定位。 说明：至于通过测试来发现故障，而不是日志，目前很多团队还很难做到。如果你或你的团队能做到，那么请忽略这个姿势。 姿势六：错误处理使用defer 我们一般通过判断error的值来处理错误，如果当前操作失败，需要将本函数中已经create的资源destroy掉，示例代码如下： 123456789101112131415161718192021222324252627func deferDemo() error &#123; err := createResource1() if err != nil &#123; return ERR_CREATE_RESOURCE1_FAILED &#125; err = createResource2() if err != nil &#123; destroyResource1() return ERR_CREATE_RESOURCE2_FAILED &#125; err = createResource3() if err != nil &#123; destroyResource1() destroyResource2() return ERR_CREATE_RESOURCE3_FAILED &#125; err = createResource4() if err != nil &#123; destroyResource1() destroyResource2() destroyResource3() return ERR_CREATE_RESOURCE4_FAILED &#125; return nil&#125; 当Golang的代码执行时，如果遇到defer的闭包调用，则压入堆栈。当函数返回时，会按照后进先出的顺序调用闭包。对于闭包的参数是值传递，而对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值。根据这个结论，我们重构上面的示例代码： 123456789101112131415161718192021222324252627282930313233343536func deferDemo() error &#123; err := createResource1() if err != nil &#123; return ERR_CREATE_RESOURCE1_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource1() &#125; &#125;() err = createResource2() if err != nil &#123; return ERR_CREATE_RESOURCE2_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource2() &#125; &#125;() err = createResource3() if err != nil &#123; return ERR_CREATE_RESOURCE3_FAILED &#125; defer func() &#123; if err != nil &#123; destroyResource3() &#125; &#125;() err = createResource4() if err != nil &#123; return ERR_CREATE_RESOURCE4_FAILED &#125; return nil&#125; 姿势七：当尝试几次可以避免失败时，不要立即返回错误 如果错误的发生是偶然性的，或由不可预知的问题导致。一个明智的选择是重新尝试失败的操作，有时第二次或第三次尝试时会成功。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。 两个案例： 我们平时上网时，尝试请求某个URL，有时第一次没有响应，当我们再次刷新时，就有了惊喜。 团队的一个QA曾经建议当Neutron的attach操作失败时，最好尝试三次，这在当时的环境下验证果然是有效的。 姿势八：当上层函数不关心错误时，建议不返回error 对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。 姿势九：当发生错误时，不忽略有用的返回值 通常，当函数返回non-nil的error时，其他的返回值是未定义的(undefined)，这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，应该将读取到的字符串和错误信息一起打印出来。 说明：对函数的返回值要有清晰的说明，以便于其他人使用。 1.7 异常处理的正确姿势姿势一：在程序开发阶段，坚持速错 速错，简单来讲就是“让它挂”，只有挂了你才会第一时间知道错误。在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。 姿势二：在程序部署后，应恢复异常避免程序终止 在Golang中，某个Goroutine如果panic了，并且没有recover，那么整个Golang进程就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。这个姿势类似于C语言中的断言，但还是有区别：一般在Release版本中，断言被定义为空而失效，但需要有if校验存在进行异常保护，尽管契约式设计中不建议这样做。在Golang中，recover完全可以终止异常展开过程，省时省力。 我们在调用recover的延迟函数中以最合理的方式响应该异常： 打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见； 将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。 我们看一个简单的例子： 123456789101112131415161718192021222324func funcA() error &#123; defer func() &#123; if p := recover(); p != nil &#123; fmt.Printf(\"panic recover! p: %v\", p) debug.PrintStack() &#125; &#125;() return funcB()&#125;func funcB() error &#123; // simulation panic(\"foo\") return errors.New(\"success\")&#125;func test() &#123; err := funcA() if err == nil &#123; fmt.Printf(\"err is nil\\\\n\") &#125; else &#123; fmt.Printf(\"err is %v\\\\n\", err) &#125;&#125; 我们期望test函数的输出是： 1err is foo 实际上test函数的输出是： 1err is nil 原因是panic异常处理机制不会自动将错误信息传递给error，所以要在funcA函数中进行显式的传递，代码如下所示： 123456789101112131415func funcA() (err error) &#123; defer func() &#123; if p := recover(); p != nil &#123; fmt.Println(\"panic recover! p:\", p) str, ok := p.(string) if ok &#123; err = errors.New(str) &#125; else &#123; err = errors.New(\"panic\") &#125; debug.PrintStack() &#125; &#125;() return funcB()&#125; 姿势三：对于不应该出现的分支，使用异常处理 当某些不应该发生的场景发生时，我们就应该调用panic函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径： 123456789101112switch s := suit(drawCard()); s &#123; case \"Spades\": // ... case \"Hearts\": // ... case \"Diamonds\": // ... case \"Clubs\": // ... default: panic(fmt.Sprintf(\"invalid suit %v\", s))&#125; 姿势四：针对入参不应该有问题的函数，使用panic设计 入参不应该有问题一般指的是硬编码，我们先看这两个函数（Compile和MustCompile），其中MustCompile函数是对Compile函数的包装： 1234567func MustCompile(str string) *Regexp &#123; regexp, error := Compile(str) if error != nil &#123; panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) &#125; return regexp&#125; 所以，对于同时支持用户输入场景和硬编码场景的情况，一般支持硬编码场景的函数是对支持用户输入场景函数的包装。对于只支持硬编码单一场景的情况，函数设计时直接使用panic，即返回值类型列表中不会有error，这使得函数的调用处理非常方便（没有了乏味的”if err != nil {/ 打印 &amp;&amp; 错误处理 /}”代码块）。 本文部分内容引自https://www.jianshu.com/p/f30da01eea97 Go语言中包的使用 @author：韩茹 版权所有：北京千锋互联科技有限公司 Go语言使用包（package）这种语法元素来组织源码，所有语法可见性均定义在package这个级别，与Java 、python等语言相比，这算不上什么创新，但与C传统的include相比，则是显得“先进”了许多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465myblog├── conf│ └── app.conf├── controllers│ ├── aboutme_controller.go│ ├── add_article_controller.go│ ├── album_controller.go│ ├── base_controller.go│ ├── default.go│ ├── delete_article_controller.go│ ├── exit_controller.go│ ├── home_controller.go│ ├── login_controller.go│ ├── register_controller.go│ ├── show_article_controller.go│ ├── tags_controller.go│ ├── update_article_controller.go│ └── upload_controller.go├── main.go├── models│ ├── album_model.go│ ├── article_model.go│ ├── home_model.go│ ├── tags_model.go│ └── user_model.go├── myblogweb├── routers│ └── router.go├── static│ ├── css│ │ ├── blogsheet.css│ │ └── lib│ │ ├── highlight.css│ │ └── login.css│ ├── img│ ├── js│ │ ├── blog.js│ │ ├── lib│ │ │ ├── jquery-3.3.1.min.js│ │ │ └── jquery.url.js│ │ └── reload.min.js│ └── upload│ └── img│ └── 2018│ └── 12│ └── 11│ ├── 1544511378-bee2.png├── tests│ └── default_test.go├── utils│ ├── myUtils.go│ └── mysqlUtils.go└── views ├── aboultme.html ├── album.html ├── block │ ├── home_block.html │ └── nav.html ├── home.html ├── index.tpl ├── login.html ├── register.html ├── show_article.html ├── tags.html └── write_article.html Go 语言的源码复用建立在包（package）基础之上。包通过 package, import, GOPATH 操作完成。 1、 main包Go 语言的入口 main() 函数所在的包（package）叫 main，main 包想要引用别的代码，需要import导入！ 2、 packagesrc 目录是以代码包的形式组织并保存 Go 源码文件的。每个代码包都和 src 目录下的文件夹一一对应。每个子目录都是一个代码包。 代码包包名和文件目录名，不要求一致。比如文件目录叫 hello，但是代码包包名可以声明为 “main”，但是同一个目录下的源码文件第一行声明的所属包，必须一致！ 同一个目录下的所有.go文件的第一行添加 包定义，以标记该文件归属的包，演示语法： 1package 包名 包需要满足： 一个目录下的同级文件归属一个包。也就是说，在同一个包下面的所有文件的package名，都是一样的。 在同一个包下面的文件package名都建议设为是该目录名，但也可以不是。也就是说，包名可以与其目录不同名。 包名为 main 的包为应用程序的入口包，其他包不能使用。 在同一个包下面的文件属于同一个工程文件，不用import包，可以直接使用 包可以嵌套定义，对应的就是嵌套目录，但包名应该与所在的目录一致，例如： 12345678// 文件：qf/ruby/tool.go中package ruby// 可以被导出的函数func FuncPublic() &#123;&#125;// 不可以被导出的函数func funcPrivate() &#123;&#125; 包中，通过标识符首字母是否大写，来确定是否可以被导出。首字母大写才可以被导出，视为 public 公共的资源。 3、 import要引用其他包，可以使用 import 关键字，可以单个导入或者批量导入，语法演示： A：通常导入 1234567// 单个导入import \"package\"// 批量导入import ( \"package1\" \"package2\" ) B：点操作我们有时候会看到如下的方式导入包 123import( . \"fmt\") 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调 用的fmt.Println(&quot;hello world&quot;)可以省略的写成Println(&quot;hello world&quot;) C：起别名 别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字。导入时，可以为包定义别名，语法演示： 123456import ( p1 \"package1\" p2 \"package2\" )// 使用时：别名操作，调用包函数时前缀变成了我们的前缀p1.Method() D：_操作如果仅仅需要导入包时执行初始化操作，并不需要使用包内的其他函数，常量等资源。则可以在导入包时，匿名导入。 这个操作经常是让很多人费解的一个操作符，请看下面这个import： 1234import ( \"database/sql\" _ \"github.com/ziutek/mymysql/godrv\" ) _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。也就是说，使用下划线作为包的别名，会仅仅执行init()。 导入的包的路径名，可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录）。 4、GOPATH环境变量import导入时，会从GO的安装目录（也就是GOROOT环境变量设置的目录）和GOPATH环境变量设置的目录中，检索 src/package 来导入包。如果不存在，则导入失败。GOROOT，就是GO内置的包所在的位置。GOPATH，就是我们自己定义的包的位置。 通常我们在开发Go项目时，调试或者编译构建时，需要设置GOPATH指向我们的项目目录，目录中的src目录中的包就可以被导入了。 5、init() 包初始化下面我们详细的来介绍一下这两个函数：init()、main() 是 go 语言中的保留函数。我们可以在源码中，定义 init() 函数。此函数会在包被导入时执行，例如如果是在 main 中导入包，包中存在 init()，那么 init() 中的代码会在 main() 函数执行前执行，用于初始化包所需要的特定资料。例如：包源码： 1234567src/userPackage/tool.gopackage userPackageimport \"fmt\"func init() &#123; fmt.Println(\"tool init\")&#125; 主函数源码： 1234567891011src/main.gopackage mainimport ( \"userPackage\" )func main() &#123; fmt.Println(\"main run\") // 使用userPackage userPackage.SomeFunc()&#125; 执行时，会先输出 “tool init”，再输出 “main run”。 下面我们详细的来介绍一下init()、main() 这两个函数。在 go 语言中的区别如下：相同点： 两个函数在定义时不能有任何的参数和返回值。该函数只能由 go 程序自动调用，不可以被引用。 不同点： init 可以应用于任意包中，且可以重复定义多个。main 函数只能用于 main 包中，且只能定义一个。 两个函数的执行顺序： 在 main 包中的 go 文件默认总是会被执行。 对同一个 go 文件的 init( ) 调用顺序是从上到下的。 对同一个 package 中的不同文件，将文件名按字符串进行“从小到大”排序，之后顺序调用各文件中的init()函数。 对于不同的 package，如果不相互依赖的话，按照 main 包中 import 的顺序调用其包中的 init() 函数。 如果 package 存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序 main –&gt; A –&gt; B –&gt; C，则初始化顺序为 C –&gt; B –&gt; A –&gt; main，一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包 图片引自网络 避免出现循环 import，例如：A –&gt; B –&gt; C –&gt; A。 一个包被其它多个包 import，但只能被初始化一次 6、管理外部包go允许import不同代码库的代码。对于import要导入的外部的包，可以使用 go get 命令取下来放到GOPATH对应的目录中去。 举个例子，比如说我们想通过go语言连接mysql数据库，那么需要先下载mysql的数据包，打开终端并输入以下命令： 1localhost:~ ruby$ go get github.com/go-sql-driver/mysql 安装之后，就可以在gopath目录的src下，看到对应的文件包目录： 也就是说，对于go语言来讲，其实并不关心你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。 扩展我们可以通过go install 来编译包文件。 我们知道一个非main包在编译后会生成一个.a文件（在临时目录下生成，除非使用go install安装到$GOROOT或​$GOPATH下，否则你看不到.a），用于后续可执行程序链接使用。 比如Go标准库中的包对应的源码部分路径在：$GOROOT/src，而标准库中包编译后的.a文件路径在$GOROOT/pkg/darwin_amd64下。","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"go-study-3","slug":"go-study-3","date":"2020-06-20T09:18:37.000Z","updated":"2020-06-23T11:27:42.959Z","comments":true,"path":"2020/06/20/go-study-3/","link":"","permalink":"http://nlbyd1119.online/2020/06/20/go-study-3/","excerpt":"Go基础学习其三","text":"Go基础学习其三 2020.6.20-21 学习了go复合类型中的数组Array、切片Slice、集合Map、函数function，此外还学习了基本类型string相关的包中的函数。先记录一下我在学习时觉得需要注意的点，然后copy千锋的笔记和代码。个人笔记一、数组 数组的创建方式 遍历方式 for index, value := range 数组变量 {} 数组是值类型，与c类似，与java、python不同。但注意数组类型就是[n]type类型，而非像c一样的指针之类的。 数组作为值类型，可以在类型、元素个数相等的情况下进行比较，逐位比较。 go的数组元素交换方式，可以写成 a, b = b, a 二、切片（列表） 切片的创建方式，一种是类似数组但不知道元素个数，一种是使用内置make函数。make函数可用来创建go中的引用类型（不包括自定义）。 内置函数append用于给切片追加元素。 遍历方式同数组。 切片的底层实际即为数组，切片变量作为引用类型，存放着底层数组的地址，通过fmt.Printf(“%p”, s)可直接打印其底层数组的地址，而数组作为值类型，打印地址还需取地址&amp;a。切片每次扩容时不超过底层数组的长度，其指向的底层数组不变，若超过，会创建一个新的数组。 在已有数组上创建切片，切面的属性与元素值与数组的关系。 切片作为引用类型，默认为浅拷贝。实现切片深拷贝的方法：逐一拷贝元素，使用内置函数copy。 三、集合Map Map创建时不初始化其值为nil，即其他语言中的null，此后也无法存放键值对。因此使用map关键字创建时必须同时初始化map[key_type]value_type{xxx:xx}，或者采用推荐的做法由make函数创建。 map的使用：存储、获取（返回value,ok）、修改、删除（使用内置函数delete）。 遍历方式。无序遍历：for k, v := range map{}。实现按键有序遍历，就需要先把键都取出来，然后用sort包中的方法排序后进行map遍历。 四、字符串相关包 内置函数 len()获得的是字节数 strings包 strconv包 五、函数function 函数定义在调用处上下均可，不需额外声明。 参数 n type 多个参数的类型一致，可以简写。 可变参 arg ..type 切片s… 表示切片中的全部元素。一个函数的参数列表只能有一个可变参数，且位置应在最后。 返回值：位置类似于js。可以只给出类型，也可以指定名称，这样在return时，不用专门return xxx。空白标识符_用来舍弃返回值。 全局变量不支持简短定义。 递归函数。看源代码 发现go的一个包下即便是不同文件也不能定义名字相同的函数，这与导包时以包为单位而非以文件为单位的做法一致。 defer延迟函数。先被defer的函数后执行。注意defer是延迟执行而非延迟调用延迟传参。 函数的数据类型：func(参数列表的数据类型)(返回值列表的数据类型)。函数的本质：函数名：指向函数体的内存地址；函数名()：将函数进行调用，函数中的代码会全部执行，然后将return的结果返回给调用处。 匿名函数 go语言支持函数式编程的两个体现：支持将一个函数作为另一个函数的参数即回调函数；支持将一个函数作为另一个函数的返回值即闭包。 笔记 一、数组(Array) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是数组Go 语言提供了数组类型的数据结构。数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。 数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个元素索引为 0，第二个索引为 1，以此类推。数组的下标取值范围是从0开始，到长度减1。 数组一旦定义后，大小不能更改。 1.2 数组的语法声明和初始化数组 需要指明数组的大小和存储的数据类型。 1var variable_name [SIZE] variable_type 示例代码： 12var balance [10] float32var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 初始化数组中 {} 中的元素个数不能大于 [] 中的数字。如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小： 1var balance = []float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 1balance[4] = 50.0 数组的其他创建方式： 123456789101112var a [4] float32 // 等价于：var arr2 = [4]float32&#123;&#125;fmt.Println(a) // [0 0 0 0]var b = [5] string&#123;\"ruby\", \"王二狗\", \"rose\"&#125;fmt.Println(b) // [ruby 王二狗 rose ]var c = [5] int&#123;'A', 'B', 'C', 'D', 'E'&#125; // bytefmt.Println(c) // [65 66 67 68 69]d := [...] int&#123;1,2,3,4,5&#125;// 根据元素的个数，设置数组的大小fmt.Println(d)//[1 2 3 4 5]e := [5] int&#123;4: 100&#125; // [0 0 0 0 100]fmt.Println(e)f := [...] int&#123;0: 1, 4: 1, 9: 1&#125; // [1 0 0 0 1 0 0 0 0 1]fmt.Println(f) 访问数组元素 1float32 salary = balance[9] 示例代码： 123456789101112131415161718package mainimport \"fmt\"func main() &#123; var n [10]int /* n 是一个长度为 10 的数组 */ var i,j int /* 为数组 n 初始化元素 */ for i = 0; i &lt; 10; i++ &#123; n[i] = i + 100 /* 设置元素为 i + 100 */ &#125; /* 输出每个数组元素的值 */ for j = 0; j &lt; 10; j++ &#123; fmt.Printf(\"Element[%d] = %d\\n\", j, n[j] ) &#125;&#125; 运行结果： 12345678910Element[0] = 100Element[1] = 101Element[2] = 102Element[3] = 103Element[4] = 104Element[5] = 105Element[6] = 106Element[7] = 107Element[8] = 108Element[9] = 109 数组的长度 通过将数组作为参数传递给len函数，可以获得数组的长度。 示例代码： 123456789package mainimport \"fmt\"func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; fmt.Println(\"length of a is\",len(a))&#125; 运行结果： 1length of a is 4 您甚至可以忽略声明中数组的长度并将其替换为…让编译器为你找到长度。这是在下面的程序中完成的。 示例代码： 12345678910package mainimport ( \"fmt\")func main() &#123; a := [...]int&#123;12, 78, 50&#125; // ... makes the compiler determine the length fmt.Println(a)&#125; 遍历数组： 12345678910package mainimport \"fmt\"func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; for i := 0; i &lt; len(a); i++ &#123; //looping from 0 to the length of the array fmt.Printf(\"%d th element of a is %.2f\\n\", i, a[i]) &#125;&#125; 使用range遍历数组： 12345678910111213package mainimport \"fmt\"func main() &#123; a := [...]float64&#123;67.7, 89.8, 21, 78&#125; sum := float64(0) for i, v := range a &#123;//range returns both the index and value fmt.Printf(\"%d the element of a is %.2f\\n\", i, v) sum += v &#125; fmt.Println(\"\\nsum of all elements of a\",sum)&#125; 如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点。 12for _, v := range a &#123; //ignores index &#125; 1.3 多维数组Go 语言支持多维数组，以下为常用的多维数组声明语法方式： 1var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 1var threedim [5][10][4]int 三维数组 12345a = [3][4]int&#123; &#123;0, 1, 2, 3&#125; , /* 第一行索引为 0 */ &#123;4, 5, 6, 7&#125; , /* 第二行索引为 1 */ &#123;8, 9, 10, 11&#125; /* 第三行索引为 2 */&#125; 1.4 数组是值类型数组是值类型Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。 1234567891011package mainimport \"fmt\"func main() &#123; a := [...]string&#123;\"USA\", \"China\", \"India\", \"Germany\", \"France\"&#125; b := a // a copy of a is assigned to b b[0] = \"Singapore\" fmt.Println(\"a is \", a) fmt.Println(\"b is \", b) &#125; 运行结果： 12a is [USA China India Germany France] b is [Singapore China India Germany France] 数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。 1234567package mainfunc main() &#123; a := [3]int&#123;5, 78, 8&#125; var b [5]int b = a //not possible since [3]int and [5]int are distinct types&#125; 一、切片(Slice) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是切片Go 语言切片是对数组的抽象。Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大 切片是一种方便、灵活且强大的包装器。切片本身没有任何数据。它们只是对现有数组的引用。 切片与数组相比，不需要设定长度，在[]中不用设定值，相对来说比较自由 从概念上面来说slice像一个结构体，这个结构体包含了三个元素： 指针，指向数组中slice指定的开始位置 长度，即slice的长度 最大长度，也就是slice开始位置到数组的最后位置的长度 1.2 切片的语法定义切片 1var identifier []type 切片不需要说明长度。或使用make()函数来创建切片: 123var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 1make([]T, length, capacity) 初始化 123s[0] = 1s[1] = 2s[2] = 3 1s :=[] int &#123;1,2,3 &#125; 1s := arr[startIndex:endIndex] 将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片（前闭后开），长度为endIndex-startIndex 1s := arr[startIndex:] 缺省endIndex时将表示一直到arr的最后一个元素 1s := arr[:endIndex] 缺省startIndex时将表示从arr的第一个元素开始 1234567891011package mainimport ( \"fmt\")func main() &#123; a := [5]int&#123;76, 77, 78, 79, 80&#125; var b []int = a[1:4] //creates a slice from a[1] to a[3] fmt.Println(b)&#125; 1.3 修改切片slice没有自己的任何数据。它只是底层数组的一个表示。对slice所做的任何修改都将反映在底层数组中。 示例代码： 123456789101112131415package mainimport ( \"fmt\")func main() &#123; darr := [...]int&#123;57, 89, 90, 82, 100, 78, 67, 69, 59&#125; dslice := darr[2:5] fmt.Println(\"array before\",darr) for i := range dslice &#123; dslice[i]++ &#125; fmt.Println(\"array after\",darr) &#125; 运行结果： 12array before [57 89 90 82 100 78 67 69 59] array after [57 89 91 83 101 78 67 69 59] 当多个片共享相同的底层数组时，每个元素所做的更改将在数组中反映出来。 示例代码： 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; numa := [3]int&#123;78, 79 ,80&#125; nums1 := numa[:] //creates a slice which contains all elements of the array nums2 := numa[:] fmt.Println(\"array before change 1\",numa) nums1[0] = 100 fmt.Println(\"array after modification to slice nums1\", numa) nums2[1] = 101 fmt.Println(\"array after modification to slice nums2\", numa)&#125; 运行结果： 123array before change 1 [78 79 80] array after modification to slice nums1 [100 79 80] array after modification to slice nums2 [100 101 80] 1.4 len() 和 cap() 函数切片的长度是切片中元素的数量。切片的容量是从创建切片的索引开始的底层数组中元素的数量。 切片是可索引的，并且可以由 len() 方法获取长度切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少 12345678910111213package mainimport \"fmt\"func main() &#123; var numbers = make([]int,3,5) printSlice(numbers)&#125;func printSlice(x []int)&#123; fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)&#125; 运行结果 1len=3 cap=5 slice=[0 0 0] 空切片 一个切片在未初始化之前默认为 nil，长度为 0 1234567891011121314151617package mainimport \"fmt\"func main() &#123; var numbers []int printSlice(numbers) if(numbers == nil)&#123; fmt.Printf(\"切片是空的\") &#125;&#125;func printSlice(x []int)&#123; fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)&#125; 运行结果 12len=0 cap=0 slice=[]切片是空的 12345678910111213141516171819202122232425262728293031323334353637package mainimport \"fmt\"func main() &#123; /* 创建切片 */ numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125; printSlice(numbers) /* 打印原始切片 */ fmt.Println(\"numbers ==\", numbers) /* 打印子切片从索引1(包含) 到索引4(不包含)*/ fmt.Println(\"numbers[1:4] ==\", numbers[1:4]) /* 默认下限为 0*/ fmt.Println(\"numbers[:3] ==\", numbers[:3]) /* 默认上限为 len(s)*/ fmt.Println(\"numbers[4:] ==\", numbers[4:]) numbers1 := make([]int,0,5) printSlice(numbers1) /* 打印子切片从索引 0(包含) 到索引 2(不包含) */ number2 := numbers[:2] printSlice(number2) /* 打印子切片从索引 2(包含) 到索引 5(不包含) */ number3 := numbers[2:5] printSlice(number3)&#125;func printSlice(x []int)&#123; fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)&#125; 运行结果 12345678len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4] 1.5 append() 和 copy() 函数append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slicecopy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数 append函数会改变slice所引用的数组的内容，从而影响到引用同一数组的其它slice。 但当slice中没有剩余空间（即(cap-len) == 0）时，此时将动态分配新的数组空间。返回的slice数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的slice则不受影响 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"func main() &#123; var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) &#125;func printSlice(x []int)&#123; fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x)&#125; 运行结果 12345len=0 cap=0 slice=[]len=1 cap=2 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=8 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4] numbers1与numbers两者不存在联系，numbers发生变化时，numbers1是不会随着变化的。也就是说copy方法是不会建立两个切片的联系的 一、集合(Map) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是Mapmap是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。 Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型 使用map过程中需要注意的几点： map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取 map的长度是不固定的，也就是和slice一样，也是一种引用类型 内置的len函数同样适用于map，返回map拥有的key的数量 map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。 1.2 Map的使用1.2.1 使用make()创建map可以使用内建函数 make 也可以使用 map 关键字来定义 Map: 12345/* 声明变量，默认 map 是 nil */var map_variable map[key_data_type]value_data_type/* 使用 make 函数 */map_variable = make(map[key_data_type]value_data_type) 1rating := map[string]float32 &#123;\"C\":5, \"Go\":4.5, \"Python\":4.5, \"C++\":2 &#125; 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() &#123; var countryCapitalMap map[string]string /* 创建集合 */ countryCapitalMap = make(map[string]string) /* map 插入 key-value 对，各个国家对应的首都 */ countryCapitalMap[\"France\"] = \"Paris\" countryCapitalMap[\"Italy\"] = \"Rome\" countryCapitalMap[\"Japan\"] = \"Tokyo\" countryCapitalMap[\"India\"] = \"New Delhi\" /* 使用 key 输出 map 值 */ for country := range countryCapitalMap &#123; fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country]) &#125; /* 查看元素在集合中是否存在 */ captial, ok := countryCapitalMap[\"United States\"] /* 如果 ok 是 true, 则存在，否则不存在 */ if(ok)&#123; fmt.Println(\"Capital of United States is\", captial) &#125;else &#123; fmt.Println(\"Capital of United States is not present\") &#125;&#125; 运行结果： 12345Capital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiCapital of United States is not present 1.2.2 delete() 函数delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。 1234567891011121314151617181920212223242526package mainimport \"fmt\"func main() &#123; /* 创建 map */ countryCapitalMap := map[string] string &#123;\"France\":\"Paris\",\"Italy\":\"Rome\",\"Japan\":\"Tokyo\",\"India\":\"New Delhi\"&#125; fmt.Println(\"原始 map\") /* 打印 map */ for country := range countryCapitalMap &#123; fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country]) &#125; /* 删除元素 */ delete(countryCapitalMap,\"France\"); fmt.Println(\"Entry for France is deleted\") fmt.Println(\"删除元素后 map\") /* 打印 map */ for country := range countryCapitalMap &#123; fmt.Println(\"Capital of\",country,\"is\",countryCapitalMap[country]) &#125;&#125; 运行结果： 12345678910原始 mapCapital of France is ParisCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New DelhiEntry for France is deleted删除元素后 mapCapital of Italy is RomeCapital of Japan is TokyoCapital of India is New Delhi 1.2.3 ok-idiom我们可以通过key获取map中对应的value值。语法为： 1map[key] 但是当key如果不存在的时候，我们会得到该value值类型的默认值，比如string类型得到空字符串，int类型得到0。但是程序不会报错。 所以我们可以使用ok-idiom获取值，可知道key/value是否存在 1value, ok := map[key] 示例代码： 1234567891011121314package mainimport ( \"fmt\")func main() &#123; m := make(map[string]int) m[\"a\"] = 1 x, ok := m[\"b\"] fmt.Println(x, ok) x, ok = m[\"a\"] fmt.Println(x, ok)&#125; 运行结果： 120 false1 true 1.2.4 map的长度使用len函数可以确定map的长度。 1len(map) // 可以得到map的长度 1.2.5 map是引用类型的与切片相似，映射是引用类型。当将映射分配给一个新变量时，它们都指向相同的内部数据结构。因此，一个的变化会反映另一个。 示例代码： 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; personSalary := map[string]int&#123; \"steve\": 12000, \"jamie\": 15000, &#125; personSalary[\"mike\"] = 9000 fmt.Println(\"Original person salary\", personSalary) newPersonSalary := personSalary newPersonSalary[\"mike\"] = 18000 fmt.Println(\"Person salary changed\", personSalary)&#125; 运行结果： 12Original person salary map[steve:12000 jamie:15000 mike:9000] Person salary changed map[steve:12000 jamie:15000 mike:18000] map不能使用==操作符进行比较。==只能用来检查map是否为空。否则会报错：invalid operation: map1 == map2 (map can only be comparedto nil) 一、字符串(string) @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是stringGo中的字符串是一个字节的切片。可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。 示例代码： 12345678910package mainimport ( \"fmt\")func main() &#123; name := \"Hello World\" fmt.Println(name)&#125; 1.2 string的使用1.2.1 访问字符串中的单个字节12345678910111213141516package mainimport ( \"fmt\")func main() &#123; name := \"Hello World\" for i:= 0; i &lt; len(s); i++ &#123; fmt.Printf(\"%d \", s[i]) &#125; fmt.Printf(\"\\n\") for i:= 0; i &lt; len(s); i++ &#123; fmt.Printf(\"%c \",s[i]) &#125;&#125; 运行结果： 72 101 108 108 111 32 87 111 114 108 100H e l l o W o r l d 1.3 strings包访问strings包，可以有很多操作string的函数。 1.4 strconv包访问strconv包，可以实现string和其他数值类型之间的转换。 一、函数的概念 @author：韩茹 版权所有：北京千锋互联科技有限公司 1.1 什么是函数函数是执行特定任务的代码块。 1.2 函数的声明go语言至少有一个main函数 语法格式： 12345func funcName(parametername type1, parametername type2) (output1 type1, output2 type2) &#123;//这里是处理逻辑代码//返回多个值return value1, value2&#125; func：函数由 func 开始声明 funcName：函数名称，函数名和参数列表一起构成了函数签名。 parametername type：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 output1 type1, output2 type2：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型。 如果只有一个返回值且不声明返回值变量，那么你可以省略包括返回值的括号（即一个返回值可以不声明返回类型） 函数体：函数定义的代码集合。 1.3 函数的使用示例代码： 12345678910111213141516171819202122232425262728package mainimport \"fmt\"func main() &#123; /* 定义局部变量 */ var a int = 100 var b int = 200 var ret int /* 调用函数并返回最大值 */ ret = max(a, b) fmt.Printf( \"最大值是 : %d\\n\", ret )&#125;/* 函数返回两个数的最大值 */func max(num1, num2 int) int &#123; /* 定义局部变量 */ var result int if (num1 &gt; num2) &#123; result = num1 &#125; else &#123; result = num2 &#125; return result &#125; 运行结果： 1最大值是 : 200 二、函数的参数2.1 参数的使用形式参数：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参。 实际参数：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。 函数调用： A：函数名称必须匹配 B：实参与形参必须一一对应：顺序，个数，类型2.2 可变参Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参： 1func myfunc(arg ...int) &#123;&#125; arg ...int告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int的slice： 123for _, n := range arg &#123;fmt.Printf(\"And the number is: %d\\n\", n)&#125; 2.3 参数传递go语言函数的参数也是存在值传递和引用传递 函数运用场景 值传递 1234567891011121314151617package mainimport ( \"fmt\" \"math\")func main()&#123; /* 声明函数变量 */ getSquareRoot := func(x float64) float64 &#123; return math.Sqrt(x) &#125; /* 使用函数 */ fmt.Println(getSquareRoot(9))&#125; 引用传递 这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&amp;x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子 1234567891011121314package mainimport \"fmt\"//简单的一个函数，实现了参数+1的操作func add1(a *int) int &#123; // 请注意，*a = *a+1 // 修改了a的值return *a // 返回新值&#125; func main() &#123;x := 3fmt.Println(\"x = \", x) // 应该输出 \"x = 3\"x1 := add1(&amp;x) // 调用 add1(&amp;x) 传x的地址fmt.Println(\"x+1 = \", x1) // 应该输出 \"x+1 = 4\"fmt.Println(\"x = \", x) // 应该输出 \"x = 4\"&#125; 传指针使得多个函数能操作同一个对象。 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。 Go语言中slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针） 三、函数的返回值3.1 什么是函数的返回值一个函数被调用后，返回给调用处的执行结果，叫做函数的返回值。 调用处需要使用变量接收该结果 3.2 一个函数可以返回多个值一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。 123456789101112package mainimport \"fmt\"func swap(x, y string) (string, string) &#123; return y, x&#125;func main() &#123; a, b := swap(\"Mahesh\", \"Kumar\") fmt.Println(a, b)&#125; 12345func SumAndProduct(A, B int) (add int, Multiplied int) &#123;add = A+BMultiplied = A*Breturn&#125; 3.3 空白标识符_是Go中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。 比如rectProps函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。 示例代码： 123456789101112131415package mainimport ( \"fmt\")func rectProps(length, width float64) (float64, float64) &#123; var area = length * width var perimeter = (length + width) * 2 return area, perimeter&#125;func main() &#123; area, _ := rectProps(10.8, 5.6) // perimeter is discarded fmt.Printf(\"Area %f \", area)&#125; 四、函数的作用域作用域：变量可以使用的范围。 4.1 局部变量一个函数内部定义的变量，就叫做局部变量 变量在哪里定义，就只能在哪个范围使用，超出这个范围，我们认为变量就被销毁了。 4.2 全局变量一个函数外部定义的变量，就叫做全局变量 所有的函数都可以使用，而且共享这一份数据 五、函数的本质函数也是Go语言中的一种数据类型，可以作为另一个函数的参数，也可以作为另一个函数的返回值。 六、defer函数6.1 延迟是什么?即延迟（defer）语句，延迟语句被用于执行一个函数调用，在这个函数之前，延迟语句返回。 6.2 延迟函数你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题 如果有很多调用defer，那么defer是采用后进先出模式 在离开所在的方法时，执行（报错的时候也会执行） 1234567891011func ReadWrite() bool &#123; file.Open(\"file\") defer file.Close() if failureX &#123; return false &#125; i f failureY &#123; return false &#125; return true&#125; 最后才执行file.Close() 示例代码： 12345678910package mainimport \"fmt\"func main() &#123; a := 1 b := 2 defer fmt.Println(b) fmt.Println(a)&#125; 运行结果： 1212 示例代码： 1234567891011121314151617181920212223242526package mainimport ( \"fmt\")func finished() &#123; fmt.Println(\"Finished finding largest\")&#125;func largest(nums []int) &#123; defer finished() fmt.Println(\"Started finding largest\") max := nums[0] for _, v := range nums &#123; if v &gt; max &#123; max = v &#125; &#125; fmt.Println(\"Largest number in\", nums, \"is\", max)&#125;func main() &#123; nums := []int&#123;78, 109, 2, 563, 300&#125; largest(nums)&#125; 运行结果： 123Started finding largest Largest number in [78 109 2 563 300] is 563 Finished finding largest 6.3 延迟方法延迟并不仅仅局限于函数。延迟一个方法调用也是完全合法的。让我们编写一个小程序来测试这个。 示例代码： 123456789101112131415161718192021222324package mainimport ( \"fmt\")type person struct &#123; firstName string lastName string&#125;func (p person) fullName() &#123; fmt.Printf(\"%s %s\",p.firstName,p.lastName)&#125;func main() &#123; p := person &#123; firstName: \"John\", lastName: \"Smith\", &#125; defer p.fullName() fmt.Printf(\"Welcome \") &#125; 运行结果： 1Welcome John Smith 6.4 延迟参数延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。 让我们通过一个例子来理解这个问题。 示例代码： 12345678910111213141516package mainimport ( \"fmt\")func printA(a int) &#123; fmt.Println(\"value of a in deferred function\", a)&#125;func main() &#123; a := 5 defer printA(a) a = 10 fmt.Println(\"value of a before deferred function call\", a)&#125; 运行结果： 12value of a before deferred function call 10 value of a in deferred function 5 6.5 堆栈的推迟当一个函数有多个延迟调用时，它们被添加到一个堆栈中，并在Last In First Out（LIFO）后进先出的顺序中执行。 我们将编写一个小程序，它使用一堆defers打印一个字符串。示例代码： 1234567891011121314package mainimport ( \"fmt\")func main() &#123; name := \"Naveen\" fmt.Printf(\"Orignal String: %s\\n\", string(name)) fmt.Printf(\"Reversed String: \") for _, v := range []rune(name) &#123; defer fmt.Printf(\"%c\", v) &#125;&#125; 运行结果： 12Orignal String: Naveen Reversed String: neevaN 6.6 defer注意点1234defer函数：当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。 代码数组相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package mainimport \"fmt\"func main() &#123; /* 数据类型： 基本类型：整数，浮点，布尔，字符串 复合类型：array，slice，map，struct，pointer，function，channel。。。 数组： 1.概念：存储一组相同数据类型的数据结构 理解为容器，存储一组数据 2.语法： var 数组名 [长度] 数据类型 var 数组名 = [长度] 数据类型&#123;元素1，元素2.。。&#125; 数组名 := [...]数据类型&#123;元素。。。&#125; 3.通过下标访问 下标，也叫索引：index， 默认从0开始的整数，直到长度减1 数组名[index] 赋值 取值 不能越界：[0,长度-1] 4.长度和容量：go语言的内置函数 len(array/map/slice/string)，长度 cap()，容量 */ var num1 int num1 = 100 num1 = 200 fmt.Println(num1) fmt.Printf(\"%p\\n\",&amp;num1) //step1：创建数组 var arr1 [4] int fmt.Printf(\"%p\\n\",&amp;arr1) //step2：数组的访问 arr1[0] = 1 arr1[1] = 2 arr1[2] = 3 arr1[3] = 4 fmt.Println(arr1[0])//打印第一个数值 fmt.Println(arr1[2])//打印第三个数值 //fmt.Println(arr1[4]) //invalid array index 4 (out of bounds for 4-element array) fmt.Println(\"数组的长度：\",len(arr1)) //容器中实际存储的数据量 fmt.Println(\"数组的容量：\",cap(arr1)) //容器中能够存储的最大的数量 //因为数组定长，长度和容量相同 arr1[0] = 100 fmt.Println(arr1[0]) //数组的其他创建方式 var a [4] int //同 var a= [4] int fmt.Println(a) var b = [4]int&#123;1,2,3,4&#125; fmt.Println(b) var c = [5]int&#123;1,2,4&#125; fmt.Println(c) var d = [5]int&#123;1:1,3:2&#125; fmt.Println(d) var e = [5]string&#123;\"rose\",\"王二狗\",\"ruby\"&#125; fmt.Println(e) f := [...]int&#123;1,2,3,4,5&#125; fmt.Println(f) fmt.Println(len(f)) g:=[...]int&#123;1:3,6:5&#125; fmt.Println(g) fmt.Println(len(g))&#125;package mainimport \"fmt\"func main() &#123; /* 一维数组：存储的多个数据是数值本身 a1 :=[3]int&#123;1,2,3&#125; 二维数组：存储的是一维的一维 a2 := [3][4]int&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125; 该二维数组的长度，就是3。 存储的元素是一维数组，一维数组的元素是数值，每个一维数组长度为4。 多维数组：。。。 */ a2 := [3][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125; fmt.Println(a2) fmt.Printf(\"二维数组的地址：%p\\n\", &amp;a2) fmt.Printf(\"二维数组的长度：%d\\n\", len(a2)) fmt.Printf(\"一维数组的长度：%d\\n\", len(a2[0])) fmt.Println(a2[0][3]) // 4 fmt.Println(a2[1][2]) //7 fmt.Println(a2[2][1]) // 10 //遍历二维数组 for i:=0;i&lt;len(a2);i++&#123; for j:=0;j&lt;len(a2[i]);j++&#123; fmt.Print(a2[i][j],\"\\t\") &#125; fmt.Println() &#125; fmt.Println(\"---------------------\") //for range 遍历二维数组 for _,arr := range a2&#123; for _,val := range arr&#123; fmt.Print(val,\"\\t\") &#125; fmt.Println() &#125;&#125;package mainimport \"fmt\"func main() &#123; /* 数组的遍历： 依次访问数组中的元素 方法一：arr[0],arr[1],arr[2].... 方法二：通过循环，配合下标 for i:=0;i&lt;len(arr);i++&#123; arr[i] &#125; 方法三：使用range range，词义\"范围\" 不需要操作数组的下标，到达数组的末尾，自动结束for range循环。 每次都数组中获取下标和对应的数值。 */ arr1 := [5]int&#123;1,2,3,4,5&#125; fmt.Println(arr1[0]) fmt.Println(arr1[1]) fmt.Println(arr1[2]) fmt.Println(arr1[3]) fmt.Println(arr1[4]) fmt.Println(\"---------------\") for i:=0;i&lt;len(arr1);i++&#123; arr1[i] = i*2+1 fmt.Println(arr1[i]) &#125; fmt.Println(arr1) fmt.Println(\"----------------\") for index,value := range arr1&#123; fmt.Printf(\"下标是：%d,数值是:%d\\n\",index,value) &#125; sum := 0 for _,v:=range arr1&#123; sum += v &#125; fmt.Println(sum)&#125;package mainimport \"fmt\"func main() &#123; /* 数组的排序： 让数组中的元素具有一定的顺序。 arr :=[5]int&#123;15,23,8,10,7&#125; 升序：[7,8,10,15,23] 将序：[23,15,10,8,7] 排序算法： 冒泡排序，插入排序，选择排序，希尔排序，堆排序，快速排序。。。。 冒泡排序：（Bubble Sort） 依次比较两个相邻的元素，如果他们的顺序（如从大到小）就把他们交换过来。 */ arr := [5]int&#123;15, 23, 8, 10, 7&#125; ////第一轮排序 //for j := 0; j &lt; 4; j++ &#123; // if arr[j] &gt; arr[j+1] &#123; // arr[j], arr[j+1] = arr[j+1], arr[j] // &#125; //&#125; //fmt.Println(arr) // ////第二轮排序 //for j:=0;j&lt;3;j++&#123; // if arr[j] &gt; arr[j+1] &#123; // arr[j], arr[j+1] = arr[j+1], arr[j] // &#125; //&#125; //fmt.Println(arr) for i:=1;i&lt;len(arr);i++&#123; for j := 0; j &lt; len(arr)-i; j++ &#123; if arr[j] &gt; arr[j+1] &#123; arr[j], arr[j+1] = arr[j+1], arr[j] &#125; &#125; fmt.Println(arr) &#125;&#125;package mainimport \"fmt\"func main() &#123; /* 数据类型： 基本类型：int，float，string，bool。。 复合类型：array，slice，map，function，pointer，channel。。 数组的数据类型： [size]type 值类型：理解为存储的数值本身 将数据传递给其他的变量，传递的是数据的副本(备份) int,float,string,bool,array 引用类型：理解为存储的数据的内存地址 slice，map。。 */ //1.数据类型 num := 10 fmt.Printf(\"%T\\n\", num) arr1 := [4]int&#123;1, 2, 3, 4&#125; arr2 := [3]float64&#123;2.15, 3.18, 6.19&#125; arr3 := [4]int&#123;5, 6, 7, 8&#125; arr4 := [2]string&#123;\"hello\", \"world\"&#125; fmt.Printf(\"%T\\n\", arr1) //[4]int fmt.Printf(\"%T\\n\", arr2) //[3]float64 fmt.Printf(\"%T\\n\", arr3) //[4]int fmt.Printf(\"%T\\n\", arr4) //[2]string //2.赋值 num2 := num //值传递 fmt.Println(num, num2) //10 10 num2 = 20 fmt.Println(num, num2) //10 20 //数组呢 arr5 := arr1 //值传递 fmt.Println(arr1) fmt.Println(arr5) arr5[0] =1 fmt.Println(arr1) fmt.Println(arr5) a := 3 b := 4 fmt.Println(a==b) //比较a和b的数值是否相等 fmt.Println(arr5 == arr1) //比较数组的对应下标位置的数值是否相等 //fmt.Println(arr1 == arr2) //invalid operation: arr1 == arr2 (mismatched types [4]int and [3]float64)&#125; 切片相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package mainimport \"fmt\"func main() &#123; /* 数组array： 存储一组相同数据类型的数据结构。 特点：定长 切片slice： 同数组类似，也叫做变长数组或者动态数组。 特点：变长 是一个引用类型的容器，指向了一个底层数组。 make() func make(t Type, size ...IntegerType) Type 第一个参数：类型 slice，map，chan 第二个参数：长度len 实际存储元素的数量 第三个参数：容量cap 最多能够存储的元素的数量 append()，专门用于向切片的尾部追加元素 slice = append(slice, elem1, elem2) slice = append(slice, anotherSlice...) */ //1.数组 arr := [4]int&#123;1,2,3,4&#125;//定长 fmt.Println(arr) //2.切片 var s1 []int fmt.Println(s1) s2 := []int&#123;1,2,3,4&#125; //变长 fmt.Println(s2) fmt.Printf(\"%T,%T\\n\",arr,s2) //[4]int,[]int s3 := make([]int,3,8) fmt.Println(s3) fmt.Printf(\"容量：%d,长度：%d\\n\",cap(s3),len(s3)) s3[0] = 1 s3[1] = 2 s3[2] = 3 fmt.Println(s3) //fmt.Println(s3[3]) //panic: runtime error: index out of range //append() s4 := make([]int,0,5) fmt.Println(s4) s4 = append(s4,1,2) fmt.Println(s4) s4 = append(s4,3,4,5,6,7) fmt.Println(s4) s4 = append(s4,s3...) fmt.Println(s4) //遍历切片 for i:=0;i&lt;len(s4);i++&#123; fmt.Println(s4[i]) &#125; for i,v :=range s4&#123; fmt.Printf(\"%d--&gt;%d\\n\",i,v) &#125;&#125;package mainimport \"fmt\"func main() &#123; /* 切片Slice： 1.每一个切片引用了一个底层数组 2.切片本身不存储任何数据，都是这个底层数组存储，所以修改切片也就是修改这个数组中的数据 3.当向切片中添加数据时，如果没有超过容量，直接添加，如果超过容量，自动扩容(成倍增长) 4.切片一旦扩容，就是重新指向一个新的底层数组 s1:3---&gt;6---&gt;12---&gt;24 s2:4---&gt;8---&gt;16---&gt;32.... */ s1 := []int&#123;1, 2, 3&#125; fmt.Println(s1) fmt.Printf(\"len:%d,cap:%d\\n\", len(s1), cap(s1)) //len:3,cap:3 fmt.Printf(\"%p\\n\", s1) s1 = append(s1, 4, 5) fmt.Println(s1) fmt.Printf(\"len:%d,cap:%d\\n\", len(s1), cap(s1)) //len:5,cap:6 fmt.Printf(\"%p\\n\", s1) s1 = append(s1,6,7,8) fmt.Println(s1) fmt.Printf(\"len:%d,cap:%d\\n\", len(s1), cap(s1)) //len:8,cap:12 fmt.Printf(\"%p\\n\", s1) s1 = append(s1,9,10) fmt.Println(s1) fmt.Printf(\"len:%d,cap:%d\\n\", len(s1), cap(s1)) //len:10,cap:12 fmt.Printf(\"%p\\n\", s1) s1 = append(s1,11,12,13,14,15) fmt.Println(s1) fmt.Printf(\"len:%d,cap:%d\\n\", len(s1), cap(s1)) //len:15,cap:24 fmt.Printf(\"%p\\n\", s1)&#125;package mainimport \"fmt\"func main() &#123; /* slice := arr[start:end] 切片中的数据：[start,end) arr[:end],从头到end arr[start:]从start到末尾 从已有的数组上，直接创建切片，该切片的底层数组就是当前的数组。 长度是从start到end切割的数据量。 但是容量从start到数组的末尾。 */ a := [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; fmt.Println(\"----------1.已有数组直接创建切片--------------------\") s1 := a[:5] //1-5 s2 := a[3:8] //4-8 s3 := a[5:] // 6-10 s4 := a[:] // 1-10 fmt.Println(\"a:\", a) fmt.Println(\"s1:\", s1) fmt.Println(\"s2:\", s2) fmt.Println(\"s3:\", s3) fmt.Println(\"s4:\", s4) fmt.Printf(\"%p\\n\",&amp;a) fmt.Printf(\"%p\\n\",s1) fmt.Println(\"----------2.长度和容量--------------------\") fmt.Printf(\"s1 len:%d,cap:%d\\n\",len(s1),cap(s1)) //s1 len:5,cap:10 fmt.Printf(\"s2 len:%d,cap:%d\\n\",len(s2),cap(s2)) //s2 len:5,cap:7 fmt.Printf(\"s3 len:%d,cap:%d\\n\",len(s3),cap(s3)) //s3 len:5,cap:5 fmt.Printf(\"s4 len:%d,cap:%d\\n\",len(s4),cap(s4)) //s4 len:10,cap:10 fmt.Println(\"----------3.更改数组的内容--------------------\") a[4] =100 fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(\"----------4.更改切片的内容--------------------\") s2[2] =200 fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(\"----------4.更改切片的内容--------------------\") s1 = append(s1,1,1,1,1) fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(\"----------5.添加元素切片扩容--------------------\") fmt.Println(len(s1),cap(s1)) s1 = append(s1,2,2,2,2,2) fmt.Println(a) fmt.Println(s1) fmt.Println(s2) fmt.Println(s3) fmt.Println(len(s1),cap(s1)) fmt.Printf(\"%p\\n\",s1) fmt.Printf(\"%p\\n\",&amp;a)&#125;package mainimport \"fmt\"func main() &#123; /* 按照类型来分： 基本类型：int，float，string，bool 复合类型：array，slice，map，struct，pointer，function，chan 按照特点来分： 值类型：int，float，string，bool，array 传递的是数据副本 引用类型：Slice 传递的地址,多个变量指向了同一块内存地址， 所以：切片是引用类型的数据，存储了底层数组的引用 */ //1.数组：值类型 a1 := [4]int&#123;1,2,3,4&#125; a2 := a1 //值传递：传递的是数据 fmt.Println(a1,a1) a1[0] =100 fmt.Println(a1,a2) //2.切片：引用类型 s1 :=[]int&#123;1,2,3,4&#125; s2 := s1 fmt.Println(s1,s2) s1[0] =100 fmt.Println(s1,s2) fmt.Printf(\"%p\\n\",s1) fmt.Printf(\"%p\\n\",s2) fmt.Printf(\"%p\\n\",&amp;s1) fmt.Printf(\"%p\\n\",&amp;s2)&#125;package mainimport \"fmt\"func main() &#123; /* 深拷贝：拷贝的是数据本身。 值类型的数据，默认都是深拷贝：array，int，float，string，bool，struct 浅拷贝：拷贝的是数据 地址。 导致多个变量指向同一块内存 引用类型的数据，默认都是浅拷贝：slice，map， 因为切片是引用类型的数据，直接拷贝的是地址。 func copy(dst, src []Type) int 可以实现切片的拷贝 */ s1 := []int&#123;1,2,3,4&#125; s2 := make([]int,0) //len:0,cap:0 for i:=0;i&lt;len(s1);i++&#123; s2 = append(s2,s1[i]) &#125; fmt.Println(s1) fmt.Println(s2) s1[0] = 100 fmt.Println(s1) fmt.Println(s2) //copy() s3 := []int&#123;7,8,9&#125; fmt.Println(s2) fmt.Println(s3) //copy(s2,s3) //将s3中的元素，拷贝到s2中 //copy(s3,s2) //将s2中的元素，拷贝到s3中 copy(s3[1:],s2[2:]) fmt.Println(s2) fmt.Println(s3)&#125; 集合相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292package mainimport \"fmt\"func main() &#123; /* map：映射，是一种专门用于存储键值对的集合。属于引用类型 存储特点： A：存储的是无序的键值对 B：键不能重复，并且和value值一一对应的。 map中的key不能重复，如果重复，那么新的value会覆盖原来的，程序不会报错。 语法结构： 1.创建map var map1 map[key类型]value类型 nil map，无法直接使用 var map2 = make(map[key类型])value类型 var map3 = map[key类型]value类型&#123;key:value,key:value,key:value...&#125; 2.添加/修改 map[key]=value 如果key不存在，就是添加数据 如果key存在，就是修改数据 3.获取 map[key]--&gt;value value,ok := map[key] 根据key获取对应的value 如果key存在，value就是对应的数据，ok为true 如果key不存在，value就是值类型的默认值，ok为false 4.删除数据： delete(map，key) 如果key存在，就可以直接删除 如果key不存在，删除失败 5.长度： len() 每种数据类型： int：0 float：0.0--&gt;0 string:\"\" array:[00000] slice：nil map：nil */ //1.创建map var map1 map[int]string //没有初始化，nil var map2 = make(map[int]string) //创建 var map3 = map[string]int&#123;\"Go\": 98, \"Python\": 87, \"Java\": 79, \"Html\": 93&#125; fmt.Println(map1) fmt.Println(map2) fmt.Println(map3) fmt.Println(map1 == nil) fmt.Println(map2 == nil) fmt.Println(map3 == nil) //2.nil map if map1 == nil &#123; map1 = make(map[int]string) fmt.Println(map1 == nil) &#125; //3.存储键值对到map中 //map1[key] = value map1[1] = \"hello\" //panic: assignment to entry in nil map map1[2] = \"world\" map1[3] = \"memeda\" map1[4] = \"王二狗\" map1[5] = \"ruby\" map1[6] = \"三胖思密达\" map1[7] = \"\" //4.获取数据，根据key获取对应的value值 //根据key获取对应的value，如果key存在，获取数值，如果key不存在，获取的是value值类型的零值 fmt.Println(map1) fmt.Println(map1[4]) //根据key为4，获取对应的value值 fmt.Println(map1[40]) //\"\" v1,ok :=map1[40] if ok &#123; fmt.Println(\"对应的数值是：\",v1) &#125;else&#123; fmt.Println(\"操作的key不存在，获取到的是零值：\",v1) &#125; //5.修改数据 fmt.Println(map1) map1[3] = \"如花\" fmt.Println(map1) //6.删除数据 delete(map1,3) fmt.Println(map1) delete(map1,30) fmt.Println(map1) //7.长度 fmt.Println(len(map1))&#125;package mainimport ( \"fmt\" \"sort\")func main() &#123; /* map的遍历： 使用：for range 数组，切片：index，value map：key，value */ map1 := make(map[int]string) map1[1] = \"红孩儿\" map1[2] = \"小钻风\" map1[3] = \"白骨精\" map1[4] = \"白素贞\" map1[5] = \"金角大王\" map1[6] = \"王二狗\" //1.遍历map for k, v := range map1 &#123; fmt.Println(k, v) &#125; fmt.Println(\"----------------------\") for i:=1;i&lt;=len(map1);i++&#123; fmt.Println(i,\"---&gt;\",map1[i]) &#125; /* 1.获取所有的key，--&gt;切片/数组 2.进行排序 3.遍历key，---&gt;map[key] */ keys :=make([]int,0,len(map1)) fmt.Println(keys) for k,_:=range map1&#123; keys = append(keys,k) &#125; fmt.Println(keys) //冒泡排序，或者使用sort包下的排序方法 sort.Ints(keys) fmt.Println(keys) for _,key :=range keys&#123; fmt.Println(key,map1[key]) &#125; s1 :=[]string&#123;\"Apple\",\"Windows\",\"Orange\",\"abc\",\"王二狗\",\"acd\",\"acc\"&#125; fmt.Println(s1) sort.Strings(s1) fmt.Println(s1)&#125;package mainimport \"fmt\"func main() &#123; /* map和slice的结合使用： 1.创建map用于存储人的信息 name，age，sex，address 2.每个map存储一个人的信息 3.将这些map存入到slice中 4.打印遍历输出 */ //1.创建map存储第一个人的信息 map1 := make(map[string]string) map1[\"name\"]= \"王二狗\" map1[\"age\"] = \"30\" map1[\"sex\"] = \"男性\" map1[\"address\"] = \"北京市XX路XX号\" fmt.Println(map1) //2.第二个人 map2 := make(map[string]string) map2[\"name\"] = \"李小花\" map2[\"age\"] = \"20\" map2[\"sex\"] = \"女性\" map2[\"address\"] = \"上海市。。。\" fmt.Println(map2) //3. map3 := map[string]string&#123;\"name\":\"ruby\",\"age\":\"30\",\"sex\":\"女性\",\"address\":\"杭州市\"&#125; fmt.Println(map3) //将map存入到slice中 s1 := make([]map[string]string ,0,3) s1 = append(s1,map1) s1 = append(s1,map2) s1= append(s1,map3) //遍历切片 for i,val :=range s1 &#123; //val ：map1，map2，map3 fmt.Printf(\"第 %d 个人的信息是：\\n\",i+1) fmt.Printf(\"\\t姓名：%s\\n\",val[\"name\"]) fmt.Printf(\"\\t年龄：%s\\n\",val[\"age\"]) fmt.Printf(\"\\t性别：%s\\n\",val[\"sex\"]) fmt.Printf(\"\\t地址：%s\\n\",val[\"address\"]) &#125;&#125;package mainimport \"fmt\"func main() &#123; /* 一：数据类型： 基本数据类型：int，float，string，bool 复合数据类型：array，slice，map，function，pointer，struct。。。 array：[size]数据类型 slice：[]数据类型 map：map[key的类型]value的类型 二：存储特点： 值类型：int，float，string，bool，array，struct 引用类型：slice，map make()，slice，map，chan */ map1 := make(map[int]string) map2 :=make(map[string]float64) fmt.Printf(\"%T\\n\",map1) fmt.Printf(\"%T\\n\",map2) map3 := make(map[string]map[string]string) //map[string]map[string]string m1 :=make(map[string]string) m1[\"name\"] = \"王二狗\" m1[\"age\"] = \"30\" m1[\"salary\"] = \"3000\" map3[\"hr\"] = m1 m2 :=make(map[string]string) m2[\"name\"]=\"ruby\" m2[\"age\"]=\"28\" m2[\"salary\"]=\"8000\" map3[\"总经理\"]= m2 fmt.Println(map3) fmt.Println(\"---------------\") map4 := make(map[string]string) map4[\"王二狗\"] = \"矮矬穷\" map4[\"李小花\"] = \"白富美\" map4[\"ruby\"] = \"住在隔壁\" fmt.Println(map4) map5 := map4 fmt.Println(map5) map5[\"王二狗\"]= \"高富帅\" fmt.Println(map4) fmt.Println(map5)&#125; string相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192package mainimport \"fmt\"func main() &#123; /* Go中的字符串是一个字节的切片。 可以通过将其内容封装在“”中来创建字符串。Go中的字符串是Unicode兼容的，并且是UTF-8编码的。 字符串是一些字节的集合。 理解为一个字符的序列。 每个字符都有固定的位置(索引，下标，index：从0开始，到长度减1) 语法：\"\"，`` \"\" \"a\",\"b\",\"中\" \"abc\",\"hello\" 字符：---&gt;对应编码表中的编码值 A--&gt;65 B--&gt;66 a--&gt;97 ... 字节：byte--&gt;uint8 utf8 */ //1.定义字符串 s1 := \"hello中国\" s2 := `hello world` fmt.Println(s1) fmt.Println(s2) //2.字符串的长度：返回的是字节的个数 fmt.Println(len(s1)) fmt.Println(len(s2)) //3.获取某个字节 fmt.Println(s2[0])//获取字符串中的第一个字节 a := 'h' b := 104 fmt.Printf(\"%c,%c,%c\\n\",s2[0],a,b) //4.字符串的遍历 for i:=0;i&lt;len(s2);i++&#123; //fmt.Println(s2[i]) fmt.Printf(\"%c\\t\",s2[i]) &#125; fmt.Println() //for range for _,v := range s2&#123; //fmt.Println(i,v) fmt.Printf(\"%c\",v) &#125; fmt.Println() //5.字符串是字节的集合 slice1 := []byte&#123;65,66,67,68,69&#125; s3 := string(slice1) //根据一个字节切片，构建字符串 fmt.Println(s3) s4 := \"abcdef\" slice2 := []byte(s4) //根据字符串，获取对应的字节切片 fmt.Println(slice2) //6.字符串不能修改 fmt.Println(s4) //s4[2] = 'B'&#125;package mainimport ( \"fmt\" \"strings\")func main() &#123; /* strings包下的关于字符串的函数 */ s1 := \"helloworld\" //1.是否包含指定的内容--&gt;bool fmt.Println(strings.Contains(s1, \"abc\")) //2.是否包含chars中任意的一个字符即可 fmt.Println(strings.ContainsAny(s1, \"abcd\")) //3.统计substr在s中出现的次数 fmt.Println(strings.Count(s1, \"lloo\")) //4.以xxx前缀开头，以xxx后缀结尾 s2 := \"20190525课堂笔记.txt\" if strings.HasPrefix(s2, \"201905\") &#123; fmt.Println(\"19年5月的文件。。\") &#125; if strings.HasSuffix(s2, \".txt\") &#123; fmt.Println(\"文本文档。。\") &#125; //索引 //helloworld fmt.Println(strings.Index(s1, \"lloo\")) //查找substr在s中的位置，如果不存在就返回-1 fmt.Println(strings.IndexAny(s1, \"abcdh\")) //查找chars中任意的一个字符，出现在s中的位置 fmt.Println(strings.LastIndex(s1, \"l\")) //查找substr在s中最后一次出现的位置 //字符串的拼接 ss1 := []string&#123;\"abc\",\"world\",\"hello\",\"ruby\"&#125; s3 := strings.Join(ss1,\"-\") fmt.Println(s3) //切割 s4 := \"123,4563,aaa,49595,45\" ss2 := strings.Split(s4,\",\") //fmt.Println(ss2) for i := 0;i&lt;len(ss2);i++&#123; fmt.Println(ss2[i]) &#125; //重复，自己拼接自己count次 s5 :=strings.Repeat(\"hello\",5) fmt.Println(s5) //替换 //helloworld s6 := strings.Replace(s1,\"l\",\"*\",-1) fmt.Println(s6) //fmt.Println(strings.Repeat(\"hello\",5)) s7:=\"heLLo WOrlD**123..\" fmt.Println(strings.ToLower(s7)) fmt.Println(strings.ToUpper(s7)) /* 截取子串： substring(start,end)--&gt;substr str[start:end]--&gt;substr 包含start，不包含end下标 */ fmt.Println(s1) s8 := s1[:5] fmt.Println(s8) fmt.Println(s1[5:])&#125;package mainimport ( \"fmt\" \"strconv\")func main() &#123; /* strconv包：字符串和基本类型之前的转换 string convert */ //fmt.Println(\"aa\"+100) //1.bool类型 s1 := \"true\" b1,err := strconv.ParseBool(s1) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(\"%T,%t\\n\",b1,b1) ss1 := strconv.FormatBool(b1) fmt.Printf(\"%T,%s\\n\",ss1,ss1) //2.整数 s2 := \"100\" i2,err := strconv.ParseInt(s2,2,64) if err != nil&#123; fmt.Println(err) return &#125; fmt.Printf(\"%T,%d\\n\",i2,i2) ss2 := strconv.FormatInt(i2,10) fmt.Printf(\"%T,%s\\n\",ss2,ss2) //itoa(),atoi() i3,err := strconv.Atoi(\"-42\") //转为int类型 fmt.Printf(\"%T,%d\\n\",i3,i3) ss3:=strconv.Itoa(-42) fmt.Printf(\"%T,%s\\n\",ss3,ss3)&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"go-study-2","slug":"go-study-2","date":"2020-06-19T09:05:04.000Z","updated":"2020-06-19T09:33:21.182Z","comments":true,"path":"2020/06/19/go-study-2/","link":"","permalink":"http://nlbyd1119.online/2020/06/19/go-study-2/","excerpt":"Go基础学习其二","text":"Go基础学习其二 2020.6.18-19 搭建了go的环境，了解了go的特点和一些机制的特点，学习了基本语法：基本数据类型、运算符、控制语句，总体来说和c java等语言类似，但go给我的感觉是糅合了多个语言的特点，也有着自己的特别之处，因此本篇先总结一下我感觉和其他语言的差异之处，然后再copy千锋的笔记。个人总结一、文件结构与编译方式 go对项目文件的类型要求较严，应该和c的类似的，以包为划分单位和java包也类似，源码文件分为命令（程序入口）、库、测试三种，命令源码文件作为入口，必须package main并且有func main的，各种源码文件编译后的存放目录有区别，在前篇有说明。 go的导入其他包的方式，导包分为标准库、自写、第三方三种，使用import依次导入，类似java，但多个包导入的方式应该是go独有了。12345import ( \"math/rand\" \"fmt\" \"time\") go源码文件的编译和c的类似的。 可以说，因为go的在c基础上发展的，应该和c最为类似，包括结构体、指针等，还有输入输出的方式（暂时看到的一些类似的地方）。 二、代码风格 注释和c的一样的 //单行注释 /**/多行注释 行尾不需写分号的特点和python js类似 go特别地对花括号的位置要求很严格 go函数的定义 func 函数名(形参) 的方式和js类似 三、基本语法 go变量的声明类似js，但也有明显区别，还有一种独有的简短定义方式，多变量声明方式也较特别。 go的整型可以指定位数 int8 int32 int64 go的单精度浮点为 float32 双精度为 float64 go的常量命名严格为大写，有一个特殊的iota关键字 go的运算符整体和java类似 go的输入输出方式和c类似 fmt.Printf fmt.Scanf go的if的特有的写法123456789101112/* if语句的其他写法： if 初始化语句; 条件&#123; //注意变量的作用域问题 &#125; */ if num := 4; num &gt; 0&#123; fmt.Println(\"正数。。\",num) &#125;else if num &lt; 0&#123; fmt.Println(\"负数。。\",num) &#125; go的switch有和if类似的特有的初始化、case跟多值、fallthrough贯通case三个特殊之处。 go的循环只有for。 笔记 基本语法——变量 @author：韩茹 版权所有：北京千锋互联科技有限公司 一、变量的使用1.1 什么是变量变量是为存储特定类型的值而提供给内存位置的名称。在go中声明变量有多种语法。 所以变量的本质就是一小块内存，用于存储数据，在程序运行过程中数值可以改变 1.2 声明变量var名称类型是声明单个变量的语法。 以字母或下划线开头，由一个或多个字母、数字、下划线组成 声明一个变量 第一种，指定变量类型，声明后若不赋值，使用默认值 12var name typename = value 第二种，根据值自行判定变量类型(类型推断Type inference) 如果一个变量有一个初始值，Go将自动能够使用初始值来推断该变量的类型。因此，如果变量具有初始值，则可以省略变量声明中的类型。 1var name = value 第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明) 123456name := value// 例如var a int = 10var b = 10c : = 10 这种方式它只能被用在函数体内，而不可以用于全局变量的声明与赋值 示例代码： 12345678package mainvar a = \"Hello\"var b string = \"World\"var c boolfunc main()&#123; println(a, b, c)&#125; 运行结果： 1Hello World false 多变量声明第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值 12var name1, name2, name3 typename1, name2, name3 = v1, v2, v3 第二种，直接赋值，下面的变量类型可以是不同的类型 1var name1, name2, name3 = v1, v2, v3 第三种，集合类型 1234var ( name1 type1 name2 type2) 1.3 注意事项 变量必须先定义才能使用 go语言是静态语言，要求变量的类型和赋值的类型必须一致。 变量名不能冲突。(同一个作用于域内不能冲突) 简短定义方式，左边的变量名至少有一个是新的 简短定义方式，不能定义全局变量。 变量的零值。也叫默认值。 变量定义了就要使用，否则无法通过编译。 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a： 1234func main() &#123; var a string = \"abc\" fmt.Println(\"hello, world\")&#125; 尝试编译这段代码将得到错误 a declared and not used 此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用 在同一个作用域中，已存在同名的变量，则之后的声明初始化，则退化为赋值操作。但这个前提是，最少要有一个新的变量被定义，且在同一作用域，例如，下面的y就是新定义的变量 12345678910111213package mainimport ( \"fmt\")func main() &#123; x := 140 fmt.Println(&amp;x) x, y := 200, \"abc\" fmt.Println(&amp;x, x) fmt.Print(y)&#125; 运行结果： 1230xc04200a2b00xc04200a2b0 200abc 基本语法——常量constant一、常量的使用1.1 常量声明常量是一个简单值的标识符，在程序运行时，不会被修改的量。 1const identifier [type] = value 12显式类型定义： const b string = \"abc\"隐式类型定义： const b = \"abc\" 123456789101112131415package mainimport \"fmt\"func main() &#123; const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, \"str\" //多重赋值 area = LENGTH * WIDTH fmt.Printf(\"面积为 : %d\", area) println() println(a, b, c) &#125; 运行结果： 12面积为 : 501 false str 常量可以作为枚举，常量组 12345const ( Unknown = 0 Female = 1 Male = 2) 常量组中如不指定类型和初始化值，则与上一行非空常量右值相同 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; const ( x uint16 = 16 y s = \"abc\" z ) fmt.Printf(\"%T,%v\\n\", y, y) fmt.Printf(\"%T,%v\\n\", z, z)&#125; 运行结果： 12uint16,16string,abc 常量的注意事项： 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型 不曾使用的常量，在编译的时候，是不会报错的 显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值 1.2 iotaiota，特殊常量，可以认为是一个可以被编译器修改的常量 iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 12345const ( a = iota b c) iota 用法 123456789101112131415161718package mainimport \"fmt\"func main() &#123; const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125; 运行结果： 10 1 2 ha ha 100 100 7 8 如果中断iota自增，则必须显式恢复。且后续自增值按行序递增 自增默认是int类型，可以自行进行显示指定类型 数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 键盘输入和打印输出 作者：韩茹 出处：千锋教育 一、打印输出1.1 fmt包fmt包实现了类似C语言printf和scanf的格式化I/O。格式化verb（’verb’）源自C语言但更简单。 详见官网fmt的API：https://golang.google.cn/pkg/fmt/ 1.2 导入包1import \"fmt\" 1.3 常用打印函数打印： func Print(a …interface{}) (n int, err error) 格式化打印： func Printf(format string, a …interface{}) (n int, err error) 打印后换行 func Println(a …interface{}) (n int, err error) 格式化打印中的常用占位符： 123456789101112131415格式化打印占位符： %v,原样输出 %T，打印类型 %t,bool类型 %s，字符串 %f，浮点 %d，10进制的整数 %b，2进制的整数 %o，8进制 %x，%X，16进制 %x：0-9，a-f %X：0-9，A-F %c，打印字符 %p，打印地址 。。。 示例代码： 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\")func main() &#123; a := 100 //int b := 3.14 //float64 c := true // bool d := \"Hello World\" //string e := `Ruby` //string f := 'A' fmt.Printf(\"%T,%b\\n\", a, a) fmt.Printf(\"%T,%f\\n\", b, b) fmt.Printf(\"%T,%t\\n\", c, c) fmt.Printf(\"%T,%s\\n\", d, d) fmt.Printf(\"%T,%s\\n\", e, e) fmt.Printf(\"%T,%d,%c\\n\", f, f, f) fmt.Println(\"-----------------------\") fmt.Printf(\"%v\\n\", a) fmt.Printf(\"%v\\n\", b) fmt.Printf(\"%v\\n\", c) fmt.Printf(\"%v\\n\", d) fmt.Printf(\"%v\\n\", e) fmt.Printf(\"%v\\n\", f)&#125; 运行结果： 二、键盘输入2.1 fmt包读取键盘输入常用方法： func Scan(a …interface{}) (n int, err error) func Scanf(format string, a …interface{}) (n int, err error) func Scanln(a …interface{}) (n int, err error) 12345678910111213141516package mainimport ( \"fmt\")func main() &#123; var x int var y float64 fmt.Println(\"请输入一个整数，一个浮点类型：\") fmt.Scanln(&amp;x,&amp;y)//读取键盘的输入，通过操作地址，赋值给x和y 阻塞式 fmt.Printf(\"x的数值：%d，y的数值：%f\\n\",x,y) fmt.Scanf(\"%d,%f\",&amp;x,&amp;y) fmt.Printf(\"x:%d,y:%f\\n\",x,y)&#125; 运行结果： 2.2 bufio包读取https://golang.google.cn/pkg/bufio/ bufio包中都是IO操作的方法： 先创建Reader对象： 然后就可以各种读取了： 示例代码： 123456789101112131415package mainimport ( \"fmt\" \"os\" \"bufio\")func main() &#123; fmt.Println(\"请输入一个字符串：\") reader := bufio.NewReader(os.Stdin) s1, _ := reader.ReadString('\\n') fmt.Println(\"读到的数据：\", s1)&#125; 运行效果： 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 基本语法——数据类型 @author：韩茹 版权所有：北京千锋互联科技有限公司 一、基本数据类型以下是go中可用的基本数据类型 1.1 布尔型bool布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true 1.2 数值型1、整数型 int8有符号 8 位整型 (-128 到 127)长度：8bit int16有符号 16 位整型 (-32768 到 32767) int32有符号 32 位整型 (-2147483648 到 2147483647) int64有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) uint8无符号 8 位整型 (0 到 255)8位都用于表示数值： uint16无符号 16 位整型 (0 到 65535) uint32无符号 32 位整型 (0 到 4294967295) uint64无符号 64 位整型 (0 到 18446744073709551615) int和uint:根据底层平台，表示32或64位整数。除非需要使用特定大小的整数，否则通常应该使用int来表示整数。大小:32位系统32位，64位系统64位。范围:-2147483648到2147483647的32位系统和-9223372036854775808到9223372036854775807的64位系统。 2、浮点型 float32 IEEE-754 32位浮点型数 float64 IEEE-754 64位浮点型数 complex64 32 位实数和虚数 complex128 64 位实数和虚数 3、其他 byte 类似 uint8 rune 类似 int32 uint 32 或 64 位 int 与 uint 一样大小 uintptr 无符号整型，用于存放一个指针 1.3 字符串型字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本 12var str stringstr = \"Hello World\" 1.4 数据类型转换：Type Convert语法格式：Type(Value) 常数：在有需要的时候，会自动转型 变量：需要手动转型 T(V) 注意点：兼容类型可以转换 二、 复合类型(派生类型)1、指针类型（Pointer）2、数组类型3、结构化类型(struct)4、Channel 类型5、函数类型6、切片类型7、接口类型（interface）8、Map 类型 运算符表达式：(a + b) * c a,b,c叫做操作数 +，*，叫做运算符一、运算符1.1 算术运算符1+ - * / %(求余) ++ -- 1.2 关系运算符1== != &gt; &lt; &gt;= &lt;= 1.3 逻辑运算符 运算符 描述 &amp;&amp; 所谓逻辑与运算符。如果两个操作数都非零，则条件变为真 || 所谓的逻辑或操作。如果任何两个操作数是非零，则条件变为真 ! 所谓逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假 1.4 位运算符 A B A&amp;B A|B A^B 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 这里最难理解的就是^了，只要认为AB两者都相同的时候，为0，其他都为1 假设A为60，B为13 运算 描述 示例 &amp; 二进制与操作副本位的结果，如果它存在于两个操作数 (A &amp; B) = 12, 也就是 0000 1100 | 二进制或操作副本，如果它存在一个操作数 (A | B) = 61, 也就是 0011 1101 ^ 二进制异或操作副本，如果它被设置在一个操作数就是按位取非 (A ^ B) = 49, 也就是 0011 0001 &amp;^ 二进制位清空&amp;^ (A&amp;^B)=48，也就是110000 &lt;&lt; 二进制左移位运算符。左边的操作数的值向左移动由右操作数指定的位数 A &lt;&lt; 2 =240 也就是 1111 0000 &gt;&gt; 二进制向右移位运算符。左边的操作数的值由右操作数指定的位数向右移动 A &gt;&gt; 2 = 15 也就是 0000 1111 1.5 赋值运算符 运算符 描述 示例 = 简单的赋值操作符，分配值从右边的操作数左侧的操作数 C = A + B 将分配A + B的值到C += 相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数 C += A 相当于 C = C + A -= 减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数 C -= A 相当于 C = C - A *= 乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数 C *= A 相当于 C = C * A /= 除法赋值运算符，它把左操作数与右操作数和分配结果左操作数 C /= A 相当于 C = C / A %= 模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移位并赋值运算符 C &lt;&lt;= 2 相同于 C = C &lt;&lt; 2 &gt;&gt;= 向右移位并赋值运算符 C &gt;&gt;= 2 相同于 C = C &gt;&gt; 2 &amp;= 按位与赋值运算符 C &amp;= 2 相同于 C = C &amp; 2 ^= 按位异或并赋值运算符 C ^= 2 相同于 C = C ^ 2 |= 按位或并赋值运算符 C |= 2 相同于 C = C | 2 1.6优先级运算符优先级有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 7 ~ ! ++ – 6 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 5 + - ^ 4 == != &lt; &lt;= &gt;= &gt; 3 &lt;- 2 &amp;&amp; 1 || 当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 一、程序的流程结构 @author：韩茹 版权所有：北京千锋互联科技有限公司 程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。 顺序结构：从上向下，逐行执行。 选择结构：条件满足，某些代码才会执行。0-1次 ​ 分支语句：if，switch，select 循环结构：条件满足，某些代码会被反复的执行多次。0-N次 ​ 循环语句：for 二、条件语句2.1 if 语句语法格式： 123if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125; 12345if 布尔表达式 &#123; /* 在布尔表达式为 true 时执行 */&#125; else &#123; /* 在布尔表达式为 false 时执行 */&#125; 1234567if 布尔表达式1 &#123; /* 在布尔表达式1为 true 时执行 */&#125; else if 布尔表达式2&#123; /* 在布尔表达式1为 false ,布尔表达式2为true时执行 */&#125; else&#123; /* 在上面两个布尔表达式都为false时，执行*/&#125; 示例代码： 123456789101112131415package mainimport \"fmt\"func main() &#123; /* 定义局部变量 */ var a int = 10 /* 使用 if 语句判断布尔表达式 */ if a &lt; 20 &#123; /* 如果条件为 true 则执行以下语句 */ fmt.Printf(\"a 小于 20\\n\" ) &#125; fmt.Printf(\"a 的值为 : %d\\n\", a)&#125; 2.2 if 变体如果其中包含一个可选的语句组件(在评估条件之前执行)，则还有一个变体。它的语法是 1234567if statement; condition &#123; &#125;if condition&#123; &#125; 示例代码： 12345678910111213package mainimport ( \"fmt\")func main() &#123; if num := 10; num % 2 == 0 &#123; //checks if number is even fmt.Println(num,\"is even\") &#125; else &#123; fmt.Println(num,\"is odd\") &#125;&#125; 需要注意的是，num的定义在if里，那么只能够在该if..else语句块中使用，否则编译器会报错的。 2.3 switch语句：“开关”switch是一个条件语句，它计算表达式并将其与可能匹配的列表进行比较，并根据匹配执行代码块。它可以被认为是一种惯用的方式来写多个if else子句。 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break。 而如果switch没有表达式，它会匹配true Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。 12345678switch var1 &#123; case val1: ... case val2: ... default: ...&#125; 示例代码： 123456789101112131415161718192021222324252627282930package mainimport \"fmt\"func main() &#123; /* 定义局部变量 */ var grade string = \"B\" var marks int = 90 switch marks &#123; case 90: grade = \"A\" case 80: grade = \"B\" case 50,60,70 : grade = \"C\" //case 后可以由多个数值 default: grade = \"D\" &#125; switch &#123; case grade == \"A\" : fmt.Printf(\"优秀!\\n\" ) case grade == \"B\", grade == \"C\" : fmt.Printf(\"良好\\n\" ) case grade == \"D\" : fmt.Printf(\"及格\\n\" ) case grade == \"F\": fmt.Printf(\"不及格\\n\" ) default: fmt.Printf(\"差\\n\" ); &#125; fmt.Printf(\"你的等级是 %s\\n\", grade ); &#125; 2.4 fallthrough如需贯通后续的case，就添加fallthrough 1234567891011121314151617181920212223package mainimport ( \"fmt\")type data [2]intfunc main() &#123; switch x := 5; x &#123; default: fmt.Println(x) case 5: x += 10 fmt.Println(x) fallthrough case 6: x += 20 fmt.Println(x) &#125;&#125; 运行结果： 121535 case中的表达式是可选的，可以省略。如果该表达式被省略，则被认为是switch true，并且每个case表达式都被计算为true，并执行相应的代码块。 示例代码： 123456789101112131415161718package mainimport ( \"fmt\")func main() &#123; num := 75 switch &#123; // expression is omitted case num &gt;= 0 &amp;&amp; num &lt;= 50: fmt.Println(\"num is greater than 0 and less than 50\") case num &gt;= 51 &amp;&amp; num &lt;= 100: fmt.Println(\"num is greater than 51 and less than 100\") case num &gt;= 101: fmt.Println(\"num is greater than 100\") &#125;&#125; switch的注意事项 case后的常量值不能重复 case后可以有多个常量值 fallthrough应该是某个case的最后一行。如果它出现在中间的某个地方，编译器就会抛出错误。 2.5 Type Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。 123456789switch x.(type)&#123; case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s);&#125; 12345678910111213141516171819202122package mainimport \"fmt\"func main() &#123; var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(\" x 的类型 :%T\",i) case int: fmt.Printf(\"x 是 int 型\") case float64: fmt.Printf(\"x 是 float64 型\") case func(int) float64: fmt.Printf(\"x 是 func(int) 型\") case bool, string: fmt.Printf(\"x 是 bool 或 string 型\" ) default: fmt.Printf(\"未知型\") &#125; &#125; 运行结果： 1x 的类型 :&lt;nil&gt; 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 一、程序的流程结构 @author：韩茹 版权所有：北京千锋互联科技有限公司 程序的流程控制结构一共有三种：顺序结构，选择结构，循环结构。 顺序结构：代码从上向下逐行的执行 选择结构：条件满足，某些代码才会被执行。0-1次 ​ if语句，switch语句 循环结构：条件满足，某些代码会被反复的多次执行。0-n次 ​ for语句 二、循环语句循环语句表示条件满足，可以反复的执行某段代码。 for是唯一的循环语句。(Go没有while循环) ##2.1 for语句 语法结构： 1for init; condition; post &#123; &#125; 初始化语句只执行一次。在初始化循环之后，将检查该条件。如果条件计算为true，那么{}中的循环体将被执行，然后是post语句。post语句将在循环的每次成功迭代之后执行。在执行post语句之后，该条件将被重新检查。如果它是正确的，循环将继续执行，否则循环终止。 示例代码： 1234567891011package mainimport ( \"fmt\")func main() &#123; for i := 1; i &lt;= 10; i++ &#123; fmt.Printf(\" %d\",i) &#125;&#125; 在for循环中声明的变量仅在循环范围内可用。因此，i不能在外部访问循环。 2.2 for循环变体所有的三个组成部分，即初始化、条件和post都是可选的。 1for condition &#123; &#125; 效果与while相似 1for &#123; &#125; 效果与for(;;) 一样 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环 123for key, value :&#x3D; range oldMap &#123; newMap[key] &#x3D; value&#125; 12345678910111213141516171819202122232425package mainimport \"fmt\"func main() &#123; var b int = 15 var a int numbers := [6]int&#123;1, 2, 3, 5&#125; /* for 循环 */ for a := 0; a &lt; 10; a++ &#123; fmt.Printf(\"a 的值为: %d\\n\", a) &#125; for a &lt; b &#123; a++ fmt.Printf(\"a 的值为: %d\\n\", a) &#125; for i,x:= range numbers &#123; fmt.Printf(\"第 %d 位 x 的值 = %d\\n\", i,x) &#125; &#125; 运行结果： 12345678910111213141516171819202122232425262728293031a 的值为: 0a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 10a 的值为: 11a 的值为: 12a 的值为: 13a 的值为: 14a 的值为: 15第 0 位 x 的值 &#x3D; 1第 1 位 x 的值 &#x3D; 2第 2 位 x 的值 &#x3D; 3第 3 位 x 的值 &#x3D; 5第 4 位 x 的值 &#x3D; 0第 5 位 x 的值 &#x3D; 0 2.2 多层for循环for循环中又有循环嵌套，就表示多层循环了。 三、跳出循环的语句 @author：韩茹版权所有：北京千锋互联科技有限公司 1、 break语句break：跳出循环体。break语句用于在结束其正常执行之前突然终止for循环 示例代码： 123456789101112131415package mainimport ( \"fmt\")func main() &#123; for i := 1; i &lt;= 10; i++ &#123; if i &gt; 5 &#123; break //loop is terminated if i &gt; 5 &#125; fmt.Printf(\"%d \", i) &#125; fmt.Printf(\"\\nline after for loop\")&#125; 2、continue语句continue：跳出一次循环。continue语句用于跳过for循环的当前迭代。在continue语句后面的for循环中的所有代码将不会在当前迭代中执行。循环将继续到下一个迭代。 示例代码： 1234567891011121314package mainimport ( \"fmt\")func main() &#123; for i := 1; i &lt;= 10; i++ &#123; if i%2 == 0 &#123; continue &#125; fmt.Printf(\"%d \", i) &#125;&#125; 四、goto语句goto：可以无条件地转移到过程中指定的行。 语法结构： 1234goto label;....label: statement; 12345678910111213141516171819package mainimport \"fmt\"func main() &#123; /* 定义局部变量 */ var a int = 10 /* 循环 */ LOOP: for a &lt; 20 &#123; if a == 15 &#123; /* 跳过迭代 */ a = a + 1 goto LOOP &#125; fmt.Printf(\"a的值为 : %d\\n\", a) a++ &#125; &#125; 统一错误处理多处错误处理存在代码重复时是非常棘手的，例如： 12345678910111213 err := firstCheckError() if err != nil &#123; goto onExit &#125; err = secondCheckError() if err != nil &#123; goto onExit &#125; fmt.Println(\"done\") returnonExit: fmt.Println(err) exitProcess() 本文图片来源于网络 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"移动布局基础","slug":"移动布局基础","date":"2020-06-18T10:24:09.000Z","updated":"2020-06-23T11:27:37.009Z","comments":true,"path":"2020/06/18/移动布局基础/","link":"","permalink":"http://nlbyd1119.online/2020/06/18/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/","excerpt":"移动布局在设置视口标签为随设备调整的基础上，有两种实现方式，其一是编写专门的移动端界面，其二是将界面实现为响应式界面。专门的移动端界面的布局方式有流式布局（百分比布局）、flex布局、rem布局三种，响应式布局可以使用BootStrap框架实现。","text":"移动布局在设置视口标签为随设备调整的基础上，有两种实现方式，其一是编写专门的移动端界面，其二是将界面实现为响应式界面。专门的移动端界面的布局方式有流式布局（百分比布局）、flex布局、rem布局三种，响应式布局可以使用BootStrap框架实现。 移动web开发流式布局1.0 移动端基础1.1浏览器现状 PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。 移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。 国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。 总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。 1.2 手机屏幕的现状 移动端设备屏幕尺寸非常多，碎片化严重。 Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。 近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。 1.3常见移动端屏幕尺寸 1.4移动端调试方法 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器 使用外网服务器，直接IP或域名访问 2.0 视口视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口 2.1 布局视口 layout viewport一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 2.2视觉视口 visual viewport字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 2.3理想视口 ideal viewport为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口 2.4meta标签 最标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 3.0二倍图####3.1物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是 750* 1334 我们开发时候的1px 不是一定等于1个物理像素的 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放 lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊 在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题 3.2背景缩放background-sizebackground-size 属性规定背景图像的尺寸 1background-size: 背景图片宽度 背景图片高度; 单位： 长度|百分比|cover|contain; cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 4.0 移动开发选择和技术解决方案####4.1移动端主流方案 1.单独制作移动端页面（主流） 通常情况下，网址域名前面加 m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。 也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站 2.响应式页面兼容移动端（其次） 响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配 4.2 移动端技术解决方案1.移动端浏览器兼容问题 移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。 我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 2.移动端公共样式 移动端 CSS 初始化推荐使用 normalize.css/ Normalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址： http://necolas.github.io/normalize.css/ 4.3 移动端大量使用 CSS3盒子模型box-sizin传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 1234&#x2F;*CSS3盒子模型*&#x2F;box-sizing: border-box;&#x2F;*传统盒子模型*&#x2F;box-sizing: content-box; 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 4.4移动端特殊样式123456789&#x2F;*CSS3盒子模型*&#x2F;box-sizing: border-box;-webkit-box-sizing: border-box;&#x2F;*点击高亮我们需要清除清除 设置为transparent 完成透明*&#x2F;-webkit-tap-highlight-color: transparent;&#x2F;*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*&#x2F;-webkit-appearance: none;&#x2F;*禁用长按页面时的弹出菜单*&#x2F;img,a &#123; -webkit-touch-callout: none; &#125; 5.0移动端常见布局移动端单独制作 流式布局（百分比布局） flex 弹性布局（强烈推荐） less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp 流式布局： 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。 移动web开发——flex布局1.0传统布局和flex布局对比1.1传统布局 兼容性好 布局繁琐 局限性，不能再移动端很好的布局 1.2 flex布局 操作方便，布局极其简单，移动端使用比较广泛 pc端浏览器支持情况比较差 IE11或更低版本不支持flex或仅支持部分 1.3 建议 如果是pc端页面布局，还是采用传统方式 如果是移动端或者是不考虑兼容的pc则采用flex 2.0 flex布局原理 flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flexitem），简称”项目”。 总结：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 3.0 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap 3.1 flex-direction设置主轴的方向 在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴方向就是 y 轴方向，水平向下 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 3.2 justify-content 设置主轴上的子元素排列方式 3.3 flex-wrap设置是否换行 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。 nowrap 不换行 wrap 换行 3.4 align-items 设置侧轴上的子元素排列方式（单行 ） 该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用 flex-start 从头部开始 flex-end 从尾部开始 center 居中显示 stretch 拉伸 3.5 align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。 3.6 align-content 和align-items区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找align-items 多行找 align-content 3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性1flex-flow:row wrap; 4.0 flex布局子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） 4.1 flex 属性flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 123.item &#123; flex: &lt;number&gt;; &#x2F;* 默认值 0 *&#x2F;&#125; 4.2 align-self控制子项自己在侧轴上的排列方式align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 1234span:nth-child(2) &#123; &#x2F;* 设置自己在侧轴上的排列方式 *&#x2F; align-self: flex-end;&#125; 4.3 order 属性定义项目的排列顺序数值越小，排列越靠前，默认为0。 注意：和 z-index 不一样。 123.item &#123; order: &lt;number&gt;;&#125; 5.0 携程网首页案例制作携程网链接：http://m.ctrip.com 1.技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取flex布局 2.搭建相关文件夹 3.设置视口标签以及引入初始化样式 1234&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no,initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;normalize.css&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;index.css&quot;&gt; 4.常用初始化样式 12345678910body &#123; max-width: 540px; min-width: 320px; margin: 0 auto; font: normal 14px&#x2F;1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei; color: #000; background: #f2f2f2; overflow-x: hidden; -webkit-tap-highlight-color: transparent;&#125; 5.模块名字划分","categories":[{"name":"移动布局","slug":"移动布局","permalink":"http://nlbyd1119.online/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"go-study-1","slug":"go-study-1","date":"2020-06-18T10:23:40.000Z","updated":"2020-06-19T09:03:21.007Z","comments":true,"path":"2020/06/18/go-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/18/go-study-1/","excerpt":"Go基础学习其一","text":"Go基础学习其一 Go语言的核心特性 @author：韩茹版权所有：北京千锋互联科技有限公司 Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。 Go 编程语言是一个开源项目，它使程序员更具生产力。Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。(摘取自官网) 一、思想Less can be more 大道至简,小而蕴真 让事情变得复杂很容易，让事情变得简单才难 深刻的工程文化 二、核心特性Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。 2.1 并发编程Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。 不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。 由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，golang的并发编程简单比并发性能更具卖点。 在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，而golang中实现协程间通讯有两种：1）共享内存型，即使用全局变量+mutex锁来实现数据共享；2）消息传递型，即使用一种独有的channel机制进行异步通讯。 对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。 高并发是Golang语言最大的亮点 2.2 内存回收(GC)从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。 GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。 GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象，而slice或数组是一个对象，因此slice或数组有利于GC。 GC性能可能随着版本不断更新会不断优化，这块没仔细调研，团队中有HotSpot开发者，应该会借鉴jvm gc的设计思想，比如分代回收、safepoint等。 内存自动回收，再也不需要开发人员管理内存 开发人员专注业务实现，降低了心智负担 只需要new分配内存，不需要释放 2.3 内存分配初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。空闲内存会按照一定策略合并，以减少碎片。 2.4 编译编译涉及到两个问题：编译速度和依赖管理 目前Golang具有两种编译器，一种是建立在GCC基础上的Gccgo，另外一种是分别针对64位x64和32位x86计算机的一套编译器(6g和8g)。 依赖管理方面，由于golang绝大多数第三方开源库都在github上，在代码的import中加上对应的github路径就可以使用了，库会默认下载到工程的pkg目录下。 另外，编译时会默认检查代码中所有实体的使用情况，凡是没使用到的package或变量，都会编译不通过。这是golang挺严谨的一面。 2.5 网络编程由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、rpc用client.Call(‘class_name.method_name’, args, &amp;reply)，等等。 高性能HTTP Server 2.6 函数多返回值在C，C++中，包括其他的一些高级语言是不支持多个函数返回值的。但是这项功能又确实是需要的，所以在C语言中一般通过将返回值定义成一个结构体，或者通过函数的参数引用的形式进行返回。而在Go语言中，作为一种新型的语言，目标定位为强大的语言当然不能放弃对这一需求的满足，所以支持函数多返回值是必须的。 函数定义时可以在入参后面再加(a,b,c)，表示将有3个返回值a、b、c。这个特性在很多语言都有，比如python。 这个语法糖特性是有现实意义的，比如我们经常会要求接口返回一个三元组（errno,errmsg,data），在大多数只允许一个返回值的语言中，我们只能将三元组放入一个map或数组中返回，接收方还要写代码来检查返回值中包含了三元组，如果允许多返回值，则直接在函数定义层面上就做了强制，使代码更简洁安全。 2.7 语言交互性语言交互性指的是本语言是否能和其他语言交互，比如可以调用其他语言编译的库。 在Go语言中直接重用了大部份的C模块，这里称为Cgo.Cgo允许开发者混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。 golang可以和C程序交互，但不能和C++交互。可以有两种替代方案：1）先将c++编译成动态库，再由go调用一段c代码，c代码通过dlfcn库动态调用动态库（记得export LD_LIBRARY_PATH）；2）使用swig(没玩过) 2.8 异常处理golang不支持try…catch这样的结构化的异常解决方式，因为觉得会增加代码量，且会被滥用，不管多小的异常都抛出。golang提倡的异常处理方式是： 普通异常：被调用方返回error对象，调用方判断error对象。 严重异常：指的是中断性panic（比如除0），使用defer…recover…panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try…catch写得到处都是的情况。当然，用户也可以使用panic(‘xxxx’)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。 2.9 其他一些有趣的特性 类型推导：类型定义：支持var abc = 10这样的语法，让golang看上去有点像动态类型语言，但golang实际上时强类型的，前面的定义会被自动推导出是int类型。 作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。 简单来说，Go是一门写起来像动态语言，有着动态语言开发效率的静态语言。 一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显式去继承。 Go编程规范推荐每个Interface只提供一到两个的方法。这样使得每个接口的目的非常清晰。另外Go的隐式推导也使得我们组织程序架构的时候更加灵活。在写JAVA／C++程序的时候，我们一开始就需要把父类／子类／接口设计好，因为一旦后面有变更，修改起来会非常痛苦。而Go不一样，当你在实现的过程中发现某些方法可以抽象成接口的时候，你直接定义好这个接口就OK了，其他代码不需要做任何修改，编译器的自动推导会帮你做好一切。 不能循环引用：即如果a.go中import了b，则b.go要是import a会报import cycle not allowed。好处是可以避免一些潜在的编程危险，比如a中的func1()调用了b中的func2()，如果func2()也能调用func1()，将会导致无限循环调用下去。 defer机制：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。 可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。 “包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。 编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。 交叉编译：比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ 三、功能此处我们说个小段子：(引自网上某篇文章，具体是哪一篇想不起来了) 很久以前，有一个IT公司，这公司有个传统，允许员工拥有20%自由时间来开发实验性项目。在2007的某一天，公司的几个大牛，正在用c++开发一些比较繁琐但是核心的工作，主要包括庞大的分布式集群，大牛觉得很闹心，后来c++委员会来他们公司演讲，说c++将要添加大概35种新特性。这几个大牛的其中一个人，名为：Rob Pike，听后心中一万个xxx飘过，“c++特性还不够多吗？简化c++应该更有成就感吧”。于是乎，Rob Pike和其他几个大牛讨论了一下，怎么解决这个问题，过了一会，Rob Pike说要不我们自己搞个语言吧，名字叫“go”，非常简短，容易拼写。其他几位大牛就说好啊，然后他们找了块白板，在上面写下希望能有哪些功能。接下来的时间里，大牛们开心的讨论设计这门语言的特性，经过漫长的岁月，他们决定，以c语言为原型，以及借鉴其他语言的一些特性，来解放程序员，解放自己，然后在2009年，go语言诞生。 以下就是这些大牛所罗列出的Go要有的功能： 规范的语法（不需要符号表来解析） 垃圾回收（独有） 无头文件 明确的依赖 无循环依赖 常量只能是数字 int和int32是两种类型 字母大小写设置可见性（letter case sets visibility） 任何类型（type）都有方法（不是类型） 没有子类型继承（不是子类） 包级别初始化以及明确的初始化顺序 文件被编译到一个包里 包package-level globals presented in any order 没有数值类型转换（常量起辅助作用） 接口隐式实现（没有“implement”声明） 嵌入（不会提升到超类） 方法按照函数声明（没有特别的位置要求） 方法即函数 接口只有方法（没有数据） 方法通过名字匹配（而非类型） 没有构造函数和析构函数 postincrement（如++i）是状态，不是表达式 没有preincrement(i++)和predecrement 赋值不是表达式 明确赋值和函数调用中的计算顺序（没有“sequence point”） 没有指针运算 内存一直以零值初始化 局部变量取值合法 方法中没有“this” 分段的堆栈 没有静态和其它类型的注释 没有模板 内建string、slice和map 数组边界检查 大牛真身最大牌的当属B和C语言设计者、Unix和Plan 9创始人、1983年图灵奖获得者Ken Thompson，这份名单中还包括了Unix核心成员Rob Pike（go语言之父）、java HotSpot虚拟机和js v8引擎的开发者Robert Griesemer、Memcached作者Brad Fitzpatrick，等等。 本文图片来自网络，侵删 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundation Go语言和其他语言的对比 @author：韩茹版权所有：北京千锋互联科技有限公司 一、Go语言设计初衷1、设计Go语言是为了解决当时Google开发遇到的问题： 大量的C++代码，同时又引入了Java和Python 成千上万的工程师 数以万计行的代码 分布式的编译系统 数百万的服务器 2、Google开发中的痛点： 编译慢 失控的依赖 每个工程师只是用了一个语言里面的一部分 程序难以维护（可读性差、文档不清晰等） 更新的花费越来越长 交叉编译困难 3、如何解决当前的问题和痛点？ Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。 所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。 但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。 4、Go语言的特色： 没有继承多态的面向对象 强一致类型 interface不需要显式声明(Duck Typing) 没有异常处理(Error is value) 基于首字母的可访问特性 不用的import或者变量引起编译错误 完整而卓越的标准库包 Go内置runtime（作用是性能监控、垃圾回收等） 二、Go语言的优势1、学习曲线容易 ​ Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。 ​ Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。 2、效率：快速的编译时间，开发效率和运行效率高 ​ 开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。 C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。 3、出身名门、血统纯正 ​ 之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。 4、自由高效：组合的思想、无侵入式的接口 ​ Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。 ​ 5、强大的标准库 ​ 这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。Go 语言的 lib 库麻雀虽小五脏俱全。Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。 6、部署方便：二进制文件，Copy部署 ​ 这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。 7、简单的并发 并行和异步编程几乎无痛点。Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。 Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。 创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。 8、稳定性 ​ Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。 三、对比其他语言Go的很多语言特性借鉴与它的三个祖先：C，Pascal和CSP。Go的语法、数据类型、控制流等继承于C，Go的包、面对对象等思想来源于Pascal分支，而Go最大的语言特色，基于管道通信的协程并发模型，则借鉴于CSP分支。 Java编译语言，速度适中（2.67s），目前的大型网站都是拿java写的，比如淘宝、京东等。主要特点是稳定，开源性好，具有自己的一套编写规范，开发效率适中，目前最主流的语言。 作为编程语言中的大腕。具有最大的知名度和用户群。无论风起云涌，我自巍然不动。他强任他强，清风拂山岗；他横由他横，明月照大江。 c#执行速度快（4.28），学习难度适中，开发速度适中。但是由于c#存在很多缺点，京东、携程等大型网站前身都是用c#开发的，但是现在都迁移到了java上。 C/C++现存编程语言中的老祖，其他语言皆由此而生。执行速度最快无人能及。但是写起来最为复杂，开发难度大。 Javascript编程语言中特立独行的傲娇美女。前端处理能力是其它语言无法比拟。发展中的js后端处理能力也是卓越不凡。前后端通吃，舍我其谁？ Python脚本语言，速度最慢（258s），代码简洁、学习进度短，开发速度快。豆瓣就是拿python写的。Python著名的服务器框架有django，flask。但是python在大型项目上不太稳定，因此有些用python的企业后来迁移到了java上。 scala编译语言，比python快十倍，和java差不多，但是学习进度慢，而且在实际编程中，如果对语言不够精通，很容易造成性能严重下降。，后来比如Yammer就从scala迁移到了java上。微服务框架有lagom等。 Go编程界的小鲜肉。高并发能力无人能及。即具有像Python一样的简洁代码、开发速度，又具有C语言一样的执行效率，优势突出。 四、最后因为Go的语法和Erlang、Python类似，所以我们将这三门语言做个详细的对比。 相比于Python的40个特性，Go只有31个，可以说Go在语言设计上是相当克制的。比如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。 但是Go的特点也很鲜明，比如，它拥有协程、自动垃圾回收、包管理系统、一等公民的函数、栈空间管理等。 Go作为静态类型语言，保证了Go在运行效率、内存用量、类型安全都要强于Python和Erlang。 Go的数据类型也更加丰富，除了支持表、字典等复杂的数据结构，还支持指针和接口类型，这是Python和Erlang所没有的。特别是接口类型特别强大，它提供了管理类型系统的手段。而指针类型提供了管理内存的手段，这让Go进入底层软件开发提供了强有力的支持。 Go在面对对象的特性支持上做了很多反思和取舍，它没有类、虚函数、继承、泛型等特性。Go语言中面向对象编程的核心是组合和方法(function)。组合很类似于C语言的struct结构体的组合方式，方法类似于Java的接口(Interface)，但是使用方法上与对象更加解耦，减少了对对象内部的侵入。Erlang则不支持面对对象编程范式，相比而言，Python对面对对象范式的支持最为全面。 在函数式编程的特性支持上，Erlang作为函数式语言，支持最为全面。但是基本的函数式语言特性，如lambda、高阶函数、curry等，三种语言都支持。 控制流的特性支持上，三种语言都差不多。Erlang支持尾递归优化，这给它在函数式编程上带来便利。而Go在通过动态扩展协程栈的方式来支持深度递归调用。Python则在深度递归调用上经常被爆栈。 Go和Erlang的并发模型都来源于CSP，但是Erlang是基于actor和消息传递（mailbox）的并发实现，Go是基于goroutine和管道（channel）的并发实现。不管Erlang的actor还是Go的goroutine，都满足协程的特点：由编程语言实现和调度，切换在用户态完成，创建销毁开销很小。至于Python，其多线程的切换和调度是基于操作系统实现，而且因为GIL的大坑级存在，无法真正做到并行。 而且从笔者的并发编程体验上看，Erlang的函数式编程语法风格和其OTP behavior框架提供的晦涩的回调（callback）使用方法，对大部分的程序员，如C/C++和Java出身的程序员来说，有一定的入门门槛和挑战。而被称为“互联网时代的C”的Go，其类C的语法和控制流，以及面对对象的编程范式，编程体验则好很多。 本文图片来自网络，侵删 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundation Go语言能做什么 @author：韩茹版权所有：北京千锋互联科技有限公司 一、我们为什么选择Go语言选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑： 执行性能 缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。 依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。 开发效率 GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。 通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。 能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。 二、Go语言能做什么Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。 鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。 服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。 分布式系统、数据库代理器、中间件等，例如Etcd。 网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。 数据库操作 开发云平台，目前国外很多云平台在采用Go开发 三、国内外有哪些企业或项目使用Go语言Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发，最近热火朝天的Docker就是采用Go开发的。 使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。 云计算基础设施领域 代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。 基础软件 代表项目：tidb、influxdb、cockroachdb等。 微服务 代表项目：go-kit、micro、monzo bank的typhon、bilibili等。 互联网基础设施 代表项目：以太坊、hyperledger等。 采用Go的一些国外公司，如Google、Docker、Apple、Cloud Foundry、CloudFlare、Couchbase、CoreOS、Dropbox、MongoDB、AWS等公司； 采用Go开发的国内企业：如阿里云CDN、百度、小米、七牛、PingCAP、华为、金山软件、猎豹移动、饿了么等公司。 DockerDocker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。 项目链接： https://github.com/docker/docker go语言Go 语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。Go 语言的源码对了解 Go 语言的底层调度有极大的参考意义，建议希望对 Go 语言有深入了解的读者读一读。 项目链接： https://github.com/golang/go KubernetesGoogle 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。 项目链接： https://github.com/kubernetes/kubernetes etcd一款分布式、可靠的 KV 存储系统，可以快速进行云配置。 项目链接： https://github.com/coreos/etcd beegobeego 是一个类似 Python的 Tornado 框架，采用了 RESTFul 的设计思路，使用 Go 语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。 项目链接： https://github.com/astaxie/beego martini一款快速构建模块化的 Web 应用的 Web 框架。 项目链接： https://github.com/go-martini/martini codis国产的优秀分布式 Redis 解决方案。 项目链接： https://github.com/CodisLabs/codis delveGo语言 强大的调试器，被很多集成环境和编辑器整合。 项目链接： https://github.com/derekparker/delve FacebookFacebook也在用，为此他们还专门在Github上建立了一个开源组织facebookgo，大家可以通过https://github.com/facebookgo访问查看facebook开源的项目，比如著名的是平滑升级的grace。 Uber腾讯腾讯作为国内的大公司，还是敢于尝试的，尤其是Docker容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice 。 百度目前所知的百度的使用是在运维这边，是百度运维的一个BFE项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个 http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend 。 其次就是百度的消息系统。负责公司手百消息通讯系统服务器端开发及维护。 京东京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。 小米小米对Golang的支持，莫过于运维监控系统的开源，也就是 http://open-falcon.com/ 。 此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。 360360对Golang的使用也不少，一个是开源的日志搜索系统Poseidon，托管在Github上，https://github.com/Qihoo360/poseidon. 还有360的推送团队也在使用，他们还写了篇博文在Golang的官方博客上 https://blog.golang.org/qihoo。 七牛云七牛云用了近50万行代码，来实现整个产品。七牛云存储产品网址：http://qiniu.com/。上线时间：2011-9-1。应用范围：整个产品（包括基础服务、Web端、统计平台、各类小工具等等）Go代码行数占比：99.9%日 PV：保密 美团美团后台流量支撑程序。应用范围：支撑主站后台流量（排序，推荐，搜索等），提供负载均衡，cache，容错，按条件分流，统计运行指标（qps，latency）等功能。 滴滴基础服务平台。 ###金山微看 应用范围：服务接口，后台流程服务，消息系统，图片系统 搜狗搜狗推送系统。Push系统中用于维持与客户端连接的部分。 QOR - 模块化的电商系统 QOR官网: QOR: E-commerce &amp; CMS SDK written in Go github地址: qor/qor · GitHub 应用范围: 整个产品 weico产品名：weico 3.0， 服务端所有代码都是用Go实现。 仙侠道 产品网址：[仙侠道官网 - 心动游戏](仙侠道官网 - 心动游戏) 应用范围： 游戏服务端（通讯、逻辑、数据存储） 快玩游戏 网址：快玩小游戏,单机游戏,网页游戏,快玩游戏,快玩游戏盒 应用范围：实时消息系统、用户认证、用户会话、统一统计接口 盛大云CDN 网址：盛大云计算 应用范围：CDN的调度系统、分发系统、监控系统、短域名服务，CDN内部开放平台、运营报表系统以及其他一些小工具等 Bmob移动后端云服务平台 产品网址：Bmob移动后端云服务平台 应用范围：Restful API(使用Beego)、统计分析平台、常用服务如发邮件、队列异步处理、统计用户空间和接口请求 群策 网址：[群策 - 统一团队沟通，高效完成工作](群策 - 统一团队沟通，高效完成工作) 应用范围：全系统 BiddingX DSP广告投放系统 网址：BiddingX_专业的DSP解决方案供应商 应用范围：竞价投放、曝光统计、点击跳转 街坊四邻 网址：首页 - 街坊四邻 应用范围：后台服务 Leanote 网址：Leanote Bearychat 网址：BearyChat 宅豆 网址：宅豆网 - 自筑最美家，宅豆随你搭 白板- 设计图讨论工具 网址：白板 实验楼 网址：实验楼 - 第一家以实验为核心的IT在线教育平台 新浪微博中间件和弹性调度用 Java 和 Go 编写，微博视频转码及存储服务用 Go 编写。 爱奇艺VR 后台系统中间件，VR 端的 HTTP 接口。 猎豹移动消息推送 网易网易蜂巢容器公有云。 哔哩哔哩弹幕 巨人网络部分手机游戏的服务端。 今日头条Nsq：Nsq 是由Go语言开发的高性能、高可用消息队列系统，性能非常高，每天能处理数十亿条的消息； Packer:用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者 Skynet：分布式调度框架 Doozer：分布式同步工具，类似ZooKeeper Heka：mazila开源的日志处理系统 Cbfs：couchbase开源的分布式文件系统 Tsuru：开源的PAAS平台，和SAE实现的功能一模一样 Groupcache：memcahe作者写的用于Google下载系统的缓存系统 God：类似redis的缓存系统，但是支持分布式和扩展性 Gor：网络流量抓包和重放工具 还有很多，比如阿里中间件、聚美优品、高升控股、探探、斗鱼直播、人人车、亚信、Udesk、方付通、招财猫、三一集团、美餐网等。一般的选择，都是选择用于自己公司合适的产品系统来做，比如消息推送的、监控的、容器的等，Golang特别适合做网络并发的服务，这是他的强项，所以也是被优先用于这些项目。Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。 四、写在最后当然，一个技术能不能发展起来，关键还要看三点。(以下观点引自https://www.cnblogs.com/qwangxiao/p/8318894.html) 有没有一个比较好的社区。像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。 有没有一个工业化的标准。像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。 有没有一个或多个杀手级应用。C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。 上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如： 学习曲线是否低，上手是否快。这点非常重要，C++ 在这点上越做越不好了。 有没有一个不错的提高开发效率的开发框架。如：Java 的 Spring 框架，C++ 的 STL 等。 是否有一个或多个巨型的技术公司作为后盾。如：Java 和 Linux 后面的 IBM、Sun…… 有没有解决软件开发中的痛点。如：Java 解决了 C 和 C++ 的内存管理问题。 用这些标尺来量一下 Go 语言，我们可以清楚地看到： Go 语言容易上手； Go 语言解决了并发编程和写底层应用开发效率的痛点； Go 语言有 Google 这个世界一流的技术公司在后面； Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。 所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。 也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。 好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。 Docker 上手很容易。 Docker 解决了运维中的环境问题以及服务调度的痛点。 Docker 的生态圈中有大公司在后面助力。比如 Google。 Docker 产出了工业界标准 OCI。 Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。 …… 所以，虽然几年前的 Docker ，当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。 同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。 最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。 技术的发展过程非常重要。因为你可以清楚地看到了这种新技术的生态圈发展过程。让我们收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。 从中，我们看到了非常具体的各种思潮和思路，这些东西比起 技术本身来说更有价值。因为，这不但让我们重新思考已经掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性。 这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。 一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。 Go的应用范围一直在扩大，云计算，微服务，区块链，哪里都有用Go写的重量级项目。docker/kubernetes生态圈，几百/千万行代码，基本统治了云原生应用市场。去年大热的区块链，以太坊的geth，比特币的btcd，闪电网络的lnd，都是Go语言开发。还是那句话，多看看各种语言的生态，或许都并没有你想象的那么不堪。。。Go语言设计上确实不够“先进”，但也是另一种“务实”。其实go不管在国内还是国外已经很受待见了，国外google用的很多，uber也在用，国内有著名的今日头条，每日千亿级的访问妥妥的。多少语言终其一生都没有这么大的应用场景。 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av47467197 https://www.bilibili.com/video/av56018934/ 源代码： https://github.com/rubyhan1314/go_foundationhttps://www.bilibili.com/video/av47467197/?p=6 第一个程序：HelloWorld @author：韩茹 版权所有：北京千锋互联科技有限公司 一、go项目工程结构配置好工作目录后，就可以编码开发了，在这之前，我们看下go的通用项目结构，这里的结构主要是源代码相应地资源文件存放目录结构。 1.1 gopath目录gopath目录就是我们存储我们所编写源代码的目录。该目录下往往要有3个子目录：src，bin，pkg。 src —- 里面每一个子目录，就是一个包。包内是Go的源码文件 pkg —- 编译后生成的，包的目标文件 bin —- 生成的可执行文件。 1.2 编写第一个程序每个编程语言的学习，都是从一个”Hello, World.”程序开始的，这个例子首次出现于1978年出版的C语言圣经《The C Programming Language》。关于”Hello, World.”还有一个很美好的故事，那就是所有的程序员期待着计算机有一天能拥有真正的智能，然后对创造他的人们”发自内心”的说一句，Hello, World。 1.在HOME/go的目录下，(就是GOPATH目录里)，创建一个目录叫src，然后再该目录下创建一个文件夹叫hello，在该目录下创建一个文件叫helloworld.go，并双击打开，输入以下内容： 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, World!\")&#125; 2.执行go程序 执行go程序由几种方式 方式一：使用go run命令 ​ step1：打开终端： ​ window下使用快捷键win+R，输入cmd打开命令行提示符 ​ linux下可以使用快捷键：ctrl+alt+T ​ mac下command+空格，输入termainl ​ step2：进入helloworld.go所在的目录 ​ step3：输入go run helloworld.go命令并观察运行结果。 方式二：使用go build命令 ​ step1：打开终端：在任意文件路径下，运行:​ go install hello ​ 也可以进入项目(应用包)的路径，然后运行：​ go install 注意，在编译生成go程序的时，go实际上会去两个地方找程序包：GOROOT下的src文件夹下，以及GOPATH下的src文件夹下。 在程序包里，自动找main包的main函数作为程序入口，然后进行编译。 ​ step2：运行go程序​ 在/home/go/bin/下(如果之前没有bin目录则会自动创建)，会发现出现了一个hello的可执行文件，用如下命令运行:​ ./hello ​ 1.3 第一个程序的解释说明3.2.1 package 在同一个包下面的文件属于同一个工程文件，不用import包，可以直接使用 在同一个包下面的所有文件的package名，都是一样的 在同一个包下面的文件package名都建议设为是该目录名，但也可以不是 3.2.2 importimport “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包的函数，fmt 包实现了格式化 IO（输入/输出）的函数 可以是相对路径也可以是绝对路径，推荐使用绝对路径（起始于工程根目录） 点操作我们有时候会看到如下的方式导入包 123import( . \"fmt\") 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调 用的fmt.Println(&quot;hello world&quot;)可以省略的写成Println(&quot;hello world&quot;) 别名操作别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字 123import( f \"fmt\") 别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(&quot;hello world&quot;) _操作这个操作经常是让很多人费解的一个操作符，请看下面这个import 1234import ( \"database/sql\" _ \"github.com/ziutek/mymysql/godrv\") _操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数 3.3.3 mainmain(),是程序运行的入口。 1.4 包的说明我们知道源代码都是存放在GOPATH的src目录下，那么多个多个项目的时候，怎么区分呢？答案是通过包，使用包来组织我们的项目目录结构。有过java开发的都知道，使用包进行组织代码，包以网站域名开头就不会有重复，比如千锋的网站是http://www.mobiletrain.org，我们就可以以mobiletrain.org的名字创建一个文件夹，我自己的go项目都放在这个文件夹里，这样就不会和其他人的项目冲突，包名也是唯一的。 如果有自己的域名，那也可以使用自己的域名。如果没有个人域名，现在流行的做法是使用你个人的github名，因为每个人的是唯一的，所以也不会有重复。 如上，src目录下跟着一个个域名命名的文件夹。再以github.com文件夹为例，它里面又是以github用户名命名的文件夹，用于存储属于这个github用户编写的go源代码。 千锋Go语言的学习群：784190273 作者B站： https://space.bilibili.com/353694001 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation Go的执行原理以及Go的命令 @author：韩茹版权所有：北京千锋互联科技有限公司 一、Go的源码文件 Go 的源码文件分类： 如上图，分为三类： 1、命令源码文件： 声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。 命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。 命令源码文件是 Go 程序的入口。 同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。 我们先打开上次课的hello目录，然后复制helloworld.go为helloworld2.go文件，并修改里面的内容： 123456package mainimport \"fmt\"func main()&#123; fmt.Println(\"我是第二个helloworld文件\") fmt.Print(\"Go Go Go !!!\")&#125; hello目录下有两个go文件了，一个是helloworld.go，一个是helloworld2.go。先说明一下，在上述文件夹中放了两个命令源码文件，同时都声明自己属于 main 代码包。 打开终端，进入hello这个目录，也可以看到这两个文件： 123localhost:~ ruby cd go/src/hellolocalhost:hello ruby lshelloworld.go helloworld2.go 然后我们分别执行go run命令，可以看到两个go文件都可以被执行： 12345localhost:hello ruby$ go run helloworld.goHelloWorldGo Go Go !!!localhost:hello ruby$ go run helloworld2.go我是第二个helloworld文件Go Go Go !!! 接下来执行 go build 和 go install ，看看会发生什么： 123456789localhost:hello ruby$ go build # hello./helloworld2.go:3:6: main redeclared in this block previous declaration at ./helloworld.go:3:6localhost:hello ruby$ go install# hello./helloworld2.go:3:6: main redeclared in this block previous declaration at ./helloworld.go:3:6localhost:hello ruby$ 运行效果图： 这也就证明了多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。 同理，如果命令源码文件和库源码文件也会出现这样的问题，库源码文件不能通过 go build 和 go install 这种常规的方法编译和安装。具体例子和上述类似，这里就不再贴代码了。 所以命令源码文件应该是被单独放在一个代码包中。 2、库源码文件 库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。 库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。 3、测试源码文件 名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数： 123func TestXXX( t *testing.T) &#123;&#125; 名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。 123func BenchmarkXXX( b *testing.B) &#123;&#125; 名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。 现在答案就很明显了： 命令源码文件是可以单独运行的。可以使用 go run 命令直接运行，也可以通过 go build 或 go install 命令得到相应的可执行文件。所以命令源码文件是可以在机器的任何目录下运行的。 举个栗子： 比如平时我们在 LeetCode 上刷算法题，这时候写的就是一个程序，这就是命令源码文件，可以在电脑的任意一个文件夹新建一个 go 文件就可以开始刷题了，写完就可以运行，对比执行结果，答案对了就可以提交代码。 但是公司项目里面的代码就不能这样了，只能存放在 GOPATH 目录下。因为公司项目不可能只有命令源码文件的，肯定是包含库源码文件，甚至包含测试源码文件的。 二、Go的命令目前Go的最新版1.12里面基本命令有以下17个。 我们可以打开终端输入：go help即可看到Go的这些命令以及简介。 1234567891011121314151617bug start a bug reportbuild compile packages and dependenciesclean remove object files and cached filesdoc show documentation for package or symbolenv print Go environment informationfix update packages to use new APIsfmt gofmt (reformat) package sourcesgenerate generate Go files by processing sourceget download and install packages and dependenciesinstall compile and install packages and dependencieslist list packages or modulesmod module maintenancerun compile and run Go programtest test packagestool run specified go toolversion print Go versionvet report likely mistakes in packages 其中和编译相关的有build、get、install、run这4个。接下来就依次看看这四个的作用。 在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的： 名称 说明 -a 用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。 -n 使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。 -race 用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。 -v 用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。 -work 用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。 -x 使命令打印其执行过程中用到的所有命令，并同时执行它们。 1. go run专门用来运行命令源码文件的命令，注意，这个命令不是用来运行所有 Go 的源码文件的！ go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。 这个命令具体干了些什么事情呢？来分析分析，我们先重新创建一个新文件：mytest.go，并加入以下代码： 123456package mainimport \"fmt\"func main()&#123; fmt.Println(\"HelloWorld\") fmt.Println(\"你好，Go!!!\")&#125; 执行go run 配合-n： 1234567891011121314151617181920212223localhost:hello ruby$ go run -n mytest.go ## command-line-arguments#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; 'EOF' # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP -dwarf=false -goversion go1.12.1 -D _/Users/ruby/go/src/hello -importcfg $WORK/b001/importcfg -pack -c=4 ./mytest.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF' # internal... # 此处省略EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=vpgT856LhbZPXp6WeHib/ieg41NOobNF0eqq3xgnP/ieg41NOobNF0eqq3xgnP/vpgT856LhbZPXp6WeHib -extld=clang $WORK/b001/_pkg_.a$WORK/b001/exe/mytestlocalhost:hello ruby$ 运行效果图： 这里可以看到创建了两个临时文件夹 b001 和 exe，先执行了 compile 命令，然后 link，生成了归档文件.a 和 最终可执行文件，最终的可执行文件放在 exe 文件夹里面。命令的最后一步就是执行了可执行文件。 总结一下如下图： 举个例子，生成的临时文件可以用go run -work看到，比如当前生成的临时文件夹是如下的路径： 12345localhost:hello ruby$ go run -work mytest.go WORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496HelloWorld你好，Go!!!localhost:hello ruby$ 我们进入：/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build593750496目录，可以看到如下目录结构： 可以看到，最终go run命令是生成了2个文件，一个是归档文件，一个是可执行文件。 go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。 123456789101112localhost:hello ruby$ go run -n mytest.go mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF' # internalpackagefile command-line-arguments=/Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-dpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/mytest -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=goiqf_1cemqljgOYzSRA/ieg41NOobNF0eqq3xgnP/MVbHdxOky1BGK6Aq_4bM/goiqf_1cemqljgOYzSRA -extld=clang /Users/ruby/Library/Caches/go-build/6b/6b9577027c8da20b0ae6da790267f558b3b71eea1feb44039fb933b35eaef6f9-d$WORK/b001/exe/mytestlocalhost:hello ruby$ 2. go buildgo build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通包，当你执行go build命令后，不会产生任何文件。 如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/可执行文件。 如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。 go build 会忽略目录下以”_”或者”.”开头的go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。 当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。 123456789// 假设当前文件夹名叫 hellolocalhost:hello ruby$ pwd/Users/ruby/go/src/hellolocalhost:hello ruby$ lshelloworld.golocalhost:hello ruby$ go buildlocalhost:hello ruby$ lshello helloworld.golocalhost:hello ruby$ 于是在当前目录直接生成了以当前文件夹为名的可执行文件（ 在 Mac 平台下是 Unix executable 文件，在 Windows 平台下是 exe 文件） 但是这种情况下，如果使用 go install 命令，如果 GOPATH 里面只有一个工作区，就会在当前工作区的 bin 目录下生成相应的可执行文件。如果 GOPATH 下有多个工作区，则是在 GOBIN 下生成对应的可执行文件。 123localhost:hello ruby$ go installgo install hello: open /usr/local/go/bin/hello: permission deniedlocalhost:hello ruby$ 这个问题是因为它需要创建bin目录，然后把可刚才的可执行文件放进去，而目前我们在gopath下还没有bin目录，那么就需要先创建这个文件，而普通用户没有直接创建文件夹的权限，这个和Go语言的命令是没有关系的。我们可以加上sodu 来执行这个命令，表示使用管理员的身份执行，然后输入密码，那么就可以创建bin这个文件夹了。 再次执行： 123localhost:hello ruby$ sudo go installPassword:localhost:hello ruby$ 执行完 go install 会发现可执行文件不见了！去哪里了呢？其实是被移动到了 bin 目录下了（如果 GOPATH 下有多个工作区，就会放在GOBIN 目录下）。 查看目录： 那 go build 和 go install 究竟干了些什么呢？ 先来说说 go build。go build 用于编译我们指定的源码文件或代码包以及它们的依赖包。但是注意如果用来编译非命令源码文件，即库源码文件，go build 执行完是不会产生任何结果的。这种情况下，go build 命令只是检查库源码文件的有效性，只会做检查性的编译，而不会输出任何结果文件。 go build 编译命令源码文件，则会在该命令的执行目录中生成一个可执行文件，上面的例子也印证了这个过程。 go build 后面不追加目录路径的话，它就把当前目录作为代码包并进行编译。go build 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被编译。 go build 命令究竟做了些什么呢？我们可以执行-n这个命令来查看： 12345678910111213141516171819202122232425localhost:hello ruby$ go build -n## hello#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; 'EOF' # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc -goversion go1.12.1 -D \"\" -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF' # internalpackagefile hello=$WORK/b001/_pkg_.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=diTh1q6kcbGRIX3aj3mU/PXDetO1R1NhLFMK5QGUc/PXDetO1R1NhLFMK5QGUc/diTh1q6kcbGRIX3aj3mU -extld=clang $WORK/b001/_pkg_.a/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internalmv $WORK/b001/exe/a.out hellolocalhost:hello ruby$ 可以看到，执行过程和 go run 大体相同，唯一不同的就是在最后一步，go run 是执行了可执行文件，但是 go build 命令，只是把库源码文件编译了一遍，然后把可执行文件移动到了当前目录的文件夹中。 总结一下如下图： 最后： 3. go installgo install 命令是用来编译并安装代码包或者源码文件的。 go install 命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者.a包)，第二步会把编译好的结果移到$GOPATH/pkg或者​$GOPATH/bin。 可执行文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。 .a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。 go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于实际上，go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到指定目录。 安装代码包会在当前工作区的 pkg 的平台相关目录下生成归档文件（即 .a 文件）。安装命令源码文件会在当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）生成可执行文件。 同样，go install 命令如果后面不追加任何参数，它会把当前目录作为代码包并安装。这和 go build 命令是完全一样的。 go install 命令后面如果跟了代码包导入路径作为参数，那么该代码包及其依赖都会被安装。 go install 命令后面如果跟了命令源码文件以及相关库源码文件作为参数的话，只有这些文件会被编译并安装。 go install 命令究竟做了些什么呢？ 123456789101112131415161718192021222324252627localhost:hello ruby$ go install -n## hello#mkdir -p $WORK/b001/cat &gt;$WORK/b001/importcfg &lt;&lt; 'EOF' # internal# import configpackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.apackagefile runtime=/usr/local/go/pkg/darwin_amd64/runtime.aEOFcd /Users/ruby/go/src/hello/usr/local/go/pkg/tool/darwin_amd64/compile -o $WORK/b001/_pkg_.a -trimpath $WORK/b001 -p main -complete -buildid E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT -goversion go1.12.1 -D \"\" -importcfg $WORK/b001/importcfg -pack -c=4 ./helloworld.go/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/_pkg_.a # internalcat &gt;$WORK/b001/importcfg.link &lt;&lt; 'EOF' # internalpackagefile hello=$WORK/b001/_pkg_.apackagefile fmt=/usr/local/go/pkg/darwin_amd64/fmt.a...EOFmkdir -p $WORK/b001/exe/cd ./usr/local/go/pkg/tool/darwin_amd64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=exe -buildid=FJ6kJTmN9rcWcwLhqfiQ/E1CTs4eXkD5M28s_FQXT/E1CTs4eXkD5M28s_FQXT/FJ6kJTmN9rcWcwLhqfiQ -extld=clang $WORK/b001/_pkg_.a/usr/local/go/pkg/tool/darwin_amd64/buildid -w $WORK/b001/exe/a.out # internalmkdir -p /usr/local/go/bin/mv $WORK/b001/exe/a.out /usr/local/go/bin/hellolocalhost:hello ruby$ 前面几步依旧和 go run 、go build 完全一致，只是最后一步的差别，go install 会把命令源码文件安装到当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）。如果是库源码文件，就会被安装到当前工作区的 pkg 的平台相关目录下。 总结一下如下图： 在安装多个库源码文件时有可能遇到如下的问题： 12localhost:hello ruby$ go install envir.go fpath.go ipath.go pnode.go util.gogo install: no install location for .go files listed on command line (GOBIN not set) 而且，在我们为环境变量 GOBIN 设置了正确的值之后，这个错误提示信息仍然会出现。这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量 GOBIN 的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。所以，命令程序会同样返回一个关于“无安装位置”的错误。这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在 go install 命令罗列并安装它们。另外，go install 命令目前无法接受标记-o以自定义结果文件的存放位置。这也从侧面说明了 go install 命令不支持针对库源码文件的安装操作。 4. go getgo get 命令用于从远程代码仓库（比如 Github ）上下载并安装代码包。注意，go get 命令会把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装。 使用 go get 下载第三方包的时候，依旧会下载到 $GOPATH 的第一个工作空间，而非 vendor 目录。当前工作链中并没有真正意义上的包依赖管理，不过好在有不少第三方工具可选。 如果在 go get 下载过程中加入-d 标记，那么下载操作只会执行下载动作，而不执行安装动作。比如有些非常特殊的代码包在安装过程中需要有特殊的处理，所以我们需要先下载下来，所以就会用到-d 标记。 还有一个很有用的标记是-u标记，加上它可以利用网络来更新已有的代码包及其依赖包。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用-u标记来更新本地的对应的代码包。如果不加这个-u标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。只有加了-u标记，命令会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装。 命令 go get 还有一个很值得称道的功能——智能下载。在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装 Go 语言的版本是1.x，那么 go get 命令会在该代码包的远程仓库中寻找名为 “go1” 的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。 go get 常用的一些标记如下： 标记名称 标记描述 -d 让命令程序只执行下载动作，而不执行安装动作。 -f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 Fork 过来的，那么这样做就尤为重要了。 -fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。 -insecure 允许命令程序使用非安全的 scheme（如 HTTP ）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab ）没有HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它。 -t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 go get 命令究竟做了些什么呢？我们还是来打印一下每一步的执行过程。 1234567891011localhost:hello ruby$ go get -x github.com/go-errors/errorscd .git clone https://github.com/go-errors/errors /Users/ruby/go/src/github.com/go-errors/errorscd /Users/ruby/go/src/github.com/go-errors/errorsgit submodule update --init --recursivecd /Users/ruby/go/src/github.com/go-errors/errorsgit show-refcd /Users/ruby/go/src/github.com/go-errors/errorsgit submodule update --init --recursiveWORK=/var/folders/kt/nlhsnpgn6lgd_q16f8j83sbh0000gn/T/go-build188558329localhost:hello ruby$ 效果图： 这里可以很明显的看到，执行完 go get 命令以后，会调用 git clone 方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到 pkg 对应的相关平台目录下。 总结一下如下图： 5. 其他命令go clean go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由 go build 产生 DIR.test(.exe) 由 go test -c 产生 MAINFILE(.exe) 由 go build MAINFILE.go产生 go fmt go fmt 命令主要是用来帮你格式化所写好的代码文件。 比如我们写了一个格式很糟糕的 test.go 文件，我们只需要使用 fmt go test.go 命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。 使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。 go test go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag go doc go doc 命令其实就是一个很强大的文档工具。 如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf； 123456# 查看net/http包localhost:hello ruby$ go doc net/http# 查看time包localhost:hello ruby$ go doc time# 查看某个包里的指定函数localhost:hello ruby$ go doc fmt Printf 通过命令在命令行执行 go doc -http=:端口号，比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。 1localhost:hello ruby$ godoc -http=:9527 go fix 用来修复以前老版本的代码到新版本，例如go1之前老版本的代码转化到go1 go version 查看go当前的版本 go env 查看当前go的环境变量 go list 列出当前全部安装的package 本文部门文字和图片引自：https://www.jianshu.com/p/35a4ec1b3067 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation 编码规范 @author：韩茹版权所有：北京千锋互联科技有限公司 本规范旨在为日常Go项目开发提供一个代码的规范指导，方便团队形成一个统一的代码风格，提高代码的可读性，规范性和统一性。本规范将从命名规范，注释规范，代码风格和 Go 语言提供的常用的工具这几个方面做一个说明。该规范参考了 go 语言官方代码的风格制定。 一、 命名规范命名是代码规范中很重要的一部分，统一的命名规则有利于提高的代码的可读性，好的命名仅仅通过命名就可以获取到足够多的信息。 Go在命名时以字母a到Z或a到Z或下划线开头，后面跟着零或更多的字母、下划线和数字(0到9)。Go不允许在命名时中使用@、$和%等标点符号。Go是一种区分大小写的编程语言。因此，Manpower和manpower是两个不同的命名。 当命名（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）； 命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ） 1、包命名：package保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。 123package demopackage main 2、 文件命名尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。 1my_test.go 3、 结构体命名 采用驼峰命名法，首字母根据访问控制大写或者小写 struct 申明和初始化格式采用多行，例如下面： 1234567891011// 多行申明type User struct&#123; Username string Email string&#125;// 多行初始化u := User&#123; Username: \"astaxie\", Email: \"astaxie@gmail.com\",&#125; 4、 接口命名 命名规则基本和上面的结构体类型 单个函数的结构名以 “er” 作为后缀，例如 Reader , Writer 。 123type Reader interface &#123; Read(p []byte) (n int, err error)&#125; 5、变量命名 和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则： 如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID 错误示例：UrlArray，应该写成 urlArray 或者 URLArray 若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头 1234var isExist boolvar hasConflict boolvar canManage boolvar allowGitHook bool 6、常量命名常量均需使用全部大写字母组成，并使用下划线分词 1const APP_VER = \"1.0\" 如果是枚举类型的常量，需要先创建相应类型： 123456type Scheme stringconst ( HTTP Scheme = \"http\" HTTPS Scheme = \"https\") 7、 关键字下面的列表显示了Go中的保留字。这些保留字不能用作常量或变量或任何其他标识符名称。 二、注释Go提供C风格的/* */块注释和C ++风格的//行注释。行注释是常态；块注释主要显示为包注释，但在表达式中很有用或禁用大量代码。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释 多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段 go 语言自带的 godoc 工具可以根据注释生成文档，生成可以自动生成对应的网站（ golang.org 就是使用 godoc 工具直接生成的），注释的质量决定了生成的文档的质量。每个包都应该有一个包注释，在package子句之前有一个块注释。对于多文件包，包注释只需要存在于一个文件中，任何一个都可以。包评论应该介绍包，并提供与整个包相关的信息。它将首先出现在godoc页面上，并应设置下面的详细文档。 详细的如何写注释可以参考：http://golang.org/doc/effective_go.html#commentary 1、包注释每个包都应该有一个包注释，一个位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中（一般是和包同名的文件）即可。 包注释应该包含下面基本信息(请严格按照这个顺序，简介，创建人，创建时间）： 包的基本简介（包名，简介） 创建者，格式： 创建人： rtx 名 创建时间，格式：创建时间： yyyyMMdd 例如 util 包的注释示例如下 123// util 包， 该包包含了项目共用的一些常量，封装了项目中一些共用函数。// 创建人： hanru// 创建时间： 20190419 2、结构（接口）注释每个自定义的结构体或者接口都应该有注释说明，该注释对结构进行简要介绍，放在结构体定义的前一行，格式为： 结构体名， 结构体说明。同时结构体内的每个成员变量都要有说明，该说明放在成员变量的后面（注意对齐），实例如下： 12345// User ， 用户对象，定义了用户的基础信息type User struct&#123; Username string // 用户名 Email string // 邮箱&#125; 3、函数（方法）注释每个函数，或者方法（结构体或者接口下的函数称为方法）都应该有注释说明，函数的注释应该包括三个方面（严格按照此顺序撰写）： 简要说明，格式说明：以函数名开头，“，”分隔说明部分 参数列表：每行一个参数，参数名开头，“，”分隔说明部分 返回值： 每行一个返回值 示例如下： 1234567// NewtAttrModel ， 属性数据层操作类的工厂方法// 参数：// ctx ： 上下文信息// 返回值：// 属性操作类指针func NewAttrModel(ctx *common.Context) *AttrModel &#123;&#125; 4、代码逻辑注释对于一些关键位置的代码逻辑，或者局部较为复杂的逻辑，需要有相应的逻辑说明，方便其他开发者阅读该段代码，实例如下： 1234// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取xxxxxxxxxxxxxxxxxxx 5、注释风格统一使用中文注释，对于中英文字符之间严格使用空格分隔， 这个不仅仅是中文和英文之间，英文和中文标点之间也都要使用空格分隔，例如： 1// 从 Redis 中批量读取属性，对于没有读取到的 id ， 记录到一个数组里面，准备从 DB 中读取 上面 Redis 、 id 、 DB 和其他中文字符之间都是用了空格分隔。 建议全部使用单行注释 和代码的规范一样，单行注释不要过长，禁止超过 120 字符。 三、代码风格1、缩进和折行 缩进直接使用 gofmt 工具格式化即可（gofmt 是使用 tab 缩进的）； 折行方面，一行最长不超过120个字符，超过的请使用换行展示，尽量保持格式优雅。 我们使用Goland开发工具，可以直接使用快捷键：ctrl+alt+L，即可。 2、语句的结尾Go语言中是不需要类似于Java需要冒号结尾，默认一行就是一条数据 如果你打算将多个语句写在同一行，它们则必须使用 ; 3、括号和空格括号和空格方面，也可以直接使用 gofmt 工具格式化（go 会强制左大括号不换行，换行会报语法错误），所有的运算符和操作数之间要留空格。 12345678910// 正确的方式if a &gt; 0 &#123;&#125; // 错误的方式if a&gt;0 // a ，0 和 &gt; 之间应该空格&#123; // 左大括号不可以换行，会报语法错误&#125; 4、import 规范import在多行的情况下，goimports会自动帮你格式化，但是我们这里还是规范一下import的一些规范，如果你在一个文件里面引入了一个package，还是建议采用如下格式： 123import ( \"fmt\") 如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包： 1234567891011import ( \"encoding/json\" \"strings\" \"myproject/models\" \"myproject/controller\" \"myproject/utils\" \"github.com/astaxie/beego\" \"github.com/go-sql-driver/mysql\") 有顺序的引入包，不同的类型采用空格分离，第一种实标准库，第二是项目包，第三是第三方包。 在项目中不要使用相对路径引入包： 12345// 这是不好的导入import “../net”// 这是正确的做法import “github.com/repo/proj/src/net” 但是如果是引入本项目中的其他包，最好使用相对路径。 5、错误处理 错误处理的原则就是不能丢弃任何有返回err的调用，不要使用 _ 丢弃，必须全部处理。接收到错误，要么返回err，或者使用log记录下来 尽早return：一旦有错误发生，马上返回 尽量不要使用panic，除非你知道你在做什么 错误描述如果是英文必须为小写，不需要标点结尾 采用独立的错误流进行处理 12345678910111213// 错误写法if err != nil &#123; // error handling&#125; else &#123; // normal code&#125;// 正确写法if err != nil &#123; // error handling return // or continue, etc.&#125;// normal code 6、测试单元测试文件名命名规范为 example_test.go测试用例的函数名称必须以 Test 开头，例如：TestExample每个重要的函数都要首先编写测试用例，测试用例和正规代码一起提交方便进行回归测试 四、常用工具上面提到了很过规范， go 语言本身在代码规范性这方面也做了很多努力，很多限制都是强制语法要求，例如左大括号不换行，引用的包或者定义的变量不使用会报错，此外 go 还是提供了很多好用的工具帮助我们进行代码的规范， gofmt大部分的格式问题可以通过gofmt解决， gofmt 自动格式化代码，保证所有的 go 代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。 goimport我们强烈建议使用 goimport ，该工具在 gofmt 的基础上增加了自动删除和引入包. 1go get golang.org/x/tools/cmd/goimports go vetvet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。 1go get golang.org/x/tools/cmd/vet 使用如下： 1go vet . 千锋Go语言的学习群：784190273 对应视频地址： https://www.bilibili.com/video/av56018934 https://www.bilibili.com/video/av47467197 源代码： https://github.com/rubyhan1314/go_foundation","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"}]},{"title":"java-spider-1","slug":"java-spider-1","date":"2020-06-16T12:52:02.000Z","updated":"2020-06-16T14:58:20.571Z","comments":true,"path":"2020/06/16/java-spider-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/16/java-spider-1/","excerpt":"本文总结刚学习的两种java实现爬虫的方式：HttpClient获取网页内容 + Jsoup/Xpath/正则解析和使用WebMagic框架实现解析。需要注意的是，无论哪种实现方式，除了单独写爬虫外，都可以直接嵌入web框架中，嵌入SpringBoot框架可以直接启动运行，也可以嵌入ssm写的web项目中。","text":"本文总结刚学习的两种java实现爬虫的方式：HttpClient获取网页内容 + Jsoup/Xpath/正则解析和使用WebMagic框架实现解析。需要注意的是，无论哪种实现方式，除了单独写爬虫外，都可以直接嵌入web框架中，嵌入SpringBoot框架可以直接启动运行，也可以嵌入ssm写的web项目中。 （一）不使用框架的以HttpClient为基础的实现方式相关依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- HttpClient --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;!-- jsoup解析 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 文件处理相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 字符串处理相关 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.dom4j/dom4j --&gt; &lt;!-- xpath解析 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt; &lt;/dependency&gt; 一、HttpClientHttpClient是Java爬虫实现的底层基础，拥有按照需要设置请求方式、参数、信息、配置的功能，获取响应内容，供其他类进行解析。 get请求1234567891011121314151617181920212223242526272829303132333435public class HttpGetTest &#123; public static void main(String[] args) &#123; //创建HttpClient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); //创建HttpGet对象，设置url访问地址 HttpGet httpGet = new HttpGet(\"http://www.itcast.cn\"); //设置User-Agent httpGet.setHeader(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36\"); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取response response = httpClient.execute(httpGet); //解析响应 if (response.getStatusLine().getStatusCode() == 200) &#123; String content = EntityUtils.toString(response.getEntity(), \"utf8\"); System.out.println(content.length()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭response try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 带参数的get请求12345678//设置请求地址是：http://yun.itheima.com/search?keys=Java//创建URIBuilderURIBuilder uriBuilder = new URIBuilder(\"http://yun.itheima.com/search\");//设置参数uriBuilder.setParameter(\"keys\",\"Java\");//创建HttpGet对象，设置url访问地址HttpGet httpGet = new HttpGet(uriBuilder.build());System.out.println(\"发起请求的信息：\"+httpGet); post请求12//创建HttpPost对象，设置url访问地址HttpPost httpPost = new HttpPost(\"http://www.itcast.cn\"); 带参数的post请求12345678910//创建HttpPost对象，设置url访问地址HttpPost httpPost = new HttpPost(\"http://yun.itheima.com/search\");//声明List集合，封装表单中的参数List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();//设置请求地址是：http://yun.itheima.com/search?keys=Javaparams.add(new BasicNameValuePair(\"keys\",\"Java\"));//创建表单的Entity对象,第一个参数就是封装好的表单数据，第二个参数就是编码UrlEncodedFormEntity formEntity = new UrlEncodedFormEntity(params,\"utf8\");//设置表单的Entity对象到Post请求中httpPost.setEntity(formEntity); 请求配置12345678//创建HttpGet对象，设置url访问地址HttpGet httpGet = new HttpGet(\"http://www.itcast.cn\");//配置请求信息RequestConfig config = RequestConfig.custom().setConnectTimeout(1000) //创建连接的最长时间，单位是毫秒 .setConnectionRequestTimeout(500) //设置获取连接的最长时间，单位是毫秒 .setSocketTimeout(10*1000) //设置数据传输的最长时间，单位是毫秒 .build();//给请求设置请求信息 连接池将HttpClient交给连接池管理，注意和多线程区分。12345678910111213141516171819202122232425262728293031323334353637383940public class HttpClientPoolTest &#123; public static void main(String[] args) &#123; //创建连接池管理器 PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(); //设置最大连接数 cm.setMaxTotal(100); //设置每个主机的最大连接数 cm.setDefaultMaxPerRoute(10); //使用连接池管理器发起请求 doGet(cm); doGet(cm); &#125; private static void doGet(PoolingHttpClientConnectionManager cm) &#123; //不是每次创建新的HttpClient，而是从连接池中获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(cm).build(); HttpGet httpGet = new HttpGet(\"http://www.itcast.cn\"); CloseableHttpResponse response = null; try &#123; response = httpClient.execute(httpGet); if (response.getStatusLine().getStatusCode() == 200) &#123; String content = EntityUtils.toString(response.getEntity(), \"utf8\"); System.out.println(content.length()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //不能关闭HttpClient，由连接池管理HttpClient //httpClient.close(); &#125; &#125; &#125;&#125; 二、Jsoup参考： https://www.jianshu.com/p/24b2cfc415adjsoup首先是可以由url、字符串或文件解析获取dom对象，然后使用两类方法获取元素，其一是类似于js的document对象的一些方法，其二是类似于jquery的select相关的方法。1.介绍 123456jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。jsoup的主要功能如下：从一个URL，文件或字符串中解析HTML；使用DOM或CSS选择器来查找、取出数据；可操作HTML元素、属性、文本； 2.api（1）解析url、字符串、文件 1234567891011121314151617181920212223242526272829303132333435363738394041解析urlJsoup可以直接输入url，它会发起请求并获取数据，封装为Document对象@Testpublic void testJsoupUrl() throws Exception &#123; // 解析url地址 Document document = Jsoup.parse(new URL(\"http://www.itcast.cn/\"), 1000); //获取title的内容 Element title = document.getElementsByTag(\"title\").first(); System.out.println(title.text());&#125;PS：虽然使用Jsoup可以替代HttpClient直接发起请求解析数据，但是往往不会这样用，因为实际的开发过程中，需要使用到多线程，连接池，代理等等方式，而jsoup对这些的支持并不是很好，所以我们一般把jsoup仅仅作为Html解析工具使用解析字符串Jsoup可以直接输入字符串，并封装为Document对象@Testpublic void testJsoupString() throws Exception &#123; //读取文件获取 String html = FileUtils.readFileToString(new File(\"D:\\\\jsoup.html\"), \"UTF-8\"); // 解析字符串 Document document = Jsoup.parse(html); //获取title的内容 Element title = document.getElementsByTag(\"title\").first(); System.out.println(title.text());&#125;解析文件Jsoup可以直接解析文件，并封装为Document对象@Testpublic void testJsoupHtml() throws Exception &#123; // 解析文件 Document document = Jsoup.parse(new File(\"D:\\\\jsoup.html\"),\"UTF-8\"); //获取title的内容 Element title = document.getElementsByTag(\"title\").first(); System.out.println(title.text());&#125; （2）dom 1234567891011121314151617181920212223242526272829303132333435363738394041424344元素获取1. 根据id查询元素getElementById2. 根据标签获取元素getElementsByTag3. 根据class获取元素getElementsByClass4. 根据属性获取元素getElementsByAttribute//1. 根据id查询元素getElementByIdElement element = document.getElementById(\"city_bj\");//2. 根据标签获取元素getElementsByTagelement = document.getElementsByTag(\"title\").first();//3. 根据class获取元素getElementsByClasselement = document.getElementsByClass(\"s_name\").last();//4. 根据属性获取元素getElementsByAttributeelement = document.getElementsByAttribute(\"abc\").first();element = document.getElementsByAttributeValue(\"class\", \"city_con\").first(); 元素中获取数据1. 从元素中获取id2. 从元素中获取className3. 从元素中获取属性的值attr4. 从元素中获取所有属性attributes5. 从元素中获取文本内容text//获取元素Element element = document.getElementById(\"test\");//1. 从元素中获取idString str = element.id();//2. 从元素中获取classNamestr = element.className();//3. 从元素中获取属性的值attrstr = element.attr(\"id\");//4. 从元素中获取所有属性attributesstr = element.attributes().toString();//5. 从元素中获取文本内容textstr = element.text(); （3）使用选择器语法查找元素jsoup elements对象支持类似于CSS (或jquery)的选择器语法，来实现非常强大和灵活的查找功能。这个select 方法在Document, Element,或Elements对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。Select方法将返回一个Elements集合，并提供一组方法来抽取和处理结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Selector选择器概述tagname: 通过标签查找元素，比如：span#id: 通过ID查找元素，比如：# city_bj.class: 通过class名称查找元素，比如：.class_a[attribute]: 利用属性查找元素，比如：[abc][attr=value]: 利用属性值来查找元素，比如：[class=s_name]//tagname: 通过标签查找元素，比如：spanElements span = document.select(\"span\");for (Element element : span) &#123; System.out.println(element.text());&#125;//#id: 通过ID查找元素，比如：#city_bjjString str = document.select(\"#city_bj\").text();//.class: 通过class名称查找元素，比如：.class_astr = document.select(\".class_a\").text();//[attribute]: 利用属性查找元素，比如：[abc]str = document.select(\"[abc]\").text();//[attr=value]: 利用属性值来查找元素，比如：[class=s_name]str = document.select(\"[class=s_name]\").text();Selector选择器组合使用el#id: 元素+ID，比如： h3#city_bjel.class: 元素+class，比如： li.class_ael[attr]: 元素+属性名，比如： span[abc]任意组合: 比如：span[abc].s_nameancestor child: 查找某个元素下子元素，比如：.city_con li 查找\"city_con\"下的所有liparent &gt; child: 查找某个父元素下的直接子元素，比如：.city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级liparent &gt; *: 查找某个父元素下所有直接子元素//el#id: 元素+ID，比如： h3#city_bjString str = document.select(\"h3#city_bj\").text();//el.class: 元素+class，比如： li.class_astr = document.select(\"li.class_a\").text();//el[attr]: 元素+属性名，比如： span[abc]str = document.select(\"span[abc]\").text();//任意组合，比如：span[abc].s_namestr = document.select(\"span[abc].s_name\").text();//ancestor child: 查找某个元素下子元素，比如：.city_con li 查找\"city_con\"下的所有listr = document.select(\".city_con li\").text();//parent &gt; child: 查找某个父元素下的直接子元素，//比如：.city_con &gt; ul &gt; li 查找city_con第一级（直接子元素）的ul，再找所有ul下的第一级listr = document.select(\".city_con &gt; ul &gt; li\").text();//parent &gt; * 查找某个父元素下所有直接子元素.city_con &gt; *str = document.select(\".city_con &gt; *\").text(); 3.注意 jsoup还可与htmlcleaner使用xpath解析参考：https://blog.csdn.net/baidu_36336788/article/details/89875926 jsoup解析推荐的做法是，jsoup parse获得dom对象后，使用select，具体内容通过在网页选择元素–检查–右键–copy selector获取 三、HttpClient + Jsoup 案例案例由SpringBoot + SpringData JPA + HttpClient + Jsoup写成，将爬虫嵌入了应用中，实现了爬取结果保存在数据库中。1.核心代码HttpClient封装类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package cn.itcast.jd.util;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.util.EntityUtils;import org.springframework.stereotype.Component;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.UUID;@Componentpublic class HttpUtils &#123; private PoolingHttpClientConnectionManager cm; public HttpUtils() &#123; this.cm = new PoolingHttpClientConnectionManager(); //设置最大连接数 this.cm.setMaxTotal(100); //设置每个主机的最大连接数 this.cm.setDefaultMaxPerRoute(10); &#125; /** * 根据请求地址下载页面数据 * * @param url * @return 页面数据 */ public String doGetHtml(String url) &#123; //获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(this.cm).build(); //创建httpGet请求对象，设置url地址 HttpGet httpGet = new HttpGet(url); //设置请求信息 httpGet.setConfig(this.getConfig()); httpGet.setHeader(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36\"); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取响应 response = httpClient.execute(httpGet); //解析响应，返回结果 if (response.getStatusLine().getStatusCode() == 200) &#123; //判断响应体Entity是否不为空，如果不为空就可以使用EntityUtils if (response.getEntity() != null) &#123; String content = EntityUtils.toString(response.getEntity(), \"utf8\"); return content; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭response if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //返回空串 return \"\"; &#125; /** * 下载图片 * * @param url * @return 图片名称 */ public String doGetImage(String url) &#123; //获取HttpClient对象 CloseableHttpClient httpClient = HttpClients.custom().setConnectionManager(this.cm).build(); //创建httpGet请求对象，设置url地址 HttpGet httpGet = new HttpGet(url); //设置请求信息 httpGet.setConfig(this.getConfig()); //设置User-Agent httpGet.setHeader(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36\"); CloseableHttpResponse response = null; try &#123; //使用HttpClient发起请求，获取响应 response = httpClient.execute(httpGet); //解析响应，返回结果 if (response.getStatusLine().getStatusCode() == 200) &#123; //判断响应体Entity是否不为空 if (response.getEntity() != null) &#123; //下载图片 //获取图片的后缀 String extName = url.substring(url.lastIndexOf(\".\")); //创建图片名，重命名图片 String picName = UUID.randomUUID().toString() + extName; //下载图片 //声明OutPutStream OutputStream outputStream = new FileOutputStream(new File(\"C:\\\\images\\\\\" + picName)); response.getEntity().writeTo(outputStream); //返回图片名称 return picName; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭response if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //如果下载失败，返回空串 return \"\"; &#125; //设置请求信息 private RequestConfig getConfig() &#123; RequestConfig config = RequestConfig.custom() .setConnectTimeout(1000) //创建连接的最长时间 .setConnectionRequestTimeout(500) // 获取连接的最长时间 .setSocketTimeout(10000) //数据传输的最长时间 .build(); return config; &#125;&#125; 解析代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package cn.itcast.jd.task;import cn.itcast.jd.pojo.Item;import cn.itcast.jd.service.ItemService;import cn.itcast.jd.util.HttpUtils;import com.fasterxml.jackson.databind.ObjectMapper;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;import java.util.List;@Componentpublic class ItemTask &#123; @Autowired private HttpUtils httpUtils; @Autowired private ItemService itemService; private static final ObjectMapper MAPPER = new ObjectMapper(); //当下载任务完成后，间隔多长时间进行下一次的任务。 @Scheduled(fixedDelay = 100 * 1000) public void itemTask() throws Exception &#123; //声明需要解析的初始地址 String url = \"https://search.jd.com/Search?keyword=手机&amp;wq=手机&amp;page=\"; //按照页面对手机的搜索结果进行遍历解析 for (int i = 1; i &lt; 10; i = i + 2) &#123; String html = httpUtils.doGetHtml(url + i); System.out.println(html); //解析页面，获取商品数据并存储 this.parse(html); &#125; System.out.println(\"手机数据抓取完成！\"); &#125; //解析页面，获取商品数据并存储 private void parse(String html) throws Exception &#123; //解析html获取Document Document doc = Jsoup.parse(html); //获取spu信息 Elements spuEles = doc.select(\"div#J_goodsList &gt; ul &gt; li\"); for (Element spuEle : spuEles) &#123; if (spuEle.attr(\"data-spu\") == null || spuEle.attr(\"data-spu\").length() == 0) &#123; continue; &#125; //获取spu long spu = Long.parseLong(spuEle.attr(\"data-spu\")); //获取sku信息 Elements skuEles = spuEle.select(\"li.ps-item\"); for (Element skuEle : skuEles) &#123; //获取sku long sku = Long.parseLong(skuEle.select(\"[data-sku]\").attr(\"data-sku\")); //根据sku查询商品数据 Item item = new Item(); item.setSku(sku); List&lt;Item&gt; list = this.itemService.findAll(item); if(list.size()&gt;0) &#123; //如果商品存在，就进行下一个循环，该商品不保存，因为已存在 continue; &#125; //设置商品的spu item.setSpu(spu); //获取商品的详情的url String itemUrl = \"https://item.jd.com/\" + sku + \".html\"; item.setUrl(itemUrl); //获取商品的图片 String picUrl =\"https:\"+ skuEle.select(\"img[data-sku]\").first().attr(\"data-lazy-img\"); picUrl = picUrl.replace(\"/n9/\",\"/n1/\"); String picName = this.httpUtils.doGetImage(picUrl); item.setPic(picName); //获取商品的价格 String priceJson = this.httpUtils.doGetHtml(\"https://p.3.cn/prices/mgets?skuIds=J_\" + sku); double price = MAPPER.readTree(priceJson).get(0).get(\"p\").asDouble(); item.setPrice(price); //获取商品的标题 String itemInfo = this.httpUtils.doGetHtml(item.getUrl()); String title = Jsoup.parse(itemInfo).select(\"div.sku-name\").text(); item.setTitle(title); item.setCreated(new Date()); item.setUpdated(item.getCreated()); //保存商品数据到数据库中 this.itemService.save(item); &#125; &#125; &#125;&#125; 2.细节 springboot中定时任务的设置 使用了json相关的解析方法 四、其他解析方法针对不同页面数据，可以考虑其他的解析方式。1.xpath 使用dom4j参考 https://www.jianshu.com/p/806bb1bdc06f https://blog.csdn.net/xf_zhen/article/details/90440330https://www.cnblogs.com/ifme/p/12402570.htmlhttps://blog.csdn.net/zz13995900221/article/details/79826173https://blog.csdn.net/qq_40374604/article/details/84327419https://blog.csdn.net/qq_33371372/article/details/82318540?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-10.nonecase 2.正则参考 https://www.cnblogs.com/jingmoxukong/p/6026474.htmlhttps://www.cnblogs.com/jingmoxukong/p/6030197.htmlhttps://www.cnblogs.com/jingmoxukong/p/6040572.html （二）WebMagic相关依赖 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/us.codecraft/webmagic-core --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/us.codecraft/webmagic-extension --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--WebMagic对布隆过滤器的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;16.0&lt;/version&gt; &lt;/dependency&gt; 一、介绍1.概述WebMagic项目代码分为核心和扩展两部分。核心部分(webmagic-core)是一个精简的、模块化的爬虫实现，而扩展部分则包括一些便利的、实用性的功能。WebMagic的设计目标是尽量的模块化，并体现爬虫的功能特点。这部分提供非常简单、灵活的API，在基本不改变开发模式的情况下，编写一个爬虫。扩展部分(webmagic-extension)提供一些便捷的功能，例如注解模式编写爬虫等。同时内置了一些常用的组件，便于爬虫开发。2.架构 WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。3.四大组件 1234567891011121314151.DownloaderDownloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了Apache HttpClient作为下载工具。2.PageProcessorPageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要使用者定制的部分。3.SchedulerScheduler负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。4.PipelinePipeline负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。Pipeline定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个Pipeline。 4.三个数据流转对象 12345678910111213141. RequestRequest是对URL地址的一层封装，一个Request对应一个URL地址。它是PageProcessor与Downloader交互的载体，也是PageProcessor控制Downloader唯一方式。除了URL本身外，它还包含一个Key-Value结构的字段extra。你可以在extra中保存一些特殊的属性，然后在其他地方读取，以完成不同的功能。例如附加上一个页面的一些信息等。2. PagePage代表了从Downloader下载到的一个页面——可能是HTML，也可能是JSON或者其他文本格式的内容。Page是WebMagic抽取过程的核心对象，它提供一些方法可供抽取、结果保存等。3. ResultItemsResultItems相当于一个Map，它保存PageProcessor处理的结果，供Pipeline使用。它的API与Map很类似，值得注意的是它有一个字段skip，若设置为true，则不应被Pipeline处理。 二、功能1.实现PageProcessor抽取元素Selectable 123456789101112131415161718WebMagic里主要使用了三种抽取技术：XPath、正则表达式和CSS选择器。另外，对于JSON格式的内容，可使用JsonPath进行解析。1. XPath以上是获取属性class=mt的div标签，里面的h1标签的内容page.getHtml().xpath(\"//div[@class=mt]/h1/text()\")也可以参考课堂资料的W3School离线手册(2017.03.11版).chm2. CSS选择器CSS选择器是与XPath类似的语言。它比XPath写起来要简单一些，但是如果写复杂一点的抽取规则，就相对要麻烦一点。div.mt&gt;h1表示class为mt的div标签下的直接子元素h1标签page.getHtml().css(\"div.mt&gt;h1\").toString()可使用:nth-child(n)选择第几个元素，如下选择第一个元素page.getHtml().css(\"div#news_div &gt; ul &gt; li:nth-child(1) a\").toString()注意：需要使用&gt;，就是直接子元素才可以选择第几个元素3. 正则表达式正则表达式则是一种通用的文本抽取语言。在这里一般用于获取url地址。 抽取元素APISelectable相关的抽取元素链式API是WebMagic的一个核心功能。使用Selectable接口，可以直接完成页面元素的链式抽取，也无需去关心抽取的细节。page.getHtml()返回的是一个Html对象，它实现了Selectable接口。这个接口包含的方法分为两类：抽取部分和获取结果部分。获取结果API当链式调用结束时，我们一般都想要拿到一个字符串类型的结果。这时候就需要用到获取结果的API了。我们知道，一条抽取规则，无论是XPath、CSS选择器或者正则表达式，总有可能抽取到多条元素。WebMagic对这些进行了统一，可以通过不同的API获取到一个或者多个元素。)这里selectable.toString()采用了toString()这个接口，是为了在输出以及和一些框架结合的时候，更加方便。因为一般情况下，我们都只需要选择一个元素！selectable.all()则会获取到所有元素。获取链接 12345678910111213141516有了处理页面的逻辑，我们的爬虫就接近完工了，但是现在还有一个问题：一个站点的页面是很多的，一开始我们不可能全部列举出来，于是如何发现后续的链接，是一个爬虫不可缺少的一部分。下面的例子就是获取https://www.jd.com/moreSubject.aspx这个页面中所有符合https://www.jd.com/news.\\\\w+?.*正则表达式的url地址并将这些链接加入到待抓取的队列中去。public void process(Page page) &#123; page.addTargetRequests(page.getHtml().links() .regex(\"(https://www.jd.com/news.\\\\w+?.*)\").all()); System.out.println(page.getHtml().css(\"div.mt&gt;h1\").all());&#125;public static void main(String[] args) &#123; Spider.create(new JobProcessor()) .addUrl(\"https://www.jd.com/moreSubject.aspx\") .run();&#125; 2.使用Pipeline保存结果 1234567891011WebMagic用于保存结果的组件叫做Pipeline。我们现在通过“控制台输出结果”这件事也是通过一个内置的Pipeline完成的，它叫做ConsolePipeline。那么，我现在想要把结果用保存到文件中，怎么做呢？只将Pipeline的实现换成\"FilePipeline\"就可以了。public static void main(String[] args) &#123; Spider.create(new JobProcessor()) //初始访问url地址 .addUrl(\"https://www.jd.com/moreSubject.aspx\") .addPipeline(new FilePipeline(\"D:/webmagic/\")) .thread(5)//设置线程数 .run();&#125; 3.爬虫的启动、配置、终止入口SpiderSpider是爬虫启动的入口。在启动爬虫之前，我们需要使用一个PageProcessor创建一个Spider对象，然后使用run()进行启动。同时Spider的其他组件（Downloader、Scheduler、Pipeline）都可以通过set方法来进行设置。爬虫配置Site 12345678Site.me()可以对爬虫进行一些配置配置，包括编码、抓取间隔、超时时间、重试次数等。在这里我们先简单设置一下：重试次数为3次，抓取间隔为一秒。private Site site = Site.me() .setCharset(\"UTF-8\")//编码 .setSleepTime(1)//抓取间隔时间 .setTimeOut(1000*10)//超时时间 .setRetrySleepTime(3000)//重试时间 .setRetryTimes(3);//重试次数站点本身的一些配置信息，例如编码、HTTP头、超时时间、重试策略等、代理等，都可以通过设置Site对象来进行配置。 4.Scheduler组件在解析页面的时候，很可能会解析出相同的url地址(例如商品标题和商品图片超链接，而且url一样)，如果不进行处理，同样的url会解析处理多次，浪费资源。所以我们需要有一个url去重的功能。WebMagic提供了Scheduler可以帮助我们解决以上问题。Scheduler是WebMagic中进行URL管理的组件。一般来说，Scheduler包括两个作用：对待抓取的URL队列进行管理；对已抓取的URL进行去重。WebMagic内置了几个常用的Scheduler。如果你只是在本地执行规模比较小的爬虫，那么基本无需定制Scheduler，但是了解一下已经提供的几个Scheduler还是有意义的。去重部分被单独抽象成了一个接口：DuplicateRemover，从而可以为同一个Scheduler选择不同的去重方式，以适应不同的需要，目前提供了两种去重方式。 1234567891011121314151617181920RedisScheduler是使用Redis的set进行去重，其他的Scheduler默认都使用HashSetDuplicateRemover来进行去重。如果要使用BloomFilter，必须要加入以下依赖：&lt;!--WebMagic对布隆过滤器的支持--&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;16.0&lt;/version&gt;&lt;/dependency&gt;修改代码，添加布隆过滤器public static void main(String[] args) &#123; Spider.create(new JobProcessor()) //初始访问url地址 .addUrl(\"https://www.jd.com/moreSubject.aspx\") .addPipeline(new FilePipeline(\"D:/webmagic/\")) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) //参数设置需要对多少条数据去重 .thread(1)//设置线程数 .run();&#125; 三种去重方式 1234567891011HashSet使用java中的HashSet不能重复的特点去重。优点是容易理解。使用方便。缺点：占用内存大，性能较低。Redis去重使用Redis的set进行去重。优点是速度快（Redis本身速度就很快），而且去重不会占用爬虫服务器的资源，可以处理更大数据量的数据爬取。缺点：需要准备Redis服务器，增加开发和使用成本。布隆过滤器（BloomFilter）使用布隆过滤器也可以实现去重。优点是占用的内存要比使用HashSet要小的多，也适合大量数据的去重操作。缺点：有误判的可能。没有重复可能会判定重复，但是重复数据一定会判定重复。 4.使用和定制Pipeline在WebMagic中，Pileline是抽取结束后，进行处理的部分，它主要用于抽取结果的保存，也可以定制Pileline可以实现一些通用的功能。在这里我们会定制Pipeline实现数据导入到数据库中。Pipeline输出 1234567891011121314151617181920Pipeline的接口定义如下：public interface Pipeline &#123; // ResultItems保存了抽取结果，它是一个Map结构， // 在page.putField(key,value)中保存的数据， //可以通过ResultItems.get(key)获取 public void process(ResultItems resultItems, Task task);&#125;可以看到，Pipeline其实就是将PageProcessor抽取的结果，继续进行了处理的，其实在Pipeline中完成的功能，你基本上也可以直接在PageProcessor实现，那么为什么会有Pipeline？有几个原因：* 为了模块分离“页面抽取”和“后处理、持久化”是爬虫的两个阶段，将其分离开来，一个是代码结构比较清晰，另一个是以后也可能将其处理过程分开，分开在独立的线程以至于不同的机器执行。* Pipeline的功能比较固定，更容易做成通用组件每个页面的抽取方式千变万化，但是后续处理方式则比较固定，例如保存到文件、保存到数据库这种操作，这些对所有页面都是通用的。在WebMagic里，一个Spider可以有多个Pipeline，使用Spider.addPipeline()即可增加一个Pipeline。这些Pipeline都会得到处理，例如可以使用spider.addPipeline(new ConsolePipeline()).addPipeline(new FilePipeline())实现输出结果到控制台，并且保存到文件的目标。 已有的PipelineWebMagic中就已经提供了控制台输出、保存到文件、保存为JSON格式的文件几种通用的Pipeline。 三、爬虫分类 1234567891011121314151617181920网络爬虫按照系统结构和实现技术，大致可以分为以下几种类型：通用网络爬虫、聚焦网络爬虫、增量式网络爬虫、深层网络爬虫。 实际的网络爬虫系统通常是几种爬虫技术相结合实现的3.1. 通用网络爬虫通用网络爬虫又称全网爬虫（Scalable Web Crawler），爬行对象从一些种子 URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。 这类网络爬虫的爬行范围和数量巨大，对于爬行速度和存储空间要求较高，对于爬行页面的顺序要求相对较低，同时由于待刷新的页面太多，通常采用并行工作方式，但需要较长时间才能刷新一次页面。 简单的说就是互联网上抓取所有数据。3.2. 聚焦网络爬虫聚焦网络爬虫（Focused Crawler），又称主题网络爬虫（Topical Crawler），是指选择性地爬行那些与预先定义好的主题相关页面的网络爬虫。和通用网络爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，还可以很好地满足一些特定人群对特定领域信息的需求 。简单的说就是互联网上只抓取某一种数据。3.3. 增量式网络爬虫增量式网络爬虫（Incremental Web Crawler）是 指 对 已 下 载 网 页 采 取 增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面。和周期性爬行和刷新页面的网络爬虫相比，增量式爬虫只会在需要的时候爬行新产生或发生更新的页面 ，并不重新下载没有发生变化的页面，可有效减少数据下载量，及时更新已爬行的网页，减小时间和空间上的耗费，但是增加了爬行算法的复杂度和实现难度。简单的说就是互联网上只抓取刚刚更新的数据。3.4. Deep Web 爬虫Web 页面按存在方式可以分为表层网页（Surface Web）和深层网页（Deep Web，也称 Invisible Web Pages 或 Hidden Web）。 表层网页是指传统搜索引擎可以索引的页面，以超链接可以到达的静态网页为主构成的 Web 页面。Deep Web 是那些大部分内容不能通过静态链接获取的、隐藏在搜索表单后的，只有用户提交一些关键词才能获得的 Web 页面。 四、案例1. url解析功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Componentpublic class JobProcessor implements PageProcessor &#123; @Autowired private SpringDataPipeline springDataPipeline; @Scheduled(initialDelay = 1000, fixedDelay = 1000 * 100) public void process() &#123; //访问入口url地址 String url = \"https://search.51job.com/list/000000,000000,0000,01%252C32,9,99,java,2,1.html?lang=c&amp;stype=&amp;postchannel=0000&amp;workyear=99&amp;cotype=99&amp;degreefrom=99&amp;jobterm=99&amp;companysize=99&amp;providesalary=99&amp;lonlat=0%2C0&amp;radius=-1&amp;ord_field=0&amp;confirmdate=9&amp;fromType=&amp;dibiaoid=0&amp;address=&amp;line=&amp;specialarea=00&amp;from=&amp;welfare=\"; Spider.create(new JobProcessor()) .addUrl(url) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) .thread(5) .run(); &#125; @Override public void process(Page page) &#123; //获取页面数据 List&lt;Selectable&gt; nodes = page.getHtml().$(\"div#resultList div.el\").nodes(); //判断nodes是否为空 if (nodes.isEmpty()) &#123; try &#123; //如果为空，表示这是招聘信息详情页保存信息详情 this.saveJobInfo(page); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; else &#123; //如果有值，表示这是招聘信息列表页 for (Selectable node : nodes) &#123; //获取招聘信息详情页url String jobUrl = node.links().toString(); //添加到url任务列表中，等待下载 page.addTargetRequest(jobUrl); //获取翻页按钮的超链接 List&lt;String&gt; listUrl = page.getHtml().$(\"div.p_in li.bk\").links().all(); //添加到任务列表中 page.addTargetRequests(listUrl); &#125; &#125; &#125; 2.页面解析功能 1234567891011121314151617181920212223242526272829303132333435/** * 解析页面，获取招聘详情 * * @param */private void saveJobInfo(Page page) &#123; //创建招聘信息对象 JobInfo jobInfo = new JobInfo(); Html html = page.getHtml(); //公司名称 jobInfo.setCompanyName(html.$(\"div.tHeader p.cname a\", \"text\").toString()); //公司地址 jobInfo.setCompanyAddr(html.$(\"div.tBorderTop_box:nth-child(3) p.fp\", \"text\").toString()); //公司信息 jobInfo.setCompanyInfo(html.$(\"div.tmsg\", \"text\").toString()); //职位名称 jobInfo.setJobName(html.$(\"div.tHeader &gt; div.in &gt; div.cn &gt; h1\", \"text\").toString()); //工作地点 jobInfo.setJobAddr(html.$(\"div.tHeader &gt; div.in &gt; div.cn &gt; span.lname\", \"text\").toString()); //职位信息 jobInfo.setJobInfo(Jsoup.parse(html.$(\"div.tBorderTop_box:nth-child(2)\").toString()).text()); //工资范围 String salaryStr = html.$(\"div.tHeader &gt; div.in &gt; div.cn &gt; strong\", \"text\").toString(); jobInfo.setSalaryMin(MathSalary.getSalary(salaryStr)[0]); jobInfo.setSalaryMax(MathSalary.getSalary(salaryStr)[1]); //职位详情url jobInfo.setUrl(page.getUrl().toString()); //职位发布时间 String time = html.$(\"div.jtag &gt; div.t1 &gt; span.sp4\", \"text\").regex(\".*发布\").toString(); jobInfo.setTime(time.substring(0, time.length() - 2));//保存数据page.putField(\"jobInfo\", jobInfo);&#125; 3.案例自定义Pipeline导入数据 123456789101112131415161718192021222324252627282930313233//自定义SpringDataPipeline@Componentpublic class SpringDataPipeline implements Pipeline &#123; @Autowired private JobInfoService jobInfoService; @Override public void process(ResultItems resultItems, Task task) &#123; //获取需要保存到MySQL的数据 JobInfo jobInfo = resultItems.get(\"jobInfo\"); //判断获取到的数据不为空 if(jobInfo!=null) &#123; //如果有值则进行保存 this.jobInfoService.save(jobInfo); &#125; &#125;&#125;在JobProcessor中修改process()启动的逻辑，添加代码@Autowiredprivate SpringDataPipeline springDataPipeline;public void process() &#123; Spider.create(new JobProcessor()) .addUrl(url) .addPipeline(this.springDataPipeline) .setScheduler(new QueueScheduler() .setDuplicateRemover(new BloomFilterDuplicateRemover(10000000))) .thread(5) .run();&#125;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://nlbyd1119.online/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"六月中学习计划调整","slug":"六月中学习计划调整","date":"2020-06-15T11:28:00.000Z","updated":"2020-06-17T07:15:54.555Z","comments":true,"path":"2020/06/15/六月中学习计划调整/","link":"","permalink":"http://nlbyd1119.online/2020/06/15/%E5%85%AD%E6%9C%88%E4%B8%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E8%B0%83%E6%95%B4/","excerpt":"学习总结","text":"学习总结 自五月末起至六月中，基本把学期中想学的大部分草草过了一遍，从2019年2月底到2020年6月中旬，学的有些广而不精，主要以兴趣和即时需求为导向，导致目前学的广度还不太够，代码能力和思维更是弱，没有专精的技术，竞争力也几乎没有。本篇是在回顾学习过的内容的基础上，反思总结自身提高的切实需求，以为大四前一年学习的阶段方向的调整作出初步安排。一、技术栈虽学了不少，越发感觉语言并不那么关键，但基本技术点还是要按语言进行划分。1.java web开发 ssm、springboot框架基本掌握 安卓开发 基本控件、开发流程掌握 爬虫 2.python pyqt简单桌面应用开发 flask web开发 爬虫 3.前端 hcj基本语法与开发方式 jquery bootstrap等前端框架 4.新技术 以太坊原理 solidity编程 深度学习基本理论 5.数据分析 numpy pandas matplotlib基本使用 echarts 二、反思以上列出的这些所谓学习过的内容，大部分其实只是会个最基本的使用方式，我本身写代码的能力和实现功能的能力还太弱了。一年多以来，我以学习web开发为主，python实现功能为辅学习了以上内容，整个学习过程终究还是以一个实现粗浅的效果为目的，而不是真正掌握技术提高能力。因此，在下个阶段，我应当不是以实现个简单功能为目的，而是要切实提高自身能力，提高自身竞争力。但即便基于这样的考虑，仍然有不少不得不去做的或学的于自身益处不大的事，单纯只是外界任务或跟风，但也只能这样了。下面考虑下一些具体的方面。 三、具体策略1.首先，最关键的也最令我头疼的问题是如何学算法和刷题。从2018年底，我就始终想走一走这条很多人在走的路，但每次都是浅尝辄止，畏难。每次我都能找到其他优先学的内容，先前很多专业课没学，因此还可以说前备知识不足，但现在算法课都已经结课了，已经没有不深入学习的理由了。一直以来，我最困扰的是，不知如何入手、学习、练习才算正确的方式，遇到简单的题被难住就会放弃近期相关的学习计划，因此从未坚持学习过。如何真正开始学习，是一个关键问题。https://www.zhihu.com/question/23148377?utm_source=qq&amp;utm_medium=social&amp;utm_oi=10095223235520512002.第二，是深度学习的方向和学习方法的问题机器学习从2019年下半年就花了一个月看了书，2020年寒假还看了吴恩达的基础课程。但深度学习的方向和算法很多了，实践也是一个难题。如果无法看到代码的效果，很难有进一步学习的能力。但目前我已基本掌握了云端开发的方法，实践不是问题，那么选择什么方向呢。之前就在想先学基础的，然后就一直搁浅在基础的过不去。初步打算是先在云上练习基本案例后，走slam方向。3.第三，是区块链学习的问题。区块链相关的知识我已经接触了不少了。从比特币、以太坊到fabric。尽管学了不少，但其相关的资料文档、项目之少使我学习它的意志越来越不坚定。但创训用到了fabric，就不得不看，但说真的，相关的文档和教程真的太tm少了，这样学习的难度就太高了，什么网络集群什么的，对于我现在都是陌生概念，但只有硬着头皮学了。4.第四，是技术栈主体的问题。我的打算是以java后端开发为根基的。因此自身java的广度和深度、项目经验一定要够，要按面试要求严格要求自己。5.第五，是前端学习的问题。前端学习的目标是可以按需熟练地做一些基本的界面，且能够使用一些通用的框架，满足自身学习后端测试做项目的需求。6.第六，是使用python的问题。python的框架不宜再单独反复学了，应该在学习其他知识时直接应用练习。 四、算法学习策略1.先参考 https://www.zhihu.com/question/23148377?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1009522323552051200目的是找到学习方法，然后参考其中“帅地学编程”的回答，还是决定看书+刷leetcode关于复杂度 https://mp.weixin.qq.com/s/070nYGokM96aorZn6MZTDA下了一本答主的书 程序员内功修炼 参考阅读一下2.然后就是看哪些书的问题，之前看了基本都没有坚持下去参考公众号的，从这里保存了一些 https://github.com/iamshuaidi/CS-Book3.之前刷了几十道题，刷不动https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=leetcode%E5%88%B7%E4%B8%8D%E5%8A%A8&amp;fenlei=256&amp;oq=%25E5%25A4%25A7%25E5%258A%259B%25E7%259B%2598&amp;rsv_pq=8e5a002c003ff2b3&amp;rsv_t=dbfbmNH2sMQeVZ1hDGjFpEXREXli1dexLA%2BOZDtpgAUai6k6JbxJn9PE5n0&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=ts_0&amp;rsv_btype=t&amp;inputT=7953&amp;rsv_sug3=25&amp;rsv_sug1=23&amp;rsv_sug7=100&amp;rsv_sug2=1&amp;prefixsug=leetcode%25E5%2588%25B7bud&amp;rsp=0&amp;rsv_sug4=9847https://www.v2ex.com/amp/t/497226/3https://www.zhihu.com/question/38067711https://zhidao.baidu.com/question/2054890257842843987.htmlhttps://www.zhihu.com/question/325183261/answer/888875227https://zhuanlan.zhihu.com/p/104983442https://www.zhihu.com/question/386655212还是需要分专题 由易到难 有基础4.那么到底如何刷leetcodehttps://www.baidu.com/s?wd=%E5%A6%82%E4%BD%95%E5%88%B7leetcode&amp;rsv_spt=1&amp;rsv_iqid=0xd95cb35a0006b96f&amp;issp=1&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=e-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ts_0&amp;rsv_sug3=14&amp;rsv_sug1=9&amp;rsv_sug7=101&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=%25E5%25A6%2582%25E4%25BD%2595%25E5%2588%25B7lee&amp;rsp=0&amp;inputT=4827&amp;rsv_sug4=5761https://www.zhihu.com/question/3217380585.个人计划牛客视频–选本书看 建立系统概念分专题刷题–总结6.补充看公众号时，顺便找了网易云java进阶的内容还有感觉有必要看看计算机网络https://www.bilibili.com/video/BV1Tb411x7CE?p=2 五、深度学习学习策略1.华为云ModelArts案例实践 https://gitee.com/ModelArts/ModelArts-Lab?_from=gitee_search华为云代码 控制台案例 https://console.huaweicloud.com/modelarts/?agencyId=082f21989980258b1f3ac0039c7558cb&amp;region=cn-north-4&amp;locale=zh-cn#/dashboard 同学帮 代码https://gitee.com/swjtugx/classmate 2.准确率(Accuracy), 精确率(Precision), 召回率(Recall)和F1-Measurehttps://blog.csdn.net/u012879957/article/details/805641483.学习方向问题预计在学习几个基础算法和模型后，学习slam六、fabric学习策略1.fabric的资料是真的少 版本越新资料越少 版本差异还大。。2.暂时只能先参考视频教程，先看一遍，再做决定，预计需要超过一台服务器。。华为云 https://www.bilibili.com/video/BV1pE411Y7DJ/?spm_id_from=333.788.videocard.0https://www.bilibili.com/video/BV1DA41147vT?p=1https://www.bilibili.com/video/BV13E411u7Pj?from=search&amp;seid=16863221312345198510BTCU高校区块链社区https://space.bilibili.com/477534964?spm_id_from=333.788.b_765f7570696e666f.1先就这两部分视频看一看，看书太费劲了。。3.博文https://www.cnblogs.com/aberic/p/7527831.html4.退出fabric网络测试ctrl+z即可5.ftp连接服务https://jingyan.baidu.com/article/03b2f78c6b5bc05ea237aee2.html七、java深入学习策略1.java进一步学习，一是框架学习练习，而是底层与高级特性全看面试要求和项目需求。2.jvm 为什么要学jvmhttps://www.cnblogs.com/yichunguo/p/11849922.htmlhttps://www.zhihu.com/question/28477388https://www.zhihu.com/question/36204510/answer/672314392 重点参考 jvm教程https://www.bilibili.com/video/BV1PJ411n7xZ?from=search&amp;seid=17139693576913925031 3.java面试要求https://www.bilibili.com/video/BV1xt411S7xyhttps://www.bilibili.com/video/BV1zb411M7NQ感觉是框架+jvm 八、考研策略1.英语2.内容 九、Go学习1.教程https://www.bilibili.com/video/BV1jJ411c7s3?p=12.源码https://github.com/rubyhan1314/Golang-100-Days 结语：不要因为学的广就学的不精，一定要有技术作为根基，提高核心竞争力","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://nlbyd1119.online/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"flask-study-4","slug":"flask-study-4","date":"2020-06-14T14:44:42.000Z","updated":"2020-06-14T15:42:28.497Z","comments":true,"path":"2020/06/14/flask-study-4/","link":"","permalink":"http://nlbyd1119.online/2020/06/14/flask-study-4/","excerpt":"黑马ihome项目 其三","text":"黑马ihome项目 其三 总结一下项目中实现的功能和技术点，按视图函数模块进行划分。 （一） api一、注册登录之一： verify_code模块 获取图片验证码 get_image_code 获取短信验证码 get_sms_code 二、注册登录之二： passport模块 注册 register 登录 login 检查登录状态 check_login 退出登录 logout 三、用户信息： profile模块 设置用户头像 set_user_avatar 修改用户名 change_user_name 获取用户信息 get_user_profile 设置实名认证信息 set_user_auth 获取实名认证信息 get_user_auth 四、房屋信息： houses模块 获取地区信息 get_area_info 保存发布房源的信息 save_house_info 保存发布房源的图片 save_house_image 获取用户拥有的房源的信息 get_user_houses 获取首页的房屋信息 get_house_index 获取房源详情 get_house_detail 获取经筛选后的房屋列表 get_house_list 五、订单支付之一： orders模块 保存订单 save_order 查询用户的订单信息 get_user_orders 接单拒单 accept_reject_order 保存订单评论信息 save_order_comment 六、订单支付之二： pay模块 发起支付宝支付 order_pay 保存订单支付结果 save_order_payment_result （二）前端请求一、注册登录 register.js 获取图片验证码 短信验证码 发送注册请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// js读取cookie的方法function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;// 保存图片验证码编号var imageCodeId = \"\";function generateUUID() &#123; var d = new Date().getTime(); if(window.performance &amp;&amp; typeof window.performance.now === \"function\")&#123; d += performance.now(); //use high-precision timer if available &#125; var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) &#123; var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16); return (c=='x' ? r : (r&amp;0x3|0x8)).toString(16); &#125;); return uuid;&#125;function generateImageCode() &#123; // 形成图片验证码的后端地址， 设置到页面中，让浏览请求验证码图片 // 1. 生成图片验证码编号 imageCodeId = generateUUID(); // 是指图片url var url = \"/api/v1.0/image_codes/\" + imageCodeId; $(\".image-code img\").attr(\"src\", url);&#125;function sendSMSCode() &#123; // 点击发送短信验证码后被执行的函数 $(\".phonecode-a\").removeAttr(\"onclick\"); var mobile = $(\"#mobile\").val(); if (!mobile) &#123; $(\"#mobile-err span\").html(\"请填写正确的手机号！\"); $(\"#mobile-err\").show(); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); return; &#125; var imageCode = $(\"#imagecode\").val(); if (!imageCode) &#123; $(\"#image-code-err span\").html(\"请填写验证码！\"); $(\"#image-code-err\").show(); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); return; &#125; // 构造向后端请求的参数 var req_data = &#123; image_code: imageCode, // 图片验证码的值 image_code_id: imageCodeId // 图片验证码的编号，（全局变量） &#125;; // 向后端发送请求 $.get(\"/api/v1.0/sms_codes/\"+ mobile, req_data, function (resp) &#123; // resp是后端返回的响应值，因为后端返回的是json字符串， // 所以ajax帮助我们把这个json字符串转换为js对象，resp就是转换后对象 if (resp.errno == \"0\") &#123; var num = 60; // 表示发送成功 var timer = setInterval(function () &#123; if (num &gt;= 1) &#123; // 修改倒计时文本 $(\".phonecode-a\").html(num + \"秒\"); num -= 1; &#125; else &#123; $(\".phonecode-a\").html(\"获取验证码\"); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); clearInterval(timer); &#125; &#125;, 1000, 60) &#125; else &#123; alert(resp.errmsg); $(\".phonecode-a\").attr(\"onclick\", \"sendSMSCode();\"); &#125; &#125;);&#125;$(document).ready(function() &#123; generateImageCode(); $(\"#mobile\").focus(function()&#123; $(\"#mobile-err\").hide(); &#125;); $(\"#imagecode\").focus(function()&#123; $(\"#image-code-err\").hide(); &#125;); $(\"#phonecode\").focus(function()&#123; $(\"#phone-code-err\").hide(); &#125;); $(\"#password\").focus(function()&#123; $(\"#password-err\").hide(); $(\"#password2-err\").hide(); &#125;); $(\"#password2\").focus(function()&#123; $(\"#password2-err\").hide(); &#125;); // 为表单的提交补充自定义的函数行为 （提交事件e） $(\".form-register\").submit(function(e)&#123; // 阻止浏览器对于表单的默认自动提交行为 e.preventDefault(); var mobile = $(\"#mobile\").val(); var phoneCode = $(\"#phonecode\").val(); var passwd = $(\"#password\").val(); var passwd2 = $(\"#password2\").val(); if (!mobile) &#123; $(\"#mobile-err span\").html(\"请填写正确的手机号！\"); $(\"#mobile-err\").show(); return; &#125; if (!phoneCode) &#123; $(\"#phone-code-err span\").html(\"请填写短信验证码！\"); $(\"#phone-code-err\").show(); return; &#125; if (!passwd) &#123; $(\"#password-err span\").html(\"请填写密码!\"); $(\"#password-err\").show(); return; &#125; if (passwd != passwd2) &#123; $(\"#password2-err span\").html(\"两次密码不一致!\"); $(\"#password2-err\").show(); return; &#125; // 调用ajax向后端发送注册请求 var req_data = &#123; mobile: mobile, sms_code: phoneCode, password: passwd, password2: passwd2, &#125;; var req_json = JSON.stringify(req_data); $.ajax(&#123; url: \"/api/v1.0/users\", type: \"post\", data: req_json, contentType: \"application/json\", dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, // 请求头，将csrf_token值放到请求中，方便后端csrf进行验证 success: function (resp) &#123; if (resp.errno == \"0\") &#123; // 注册成功，跳转到主页 location.href = \"/index.html\"; &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;);&#125;) login.js 发送登录请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function() &#123; $(\"#mobile\").focus(function()&#123; $(\"#mobile-err\").hide(); &#125;); $(\"#password\").focus(function()&#123; $(\"#password-err\").hide(); &#125;); $(\".form-login\").submit(function(e)&#123; e.preventDefault(); mobile = $(\"#mobile\").val(); passwd = $(\"#password\").val(); if (!mobile) &#123; $(\"#mobile-err span\").html(\"请填写正确的手机号！\"); $(\"#mobile-err\").show(); return; &#125; if (!passwd) &#123; $(\"#password-err span\").html(\"请填写密码!\"); $(\"#password-err\").show(); return; &#125; // 将表单的数据存放到对象data中 var data = &#123; mobile: mobile, password: passwd &#125;; // 将data转为json字符串 var jsonData = JSON.stringify(data); $.ajax(&#123; url:\"/api/v1.0/sessions\", type:\"post\", data: jsonData, contentType: \"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFToken\":getCookie(\"csrf_token\") &#125;, success: function (data) &#123; if (data.errno == \"0\") &#123; // 登录成功，跳转到主页 location.href = \"/\"; &#125; else &#123; // 其他错误信息，在页面中展示 $(\"#password-err span\").html(data.errmsg); $(\"#password-err\").show(); &#125; &#125; &#125;); &#125;);&#125;) 二、用户信息 profile.js 设置用户头像 修改用户名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586function showSuccessMsg() &#123; $('.popup_con').fadeIn('fast', function() &#123; setTimeout(function()&#123; $('.popup_con').fadeOut('fast',function()&#123;&#125;); &#125;,1000) &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function () &#123; $(\"#form-avatar\").submit(function (e) &#123; // 阻止表单的默认行为 e.preventDefault(); // 利用jquery.form.min.js提供的ajaxSubmit对表单进行异步提交 $(this).ajaxSubmit(&#123; url: \"/api/v1.0/users/avatar\", type: \"post\", dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"0\") &#123; // 上传成功 var avatarUrl = resp.data.avatar_url; $(\"#user-avatar\").attr(\"src\", avatarUrl); &#125; else if (resp.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;); // 在页面加载是向后端查询用户的信息 $.get(\"/api/v1.0/user\", function(resp)&#123; // 用户未登录 if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; // 查询到了用户的信息 else if (\"0\" == resp.errno) &#123; $(\"#user-name\").val(resp.data.name); if (resp.data.avatar) &#123; $(\"#user-avatar\").attr(\"src\", resp.data.avatar); &#125; &#125; &#125;, \"json\"); $(\"#form-name\").submit(function(e)&#123; e.preventDefault(); // 获取参数 var name = $(\"#user-name\").val(); if (!name) &#123; alert(\"请填写用户名！\"); return; &#125; $.ajax(&#123; url:\"/api/v1.0/users/name\", type:\"PUT\", data: JSON.stringify(&#123;name: name&#125;), contentType: \"application/json\", dataType: \"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\") &#125;, success: function (data) &#123; if (\"0\" == data.errno) &#123; $(\".error-msg\").hide(); showSuccessMsg(); &#125; else if (\"4001\" == data.errno) &#123; $(\".error-msg\").show(); &#125; else if (\"4101\" == data.errno) &#123; location.href = \"/login.html\"; &#125; &#125; &#125;); &#125;)&#125;) my.js 退出登录 获取用户信息123456789101112131415161718192021222324252627282930313233343536373839function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;// 点击推出按钮时执行的函数function logout() &#123; $.ajax(&#123; url: \"/api/v1.0/session\", type: \"delete\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, dataType: \"json\", success: function (resp) &#123; if (\"0\" == resp.errno) &#123; location.href = \"/index.html\"; &#125; &#125; &#125;);&#125;$(document).ready(function()&#123; $.get(\"/api/v1.0/user\", function(resp)&#123; // 用户未登录 if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; // 查询到了用户的信息 else if (\"0\" == resp.errno) &#123; $(\"#user-name\").html(resp.data.name); $(\"#user-mobile\").html(resp.data.mobile); if (resp.data.avatar) &#123; $(\"#user-avatar\").attr(\"src\", resp.data.avatar); &#125; &#125; &#125;, \"json\");&#125;) auth.js 设置与获取实名认证信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function showSuccessMsg() &#123; $('.popup_con').fadeIn('fast', function() &#123; setTimeout(function()&#123; $('.popup_con').fadeOut('fast',function()&#123;&#125;); &#125;,1000) &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; // 查询用户的实名认证信息 $.get(\"/api/v1.0/users/auth\", function(resp)&#123; // 4101代表用户未登录 if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; // 如果返回的数据中real_name与id_card不为null，表示用户有填写实名信息 if (resp.data.real_name &amp;&amp; resp.data.id_card) &#123; $(\"#real-name\").val(resp.data.real_name); $(\"#id-card\").val(resp.data.id_card); // 给input添加disabled属性，禁止用户修改 $(\"#real-name\").prop(\"disabled\", true); $(\"#id-card\").prop(\"disabled\", true); // 隐藏提交保存按钮 $(\"#form-auth&gt;input[type=submit]\").hide(); &#125; &#125; else &#123; alert(resp.errmsg); &#125; &#125;, \"json\"); // 管理实名信息表单的提交行为 $(\"#form-auth\").submit(function(e)&#123; e.preventDefault(); // 如果用户没有填写完整，展示错误信息 var realName = $(\"#real-name\").val(); var idCard = $(\"#id-card\").val(); if (realName == \"\" || idCard == \"\") &#123; $(\".error-msg\").show(); &#125; // 将表单的数据转换为json字符串 var data = &#123; real_name: realName, id_card: idCard &#125;; var jsonData = JSON.stringify(data); // 向后端发送请求 $.ajax(&#123; url:\"/api/v1.0/users/auth\", type:\"post\", data: jsonData, contentType: \"application/json\", dataType: \"json\", headers: &#123; \"X-CSRFTOKEN\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (0 == resp.errno) &#123; $(\".error-msg\").hide(); // 显示保存成功的提示信息 showSuccessMsg(); $(\"#real-name\").prop(\"disabled\", true); $(\"#id-card\").prop(\"disabled\", true); $(\"#form-auth&gt;input[type=submit]\").hide(); &#125; &#125; &#125;); &#125;)&#125;) 三、房屋信息 index.js 检查用户的登录状态以控制不同显示 获取幻灯片要展示的房屋基本信息 获取城区信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//模态框居中的控制function centerModals()&#123; $('.modal').each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css('display', 'block').appendTo('body'); var top = Math.round(($clone.height() - $clone.find('.modal-content').height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find('.modal-content').css(\"margin-top\", top-30); //修正原先已经有的30个像素 &#125;);&#125;function setStartDate() &#123; var startDate = $(\"#start-date-input\").val(); if (startDate) &#123; $(\".search-btn\").attr(\"start-date\", startDate); $(\"#start-date-btn\").html(startDate); $(\"#end-date\").datepicker(\"destroy\"); $(\"#end-date-btn\").html(\"离开日期\"); $(\"#end-date-input\").val(\"\"); $(\".search-btn\").attr(\"end-date\", \"\"); $(\"#end-date\").datepicker(&#123; language: \"zh-CN\", keyboardNavigation: false, startDate: startDate, format: \"yyyy-mm-dd\" &#125;); $(\"#end-date\").on(\"changeDate\", function() &#123; $(\"#end-date-input\").val( $(this).datepicker(\"getFormattedDate\") ); &#125;); $(\".end-date\").show(); &#125; $(\"#start-date-modal\").modal(\"hide\");&#125;function setEndDate() &#123; var endDate = $(\"#end-date-input\").val(); if (endDate) &#123; $(\".search-btn\").attr(\"end-date\", endDate); $(\"#end-date-btn\").html(endDate); &#125; $(\"#end-date-modal\").modal(\"hide\");&#125;function goToSearchPage(th) &#123; var url = \"/search.html?\"; url += (\"aid=\" + $(th).attr(\"area-id\")); url += \"&amp;\"; var areaName = $(th).attr(\"area-name\"); if (undefined == areaName) areaName=\"\"; url += (\"aname=\" + areaName); url += \"&amp;\"; url += (\"sd=\" + $(th).attr(\"start-date\")); url += \"&amp;\"; url += (\"ed=\" + $(th).attr(\"end-date\")); location.href = url;&#125;$(document).ready(function()&#123; // 检查用户的登录状态 $.get(\"/api/v1.0/session\", function(resp) &#123; if (\"0\" == resp.errno) &#123; $(\".top-bar&gt;.user-info&gt;.user-name\").html(resp.data.name); $(\".top-bar&gt;.user-info\").show(); &#125; else &#123; $(\".top-bar&gt;.register-login\").show(); &#125; &#125;, \"json\"); // 获取幻灯片要展示的房屋基本信息 $.get(\"/api/v1.0/houses/index\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".swiper-wrapper\").html(template(\"swiper-houses-tmpl\", &#123;houses:resp.data&#125;)); // 设置幻灯片对象，开启幻灯片滚动 var mySwiper = new Swiper ('.swiper-container', &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: '.swiper-pagination', paginationClickable: true &#125;); &#125; &#125;); // 获取城区信息 $.get(\"/api/v1.0/areas\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".area-list\").html(template(\"area-list-tmpl\", &#123;areas:resp.data&#125;)); $(\".area-list a\").click(function(e)&#123; $(\"#area-btn\").html($(this).html()); $(\".search-btn\").attr(\"area-id\", $(this).attr(\"area-id\")); $(\".search-btn\").attr(\"area-name\", $(this).html()); $(\"#area-modal\").modal(\"hide\"); &#125;); &#125; &#125;); $('.modal').on('show.bs.modal', centerModals); //当模态框出现的时候 $(window).on('resize', centerModals); //当窗口大小变化的时候 $(\"#start-date\").datepicker(&#123; language: \"zh-CN\", keyboardNavigation: false, startDate: \"today\", format: \"yyyy-mm-dd\" &#125;); $(\"#start-date\").on(\"changeDate\", function() &#123; var date = $(this).datepicker(\"getFormattedDate\"); $(\"#start-date-input\").val(date); &#125;);&#125;) detail.js 获取房屋的具体信息12345678910111213141516171819202122232425262728293031323334353637383940function hrefBack() &#123; history.go(-1);&#125;// 解析提取url中的查询字符串参数function decodeQuery()&#123; var search = decodeURI(document.location.search); return search.replace(/(^\\?)/, '').split('&amp;').reduce(function(result, item)&#123; values = item.split('='); result[values[0]] = values[1]; return result; &#125;, &#123;&#125;);&#125;$(document).ready(function()&#123; // 获取详情页面要展示的房屋编号 var queryData = decodeQuery(); var houseId = queryData[\"id\"]; // 获取该房屋的详细信息 $.get(\"/api/v1.0/houses/\" + houseId, function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".swiper-container\").html(template(\"house-image-tmpl\", &#123;img_urls:resp.data.house.img_urls, price:resp.data.house.price&#125;)); $(\".detail-con\").html(template(\"house-detail-tmpl\", &#123;house:resp.data.house&#125;)); // resp.user_id为访问页面用户,resp.data.user_id为房东 if (resp.data.user_id != resp.data.house.user_id) &#123; $(\".book-house\").attr(\"href\", \"/booking.html?hid=\"+resp.data.house.hid); $(\".book-house\").show(); &#125; var mySwiper = new Swiper ('.swiper-container', &#123; loop: true, autoplay: 2000, autoplayDisableOnInteraction: false, pagination: '.swiper-pagination', paginationType: 'fraction' &#125;); &#125; &#125;)&#125;) myhouse.js 获取用户拥有的房源信息1234567891011121314151617181920212223$(document).ready(function()&#123; // 对于发布房源，只有认证后的用户才可以，所以先判断用户的实名认证状态 $.get(\"/api/v1.0/users/auth\", function(resp)&#123; if (\"4101\" == resp.errno) &#123; // 用户未登录 location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; // 未认证的用户，在页面中展示 \"去认证\"的按钮 if (!(resp.data.real_name &amp;&amp; resp.data.id_card)) &#123; $(\".auth-warn\").show(); return; &#125; // 已认证的用户，请求其之前发布的房源信息 $.get(\"/api/v1.0/user/houses\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\"#houses-list\").html(template(\"houses-list-tmpl\", &#123;houses:resp.data.houses&#125;)); &#125; else &#123; $(\"#houses-list\").html(template(\"houses-list-tmpl\", &#123;houses:[]&#125;)); &#125; &#125;); &#125; &#125;);&#125;) newhouse.js 获取城区信息 上传房源基本信息 上传房源图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; // 向后端获取城区信息 $.get(\"/api/v1.0/areas\", function (resp) &#123; if (resp.errno == \"0\") &#123; var areas = resp.data; // for (i=0; i&lt;areas.length; i++) &#123; // var area = areas[i]; // $(\"#area-id\").append('&lt;option value=\"'+ area.aid +'\"&gt;'+ area.aname +'&lt;/option&gt;'); // &#125; // 使用js模板 var html = template(\"areas-tmpl\", &#123;areas: areas&#125;) $(\"#area-id\").html(html); &#125; else &#123; alert(resp.errmsg); &#125; &#125;, \"json\"); $(\"#form-house-info\").submit(function (e) &#123; e.preventDefault(); // 处理表单数据 var data = &#123;&#125;; $(\"#form-house-info\").serializeArray().map(function(x) &#123; data[x.name]=x.value &#125;); // 收集设置id信息 var facility = []; $(\":checked[name=facility]\").each(function(index, x)&#123;facility[index] = $(x).val()&#125;); data.facility = facility; // 向后端发送请求 $.ajax(&#123; url: \"/api/v1.0/houses/info\", type: \"post\", contentType: \"application/json\", data: JSON.stringify(data), dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, success: function (resp) &#123; if (resp.errno == \"4101\") &#123; // 用户未登录 location.href = \"/login.html\"; &#125; else if (resp.errno == \"0\") &#123; // 隐藏基本信息表单 $(\"#form-house-info\").hide(); // 显示图片表单 $(\"#form-house-image\").show(); // 设置图片表单中的house_id $(\"#house-id\").val(resp.data.house_id); &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;); $(\"#form-house-image\").submit(function (e) &#123; e.preventDefault(); $(this).ajaxSubmit(&#123; url: \"/api/v1.0/houses/image\", type: \"post\", dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\"), &#125;, success: function (resp) &#123; if (resp.errno == \"4101\") &#123; location.href = \"/login.html\"; &#125; else if (resp.errno == \"0\") &#123; $(\".house-image-cons\").append('&lt;img src=\"' + resp.data.image_url +'\"&gt;'); &#125; else &#123; alert(resp.errmsg); &#125; &#125; &#125;) &#125;)&#125;) 四、订单支付因未实现支付宝接入支付，故此处仅列查询订单的js。 orders.js 获取房客订单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//模态框居中的控制function centerModals()&#123; $('.modal').each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css('display', 'block').appendTo('body'); var top = Math.round(($clone.height() - $clone.find('.modal-content').height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find('.modal-content').css(\"margin-top\", top-30); //修正原先已经有的30个像素 &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; $('.modal').on('show.bs.modal', centerModals); //当模态框出现的时候 $(window).on('resize', centerModals); // 查询房客订单 $.get(\"/api/v1.0/user/orders?role=custom\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".orders-list\").html(template(\"orders-list-tmpl\", &#123;orders:resp.data.orders&#125;)); $(\".order-pay\").on(\"click\", function () &#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $.ajax(&#123; url: \"/api/v1.0/orders/\" + orderId + \"/payment\", type: \"post\", dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\"), &#125;, success: function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; // 引导用户跳转到支付宝连接 location.href = resp.data.pay_url; &#125; &#125; &#125;); &#125;); $(\".order-comment\").on(\"click\", function()&#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $(\".modal-comment\").attr(\"order-id\", orderId); &#125;); $(\".modal-comment\").on(\"click\", function()&#123; var orderId = $(this).attr(\"order-id\"); var comment = $(\"#comment\").val() if (!comment) return; var data = &#123; order_id:orderId, comment:comment &#125;; // 处理评论 $.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/comment\", type:\"PUT\", data:JSON.stringify(data), contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\"), &#125;, success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已完成\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#comment-modal\").modal(\"hide\"); &#125; &#125; &#125;); &#125;); &#125; &#125;);&#125;); lorder,js 获取房主订单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//模态框居中的控制function centerModals()&#123; $('.modal').each(function(i)&#123; //遍历每一个模态框 var $clone = $(this).clone().css('display', 'block').appendTo('body'); var top = Math.round(($clone.height() - $clone.find('.modal-content').height()) / 2); top = top &gt; 0 ? top : 0; $clone.remove(); $(this).find('.modal-content').css(\"margin-top\", top-30); //修正原先已经有的30个像素 &#125;);&#125;function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined;&#125;$(document).ready(function()&#123; $('.modal').on('show.bs.modal', centerModals); //当模态框出现的时候 $(window).on('resize', centerModals); // 查询房东的订单 $.get(\"/api/v1.0/user/orders?role=landlord\", function(resp)&#123; if (\"0\" == resp.errno) &#123; $(\".orders-list\").html(template(\"orders-list-tmpl\", &#123;orders:resp.data.orders&#125;)); $(\".order-accept\").on(\"click\", function()&#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $(\".modal-accept\").attr(\"order-id\", orderId); &#125;); // 接单处理 $(\".modal-accept\").on(\"click\", function()&#123; var orderId = $(this).attr(\"order-id\"); $.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/status\", type:\"PUT\", data:'&#123;\"action\":\"accept\"&#125;', contentType:\"application/json\", dataType:\"json\", headers:&#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\"), &#125;, success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已接单\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#accept-modal\").modal(\"hide\"); &#125; &#125; &#125;) &#125;); $(\".order-reject\").on(\"click\", function()&#123; var orderId = $(this).parents(\"li\").attr(\"order-id\"); $(\".modal-reject\").attr(\"order-id\", orderId); &#125;); // 处理拒单 $(\".modal-reject\").on(\"click\", function()&#123; var orderId = $(this).attr(\"order-id\"); var reject_reason = $(\"#reject-reason\").val(); if (!reject_reason) return; var data = &#123; action: \"reject\", reason:reject_reason &#125;; $.ajax(&#123; url:\"/api/v1.0/orders/\"+orderId+\"/status\", type:\"PUT\", data:JSON.stringify(data), contentType:\"application/json\", headers: &#123; \"X-CSRFTOKEN\":getCookie(\"csrf_token\") &#125;, dataType:\"json\", success:function (resp) &#123; if (\"4101\" == resp.errno) &#123; location.href = \"/login.html\"; &#125; else if (\"0\" == resp.errno) &#123; $(\".orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-content&gt;div.order-text&gt;ul li:eq(4)&gt;span\").html(\"已拒单\"); $(\"ul.orders-list&gt;li[order-id=\"+ orderId +\"]&gt;div.order-title&gt;div.order-operate\").hide(); $(\"#reject-modal\").modal(\"hide\"); &#125; &#125; &#125;); &#125;) &#125; &#125;);&#125;); （三）技术点 一、第三方sdk的接入使用 生成图片验证码 发送短信 www.yuntongxun.com 图片存储 七牛 支付宝 python-alipay-sdk https://github.com/fzlee/alipay 二、前端界面显示模板/插件 art-templatehttps://aui.github.io/art-template/zh-cn/index.html jquery表单插件 swiper轮播图插件 三、ajax请求的构成 请求参数/请求体的设置 响应回调 四、redis缓存的各种设置 有效期逻辑 存储数据类型 五、模型类属性设置与自定义方法 转换为字典的方法 属性装饰器 六、返回json数据的构造 jsonify json.dumps redis存取 七、sqlalchemy进行数据库操作 复杂查询条件的设置 优化 八、视图函数获取参数、检验参数、业务逻辑处理、返回结果的整体流程与逻辑细节处理","categories":[{"name":"Flask","slug":"Flask","permalink":"http://nlbyd1119.online/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"http://nlbyd1119.online/tags/PythonWeb/"}]},{"title":"flask-study-3","slug":"flask-study-3","date":"2020-06-14T13:28:55.000Z","updated":"2020-06-14T14:44:35.093Z","comments":true,"path":"2020/06/14/flask-study-3/","link":"","permalink":"http://nlbyd1119.online/2020/06/14/flask-study-3/","excerpt":"黑马ihome项目 其二","text":"黑马ihome项目 其二 一、城区信息与发布房源 为将Area对象的列表转为json字符串，先在对应模型类中定义了to_dict方法，可调用将对象转为字典（高度自定义）。 对于城区信息这种一般不会变化的数据，需要存入缓存，存入的是由errno、errmsg、area_dict_li转成的json字符串，先传入dict又传入json.dumps。这样的处理就需要在返回时添加200, {“Content-Type”: “application/json”}，这是dumps和jsonify的一个显著区别。 缓存数据同步的问题 使用前端js模板 art-templatehttps://aui.github.io/art-template/zh-cn/index.html 填写房源信息时，注意如何处理表单中的基本信息和设施信息。设施信息由于复选可能有多个，使用id数组存储，需要单独处理。1234567// 处理表单数据var data = &#123;&#125;;$(\"#form-house-info\").serializeArray().map(function(x) &#123; data[x.name]=x.value &#125;);// 收集设置id信息var facility = [];$(\":checked[name=facility]\").each(function(index, x)&#123;facility[index] = $(x).val()&#125;); 上传图片表单。为了通过ajax自定义含图片表单的提交，需要使用插件。1&lt;script src=\"/static/js/jquery.form.min.js\"&gt;&lt;/script&gt; 二、celery 说明Celery是一个功能完备即插即用的任务队列。celery适用异步处理问题，当发送邮件、或者文件上传, 图像处理等等一些比较耗时的操作，我们可将其异步执行，这样用户不需要等待很久，提高用户体验。 celery的特点是：简单，易于使用和维护，有丰富的文档；高效，单个celery进程每分钟可以处理数百万个任务；灵活，celery中几乎每个部分都可以自定义扩展。celery非常易于集成到一些web开发框架中. 使用流程 定义任务（函数） 调用发布任务delay 启动celery 三、房屋管理 获取房东发布的房源信息条目get_user_houses 获取主页幻灯片展示的房屋基本信息get_house_index 获取房屋详情get_house_detail 以上三个方法都是显示房屋信息的。其逻辑关系是，在访问首页时，会有一个幻灯片/轮播图显示订单量最高的房源图片的效果，点击某张时，会进入对应的详情页；在个人信息页选择自己的房源可以查看自己发布的房源信息。 以上三个方法为控制对象的序列化，定义了几个不同的to_dict方法，用于不同详略程度信息的转换获取。 首页的轮播效果使用了swiper插件结合模板实现。 四、房屋列表（搜索筛选） 参数处理与判断 start_date和end_date这两个参数传过来是字符串，数据库字段类型是datetime，需要转换。python中的datetime模块，可以进行字符串和datetime类型的相互转换。123strptime 字符串转datetimestrftime datetime转字符串start_date = datetime.strptime(start_date, \"%Y-%m-%d\") 区域、页数、排序关键字 查询条件 设置了存放查询条件的容器 时间条件 区域条件 排序方式 分页 分页实现方式 paginate redis的pipeline使用 多个操作一次提交的情形 列表页数据设置的两种方式：条件改变时的清空重设，滚动时页数增加发送请求追加。 五、订单与支付宝接入 保存订单 save_order 查询用户的订单信息 get_user_orders 接单拒单 accept_reject_order 保存订单评论信息 save_order_comment 支付宝支付使用流程与接入方法 六、项目优化数据库优化方法 关系数据库的三范式https://blog.csdn.net/zhouhuakang/article/details/51153309https://www.cnblogs.com/wsg25/p/9615100.htmlhttps://www.cnblogs.com/knowledgesea/p/3667395.html 索引https://www.jianshu.com/p/2b541c028157 慢查询工具https://flyerboy.github.io/2016/12/23/mysql_slow/https://yemengying.com/2016/05/24/mysql-tuning/ 读写分离 分库分表","categories":[{"name":"Flask","slug":"Flask","permalink":"http://nlbyd1119.online/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"http://nlbyd1119.online/tags/PythonWeb/"}]},{"title":"Echarts","slug":"Echarts","date":"2020-06-13T12:37:13.000Z","updated":"2020-06-13T12:49:16.839Z","comments":true,"path":"2020/06/13/Echarts/","link":"","permalink":"http://nlbyd1119.online/2020/06/13/Echarts/","excerpt":"使用Echarts绘制柱形图、折线图、饼状图等的基本流程和设置，以及如何利用ajax请求获取数据后，由Echarts显示数据。","text":"使用Echarts绘制柱形图、折线图、饼状图等的基本流程和设置，以及如何利用ajax请求获取数据后，由Echarts显示数据。 官网：https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts一、几种常见图的写法柱形图1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 柱状图模块1(function() &#123; // 1实例化对象 var myChart = echarts.init(document.querySelector(\".bar .chart\")); // 2. 指定配置项和数据 var option = &#123; color: [\"#2f89cf\"], tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, // 修改图表的大小 grid: &#123; left: \"0%\", top: \"10px\", right: \"0%\", bottom: \"4%\", containLabel: true &#125;, xAxis: [ &#123; type: \"category\", data: [ \"旅游行业\", \"教育培训\", \"游戏行业\", \"医疗行业\", \"电商行业\", \"社交行业\", \"金融行业\" ], axisTick: &#123; alignWithLabel: true &#125;, // 修改刻度标签 相关样式 axisLabel: &#123; color: \"rgba(255,255,255,.6) \", fontSize: \"8\" &#125;, // 不显示x坐标轴的样式 axisLine: &#123; show: false &#125; &#125; ], yAxis: [ &#123; type: \"value\", // 修改刻度标签 相关样式 axisLabel: &#123; color: \"rgba(255,255,255,.6) \", fontSize: 12 &#125;, // y轴的线条改为了 2像素 axisLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\", width: 2 &#125; &#125;, // y轴分割线的颜色 splitLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\" &#125; &#125; &#125; ], series: [ &#123; name: \"直接访问\", type: \"bar\", barWidth: \"35%\", data: [200, 300, 300, 900, 1500, 1200, 600], itemStyle: &#123; // 修改柱子圆角 barBorderRadius: 5 &#125; &#125; ] &#125;; // 3. 把配置项给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 柱形图2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 柱状图2(function() &#123; var myColor = [\"#1089E7\", \"#F57474\", \"#56D0E3\", \"#F8B448\", \"#8B78F6\"]; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(\".bar2 .chart\")); // 2. 指定配置和数据 var option = &#123; grid: &#123; top: \"10%\", left: \"22%\", bottom: \"10%\" // containLabel: true &#125;, // 不显示x轴的相关信息 xAxis: &#123; show: false &#125;, yAxis: [ &#123; type: \"category\", inverse: true, data: [\"HTML5\", \"CSS3\", \"javascript\", \"VUE\", \"NODE\"], // 不显示y轴的线 axisLine: &#123; show: false &#125;, // 不显示刻度 axisTick: &#123; show: false &#125;, // 把刻度标签里面的文字颜色设置为白色 axisLabel: &#123; color: \"#fff\" &#125; &#125;, &#123; data: [702, 350, 610, 793, 664], inverse: true, // 不显示y轴的线 axisLine: &#123; show: false &#125;, // 不显示刻度 axisTick: &#123; show: false &#125;, // 把刻度标签里面的文字颜色设置为白色 axisLabel: &#123; color: \"#fff\" &#125; &#125; ], series: [ &#123; name: \"条\", type: \"bar\", data: [70, 34, 60, 78, 69], yAxisIndex: 0, // 修改第一组柱子的圆角 itemStyle: &#123; barBorderRadius: 20, // 此时的color 可以修改柱子的颜色 color: function(params) &#123; // params 传进来的是柱子对象 // console.log(params); // dataIndex 是当前柱子的索引号 return myColor[params.dataIndex]; &#125; &#125;, // 柱子之间的距离 barCategoryGap: 50, //柱子的宽度 barWidth: 10, // 显示柱子内的文字 label: &#123; show: true, position: \"inside\", // &#123;c&#125; 会自动的解析为 数据 data里面的数据 formatter: \"&#123;c&#125;%\" &#125; &#125;, &#123; name: \"框\", type: \"bar\", barCategoryGap: 50, barWidth: 15, yAxisIndex: 1, data: [100, 100, 100, 100, 100], itemStyle: &#123; color: \"none\", borderColor: \"#00c1de\", borderWidth: 3, barBorderRadius: 15 &#125; &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 折线图1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 折线图1模块制作(function() &#123; var yearData = [ &#123; year: \"2020\", // 年份 data: [ // 两个数组是因为有两条线 [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120], [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79] ] &#125;, &#123; year: \"2021\", // 年份 data: [ // 两个数组是因为有两条线 [123, 175, 112, 197, 121, 67, 98, 21, 43, 64, 76, 38], [143, 131, 165, 123, 178, 21, 82, 64, 43, 60, 19, 34] ] &#125; ]; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(\".line .chart\")); // 2.指定配置 var option = &#123; // 通过这个color修改两条线的颜色 color: [\"#00f2f1\", \"#ed3f35\"], tooltip: &#123; trigger: \"axis\" &#125;, legend: &#123; // 如果series 对象有name 值，则 legend可以不用写data // 修改图例组件 文字颜色 textStyle: &#123; color: \"#4c9bfd\" &#125;, // 这个10% 必须加引号 right: \"10%\" &#125;, grid: &#123; top: \"20%\", left: \"3%\", right: \"4%\", bottom: \"3%\", show: true, // 显示边框 borderColor: \"#012f4a\", // 边框颜色 containLabel: true // 包含刻度文字在内 &#125;, xAxis: &#123; type: \"category\", boundaryGap: false, data: [ \"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\" ], axisTick: &#123; show: false // 去除刻度线 &#125;, axisLabel: &#123; color: \"#4c9bfd\" // 文本颜色 &#125;, axisLine: &#123; show: false // 去除轴线 &#125; &#125;, yAxis: &#123; type: \"value\", axisTick: &#123; show: false // 去除刻度线 &#125;, axisLabel: &#123; color: \"#4c9bfd\" // 文本颜色 &#125;, axisLine: &#123; show: false // 去除轴线 &#125;, splitLine: &#123; lineStyle: &#123; color: \"#012f4a\" // 分割线颜色 &#125; &#125; &#125;, series: [ &#123; name: \"新增粉丝\", type: \"line\", // true 可以让我们的折线显示带有弧度 smooth: true, data: yearData[0].data[0] &#125;, &#123; name: \"新增游客\", type: \"line\", smooth: true, data: yearData[0].data[1] &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;); // 5.点击切换效果 $(\".line h2\").on(\"click\", \"a\", function() &#123; // alert(1); // console.log($(this).index()); // 点击 a 之后 根据当前a的索引号 找到对应的 yearData的相关对象 // console.log(yearData[$(this).index()]); var obj = yearData[$(this).index()]; option.series[0].data = obj.data[0]; option.series[1].data = obj.data[1]; // 需要重新渲染 myChart.setOption(option); &#125;);&#125;)(); 折线图2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259// 折线图2 模块制作(function() &#123; var myChart = echarts.init(document.querySelector(\".line2 .chart\")); var option = &#123; tooltip: &#123; trigger: \"axis\" &#125;, legend: &#123; top: \"0%\", data: [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], textStyle: &#123; color: \"rgba(255,255,255,.5)\", fontSize: \"12\" &#125; &#125;, grid: &#123; left: \"10\", top: \"30\", right: \"10\", bottom: \"10\", containLabel: true &#125;, xAxis: [ &#123; type: \"category\", boundaryGap: false, // x轴更换数据 data: [ \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"26\", \"28\", \"29\", \"30\" ], // 文本颜色为rgba(255,255,255,.6) 文字大小为 12 axisLabel: &#123; textStyle: &#123; color: \"rgba(255,255,255,.6)\", fontSize: 12 &#125; &#125;, // x轴线的颜色为 rgba(255,255,255,.2) axisLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.2)\" &#125; &#125; &#125; ], yAxis: [ &#123; type: \"value\", axisTick: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\" &#125; &#125;, axisLabel: &#123; textStyle: &#123; color: \"rgba(255,255,255,.6)\", fontSize: 12 &#125; &#125;, // 修改分割线的颜色 splitLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\" &#125; &#125; &#125; ], series: [ &#123; name: \"邮件营销\", type: \"line\", smooth: true, // 单独修改当前线条的样式 lineStyle: &#123; color: \"#0184d5\", width: \"2\" &#125;, // 填充颜色设置 areaStyle: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123; offset: 0, color: \"rgba(1, 132, 213, 0.4)\" // 渐变色的起始颜色 &#125;, &#123; offset: 0.8, color: \"rgba(1, 132, 213, 0.1)\" // 渐变线的结束颜色 &#125; ], false ), shadowColor: \"rgba(0, 0, 0, 0.1)\" &#125;, // 设置拐点 symbol: \"circle\", // 拐点大小 symbolSize: 8, // 开始不显示拐点， 鼠标经过显示 showSymbol: false, // 设置拐点颜色以及边框 itemStyle: &#123; color: \"#0184d5\", borderColor: \"rgba(221, 220, 107, .1)\", borderWidth: 12 &#125;, data: [ 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 30, 40, 30, 40, 30, 40, 30, 60, 20, 40, 30, 40, 30, 40, 30, 40, 20, 60, 50, 40 ] &#125;, &#123; name: \"联盟广告\", type: \"line\", smooth: true, lineStyle: &#123; normal: &#123; color: \"#00d887\", width: 2 &#125; &#125;, areaStyle: &#123; normal: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123; offset: 0, color: \"rgba(0, 216, 135, 0.4)\" &#125;, &#123; offset: 0.8, color: \"rgba(0, 216, 135, 0.1)\" &#125; ], false ), shadowColor: \"rgba(0, 0, 0, 0.1)\" &#125; &#125;, // 设置拐点 小圆点 symbol: \"circle\", // 拐点大小 symbolSize: 5, // 设置拐点颜色以及边框 itemStyle: &#123; color: \"#00d887\", borderColor: \"rgba(221, 220, 107, .1)\", borderWidth: 12 &#125;, // 开始不显示拐点， 鼠标经过显示 showSymbol: false, data: [ 130, 10, 20, 40, 30, 40, 80, 60, 20, 40, 90, 40, 20, 140, 30, 40, 130, 20, 20, 40, 80, 70, 30, 40, 30, 120, 20, 99, 50, 20 ] &#125; ] &#125;; myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 饼状图1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 饼形图1(function() &#123; // 1. 实例化对象 var myChart = echarts.init(document.querySelector(\".pie .chart\")); // 2.指定配置 var option = &#123; color: [\"#065aab\", \"#066eab\", \"#0682ab\", \"#0696ab\", \"#06a0ab\"], tooltip: &#123; trigger: \"item\", formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; bottom: \"0%\", // 修改小图标的大小 itemWidth: 10, itemHeight: 10, // 修改图例组件的文字为 12px textStyle: &#123; color: \"rgba(255,255,255,.5)\", fontSize: \"12\" &#125; &#125;, series: [ &#123; name: \"年龄分布\", type: \"pie\", // 这个radius可以修改饼形图的大小 // radius 第一个值是内圆的半径 第二个值是外圆的半径 radius: [\"40%\", \"60%\"], center: [\"50%\", \"45%\"], avoidLabelOverlap: false, // 图形上的文字 label: &#123; show: false, position: \"center\" &#125;, // 链接文字和图形的线是否显示 labelLine: &#123; show: false &#125;, data: [ &#123; value: 1, name: \"0岁以下\" &#125;, &#123; value: 4, name: \"20-29岁\" &#125;, &#123; value: 2, name: \"30-39岁\" &#125;, &#123; value: 2, name: \"40-49岁\" &#125;, &#123; value: 1, name: \"50岁以上\" &#125; ] &#125; ] &#125;; // 3. 把配置给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 饼状图2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 饼形图2 地区分布模块(function() &#123; var myChart = echarts.init(document.querySelector(\".pie2 .chart\")); var option = &#123; color: [ \"#006cff\", \"#60cda0\", \"#ed8884\", \"#ff9f7f\", \"#0096ff\", \"#9fe6b8\", \"#32c5e9\", \"#1d9dff\" ], tooltip: &#123; trigger: \"item\", formatter: \"&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)\" &#125;, legend: &#123; bottom: \"0%\", itemWidth: 10, itemHeight: 10, textStyle: &#123; color: \"rgba(255,255,255,.5)\", fontSize: \"12\" &#125; &#125;, series: [ &#123; name: \"地区分布\", type: \"pie\", radius: [\"10%\", \"70%\"], center: [\"50%\", \"50%\"], roseType: \"radius\", // 图形的文字标签 label: &#123; fontSize: 10 &#125;, // 链接图形和文字的线条 labelLine: &#123; // length 链接图形的线条 length: 6, // length2 链接文字的线条 length2: 8 &#125;, data: [ &#123; value: 20, name: \"云南\" &#125;, &#123; value: 26, name: \"北京\" &#125;, &#123; value: 24, name: \"山东\" &#125;, &#123; value: 25, name: \"河北\" &#125;, &#123; value: 20, name: \"江苏\" &#125;, &#123; value: 25, name: \"浙江\" &#125;, &#123; value: 30, name: \"四川\" &#125;, &#123; value: 42, name: \"湖北\" &#125; ] &#125; ] &#125;; myChart.setOption(option); // 监听浏览器缩放，图表对象调用缩放resize函数 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 社区的飞行图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312// 模拟飞行路线模块地图模块(function() &#123; var myChart = echarts.init(document.querySelector(\".map .chart\")); var geoCoordMap = &#123; 上海: [121.4648, 31.2891], 东莞: [113.8953, 22.901], 东营: [118.7073, 37.5513], 中山: [113.4229, 22.478], 临汾: [111.4783, 36.1615], 临沂: [118.3118, 35.2936], 丹东: [124.541, 40.4242], 丽水: [119.5642, 28.1854], 乌鲁木齐: [87.9236, 43.5883], 佛山: [112.8955, 23.1097], 保定: [115.0488, 39.0948], 兰州: [103.5901, 36.3043], 包头: [110.3467, 41.4899], 北京: [116.4551, 40.2539], 北海: [109.314, 21.6211], 南京: [118.8062, 31.9208], 南宁: [108.479, 23.1152], 南昌: [116.0046, 28.6633], 南通: [121.1023, 32.1625], 厦门: [118.1689, 24.6478], 台州: [121.1353, 28.6688], 合肥: [117.29, 32.0581], 呼和浩特: [111.4124, 40.4901], 咸阳: [108.4131, 34.8706], 哈尔滨: [127.9688, 45.368], 唐山: [118.4766, 39.6826], 嘉兴: [120.9155, 30.6354], 大同: [113.7854, 39.8035], 大连: [122.2229, 39.4409], 天津: [117.4219, 39.4189], 太原: [112.3352, 37.9413], 威海: [121.9482, 37.1393], 宁波: [121.5967, 29.6466], 宝鸡: [107.1826, 34.3433], 宿迁: [118.5535, 33.7775], 常州: [119.4543, 31.5582], 广州: [113.5107, 23.2196], 廊坊: [116.521, 39.0509], 延安: [109.1052, 36.4252], 张家口: [115.1477, 40.8527], 徐州: [117.5208, 34.3268], 德州: [116.6858, 37.2107], 惠州: [114.6204, 23.1647], 成都: [103.9526, 30.7617], 扬州: [119.4653, 32.8162], 承德: [117.5757, 41.4075], 拉萨: [91.1865, 30.1465], 无锡: [120.3442, 31.5527], 日照: [119.2786, 35.5023], 昆明: [102.9199, 25.4663], 杭州: [119.5313, 29.8773], 枣庄: [117.323, 34.8926], 柳州: [109.3799, 24.9774], 株洲: [113.5327, 27.0319], 武汉: [114.3896, 30.6628], 汕头: [117.1692, 23.3405], 江门: [112.6318, 22.1484], 沈阳: [123.1238, 42.1216], 沧州: [116.8286, 38.2104], 河源: [114.917, 23.9722], 泉州: [118.3228, 25.1147], 泰安: [117.0264, 36.0516], 泰州: [120.0586, 32.5525], 济南: [117.1582, 36.8701], 济宁: [116.8286, 35.3375], 海口: [110.3893, 19.8516], 淄博: [118.0371, 36.6064], 淮安: [118.927, 33.4039], 深圳: [114.5435, 22.5439], 清远: [112.9175, 24.3292], 温州: [120.498, 27.8119], 渭南: [109.7864, 35.0299], 湖州: [119.8608, 30.7782], 湘潭: [112.5439, 27.7075], 滨州: [117.8174, 37.4963], 潍坊: [119.0918, 36.524], 烟台: [120.7397, 37.5128], 玉溪: [101.9312, 23.8898], 珠海: [113.7305, 22.1155], 盐城: [120.2234, 33.5577], 盘锦: [121.9482, 41.0449], 石家庄: [114.4995, 38.1006], 福州: [119.4543, 25.9222], 秦皇岛: [119.2126, 40.0232], 绍兴: [120.564, 29.7565], 聊城: [115.9167, 36.4032], 肇庆: [112.1265, 23.5822], 舟山: [122.2559, 30.2234], 苏州: [120.6519, 31.3989], 莱芜: [117.6526, 36.2714], 菏泽: [115.6201, 35.2057], 营口: [122.4316, 40.4297], 葫芦岛: [120.1575, 40.578], 衡水: [115.8838, 37.7161], 衢州: [118.6853, 28.8666], 西宁: [101.4038, 36.8207], 西安: [109.1162, 34.2004], 贵阳: [106.6992, 26.7682], 连云港: [119.1248, 34.552], 邢台: [114.8071, 37.2821], 邯郸: [114.4775, 36.535], 郑州: [113.4668, 34.6234], 鄂尔多斯: [108.9734, 39.2487], 重庆: [107.7539, 30.1904], 金华: [120.0037, 29.1028], 铜川: [109.0393, 35.1947], 银川: [106.3586, 38.1775], 镇江: [119.4763, 31.9702], 长春: [125.8154, 44.2584], 长沙: [113.0823, 28.2568], 长治: [112.8625, 36.4746], 阳泉: [113.4778, 38.0951], 青岛: [120.4651, 36.3373], 韶关: [113.7964, 24.7028] &#125;; var XAData = [ [&#123; name: \"西安\" &#125;, &#123; name: \"拉萨\", value: 100 &#125;], [&#123; name: \"西安\" &#125;, &#123; name: \"上海\", value: 100 &#125;], [&#123; name: \"西安\" &#125;, &#123; name: \"广州\", value: 100 &#125;], [&#123; name: \"西安\" &#125;, &#123; name: \"西宁\", value: 100 &#125;], [&#123; name: \"西安\" &#125;, &#123; name: \"银川\", value: 100 &#125;] ]; var XNData = [ [&#123; name: \"西宁\" &#125;, &#123; name: \"北京\", value: 100 &#125;], [&#123; name: \"西宁\" &#125;, &#123; name: \"上海\", value: 100 &#125;], [&#123; name: \"西宁\" &#125;, &#123; name: \"广州\", value: 100 &#125;], [&#123; name: \"西宁\" &#125;, &#123; name: \"西安\", value: 100 &#125;], [&#123; name: \"西宁\" &#125;, &#123; name: \"银川\", value: 100 &#125;] ]; var YCData = [ [&#123; name: \"拉萨\" &#125;, &#123; name: \"潍坊\", value: 100 &#125;], [&#123; name: \"拉萨\" &#125;, &#123; name: \"哈尔滨\", value: 100 &#125;], [&#123; name: \"银川\" &#125;, &#123; name: \"上海\", value: 100 &#125;], [&#123; name: \"银川\" &#125;, &#123; name: \"西安\", value: 100 &#125;], [&#123; name: \"银川\" &#125;, &#123; name: \"西宁\", value: 100 &#125;] ]; var planePath = \"path://M1705.06,1318.313v-89.254l-319.9-221.799l0.073-208.063c0.521-84.662-26.629-121.796-63.961-121.491c-37.332-0.305-64.482,36.829-63.961,121.491l0.073,208.063l-319.9,221.799v89.254l330.343-157.288l12.238,241.308l-134.449,92.931l0.531,42.034l175.125-42.917l175.125,42.917l0.531-42.034l-134.449-92.931l12.238-241.308L1705.06,1318.313z\"; //var planePath = 'arrow'; var convertData = function(data) &#123; var res = []; for (var i = 0; i &lt; data.length; i++) &#123; var dataItem = data[i]; var fromCoord = geoCoordMap[dataItem[0].name]; var toCoord = geoCoordMap[dataItem[1].name]; if (fromCoord &amp;&amp; toCoord) &#123; res.push(&#123; fromName: dataItem[0].name, toName: dataItem[1].name, coords: [fromCoord, toCoord], value: dataItem[1].value &#125;); &#125; &#125; return res; &#125;; var color = [\"#a6c84c\", \"#ffa022\", \"#46bee9\"]; //航线的颜色 var series = []; [ [\"西安\", XAData], [\"西宁\", XNData], [\"银川\", YCData] ].forEach(function(item, i) &#123; series.push( &#123; name: item[0] + \" Top3\", type: \"lines\", zlevel: 1, effect: &#123; show: true, period: 6, trailLength: 0.7, color: \"red\", //arrow箭头的颜色 symbolSize: 3 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 0, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + \" Top3\", type: \"lines\", zlevel: 2, symbol: [\"none\", \"arrow\"], symbolSize: 10, effect: &#123; show: true, period: 6, trailLength: 0, symbol: planePath, symbolSize: 15 &#125;, lineStyle: &#123; normal: &#123; color: color[i], width: 1, opacity: 0.6, curveness: 0.2 &#125; &#125;, data: convertData(item[1]) &#125;, &#123; name: item[0] + \" Top3\", type: \"effectScatter\", coordinateSystem: \"geo\", zlevel: 2, rippleEffect: &#123; brushType: \"stroke\" &#125;, label: &#123; normal: &#123; show: true, position: \"right\", formatter: \"&#123;b&#125;\" &#125; &#125;, symbolSize: function(val) &#123; return val[2] / 8; &#125;, itemStyle: &#123; normal: &#123; color: color[i] &#125;, emphasis: &#123; areaColor: \"#2B91B7\" &#125; &#125;, data: item[1].map(function(dataItem) &#123; return &#123; name: dataItem[1].name, value: geoCoordMap[dataItem[1].name].concat([dataItem[1].value]) &#125;; &#125;) &#125; ); &#125;); var option = &#123; tooltip: &#123; trigger: \"item\", formatter: function(params, ticket, callback) &#123; if (params.seriesType == \"effectScatter\") &#123; return \"线路：\" + params.data.name + \"\" + params.data.value[2]; &#125; else if (params.seriesType == \"lines\") &#123; return ( params.data.fromName + \"&gt;\" + params.data.toName + \"&lt;br /&gt;\" + params.data.value ); &#125; else &#123; return params.name; &#125; &#125; &#125;, legend: &#123; orient: \"vertical\", top: \"bottom\", left: \"right\", data: [\"西安 Top3\", \"西宁 Top3\", \"银川 Top3\"], textStyle: &#123; color: \"#fff\" &#125;, selectedMode: \"multiple\" &#125;, geo: &#123; map: \"china\", label: &#123; emphasis: &#123; show: true, color: \"#fff\" &#125; &#125;, // 把中国地图放大了1.2倍 zoom: 1.2, roam: true, itemStyle: &#123; normal: &#123; // 地图省份的背景颜色 areaColor: \"rgba(20, 41, 87,0.6)\", borderColor: \"#195BB9\", borderWidth: 1 &#125;, emphasis: &#123; areaColor: \"#2B91B7\" &#125; &#125; &#125;, series: series &#125;; myChart.setOption(option); // 监听浏览器缩放，图表对象调用缩放resize函数 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;);&#125;)(); 二、由后端获取数据给Echarts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118$(document).ready(function() &#123; $.get(\"http://localhost:8080/video/findAll.do\", function (data) &#123; var name_list = []; var num_list = []; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; if (key == \"v_name\") &#123; // alert(key); // alert(u[key]); name_list.push(u[key]) &#125; if (key == \"v_view\") &#123; // alert(key); // alert(u[key]); num_list.push(u[key]) &#125; &#125; &#125; // alert(name_list[0]); // for (var name in name_list) &#123; 经过测试，发现数组不能使用这种遍历方式 // alert(name); // &#125; for (var i = 0; i &lt; name_list.length; i++) &#123; // alert(name_list[i]); &#125; // 柱状图模块1 (function() &#123; // 发现要用ajax取数据的话，应该写在响应回调里 alert(name_list.length) // 1实例化对象 var myChart = echarts.init(document.querySelector(\".bar .chart\")); // 2. 指定配置项和数据 var option = &#123; color: [\"#2f89cf\"], tooltip: &#123; trigger: \"axis\", axisPointer: &#123; // 坐标轴指示器，坐标轴触发有效 type: \"shadow\" // 默认为直线，可选为：'line' | 'shadow' &#125; &#125;, // 修改图表的大小 grid: &#123; left: \"0%\", top: \"10px\", right: \"0%\", bottom: \"4%\", containLabel: true &#125;, xAxis: [ &#123; type: \"category\", data: name_list.slice(0, 7), axisTick: &#123; alignWithLabel: true &#125;, // 修改刻度标签 相关样式 axisLabel: &#123; color: \"rgba(255,255,255,.6) \", fontSize: \"8\", formatter: function (name) &#123; // do some thing return name.substring(0,3) &#125; &#125;, // 不显示x坐标轴的样式 axisLine: &#123; show: false &#125; &#125; ], yAxis: [ &#123; type: \"value\", // 修改刻度标签 相关样式 axisLabel: &#123; color: \"rgba(255,255,255,.6) \", fontSize: 12 &#125;, // y轴的线条改为了 2像素 axisLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\", width: 2 &#125; &#125;, // y轴分割线的颜色 splitLine: &#123; lineStyle: &#123; color: \"rgba(255,255,255,.1)\" &#125; &#125; &#125; ], series: [ &#123; name: \"直接访问\", type: \"bar\", barWidth: \"35%\", data: num_list.slice(0, 7), itemStyle: &#123; // 修改柱子圆角 barBorderRadius: 5 &#125; &#125; ] &#125;; // 3. 把配置项给实例对象 myChart.setOption(option); // 4. 让图表跟随屏幕自动的去适应 window.addEventListener(\"resize\", function() &#123; myChart.resize(); &#125;); &#125;)(); &#125;);&#125;) 把关于Echarts的代码写在ajax的响应回调中。 三、细节 如何格式化输出axisLabel参考： https://www.cnblogs.com/lxl0419/p/9081453.html","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://nlbyd1119.online/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Ajax-Json","slug":"Ajax-Json","date":"2020-06-12T14:50:19.000Z","updated":"2020-06-13T08:52:53.045Z","comments":true,"path":"2020/06/12/Ajax-Json/","link":"","permalink":"http://nlbyd1119.online/2020/06/12/Ajax-Json/","excerpt":"一、Json基础","text":"一、Json基础 基本规则123456789101112* 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） &#123;\"persons\":[&#123;&#125;,&#123;&#125;]&#125; 5. 对象（在花括号中） &#123;\"address\":&#123;\"province\"：\"陕西\"....&#125;&#125; 6. null* 数据由逗号分隔：多个键值对由逗号分隔* 花括号保存对象：使用&#123;&#125;定义json 格式* 方括号保存数组：[] 获取数据1234567891011121314151617181920212223242526271. json对象.键名2. json对象[\"键名\"]3. 数组对象[索引]4. 遍历--------------------------------- //1.定义基本格式 var person = &#123;\"name\": \"张三\", age: 23, 'gender': true&#125;; var ps = [&#123;\"name\": \"张三\", \"age\": 23, \"gender\": true&#125;, &#123;\"name\": \"李四\", \"age\": 24, \"gender\": true&#125;, &#123;\"name\": \"王五\", \"age\": 25, \"gender\": false&#125;]; //2.获取person对象中所有的键和值//for in 循环/* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.\"name\" //alert(key + \":\" + person.key); alert(key+\":\"+person[key]);&#125;*///3.获取ps中的所有值for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+\":\"+p[key]); &#125;&#125; 三、Java中的Json解析 JSON解析器常见的解析器：Jsonlib，Gson，fastjson，jackson因为spring中集成了jackson，所以使用它进行json解析 转换方法123456789101112131415161718191. 导入jackson的相关jar包2. 创建Jackson核心对象 ObjectMapper3. 调用ObjectMapper的相关方法进行转换1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 @JsonFormat(pattern = \"yyyy-MM-dd\")3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 测试代码与结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import domain.User;import org.junit.Test;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class JSONTest &#123; @Test public void test1() &#123; User user = new User(\"nnn\", \"1\", \"1\", \"1\"); ObjectMapper mapper = new ObjectMapper(); String result = \"\"; try &#123; // 测试java对象转换为json字符串 result = mapper.writeValueAsString(user); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; System.out.println(result); try &#123; // 测试json字符串转换为java对象 user = mapper.readValue(result, User.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(user.toString()); User user2 = user; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(user); userList.add(user2); try &#123; // 测试List&lt;Object&gt;转换为json字符串 System.out.println(mapper.writeValueAsString(userList)); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"张三\"); map.put(\"sex\", \"男\"); try &#123; // 测试Map转换为json字符串 System.out.println(mapper.writeValueAsString(map)); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234&#123;\"status\":0,\"message\":null,\"id\":null,\"username\":\"nnn\",\"password\":\"1\",\"phone\":\"1\",\"mail\":\"1\",\"createAt\":\"2020年6月13日16时3分\",\"updateAt\":\"2020年6月13日16时3分\"&#125;User&#123;id='null', username='nnn', password='1', phone='1', mail='1', createAt='2020年6月13日16时3分', updateAt='2020年6月13日16时3分'&#125;[&#123;\"status\":0,\"message\":null,\"id\":null,\"username\":\"nnn\",\"password\":\"1\",\"phone\":\"1\",\"mail\":\"1\",\"createAt\":\"2020年6月13日16时3分\",\"updateAt\":\"2020年6月13日16时3分\"&#125;,&#123;\"status\":0,\"message\":null,\"id\":null,\"username\":\"nnn\",\"password\":\"1\",\"phone\":\"1\",\"mail\":\"1\",\"createAt\":\"2020年6月13日16时3分\",\"updateAt\":\"2020年6月13日16时3分\"&#125;]&#123;\"sex\":\"男\",\"name\":\"张三\"&#125; 测试过程中出现的问题与解决方法!!! JUnit version 3.8 or later expected:报错解决参考 https://blog.csdn.net/XYmar/article/details/96275926https://blog.csdn.net/niuniu1994/article/details/82814132将所用junit依赖上移 三、Java中 Ajax请求-Json响应在java这里，先说一下Ajax请求与Json响应的原理。注意Json的响应，必须是将数据转换为Json字符串的，java中利用springmvc的注解，可以使用注解标识，方法返回对象、列表类型均可，这是相对python处理的一个优点。为确定一般情况下的处理方式，进行了如下测试： 返回文本即dataType:”Text” 返回java对象 响应回调取值 返回java列表 响应回调遍历 1.测试代码 前端ajax请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 测试返回文本 url中无.do java&lt;input id=\"test\" url=\"http://localhost:8080/test/text\" type=\"button\" value=\"测试\"/&gt;测试返回java对象 java&lt;input id=\"test2\" url=\"http://localhost:8080/test/json\" type=\"button\" value=\"测试二\"/&gt;测试返回 返回列表对象 java&lt;input id=\"test3\" url=\"http://localhost:8080/test/json2\" type=\"button\" value=\"测试三\"/&gt;&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function() &#123; $(\"#test\").click(function () &#123; alert($(this).attr(\"url\")); $.ajax(&#123; url:$(this).attr(\"url\") , // 请求路径 type:\"GET\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 //data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(\"出错啦...\") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式 &#125;); &#125;) $(\"#test2\").click(function () &#123; alert($(this).attr(\"url\")); var req_data = &#123; username: \"nnn\", password: \"1\" &#125; $.get($(this).attr(\"url\"), req_data, function (data) &#123; for(var key in data)&#123; alert(key+\":\"+data[key]); &#125; &#125;); &#125;) $(\"#test3\").click(function () &#123; alert($(this).attr(\"url\")); $.get($(this).attr(\"url\"), function (data) &#123; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; alert(key+\":\"+u[key]); &#125; &#125; &#125;); &#125;)&#125;)&lt;/script&gt; 后端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package controller;import dao.IUserDao;import domain.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.nio.charset.Charset;import java.util.List;@Controller@RequestMapping(\"/test\")@CrossOriginpublic class AJTestController &#123; @Autowired private IUserDao userDao; @ResponseBody @RequestMapping(\"/text\") public ResponseEntity&lt;String&gt; testText() throws Exception&#123; String content = \"测试返回文本\"; HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.setContentType(new MediaType(\"text\",\"html\", Charset.forName(\"UTF-8\"))); return new ResponseEntity&lt;String&gt;(content, responseHeaders, HttpStatus.OK); &#125; @ResponseBody @RequestMapping(\"/json\") public User testJson(String username, String password) throws Exception&#123; User user = userDao.findUserByName(username); if (user == null) &#123; return new User(); &#125; System.out.println(user.getUsername()); return user; &#125; @ResponseBody @RequestMapping(\"/json2\") public List&lt;User&gt; testJson2() throws Exception&#123; return userDao.findAll(); &#125;&#125;2.细节 当用$.ajax设置data或设置$.get的第二个参数时，注意无论是采用字典的方式或是”&amp;”连接串的方式，设置的都是请求参数，和Content-Type无关，和json处理无关。 当ajax请求中未指明dataType即响应数据类型时，具体响应数据类型由后端决定，是纯文本还是json由具体响应结果决定，即不设置dataType，后端代码中使用了@ResponseBody响应体就是json类型；但一旦设置为”text”或”json”，后端就必须响应相应类型的数据，否则是无法获取响应数据的。 3.总结由于springmvc注解的存在，使java对象转换为json字符串很容易，这是相对python处理的一个显著优点。 四、python中的json解析这里统一说一下python中json解析的一般方法和flask中的做法，以及flask为何采用自定的方法。1.python中的json模块json模块提供了四个功能：dumps、dump、loads、load，用于字符串 和 python数据类型间进行转换 json.loads()把Json格式字符串解码转换成Python对象 从json到python的类型转化对照如下： 1234567import jsonstrList = '[1, 2, 3, 4]'strDict = '&#123;\"city\": \"北京\", \"name\": \"范爷\"&#125;'json.loads(strList) # [1, 2, 3, 4]json.loads(strDict) # json数据自动按Unicode存储# &#123;u'city': u'\\u5317\\u4eac', u'name': u'\\u5927\\u732b'&#125; json.dumps()实现python类型转化为json字符串，返回一个str对象 把一个Python对象编码转换成Json字符串从python原始类型向json类型的转化对照如下： 12345678910111213141516171819import jsonlistStr = [1, 2, 3, 4]tupleStr = (1, 2, 3, 4)dictStr = &#123;\"city\": \"北京\", \"name\": \"范爷\"&#125;json.dumps(listStr)# '[1, 2, 3, 4]'json.dumps(tupleStr)# '[1, 2, 3, 4]'# 注意：json.dumps() 序列化时默认使用的ascii编码# 添加参数 ensure_ascii=False 禁用ascii编码，按utf-8编码json.dumps(dictStr) # '&#123;\"city\": \"\\\\u5317\\\\u4eac\", \"name\": \"\\\\u5927\\\\u5218\"&#125;'print(json.dumps(dictStr, ensure_ascii=False))# &#123;\"city\": \"北京\", \"name\": \"范爷\"&#125; json.dump()将Python内置类型序列化为json对象后写入文件 1234567import jsonlistStr = [&#123;\"city\": \"北京\"&#125;, &#123;\"name\": \"范爷\"&#125;]json.dump(listStr, open(\"listStr.json\",\"w\"), ensure_ascii=False)dictStr = &#123;\"city\": \"北京\", \"name\": \"范爷\"&#125;json.dump(dictStr, open(\"dictStr.json\",\"w\"), ensure_ascii=False) json.load()读取文件中json形式的字符串元素 转化成python类型 12345678910import jsonstrList = json.load(open(\"listStr.json\"))print(strList)# [&#123;u'city': u'\\u5317\\u4eac'&#125;, &#123;u'name': u'\\u5927\\u5218'&#125;]strDict = json.load(open(\"dictStr.json\"))print(strDict)# &#123;u'city': u'\\u5317\\u4eac', u'name': u'\\u5927\\u5218'&#125; 2.使用JsonPath解析Json字符串具体在数据解析篇中介绍。 1234567JsonPath 是一种信息抽取类库，是从JSON文档中抽取指定信息的工具，提供多种语言实现版本，包括：Javascript, Python， PHP 和 Java。JsonPath 对于 JSON 来说，相当于 XPATH 对于 XML。安装方法：`pip install jsonpath`官方文档：http://goessner.net/articles/JsonPath 3.flask中处理python的过程 123456789# jsonify 与 json.dumps 作用类似 把python json对象（字典）转换为 json字符串 但两者处理返回的 Content-Type不同# 前端请求时 contentType: \"application/json\" 实则请求体中的定义按字典来（这个说法是错的） 但后端接收的应该是json字符串# 后端处理时 需先用 request.get_json() 转换为字典对象 再取值# 经过测试 get请求设置的那些 data 不管是以 &amp; 拼接的 还是传入字典 其类似都和json无关 只是普通的请求参数 python后端通过request.args获取# 只有 post请求时 且 contentType: \"application/json\" 才为请求体中要求是 json数据 且一定注意 需要将字典对象 用 JSON.stringify 转换为json字符串# 综上 请求和响应的处理其实是一致的 传送的必须是 json 字符串 若想取里面的值需要转换成json对象（字典）# 后端flask需要用 get_json() 前端 当把 dataType设置为 json时 其即会自动处理为json对象# 其实根据 java的测试来看 dataType设置不是关键的 关键是后端如何响应 如果不设置 该返回什么还是会返回什么# 但一旦设置了dataType 就必须一致 4.对比 python中json模块的dumps方法和flask的jsonify方法https://www.jianshu.com/p/a25357f2d930 js中的stringify方法和上述两方法作用类似 python中json模块的loads方法和flask的request.get_json()方法 五、python中 Ajax请求-Json响应主要说明使用flask框架的情况。get方法和java类似，但post方法一定注意csrf验证的问题；且python flask相对ssm一个很大的缺陷就是没有方法将对象、列表之类的直接转换为json字符串，需要自行先对对象进行序列化处理。为确定一般情况下的处理方式，进行了如下测试： ajax get请求 ajax post请求 返回对象/列表的情况 1.测试代码前端ajax请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263测试 get python&lt;input id=\"test4\" url=\"http://localhost:5000/api/v1.0/test\" type=\"button\" value=\"测试四\"/&gt;测试 post python&lt;input id=\"test5\" url=\"http://localhost:5000/api/v1.0/test\" type=\"button\" value=\"测试五\"/&gt;测试 返回 对象/列表转成的json对象&lt;input id=\"test6\" url=\"http://localhost:5000/api/v1.0/test2\" type=\"button\" value=\"测试六\"/&gt;&lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function() &#123; $(\"#test4\").click(function () &#123; alert($(this).attr(\"url\")); var req_data = &#123; username: \"nnn\", password: \"1\" &#125; $.get($(this).attr(\"url\"), req_data, function (data) &#123; alert(data); &#125;); &#125;) function getCookie(name) &#123; var r = document.cookie.match(\"\\\\b\" + name + \"=([^;]*)\\\\b\"); return r ? r[1] : undefined; &#125; $(\"#test5\").click(function () &#123; alert($(this).attr(\"url\")); var req_data = &#123; username: \"nnn\", password: \"1\" &#125; var req_json = JSON.stringify(req_data); $.ajax(&#123; url: $(this).attr(\"url\"), type: \"post\", data: req_json, contentType: \"application/json\", // dataType: \"json\", headers: &#123; \"X-CSRFToken\": getCookie(\"csrf_token\") &#125;, // 请求头，将csrf_token值放到请求中，方便后端csrf进行验证 success: function (resp) &#123; alert(resp); alert(resp.msg) &#125; &#125;) &#125;) $(\"#test6\").click(function () &#123; alert($(this).attr(\"url\")); $.get($(this).attr(\"url\"), function (data) &#123; for (var i = 0; i &lt; data.length; i++) &#123; var u = data[i]; for(var key in u)&#123; alert(key+\":\"+u[key]); &#125; &#125; &#125;); &#125;) &#125;)&lt;/script&gt; 后端flask视图函数 12345678910111213141516171819202122232425262728293031323334from . import apifrom flask import jsonify, requestfrom ihome.models import User# jsonify 与 json.dumps 作用类似 把python json对象（字典）转换为 json字符串 但两者处理返回的 Content-Type不同# 前端请求时 contentType: \"application/json\" 实则请求体中的定义按字典来（这个说法是错的） 但后端接收的应该是json字符串# 后端处理时 需先用 request.get_json() 转换为字典对象 再取值# 经过测试 get请求设置的那些 data 不管是以 &amp; 拼接的 还是传入字典 其类似都和json无关 只是普通的请求参数 python后端通过request.args获取# 只有 post请求时 且 contentType: \"application/json\" 才为请求体中要求是 json数据 且一定注意 需要将字典对象 用 JSON.stringify 转换为json字符串# 综上 请求和响应的处理其实是一致的 传送的必须是 json 字符串 若想取里面的值需要转换成json对象（字典）# 后端flask需要用 get_json() 前端 当把 dataType设置为 json时 其即会自动处理为json对象# 其实根据 java的测试来看 dataType设置不是关键的 关键是后端如何响应 如果不设置 该返回什么还是会返回什么# 但一旦设置了dataType 就必须一致@api.route(\"/test\", methods=[\"POST\", \"GET\"])def test_json(): print(\"test\") print(request.get_json()) # return \"hello\" return jsonify(msg=\"hello\")# 序列化对象def serialize(model): from sqlalchemy.orm import class_mapper columns = [c.key for c in class_mapper(model.__class__).columns] return dict((c, getattr(model, c)) for c in columns)@api.route(\"/test2\", methods=[\"POST\", \"GET\"])def test_json_object(): user_list = User.query.all() for i in range(len(user_list)): user_list[i] = serialize(user_list[i]) print(user_list) return jsonify(user_list) 2.细节说明 java中的get和post请求参数和请求体的区别、dataType的设置等同 当请求方法为post，且contentType: “application/json”时，需要请求体中为json字符串，需将定义的字典用js中的JSON.stringify转换为json字符串 序列化python自定义类的方法 3.序列化python自定义对象的方法参考：https://www.baidu.com/s?wd=%E6%80%8E%E6%A0%B7%E5%B0%86python%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%BA%E5%8F%AFjson%E5%BA%8F%E5%88%97%E5%8C%96&amp;rsv_spt=1&amp;rsv_iqid=0xef52e02a0016d473&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=57&amp;rsv_sug1=16&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=23331&amp;rsv_sug4=24614https://blog.csdn.net/weixin_30670151/article/details/97388207https://blog.csdn.net/xuelians/article/details/79999275https://blog.csdn.net/weixin_41431904/article/details/80733600https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=flask%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1&amp;fenlei=256&amp;rsv_pq=9269d48900010ebb&amp;rsv_t=6d28cuzG5OZ6ZbTQBO2Uf9NWwP54HKc0OrWY1MrdcgcayGwRFoF82cTYQaE&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=17&amp;rsv_sug1=20&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_btype=i&amp;prefixsug=flask%25E8%25BF%2594%25E5%259B%259E%25E5%25AF%25B9%25E8%25B1%25A1&amp;rsp=1&amp;inputT=10815&amp;rsv_sug4=10816https://blog.csdn.net/qq_43665151/article/details/103969991https://blog.csdn.net/u011205177/article/details/31775133https://blog.csdn.net/fanyunlei/article/details/31775133https://blog.csdn.net/weixin_33995481/article/details/89371518https://blog.csdn.net/baidu_30809315/article/details/86686413 https://www.baidu.com/s?wd=jsonify%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1&amp;rsv_spt=1&amp;rsv_iqid=0xc7fd38c0001541cb&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=cn&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;oq=python%25E5%25AF%25B9%25E8%25B1%25A1%2520JSON%2520serializable&amp;rsv_btype=t&amp;inputT=17048&amp;rsv_t=54a2mgS05wbRRO0Tc7JK2a1HhOoF%2B5%2Fl3FA6f55WAx1J8YcodcspBzx6abZf0k6W2nbF&amp;rsv_sug3=74&amp;rsv_pq=c886278d0014b3a7&amp;rsv_sug1=24&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=18114https://blog.csdn.net/JENREY/article/details/87715651https://blog.csdn.net/t8116189520/article/details/91562915https://blog.csdn.net/u012887259/article/details/103345128https://www.jianshu.com/p/bf3f9078af74https://blog.csdn.net/qq_42226324/article/details/82989304https://www.baidu.com/s?wd=python%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E6%88%90json&amp;rsv_spt=1&amp;rsv_iqid=0xbe54345400280b02&amp;issp=1&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ts_1&amp;rsv_sug3=25&amp;rsv_sug1=18&amp;rsv_sug7=101&amp;rsv_sug2=1&amp;rsv_btype=i&amp;prefixsug=python%25E5%25B0%2586%25E5%25AF%25B9%25E8%25B1%25A1zhuan&amp;rsp=1&amp;inputT=9836&amp;rsv_sug4=10597https://www.cnblogs.com/qttblog/p/8615205.htmlhttps://www.cnblogs.com/qiumingcheng/p/11589657.html 最终参考：https://blog.csdn.net/baidu_30809315/article/details/86686413 代码： 123456def serialize(model): from sqlalchemy.orm import class_mapper columns = [c.key for c in class_mapper(model.__class__).columns] return dict((c, getattr(model, c)) for c in columns) # 参数为自定义类的对象","categories":[{"name":"写法","slug":"写法","permalink":"http://nlbyd1119.online/categories/%E5%86%99%E6%B3%95/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"系统类型 Web开发","slug":"系统类型-Web开发","date":"2020-06-12T14:00:18.000Z","updated":"2020-06-13T08:52:49.266Z","comments":true,"path":"2020/06/12/系统类型-Web开发/","link":"","permalink":"http://nlbyd1119.online/2020/06/12/%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B-Web%E5%BC%80%E5%8F%91/","excerpt":"一、系统类型","text":"一、系统类型 OA系统办公自动化（Office Automation，简称OA），是将计算机、通信等现代化技术运用到传统办公方式，进而形成的一种新型办公方式。办公自动化利用现代化设备和信息化技术，代替办公人员传统的部分手动或重复性业务活动，优质而高效地处理办公事务和业务信息，实现对信息资源的高效利用，进而达到提高生产率、辅助决策的目的，最大限度地提高工作效率和质量、改善工作环境。https://baike.baidu.com/item/OA%E7%B3%BB%E7%BB%9F/10677850?fr=aladdin CMS系统网站系统又名网站CMS系统，主要用途是为了节约网站开发的成本而开发的建站系统。早期的网站系统一般叫自助建站系统。现在的网站系统又分为企业网站系统，论坛系统，门户站系统和购物网站系统。https://baike.baidu.com/item/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F/7962477?fromtitle=CMS%E7%B3%BB%E7%BB%9F&amp;fromid=6089246&amp;fr=aladdin CRM系统CRM系统一般指客户关系管理系统，是指利用软件、硬件和网络技术，为企业建立一个客户信息收集、管理、分析和利用的信息系统。以客户数据的管理为核心，记录企业在市场营销和销售过程中和客户发生的各种交互行为，以及各类有关活动的状态，提供各类数据模型，为后期的分析和决策提供支持。https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/824647?fromtitle=CRM%E7%B3%BB%E7%BB%9F&amp;fromid=11000423&amp;fr=aladdin ERP系统ERP系统是企业资源计划 (Enterprise Resource Planning) 的简称，是指建立在信息技术基础上，集信息技术与先进管理思想于一身，以系统化的管理思想，为企业员工及决策层提供决策手段的管理平台。它是从MRP（物料需求计划）发展而来的新一代集成化管理信息系统，它扩展了MRP的功能，其核心思想是供应链管理。它跳出了传统企业边界，从供应链范围去优化企业的资源，优化了现代企业的运行模式，反映了市场对企业合理调配资源的要求。它对于改善企业业务流程、提高企业核心竞争力具有显著作用。https://baike.baidu.com/item/ERP%E7%B3%BB%E7%BB%9F/1569198?fr=aladdin MES系统制造执行系统 (manufacturing execution system， 简称MES)是美国AMR公司(Advanced Manufacturing Research，Inc．)在90年代初提出的，旨在加强MRP计划的执行功能，把MRP计划同车间作业现场控制，通过执行系统联系起来。这里的现场控制包括PLC程控器、数据采集器、条型码、各种计量及检测仪器、机械手等。MES系统设置了必要的接口，与提供生产现场控制设施的厂商建立合作关系。https://baike.baidu.com/item/%E5%88%B6%E9%80%A0%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F?fromtitle=MES%E7%B3%BB%E7%BB%9F&amp;fromid=1742501 HR系统人力资源管理系统， 通过提高内部员工的满意度、忠诚度，从而提高员工贡献度，即绩效，帮助管理者通过有效组织管理降低成本和加速增长来创造价值链利润。https://baike.baidu.com/item/%E4%BA%BA%E5%8A%9B%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/510186?fr=aladdin PDM系统 SCM系统 概念区分 MS、CRM、OA的区别是什么 https://zhidao.baidu.com/question/336336138.html erp，scm，scm三者的区别和联系https://zhidao.baidu.com/question/425814155748688012.htmlhttps://jingyan.baidu.com/article/20b68a88537f10796cec62e3.html 国内外CMS系统分类https://www.jianshu.com/p/63bdd6ef9992 二、Python Web开发相关https://www.baidu.com/s?wd=%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%81%E4%B8%9A%E4%B8%8D%E7%94%A8python%20web%E5%BC%80%E5%8F%91&amp;rsv_spt=1&amp;rsv_iqid=0xa453362c0005923f&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=36&amp;rsv_sug1=23&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=9950&amp;rsv_sug4=10605https://www.zhihu.com/question/278798145https://www.zhihu.com/question/290111945https://www.zhihu.com/question/371071919https://blog.csdn.net/ajian6/article/details/92634622https://baijiahao.baidu.com/s?id=1647445047044534535&amp;wfr=spider&amp;for=pc","categories":[{"name":"概念","slug":"概念","permalink":"http://nlbyd1119.online/categories/%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"live2d-study-1","slug":"live2d-study-1","date":"2020-06-10T00:36:32.000Z","updated":"2020-06-11T15:50:32.702Z","comments":true,"path":"2020/06/10/live2d-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/10/live2d-study-1/","excerpt":"关于live2d两个问题的解决","text":"关于live2d两个问题的解决 经过查找和测试代码，基本解决在桌面上显示live2d模型和在网页上显示moc3模型的问题。一、在桌面上显示live2d模型 先后参考https://github.com/search?q=%E6%A1%8C%E9%9D%A2live2dhttps://github.com/fguby/Electron-elf 界面好，但无法自定义模型和有音效https://github.com/dreamfalldown/AnimSprite 未测试https://github.com/horou-dsk/live2d_desktop_kb 未测试https://github.com/super233/Desktop-Helper 未测试https://github.com/erwindy/live2d-desktop 效果有一定缺陷，但是是最可用的https://github.com/fghrsh/live2d_demo 一个网页插件 最终使用https://github.com/erwindy/live2d-desktop已修改样式，并添加自定义模型，在D盘的Download/live目录下 综上代码，发现共用的一个依赖是 electron是一个js开发桌面应用的框架官网： https://www.electronjs.org/ 二、在网页上显示moc3模型经过很多测试，最终才确定可行的方案 先贴可行的代码参考： https://github.com/HCLonely/Live2dV31234567891011121314151617181920212223242526272829303132&lt;!------ 位置可自定义 ------&gt;&lt;div class=\"Canvas\" style=\"position: fixed; right: 10px; bottom: 10px;z-index: 99999999\" id=\"L2dCanvas\"&gt;&lt;/div&gt;&lt;!------ 依赖 JS | Dependent JS ------&gt;&lt;!---- 可选 | Optional ----&gt;&lt;!-- 兼容低版本浏览器 | Compatible with low-level browsers --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js\"&gt; &lt;/script&gt;&lt;!-- 音频播放兼容 | Audio playback compatible --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/howler@2.1.3/dist/howler.min.js\"&gt;&lt;/script&gt;&lt;!---- 必需 | Required ----&gt;&lt;script src=\"https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dcubismcore.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js\"&gt;&lt;/script&gt;&lt;!-- live2dv3.js --&gt;&lt;script src=\"https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dv3.js\"&gt;&lt;/script&gt;&lt;!------ 加载Live2d模型 | Load Live2d model ------&gt;&lt;script&gt; window.onload = () =&gt; &#123; new l2dViewer(&#123; el: document.getElementById('L2dCanvas'), basePath: 'https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/assets', // 模型根目录 modelName: 'aidang_2', // 模型目录 sizeLimit: false, mobileLimit: false &#125;) &#125;&lt;/script&gt;&lt;body&gt;hello&lt;/body&gt; 参考https://github.com/search?q=live2d3某大佬的一系列参考：https://gitee.com/nlby/Live2d-model/tree/masterhttps://eikanya.github.io/link/https://github.com/Eikanya/eikanya.github.io 通过分析loadModel.js文件，发现其加载模型url和https://github.com/HCLonely/Live2dV3 的共同点，都是模型使用 jsdelivr 关于模型加载的问题开始使用https://github.com/HCLonely/Live2dV3 的代码测试时，发现将模型换成本地的，无论如何都加载不出来，后来想到可能需要网络链接，于是开通腾讯COS，发现还不行，对比这份代码和dl的，发现两者的模型存放的url均使用了jsdelivhttps://cdn.jsdelivr.net/gh/Eikanya/live2dCDN@1.2.1/live2dv3/assets/https://cdn.jsdelivr.net/npm/live2dv3@1.2.2/https://github.com/Eikanya/live2dCDN于是就想到使用jsdeliv jsdeliv的使用参考 https://blog.csdn.net/qq_36759224/article/details/86936453几个步骤，github建库上传相关文件 创建release 然后就可以用jsdeliv访问，注意仓库中文件的总大小一定不能超过50M，否则不能访问本人仓库： https://github.com/nlby/live2dCDN/tree/1.0.2https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/assets/","categories":[{"name":"live2d","slug":"live2d","permalink":"http://nlbyd1119.online/categories/live2d/"}],"tags":[{"name":"效果","slug":"效果","permalink":"http://nlbyd1119.online/tags/%E6%95%88%E6%9E%9C/"}]},{"title":"flask-study-2","slug":"flask-study-2","date":"2020-06-09T09:14:14.000Z","updated":"2020-06-14T15:42:32.959Z","comments":true,"path":"2020/06/09/flask-study-2/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/flask-study-2/","excerpt":"黑马ihome项目 其一","text":"黑马ihome项目 其一 一、项目文件目录结构搭建1.单一全依赖manage.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# coding:utf-8from flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom flask_session import Sessionfrom flask_wtf import CSRFProtectimport redisapp = Flask(__name__)class Config: \"\"\"配置信息\"\"\" DEBUG = True SECRET_KEY = \"nlby33068080\" # 数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:6774258@127.0.0.1:3306/ihome_nlby\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # flask-session配置 SESSION_TYPE = \"redis\" SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 连接的redis实例 SESSION_USER_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期 单位秒app.config.from_object(Config)# 数据库db = SQLAlchemy(app)# 创建redis连接对象redis_store = redis.StrictRedis(host=Config.REDIS_HOST, port=Config.REDIS_PORT)# 利用flask-session 将session数据保存到redis中Session(app)# 为flask补充csrf防护 只要有post请求 就需要crsf防护CSRFProtect(app)@app.route(\"/index\")def index(): return \"hello\"if __name__ == '__main__': app.run() 2.拆分–项目结构（一）工程根目录manage.py 工程入口模块 12345678910111213from ihome import create_app, dbfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommand# 创建flask应用对象app = create_app(\"develop\")manager = Manager(app)Migrate(app, db)manager.add_command(\"db\", MigrateCommand)if __name__ == '__main__': manager.run() config.py 配置类 123456789101112131415161718192021222324252627282930313233import redisclass Config: \"\"\"配置信息\"\"\" SECRET_KEY = \"nlby33068080\" # 数据库 SQLALCHEMY_DATABASE_URI = \"mysql://root:6774258@127.0.0.1:3306/ihome_nlby\" SQLALCHEMY_TRACK_MODIFICATIONS = True # redis REDIS_HOST = \"127.0.0.1\" REDIS_PORT = 6379 # flask-session配置 SESSION_TYPE = \"redis\" SESSION_REDIS = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT) # 连接的redis实例 SESSION_USER_SIGNER = True # 对cookie中session_id进行隐藏处理 PERMANENT_SESSION_LIFETIME = 86400 # session数据的有效期 单位秒class DevelopmentConfig(Config): \"\"\"开发环境的配置信息\"\"\" DEBUG = Trueclass ProductionConfig(Config): \"\"\"生产环境的配置信息\"\"\" passconfig_map = &#123; \"develop\": DevelopmentConfig, \"product\": ProductionConfig&#125; （二）工程实现包ihomeinit.py 进行所有的app初始化 设置用到的全局变量 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from flask import Flaskfrom config import *from flask_sqlalchemy import SQLAlchemyfrom flask_session import Sessionfrom flask_wtf import CSRFProtectimport redisimport loggingfrom logging.handlers import RotatingFileHandler# 数据库db = SQLAlchemy()# 创建redis连接对象redis_store = None# 配置日志信息# 创建日志记录器，指明日志保存的路径、每个日志文件的最大大小、保存的日志文件个数上限file_log_handler = RotatingFileHandler(\"logs/log\", maxBytes=1024*1024*100, backupCount=10)# 创建日志记录的格式 日志等级 输入日志信息的文件名 行数 日志信息formatter = logging.Formatter('%(levelname)s %(filename)s:%(lineno)d %(message)s')# 为刚创建的日志记录器设置日志记录格式file_log_handler.setFormatter(formatter)# 为全局的日志工具对象（flask app使用的）添加日记录器logging.getLogger().addHandler(file_log_handler)# 设置日志的记录等级logging.basicConfig(level=logging.DEBUG) # 调试debug级logging.error(\"\") # 错误级别logging.warn(\"\") # 警告级别logging.info(\"\") # 消息提示级别logging.debug(\"\") # 调试级别# 工厂模式def create_app(config_name): \"\"\" 创建flask的应用对象 :param config_name: str 配置模式的名字 (\"develop\", \"product\") :return: \"\"\" app = Flask(__name__) # 根据配置模式的名字获取配置参数的类 config_class = config_map.get(config_name) app.config.from_object(config_class) # 使用app初始化db db.init_app(app) # 初始化redis工具 global redis_store redis_store = redis.StrictRedis(host=config_class.REDIS_HOST, port=config_class.REDIS_PORT) # 利用flask-session 将session数据保存到redis中 Session(app) # 为flask补充csrf防护 只要有post请求 就需要crsf防护 CSRFProtect(app) from ihome import api_1_0 # 注册蓝图 app.register_blueprint(api_1_0.api, url_prefix=\"/api/v1.0\") return app models.py 模型类模块api_1_0 1.0蓝图的视图存放目录api_1_0/init.py 1.0版本蓝图的创建 1234567from flask import Blueprint# 创建蓝图对象api = Blueprint(\"api_1_0\", __name__)# 导入蓝图的视图from . import demo api_1_0/views.py 1.0版本的视图函数模块 12345from . import api@api.route(\"/index\")def index(): return \"hello\" libs 存放外界依赖的目录utils 工具包static 静态资源文件（三）logs 存放日志文件 二、数据库设计1.数据库设计2.根据设计创建模型类3.迁移 12345python manage.py db initpython manage.py db migrate -m \"init tables\"python manage.py db upgrade 三、静态文件接口1.前后端分离与不分离的方式2.静态文件蓝图3.csrf防护机制与生成 四、图片验证码1.生成图片验证码的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#!/usr/bin/env python# -*- coding: utf-8 -*-# refer to `https://bitbucket.org/akorn/wheezy.captcha`import randomimport stringimport os.pathfrom io import BytesIOfrom PIL import Imagefrom PIL import ImageFilterfrom PIL.ImageDraw import Drawfrom PIL.ImageFont import truetypeclass Bezier: def __init__(self): self.tsequence = tuple([t / 20.0 for t in range(21)]) self.beziers = &#123;&#125; def pascal_row(self, n): \"\"\" Returns n-th row of Pascal's triangle \"\"\" result = [1] x, numerator = 1, n for denominator in range(1, n // 2 + 1): x *= numerator x /= denominator result.append(x) numerator -= 1 if n &amp; 1 == 0: result.extend(reversed(result[:-1])) else: result.extend(reversed(result)) return result def make_bezier(self, n): \"\"\" Bezier curves: http://en.wikipedia.org/wiki/B%C3%A9zier_curve#Generalization \"\"\" try: return self.beziers[n] except KeyError: combinations = self.pascal_row(n - 1) result = [] for t in self.tsequence: tpowers = (t ** i for i in range(n)) upowers = ((1 - t) ** i for i in range(n - 1, -1, -1)) coefs = [c * a * b for c, a, b in zip(combinations, tpowers, upowers)] result.append(coefs) self.beziers[n] = result return resultclass Captcha(object): def __init__(self): self._bezier = Bezier() self._dir = os.path.dirname(__file__) # self._captcha_path = os.path.join(self._dir, '..', 'static', 'captcha') @staticmethod def instance(): if not hasattr(Captcha, \"_instance\"): Captcha._instance = Captcha() return Captcha._instance def initialize(self, width=200, height=75, color=None, text=None, fonts=None): # self.image = Image.new('RGB', (width, height), (255, 255, 255)) self._text = text if text else random.sample(string.ascii_uppercase + string.ascii_uppercase + '3456789', 4) self.fonts = fonts if fonts else \\ [os.path.join(self._dir, 'fonts', font) for font in ['Arial.ttf', 'Georgia.ttf', 'actionj.ttf']] self.width = width self.height = height self._color = color if color else self.random_color(0, 200, random.randint(220, 255)) @staticmethod def random_color(start, end, opacity=None): red = random.randint(start, end) green = random.randint(start, end) blue = random.randint(start, end) if opacity is None: return red, green, blue return red, green, blue, opacity # draw image def background(self, image): Draw(image).rectangle([(0, 0), image.size], fill=self.random_color(238, 255)) return image @staticmethod def smooth(image): return image.filter(ImageFilter.SMOOTH) def curve(self, image, width=4, number=6, color=None): dx, height = image.size dx /= number path = [(dx * i, random.randint(0, height)) for i in range(1, number)] bcoefs = self._bezier.make_bezier(number - 1) points = [] for coefs in bcoefs: points.append(tuple(sum([coef * p for coef, p in zip(coefs, ps)]) for ps in zip(*path))) Draw(image).line(points, fill=color if color else self._color, width=width) return image def noise(self, image, number=50, level=2, color=None): width, height = image.size dx = width / 10 width -= dx dy = height / 10 height -= dy draw = Draw(image) for i in range(number): x = int(random.uniform(dx, width)) y = int(random.uniform(dy, height)) draw.line(((x, y), (x + level, y)), fill=color if color else self._color, width=level) return image def text(self, image, fonts, font_sizes=None, drawings=None, squeeze_factor=0.75, color=None): color = color if color else self._color fonts = tuple([truetype(name, size) for name in fonts for size in font_sizes or (65, 70, 75)]) draw = Draw(image) char_images = [] for c in self._text: font = random.choice(fonts) c_width, c_height = draw.textsize(c, font=font) char_image = Image.new('RGB', (c_width, c_height), (0, 0, 0)) char_draw = Draw(char_image) char_draw.text((0, 0), c, font=font, fill=color) char_image = char_image.crop(char_image.getbbox()) for drawing in drawings: d = getattr(self, drawing) char_image = d(char_image) char_images.append(char_image) width, height = image.size offset = int((width - sum(int(i.size[0] * squeeze_factor) for i in char_images[:-1]) - char_images[-1].size[0]) / 2) for char_image in char_images: c_width, c_height = char_image.size mask = char_image.convert('L').point(lambda i: i * 1.97) image.paste(char_image, (offset, int((height - c_height) / 2)), mask) offset += int(c_width * squeeze_factor) return image # draw text @staticmethod def warp(image, dx_factor=0.27, dy_factor=0.21): width, height = image.size dx = width * dx_factor dy = height * dy_factor x1 = int(random.uniform(-dx, dx)) y1 = int(random.uniform(-dy, dy)) x2 = int(random.uniform(-dx, dx)) y2 = int(random.uniform(-dy, dy)) image2 = Image.new('RGB', (width + abs(x1) + abs(x2), height + abs(y1) + abs(y2))) image2.paste(image, (abs(x1), abs(y1))) width2, height2 = image2.size return image2.transform( (width, height), Image.QUAD, (x1, y1, -x1, height2 - y2, width2 + x2, height2 + y2, width2 - x2, -y1)) @staticmethod def offset(image, dx_factor=0.1, dy_factor=0.2): width, height = image.size dx = int(random.random() * width * dx_factor) dy = int(random.random() * height * dy_factor) image2 = Image.new('RGB', (width + dx, height + dy)) image2.paste(image, (dx, dy)) return image2 @staticmethod def rotate(image, angle=25): return image.rotate( random.uniform(-angle, angle), Image.BILINEAR, expand=1) def captcha(self, path=None, fmt='JPEG'): \"\"\"Create a captcha. Args: path: save path, default None. fmt: image format, PNG / JPEG. Returns: A tuple, (name, text, StringIO.value). For example: ('fXZJN4AFxHGoU5mIlcsdOypa', 'JGW9', '\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\r...') \"\"\" image = Image.new('RGB', (self.width, self.height), (255, 255, 255)) image = self.background(image) image = self.text(image, self.fonts, drawings=['warp', 'rotate', 'offset']) image = self.curve(image) image = self.noise(image) image = self.smooth(image) name = \"\".join(random.sample(string.ascii_lowercase + string.ascii_uppercase + '3456789', 24)) text = \"\".join(self._text) out = BytesIO() image.save(out, format=fmt) if path: image.save(os.path.join(path, name), fmt) return name, text, out.getvalue() def generate_captcha(self): self.initialize() return self.captcha(\"\")captcha = Captcha.instance()if __name__ == '__main__': print (captcha.generate_captcha()) 2.获取图片验证码的逻辑 五、短信验证码1.云通讯sdk使用参考 https://blog.csdn.net/kk907528318/article/details/98250009https://www.yuntongxun.com/2.短信验证码相关的逻辑 六、注册登录 个人信息1.密码加密方法2.csrf设置3.登录验证装饰器4.使用七牛云sdk上传图片5.修改用户名6.获取个人资料7.实名认证","categories":[{"name":"Flask","slug":"Flask","permalink":"http://nlbyd1119.online/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"http://nlbyd1119.online/tags/PythonWeb/"}]},{"title":"pandas-note-1","slug":"numpy-note-11","date":"2020-06-09T07:11:39.000Z","updated":"2020-06-09T07:16:53.418Z","comments":true,"path":"2020/06/09/numpy-note-11/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/numpy-note-11/","excerpt":"pandas笔记一","text":"pandas笔记一 一、参考https://www.jianshu.com/p/0f6749c23d0fhttps://www.cnblogs.com/xbyfight/p/11172071.html 二、基本知识 常用数据类型 读取外部数据 DataFrame 索引 缺失数据处理 常用统计方法 分组和聚合 时间序列","categories":[{"name":"pandas","slug":"pandas","permalink":"http://nlbyd1119.online/categories/pandas/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"pandas-note-1","slug":"pandas-note-1","date":"2020-06-09T07:11:39.000Z","updated":"2020-06-09T07:12:47.906Z","comments":true,"path":"2020/06/09/pandas-note-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/pandas-note-1/","excerpt":"","text":"","categories":[{"name":"pandas","slug":"pandas","permalink":"http://nlbyd1119.online/categories/pandas/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"numpy-note-4","slug":"numpy-note-4","date":"2020-06-09T00:32:49.000Z","updated":"2020-06-09T00:46:42.096Z","comments":true,"path":"2020/06/09/numpy-note-4/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/numpy-note-4/","excerpt":"numpy笔记四","text":"numpy笔记四 create_ndarrays 1import numpy as np 123456print '使用普通一维数组生成Numpy一维数组'data = [6, 7.5, 8, 0, 1]arr = np.array(data)print arrprint '打印元素类型'print arr.dtype 123456print '使用普通二维数组生成NumPy二维数组'data= [[1, 2, 3, 4],[5, 6, 7, 8]]arr = np.array(data)print arrprint '维度'print arr.shape 使用普通二维数组生成NumPy二维数组 [[1 2 3 4] [5 6 7 8]] 维度 (2L, 4L)1234print '使用zeros/empty'print np.zeros(10) #10个0print np.zeros((3, 6)) #3*6 全0数组print np.empty((2,3,2)) #2*3*2数组 未初始化 使用zeros/empty [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [[ 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 0. 0.]] [[[ 0.00000000e+000 6.36598737e-314] [ 0.00000000e+000 1.27319747e-313] [ 1.27319747e-313 1.27319747e-313]] [[ 2.96439388e-323 1.90979621e-313] [ 0.00000000e+000 2.75859453e-313] [ 6.91691904e-323 3.60739284e-313]]]12print '使用arrange生成连续元素'print np.arange(15) 使用arrange生成连续元素 [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14]1234print '使用ones'a = np.ones((2,10))print aprint np.ones_like(a) 使用ones [[ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] [[ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]12print np.eye(4)print np.identity(6) [[ 1. 0. 0. 0.] [ 0. 1. 0. 0.] [ 0. 0. 1. 0.] [ 0. 0. 0. 1.]] [[ 1. 0. 0. 0. 0. 0.] [ 0. 1. 0. 0. 0. 0.] [ 0. 0. 1. 0. 0. 0.] [ 0. 0. 0. 1. 0. 0.] [ 0. 0. 0. 0. 1. 0.] [ 0. 0. 0. 0. 0. 1.]]123456print 'astype类型转换'b= np.arange(15).astype('string')print bprint b.astype('float32')print b.dtypeprint b.astype('float64') astype类型转换 [&apos;0&apos; &apos;1&apos; &apos;2&apos; &apos;3&apos; &apos;4&apos; &apos;5&apos; &apos;6&apos; &apos;7&apos; &apos;8&apos; &apos;9&apos; &apos;10&apos; &apos;11&apos; &apos;12&apos; &apos;13&apos; &apos;14&apos;] [ 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14.] |S11 [ 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14.]12print '指定dtype创建ndarray'print np.ones(15,dtype='string') 指定dtype创建ndarray [&apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos; &apos;1&apos;]operations_between_arrays_and_scalars 1import numpy as np 123456# 数组乘法／减法，对应元素相乘／相减。arr = np.array([[1.0, 2.0, 3.0], [4., 5., 6.]])print arr + arrprint arr - arrprint arr * arrprint arr / arr [[ 2. 4. 6.] [ 8. 10. 12.]] [[ 0. 0. 0.] [ 0. 0. 0.]] [[ 1. 4. 9.] [ 16. 25. 36.]] [[ 1. 1. 1.] [ 1. 1. 1.]]12345#标量操作作用在数组的每个元素上arr= np.array([[1.0, 2.0, 3.0], [4., 5., 6.]])print 1/arrprint arr ** 0.5print np.sqrt(arr) #np库函数 [[ 1. 0.5 0.33333333] [ 0.25 0.2 0.16666667]] [[ 1. 1.41421356 1.73205081] [ 2. 2.23606798 2.44948974]] [[ 1. 1.41421356 1.73205081] [ 2. 2.23606798 2.44948974]]basic_indexing_and_slicing 12import numpy as npfrom numpy import asarray 12345#通过索引访问二维数组某一行或某个元素arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print arr[2]print arr[0][2]print arr[0, 2] # 普通Python数组不能用。 [7 8 9] 3 312345678910# 对更高维数组的访问和操作arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10,11,12]]])print arr[0]print arr[1, 0]old_values = arr[0].copy() #复制arr[0]arr[0] = 42print arrprint arr[0] = old_valuesprint arr [[1 2 3] [4 5 6]] [7 8 9] [[[42 42 42] [42 42 42]] [[ 7 8 9] [10 11 12]]] [[[ 1 2 3] [ 4 5 6]] [[ 7 8 9] [10 11 12]]]12345# 附asarray 拷贝为ndarray的使用方法a = [1, 2, 3]b = asarray(a)print bb.dtype [1 2 3] dtype(&apos;int32&apos;)12345678910print '使用切片访问和操作数组'arr = np.arange(10)+1print arrprint arr [1:6]arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print arr[:2]print arr[:2, 1:]print arr[:, :1]arr[:2, 1:]=0print arr 使用切片访问和操作数组 [ 1 2 3 4 5 6 7 8 9 10] [2 3 4 5 6] [[1 2 3] [4 5 6]] [[2 3] [5 6]] [[1] [4] [7]] [[1 0 0] [4 0 0] [7 8 9]]boolean_indexing 12import numpy as npimport numpy.random as np_random 1234567print '使用布尔数组作为索引'name_arr = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])rnd_arr = np_random.randn(7, 4) # random 7*4 arrayprint rnd_arrprint name_arr == 'Bob'print rnd_arr[name_arr == 'Bob']print rnd_arr[name_arr == 'Bob', :2] 使用布尔数组作为索引 [[-1.42800631 -2.62500425 -1.52057421 -1.3482058 ] [ 0.4409493 1.48540013 0.40731781 0.16606016] [ 0.84783595 -2.15533993 1.50628519 -0.31510995] [-1.59846491 -1.47390465 -0.13706371 -2.51937338] [ 0.15842983 -0.11273919 0.06812044 -0.24180305] [-1.73153848 0.32802232 -0.28211856 -0.22661218] [-0.00328644 -0.15188049 0.92744076 -1.04438799]] [ True False False True False False False] [[-1.42800631 -2.62500425 -1.52057421 -1.3482058 ] [-1.59846491 -1.47390465 -0.13706371 -2.51937338]] [[-1.42800631 -2.62500425] [-1.59846491 -1.47390465]]1print rnd_arr[-(name_arr == 'Bob')] #输出的是 name_arr!='Bob'的行 [[ 0.4409493 1.48540013 0.40731781 0.16606016] [ 0.84783595 -2.15533993 1.50628519 -0.31510995] [ 0.15842983 -0.11273919 0.06812044 -0.24180305] [-1.73153848 0.32802232 -0.28211856 -0.22661218] [-0.00328644 -0.15188049 0.92744076 -1.04438799]] e:\\programs\\anaconda\\lib\\site-packages\\ipykernel\\__main__.py:1: DeprecationWarning: numpy boolean negative (the unary `-` operator) is deprecated, use the bitwise_xor (the `^` operator) or the logical_xor function instead. if __name__ == &apos;__main__&apos;:123456print rnd_arr[name_arr != 'Bob']mask_arr = (name_arr == 'Bob')| (name_arr == 'Will')print rnd_arr[mask_arr]print name_arrrnd_arr[name_arr == 'Joe'] = 7print rnd_arr [[ 0.4409493 1.48540013 0.40731781 0.16606016] [ 0.84783595 -2.15533993 1.50628519 -0.31510995] [ 0.15842983 -0.11273919 0.06812044 -0.24180305] [-1.73153848 0.32802232 -0.28211856 -0.22661218] [-0.00328644 -0.15188049 0.92744076 -1.04438799]] [[-1.42800631 -2.62500425 -1.52057421 -1.3482058 ] [ 0.84783595 -2.15533993 1.50628519 -0.31510995] [-1.59846491 -1.47390465 -0.13706371 -2.51937338] [ 0.15842983 -0.11273919 0.06812044 -0.24180305]] [&apos;Bob&apos; &apos;Joe&apos; &apos;Will&apos; &apos;Bob&apos; &apos;Will&apos; &apos;Joe&apos; &apos;Joe&apos;] [[-1.42800631 -2.62500425 -1.52057421 -1.3482058 ] [ 7. 7. 7. 7. ] [ 0.84783595 -2.15533993 1.50628519 -0.31510995] [-1.59846491 -1.47390465 -0.13706371 -2.51937338] [ 0.15842983 -0.11273919 0.06812044 -0.24180305] [ 7. 7. 7. 7. ] [ 7. 7. 7. 7. ]]fancy_indexing 1import numpy as np 12345print 'Fancy Indexing: 使用整数数组作为索引'arr = np.empty((8, 4))for i in range(8): arr[i] = iprint arr Fancy Indexing: 使用整数数组作为索引 [[ 0. 0. 0. 0.] [ 1. 1. 1. 1.] [ 2. 2. 2. 2.] [ 3. 3. 3. 3.] [ 4. 4. 4. 4.] [ 5. 5. 5. 5.] [ 6. 6. 6. 6.] [ 7. 7. 7. 7.]]123#指定第一维print arr[[4,3,0,6]]print arr[[-3,-5,-7]] [[ 4. 4. 4. 4.] [ 3. 3. 3. 3.] [ 0. 0. 0. 0.] [ 6. 6. 6. 6.]] [[ 5. 5. 5. 5.] [ 3. 3. 3. 3.] [ 1. 1. 1. 1.]]123arr = np.arange(32).reshape((8, 4))print arrprint arr[[1, 5, 7, 2], [0, 3, 1, 2]] #指定前两维 [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23] [24 25 26 27] [28 29 30 31]] [ 4 23 29 10]12print arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]print arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])] [[ 4 7 5 6] [20 23 21 22] [28 31 29 30] [ 8 11 9 10]] [[ 4 7 5 6] [20 23 21 22] [28 31 29 30] [ 8 11 9 10]]transposing_arrays_and_swapping_axes 12import numpy as npimport numpy.random as np_random 1234print '转置矩阵'arr = np.arange(15).reshape((3, 5))print arrprint arr.T 转置矩阵 [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] [[ 0 5 10] [ 1 6 11] [ 2 7 12] [ 3 8 13] [ 4 9 14]]123print '转置矩阵做点积'arr= np_random.randn(6, 3)print np.dot(arr.T, arr) 转置矩阵做点积 [[ 5.7096878 2.41366263 1.88994973] [ 2.41366263 7.9364555 -4.15577044] [ 1.88994973 -4.15577044 8.2566673 ]]123print '高维矩阵转换'arr = np.arange(16).reshape((2, 2, 4))print arr 高维矩阵转换 [[[ 0 1 2 3] [ 4 5 6 7]] [[ 8 9 10 11] [12 13 14 15]]]12print arr.transpose((1, 0, 2))print arr.swapaxes(1, 2) [[[ 0 1 2 3] [ 8 9 10 11]] [[ 4 5 6 7] [12 13 14 15]]] [[[ 0 4] [ 1 5] [ 2 6] [ 3 7]] [[ 8 12] [ 9 13] [10 14] [11 15]]]12arr2 = np.array([['xiaozhang','xiaowang'],['30','40'],['engineer','teacher']])print arr2.swapaxes(0,1) [[&apos;xiaozhang&apos; &apos;30&apos; &apos;engineer&apos;] [&apos;xiaowang&apos; &apos;40&apos; &apos;teacher&apos;]]universal_functions 12import numpy as npimport numpy.random as np_random 123print '求平方根'arr = np.arange(10)print np.sqrt(arr) 求平方根 [ 0. 1. 1.41421356 1.73205081 2. 2.23606798 2.44948974 2.64575131 2.82842712 3. ]123456print '数组比较'x = np_random.randn(8)y = np_random.randn(8)print xprint yprint np.maximum(x,y) 数组比较 [ 0.7545063 1.09322751 -0.61806054 -1.01449904 -1.03062829 -0.43887283 0.18096014 0.2158842 ] [-0.29827664 -0.4190177 -0.24344043 1.02676912 -0.41224523 0.76204459 -0.36508918 0.79134304] [ 0.7545063 1.09322751 -0.24344043 1.02676912 -0.41224523 0.76204459 0.18096014 0.79134304]12345print '四舍五入到接近的整数'arr = np.array([1, 2.4, 3.1, 5.6])print np.rint(arr)print '整数 小数分开存为两个数组'print np.modf(arr) 四舍五入到接近的整数 [ 1. 2. 3. 6.] 整数 小数分开存为两个数组 (array([ 0. , 0.4, 0.1, 0.6]), array([ 1., 2., 3., 5.]))1234567print '分为表示关于判断NaN（非数字）的逻辑数组'arr = np.array(['1','f', '3', '42', 'd'])print np.dtype# todo np.isnan(np.nan)np.isnan(np.inf)np.isnan([np.log(-1.),1.,np.log(0)]) 分为表示关于判断NaN（非数字）的逻辑数组 &lt;type &apos;numpy.dtype&apos;&gt; e:\\programs\\anaconda\\lib\\site-packages\\ipykernel\\__main__.py:7: RuntimeWarning: invalid value encountered in log e:\\programs\\anaconda\\lib\\site-packages\\ipykernel\\__main__.py:7: RuntimeWarning: divide by zero encountered in log array([ True, False, False], dtype=bool)12print np.isfinite(np.inf)print np.isinf(np.inf) False True123print '三角函数'arr = np.arange(10).reshape(2,5)print np.cos(arr) 三角函数 [[ 1. 0.54030231 -0.41614684 -0.9899925 -0.65364362] [ 0.28366219 0.96017029 0.75390225 -0.14550003 -0.91113026]]123print '逻辑取反 与 取反'print np.logical_not(arr)print -arr 逻辑取反 与 取反 [[ True False False False False] [False False False False False]] [[ 0 -1 -2 -3 -4] [-5 -6 -7 -8 -9]]123456789print '二元函数'arr1 = [ 1, 3, 4, 14, 62]arr2 = [2, 5, 65, 7, 2]print np.add(arr1,arr2)print np.subtract(arr1,arr2)print np.multiply(arr1,arr2)print np.divide(arr1,arr2)print '向下取整除法'print np,floor_divede(arr1, arr2) 二元函数 [ 3 8 69 21 64] [ -1 -2 -61 7 60] [ 2 15 260 98 124] [ 0 0 0 2 31] 向下取整除法 &lt;module &apos;numpy&apos; from &apos;e:\\programs\\anaconda\\lib\\site-packages\\numpy\\__init__.pyc&apos;&gt; --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-37-e1e880da8cc1&gt; in &lt;module&gt;() 7 print np.divide(arr1,arr2) 8 print &apos;向下取整除法&apos; ----&gt; 9 print np,floor_divede(arr1, arr2) NameError: name &apos;floor_divede&apos; is not defined1234print power(arr1,arr2) #a^bprint maximum(arr1,arr2) #fmax(arr1,arr2)会忽略NaNprint minimum(arr1,arr2) #fmin(arr1,arr2)会忽略NaNprint mod(arr1,arr2) --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-38-808faaeb378c&gt; in &lt;module&gt;() ----&gt; 1 print power(arr1,arr2) #a^b 2 print maximum(arr1,arr2) #fmax(arr1,arr2)会忽略NaN 3 print minimum(arr1,arr2) #fmin(arr1,arr2)会忽略NaN 4 print mod(arr1,arr2) NameError: name &apos;power&apos; is not defined1#todo data_processing_intro 123import matplotlib.pyplot as pltimport numpy as npimport pylab 123456points = np.arange(-5, 5, 0.01) #generate 100 pointsxs, ys = np.meshgrid(points, points) # xs, ysprint xsprint ysz = np.sqrt(xs **2 + ys ** 2)print z [[-5. -4.99 -4.98 ..., 4.97 4.98 4.99] [-5. -4.99 -4.98 ..., 4.97 4.98 4.99] [-5. -4.99 -4.98 ..., 4.97 4.98 4.99] ..., [-5. -4.99 -4.98 ..., 4.97 4.98 4.99] [-5. -4.99 -4.98 ..., 4.97 4.98 4.99] [-5. -4.99 -4.98 ..., 4.97 4.98 4.99]] [[-5. -5. -5. ..., -5. -5. -5. ] [-4.99 -4.99 -4.99 ..., -4.99 -4.99 -4.99] [-4.98 -4.98 -4.98 ..., -4.98 -4.98 -4.98] ..., [ 4.97 4.97 4.97 ..., 4.97 4.97 4.97] [ 4.98 4.98 4.98 ..., 4.98 4.98 4.98] [ 4.99 4.99 4.99 ..., 4.99 4.99 4.99]] [[ 7.07106781 7.06400028 7.05693985 ..., 7.04988652 7.05693985 7.06400028] [ 7.06400028 7.05692568 7.04985815 ..., 7.04279774 7.04985815 7.05692568] [ 7.05693985 7.04985815 7.04278354 ..., 7.03571603 7.04278354 7.04985815] ..., [ 7.04988652 7.04279774 7.03571603 ..., 7.0286414 7.03571603 7.04279774] [ 7.05693985 7.04985815 7.04278354 ..., 7.03571603 7.04278354 7.04985815] [ 7.06400028 7.05692568 7.04985815 ..., 7.04279774 7.04985815 7.05692568]]12345# drawplt.imshow(z, cmap = plt.cm.gray)plt.colorbar()plt.title(\"Image plot of $\\sqrt&#123;x^2+y^2&#125;$ for a grid of values\")pylab.show() expressing_conditional_logical_as_array_operations 1234from __builtin__ import xrangefrom __builtin__ import lenimport numpy as npimport numpy.random as np_random 12345678910'''关于zip函数的一点解释，zip可以接受任意多参数，然后重新组合成1个tuple列表。zip([1, 2, 3], [4, 5, 6], [7, 8, 9])返回结果：[(1, 4, 7), (2, 5, 8), (3, 6, 9)]'''print u'通过真值表选择元素'x_arr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])y_arr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])cond = np.array([True, False, True, True, False])result =","categories":[{"name":"numpy","slug":"numpy","permalink":"http://nlbyd1119.online/categories/numpy/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"numpy-note-3","slug":"numpy-note-3","date":"2020-06-09T00:21:03.000Z","updated":"2020-06-09T00:24:06.423Z","comments":true,"path":"2020/06/09/numpy-note-3/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/numpy-note-3/","excerpt":"numpy笔记三","text":"numpy笔记三 文档 https://www.runoob.com/numpy/numpy-tutorial.html numpy 创建数组 import numpy as npnp.array([])np.array(range())np.arange(3,10,2) #生成从3到10，步长为2的一个一维数组 数据类型 int, float, “int64” ,”int32”,”float32”,boolt1.dtype #观察数据类型t1.astype() numpy的索引和切片 t[10,20] t[[2,5],[4,8]] t[3:] t[[2,5,6]] t[:,:4] t[:,[2,5,6]] t[2:3,5:7] numpy中的bool索引,where,clip的使用 t[t&lt;30] = 2 np.where(t&lt;10,20,5) t.clip(10,20) 转置和读取本地文件 t.T t.transpose() t.sawpaxes() np.loadtxt(file_path,delimiter,dtype) nan和inf是什么 nan not a number np.nan != np.nan 任何值和nan进行计算都是nan inf 无穷 常用统计函数 t.sum() t.mean() np.meadian() t.max() t.min() np.ptp() t.std() numpy数组的拼接 np.hstack(t1,t2) np.vstack(t1,t2)","categories":[{"name":"numpy","slug":"numpy","permalink":"http://nlbyd1119.online/categories/numpy/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"numpy-note-2","slug":"numpy-note-2","date":"2020-06-08T23:50:25.000Z","updated":"2020-06-08T23:51:26.108Z","comments":true,"path":"2020/06/09/numpy-note-2/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/numpy-note-2/","excerpt":"numpy笔记二","text":"numpy笔记二 CSDN：http://blog.csdn.net/kicilove/article/ github：https://github.com/zhaohuicici?tab=repositories 1234import numpyworld_alcohol = numpy.genfromtxt(\"world_alcohol.txt\", delimiter=\",\")print(type(world_alcohol)) &lt;class &apos;numpy.ndarray&apos;&gt;123456#The numpy.array() function can take a list or list of lists as input. When we input a list, we get a one-dimensional array as a result:vector = numpy.array([5, 10, 15, 20])#When we input a list of lists, we get a matrix as a result:matrix = numpy.array([[5, 10, 15], [20, 25, 30], [35, 40, 45]])print (vector)print (matrix) [ 5 10 15 20] [[ 5 10 15] [20 25 30] [35 40 45]]123456#We can use the ndarray.shape property to figure out how many elements are in the arrayvector = numpy.array([1, 2, 3, 4])print(vector.shape)#For matrices, the shape property contains a tuple with 2 elements.matrix = numpy.array([[5, 10, 15], [20, 25, 30]])print(matrix.shape) (4,) (2, 3)12345#Each value in a NumPy array has to have the same data type#NumPy will automatically figure out an appropriate data type when reading in data or converting lists to arrays. #You can check the data type of a NumPy array using the dtype property.numbers = numpy.array([1, 2, 3, 4])numbers.dtype dtype(&apos;int32&apos;)1234#When NumPy can't convert a value to a numeric data type like float or integer, it uses a special nan value that stands for Not a Number#nan is the missing data#1.98600000e+03 is actually 1.986 * 10 ^ 3world_alcohol array([[ nan, nan, nan, nan, nan], [ 1.98600000e+03, nan, nan, nan, 0.00000000e+00], [ 1.98600000e+03, nan, nan, nan, 5.00000000e-01], ..., [ 1.98700000e+03, nan, nan, nan, 7.50000000e-01], [ 1.98900000e+03, nan, nan, nan, 1.50000000e+00], [ 1.98500000e+03, nan, nan, nan, 3.10000000e-01]])12world_alcohol = numpy.genfromtxt(\"world_alcohol.txt\", delimiter=\",\", dtype=\"U75\", skip_header=1)print(world_alcohol) [[&apos;1986&apos; &apos;Western Pacific&apos; &apos;Viet Nam&apos; &apos;Wine&apos; &apos;0&apos;] [&apos;1986&apos; &apos;Americas&apos; &apos;Uruguay&apos; &apos;Other&apos; &apos;0.5&apos;] [&apos;1985&apos; &apos;Africa&apos; &quot;Cte d&apos;Ivoire&quot; &apos;Wine&apos; &apos;1.62&apos;] ..., [&apos;1987&apos; &apos;Africa&apos; &apos;Malawi&apos; &apos;Other&apos; &apos;0.75&apos;] [&apos;1989&apos; &apos;Americas&apos; &apos;Bahamas&apos; &apos;Wine&apos; &apos;1.5&apos;] [&apos;1985&apos; &apos;Africa&apos; &apos;Malawi&apos; &apos;Spirits&apos; &apos;0.31&apos;]]1234uruguay_other_1986 = world_alcohol[1,4]third_country = world_alcohol[2,2]print (uruguay_other_1986)print (third_country) 0.5 Cte d&apos;Ivoire12vector = numpy.array([5, 10, 15, 20])print(vector[0:3]) [ 5 10 15]123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])print(matrix[:,1]) [10 25 40]123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])print(matrix[:,0:2]) [[ 5 10] [20 25] [35 40]]123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])print(matrix[1:3,0:2]) [[20 25] [35 40]]12345import numpy#it will compare the second value to each element in the vector# If the values are equal, the Python interpreter returns True; otherwise, it returns Falsevector = numpy.array([5, 10, 15, 20])vector == 10 array([False, True, False, False], dtype=bool)123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])matrix == 25 array([[False, False, False], [False, True, False], [False, False, False]], dtype=bool)12345#Compares vector to the value 10, which generates a new Boolean vector [False, True, False, False]. It assigns this result to equal_to_tenvector = numpy.array([5, 10, 15, 20])equal_to_ten = (vector == 10)print (equal_to_ten)print(vector[equal_to_ten]) [False True False False] [10]12345678matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])second_column_25 = (matrix[:,1] == 25)print (second_column_25)print(matrix[second_column_25, :]) [False True False] [[20 25 30]]1234#We can also perform comparisons with multiple conditionsvector = numpy.array([5, 10, 15, 20])equal_to_ten_and_five = (vector == 10) &amp; (vector == 5)print(equal_to_ten_and_five) [False False False False]123vector = numpy.array([5, 10, 15, 20])equal_to_ten_or_five = (vector == 10) | (vector == 5)print(equal_to_ten_or_five) [ True True False False]1234vector = numpy.array([5, 10, 15, 20])equal_to_ten_or_five = (vector == 10) | (vector == 5)vector[equal_to_ten_or_five] = 50print(vector) [50 50 15 20]123456789matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])second_column_25 = matrix[:,1] == 25print (second_column_25)matrix[second_column_25, 1] = 10print(matrix) [False True False] [[ 5 10 15] [20 10 30] [35 40 45]]1234567#We can convert the data type of an array with the ndarray.astype() method.vector = numpy.array([\"1\", \"2\", \"3\"])print (vector.dtype)print (vector)vector = vector.astype(float)print (vector.dtype)print (vector) &lt;U1 [&apos;1&apos; &apos;2&apos; &apos;3&apos;] float64 [ 1. 2. 3.]12vector = numpy.array([5, 10, 15, 20])vector.sum() 5012345678# The axis dictates which dimension we perform the operation on#1 means that we want to perform the operation on each row, and 0 means on each columnmatrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])matrix.sum(axis=1) array([ 30, 75, 120])123456matrix = numpy.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])matrix.sum(axis=0) array([60, 75, 90])123456789101112#replace nan value with 0world_alcohol = numpy.genfromtxt(\"world_alcohol.txt\", delimiter=\",\")#print world_alcoholis_value_empty = numpy.isnan(world_alcohol[:,4])#print is_value_emptyworld_alcohol[is_value_empty, 4] = '0'alcohol_consumption = world_alcohol[:,4]alcohol_consumption = alcohol_consumption.astype(float)total_alcohol = alcohol_consumption.sum()average_alcohol = alcohol_consumption.mean()print (total_alcohol)print (average_alcohol) 1137.78 1.140060120241import numpy as np 123a = np.arange(15).reshape(3, 5)a array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])1a.shape (3, 5)12#the number of axes (dimensions) of the arraya.ndim 21a.dtype.name &apos;int32&apos;12#the total number of elements of the arraya.size 151np.zeros ((3,4)) array([[ 0., 0., 0., 0.], [ 0., 0., 0., 0.], [ 0., 0., 0., 0.]])1np.ones( (2,3,4), dtype=np.int32 ) array([[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]])12#To create sequences of numbersnp.arange( 10, 30, 5 ) array([10, 15, 20, 25])1np.arange( 0, 2, 0.3 ) array([ 0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])1np.arange(12).reshape(4,3) array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]])1np.random.random((2,3)) array([[ 0.0676035 , 0.95493504, 0.59916183], [ 0.02919477, 0.95589551, 0.74567506]])12from numpy import pinp.linspace( 0, 2*pi, 100 ) array([ 0. , 0.06346652, 0.12693304, 0.19039955, 0.25386607, 0.31733259, 0.38079911, 0.44426563, 0.50773215, 0.57119866, 0.63466518, 0.6981317 , 0.76159822, 0.82506474, 0.88853126, 0.95199777, 1.01546429, 1.07893081, 1.14239733, 1.20586385, 1.26933037, 1.33279688, 1.3962634 , 1.45972992, 1.52319644, 1.58666296, 1.65012947, 1.71359599, 1.77706251, 1.84052903, 1.90399555, 1.96746207, 2.03092858, 2.0943951 , 2.15786162, 2.22132814, 2.28479466, 2.34826118, 2.41172769, 2.47519421, 2.53866073, 2.60212725, 2.66559377, 2.72906028, 2.7925268 , 2.85599332, 2.91945984, 2.98292636, 3.04639288, 3.10985939, 3.17332591, 3.23679243, 3.30025895, 3.36372547, 3.42719199, 3.4906585 , 3.55412502, 3.61759154, 3.68105806, 3.74452458, 3.8079911 , 3.87145761, 3.93492413, 3.99839065, 4.06185717, 4.12532369, 4.1887902 , 4.25225672, 4.31572324, 4.37918976, 4.44265628, 4.5061228 , 4.56958931, 4.63305583, 4.69652235, 4.75998887, 4.82345539, 4.88692191, 4.95038842, 5.01385494, 5.07732146, 5.14078798, 5.2042545 , 5.26772102, 5.33118753, 5.39465405, 5.45812057, 5.52158709, 5.58505361, 5.64852012, 5.71198664, 5.77545316, 5.83891968, 5.9023862 , 5.96585272, 6.02931923, 6.09278575, 6.15625227, 6.21971879, 6.28318531])1np.sin(np.linspace( 0, 2*pi, 100 )) array([ 0.00000000e+00, 6.34239197e-02, 1.26592454e-01, 1.89251244e-01, 2.51147987e-01, 3.12033446e-01, 3.71662456e-01, 4.29794912e-01, 4.86196736e-01, 5.40640817e-01, 5.92907929e-01, 6.42787610e-01, 6.90079011e-01, 7.34591709e-01, 7.76146464e-01, 8.14575952e-01, 8.49725430e-01, 8.81453363e-01, 9.09631995e-01, 9.34147860e-01, 9.54902241e-01, 9.71811568e-01, 9.84807753e-01, 9.93838464e-01, 9.98867339e-01, 9.99874128e-01, 9.96854776e-01, 9.89821442e-01, 9.78802446e-01, 9.63842159e-01, 9.45000819e-01, 9.22354294e-01, 8.95993774e-01, 8.66025404e-01, 8.32569855e-01, 7.95761841e-01, 7.55749574e-01, 7.12694171e-01, 6.66769001e-01, 6.18158986e-01, 5.67059864e-01, 5.13677392e-01, 4.58226522e-01, 4.00930535e-01, 3.42020143e-01, 2.81732557e-01, 2.20310533e-01, 1.58001396e-01, 9.50560433e-02, 3.17279335e-02, -3.17279335e-02, -9.50560433e-02, -1.58001396e-01, -2.20310533e-01, -2.81732557e-01, -3.42020143e-01, -4.00930535e-01, -4.58226522e-01, -5.13677392e-01, -5.67059864e-01, -6.18158986e-01, -6.66769001e-01, -7.12694171e-01, -7.55749574e-01, -7.95761841e-01, -8.32569855e-01, -8.66025404e-01, -8.95993774e-01, -9.22354294e-01, -9.45000819e-01, -9.63842159e-01, -9.78802446e-01, -9.89821442e-01, -9.96854776e-01, -9.99874128e-01, -9.98867339e-01, -9.93838464e-01, -9.84807753e-01, -9.71811568e-01, -9.54902241e-01, -9.34147860e-01, -9.09631995e-01, -8.81453363e-01, -8.49725430e-01, -8.14575952e-01, -7.76146464e-01, -7.34591709e-01, -6.90079011e-01, -6.42787610e-01, -5.92907929e-01, -5.40640817e-01, -4.86196736e-01, -4.29794912e-01, -3.71662456e-01, -3.12033446e-01, -2.51147987e-01, -1.89251244e-01, -1.26592454e-01, -6.34239197e-02, -2.44929360e-16])1234567891011#the product operator * operates elementwise in NumPy arraysa = np.array( [20,30,40,50] )b = np.arange( 4 )#print a #print b#bc = a-b#print cb**2#print b**2print (a&lt;35) [ True True False False]12345678910#The matrix product can be performed using the dot function or methodA = np.array( [[1,1], [0,1]] )B = np.array( [[2,0], [3,4]] )print (A)print (B)print (A*B)print (A.dot(B))print (np.dot(A, B) ) [[1 1] [0 1]] [[2 0] [3 4]] [[2 0] [0 4]] [[5 4] [3 4]] [[5 4] [3 4]]12345import numpy as npB = np.arange(3)print(B) #print np.exp(B)print(np.sqrt(B)) [0 1 2] [ 0. 1. 1.41421356]123456789101112131415#Return the floor of the inputa = np.floor(10*np.random.random((3,4)))#print a#a.shape## flatten the array#print a.ravel()#a.shape = (6, 2)#print a #print a.Tprint (a.resize((2,6)))print (a)#If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:#a.reshape(3,-1) None [[ 2. 8. 0. 1. 3. 9.] [ 7. 4. 1. 3. 2. 7.]]12345678a = np.floor(10*np.random.random((2,2)))b = np.floor(10*np.random.random((2,2)))print (a)print (b)print('---') print (np.hstack((a,b)))#np.hstack((a,b)) [[ 2. 9.] [ 5. 3.]] [[ 5. 4.] [ 9. 3.]] --- [[ 2. 9. 5. 4.] [ 5. 3. 9. 3.]]1234567a = np.floor(10*np.random.random((2,12)))#print a#print np.hsplit(a,3)#print np.hsplit(a,(3,4)) # Split a after the third and the fourth columna = np.floor(10*np.random.random((12,2)))print (a)np.vsplit(a,3) [[ 2. 8.] [ 9. 1.] [ 3. 2.] [ 0. 6.] [ 1. 4.] [ 5. 6.] [ 0. 1.] [ 9. 9.] [ 8. 2.] [ 2. 4.] [ 6. 9.] [ 6. 1.]] [array([[ 2., 8.], [ 9., 1.], [ 3., 2.], [ 0., 6.]]), array([[ 1., 4.], [ 5., 6.], [ 0., 1.], [ 9., 9.]]), array([[ 8., 2.], [ 2., 4.], [ 6., 9.], [ 6., 1.]])]123456789#Simple assignments make no copy of array objects or of their data.a = np.arange(12)b = a# a and b are two names for the same ndarray objectb is ab.shape = 3,4print (a.shape)#print id(a)#print id(b) (3, 4)1234567#The view method creates a new array object that looks at the same data.c = a.view()c is ac.shape = 2,6#print a.shapec[0,4] = 1234a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]])123456#The copy method makes a complete copy of the array and its data.d = a.copy() d is ad[0,0] = 9999print (d) print (a) [[9999 1 2 3] [1234 5 6 7] [ 8 9 10 11]] [[ 0 1 2 3] [1234 5 6 7] [ 8 9 10 11]]12345678import numpy as npdata = np.sin(np.arange(20)).reshape(5,4)print (data)ind = data.argmax(axis=0)print (ind)data_max = data[ind, range(data.shape[1])]print(data_max)all(data_max == data.max(axis=0)) [[ 0. 0.84147098 0.90929743 0.14112001] [-0.7568025 -0.95892427 -0.2794155 0.6569866 ] [ 0.98935825 0.41211849 -0.54402111 -0.99999021] [-0.53657292 0.42016704 0.99060736 0.65028784] [-0.28790332 -0.96139749 -0.75098725 0.14987721]] [2 0 3 1] [ 0.98935825 0.84147098 0.99060736 0.6569866 ] True123a = np.arange(0, 40, 10)b = np.tile(a, (3, 5)) print (b) [[ 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30] [ 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30] [ 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30 0 10 20 30]]1234567891011a = np.array([[4, 3, 5], [1, 2, 1]])print (a)b = np.sort(a, axis=1)print (b)ba.sort(axis=1)print (a)a = np.array([4, 3, 1, 2])j = np.argsort(a)print (j)print(a[j]) [[4 3 5] [1 2 1]] [[3 4 5] [1 1 2]] [[3 4 5] [1 1 2]] [2 3 1 0] [1 2 3 4]123456import numpy as np#1:8*8棋盘矩阵，其中1、3、5、7行&amp;&amp;0、2、4、6列的元素置为1 1 ,3，5，7列&amp;&amp;0,2,4,6行也是1z = np.zeros((8,8),dtype=int)z[1::2,::2] = 1z[::2,1::2] = 1print (z) [[0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0] [0 1 0 1 0 1 0 1] [1 0 1 0 1 0 1 0]]1#2：min()、max()函数 12z = np.random.random((10,10))zmin,zmax = z.min(),z.max() 123456#归一化，将矩阵规格化到0～1，即最小的变成0，最大的变成1，最小与最大之间的等比缩放z = 10*np.random.random((5,5))print (z)zmin,zmax = z.min(),z.max()z = (z-zmin)/(zmax-zmin)print (z) [[ 2.47659898 0.22816549 3.87927306 1.88556067 4.68572514] [ 5.63682073 1.43651282 3.44955402 7.87808309 6.44127844] [ 7.1311386 4.4476395 7.01197691 2.41733361 7.55812153] [ 0.20384964 6.44726354 7.70855481 5.74265816 5.85204422] [ 0.4881117 1.06615498 5.81050566 3.52414911 4.78356764]] [[ 0.29615327 0.00316851 0.47893036 0.21913733 0.58401605] [ 0.70794968 0.16062362 0.42293532 1. 0.81277548] [ 0.90266852 0.55299202 0.88714102 0.28843063 0.95830703] [ 0. 0.81355538 0.97790942 0.72174095 0.73599463] [ 0.0370411 0.11236371 0.7305819 0.43265552 0.59676553]]12345#矩阵相加z = np.zeros((5,5))z += np.arange(5)print(np.arange(5)) print (z) [0 1 2 3 4] [[ 0. 1. 2. 3. 4.] [ 0. 1. 2. 3. 4.] [ 0. 1. 2. 3. 4.] [ 0. 1. 2. 3. 4.] [ 0. 1. 2. 3. 4.]]1234#生成0~10之间均匀分布的11个数，包括0和10z = np.linspace(0,10,11,endpoint=True,retstep=True)print (z) (array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]), 1.0)1help(np.linspace) Help on function linspace in module numpy.core.function_base: linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) Return evenly spaced numbers over a specified interval. Returns `num` evenly spaced samples, calculated over the interval [`start`, `stop`]. The endpoint of the interval can optionally be excluded. Parameters ---------- start : scalar The starting value of the sequence. stop : scalar The end value of the sequence, unless `endpoint` is set to False. In that case, the sequence consists of all but the last of ``num + 1`` evenly spaced samples, so that `stop` is excluded. Note that the step size changes when `endpoint` is False. num : int, optional Number of samples to generate. Default is 50. Must be non-negative. endpoint : bool, optional If True, `stop` is the last sample. Otherwise, it is not included. Default is True. retstep : bool, optional If True, return (`samples`, `step`), where `step` is the spacing between samples. dtype : dtype, optional The type of the output array. If `dtype` is not given, infer the data type from the other input arguments. .. versionadded:: 1.9.0 Returns ------- samples : ndarray There are `num` equally spaced samples in the closed interval ``[start, stop]`` or the half-open interval ``[start, stop)`` (depending on whether `endpoint` is True or False). step : float Only returned if `retstep` is True Size of spacing between samples. See Also -------- arange : Similar to `linspace`, but uses a step size (instead of the number of samples). logspace : Samples uniformly distributed in log space. Examples -------- &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5) array([ 2. , 2.25, 2.5 , 2.75, 3. ]) &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False) array([ 2. , 2.2, 2.4, 2.6, 2.8]) &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True) (array([ 2. , 2.25, 2.5 , 2.75, 3. ]), 0.25) Graphical illustration: &gt;&gt;&gt; import matplotlib.pyplot as plt &gt;&gt;&gt; N = 8 &gt;&gt;&gt; y = np.zeros(N) &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True) &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False) &gt;&gt;&gt; plt.plot(x1, y, &apos;o&apos;) [&lt;matplotlib.lines.Line2D object at 0x...&gt;] &gt;&gt;&gt; plt.plot(x2, y + 0.5, &apos;o&apos;) [&lt;matplotlib.lines.Line2D object at 0x...&gt;] &gt;&gt;&gt; plt.ylim([-0.5, 1]) (-0.5, 1) &gt;&gt;&gt; plt.show()123456import numpy as np#交换矩阵的其中两行a = np.arange(25).reshape(5,5)print (a)a[[0,1]] = a[[1,0]]print (a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] [[ 5 6 7 8 9] [ 0 1 2 3 4] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]]1234#找出数组中与给定值最接近的数z = np.array([[0,1,2,3],[4,5,6,7]])a = 5.1print (np.abs(z-a).argmin()) 51234#判断二维矩阵中有没有一整列数为0？z = np.random.randint(0,3,(2,10))print (z)print (z.any(axis=0)) [[1 2 2 0 2 1 2 2 0 0] [2 1 2 2 2 1 0 0 0 1]] [ True True True True True True True True False True]12#生成二维的高斯矩阵help(np.random.randint) Help on built-in function randint: randint(...) method of mtrand.RandomState instance randint(low, high=None, size=None, dtype=&apos;l&apos;) Return random integers from `low` (inclusive) to `high` (exclusive). Return random integers from the &quot;discrete uniform&quot; distribution of the specified dtype in the &quot;half-open&quot; interval [`low`, `high`). If `high` is None (the default), then results are from [0, `low`). Parameters ---------- low : int Lowest (signed) integer to be drawn from the distribution (unless ``high=None``, in which case this parameter is the *highest* such integer). high : int, optional If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if ``high=None``). size : int or tuple of ints, optional Output shape. If the given shape is, e.g., ``(m, n, k)``, then ``m * n * k`` samples are drawn. Default is None, in which case a single value is returned. dtype : dtype, optional Desired dtype of the result. All dtypes are determined by their name, i.e., &apos;int64&apos;, &apos;int&apos;, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is &apos;np.int&apos;. .. versionadded:: 1.11.0 Returns ------- out : int or ndarray of ints `size`-shaped array of random integers from the appropriate distribution, or a single such random int if `size` not provided. See Also -------- random.random_integers : similar to `randint`, only for the closed interval [`low`, `high`], and 1 is the lowest value if `high` is omitted. In particular, this other one is the one to use to generate uniformly distributed discrete non-integers. Examples -------- &gt;&gt;&gt; np.random.randint(2, size=10) array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) &gt;&gt;&gt; np.random.randint(1, size=10) array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) Generate a 2 x 4 array of ints between 0 and 4, inclusive: &gt;&gt;&gt; np.random.randint(5, size=(2, 4)) array([[4, 0, 2, 1], [3, 2, 2, 0]])12345678x,y = np.meshgrid(np.linspace(-1,1,10),np.linspace(-1,1,10))print (x)print (y)D = np.sqrt(x**2+y**2)print (D)sigma,mu = 1,0a = np.exp(-(D-mu)**2/(2*sigma**2))print (a) [[-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ] [-1. -0.77777778 -0.55555556 -0.33333333 -0.11111111 0.11111111 0.33333333 0.55555556 0.77777778 1. ]] [[-1. -1. -1. -1. -1. -1. -1. -1. -1. -1. ] [-0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778 -0.77777778] [-0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556 -0.55555556] [-0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333 -0.33333333] [-0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111 -0.11111111] [ 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111 0.11111111] [ 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333 0.33333333] [ 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556 0.55555556] [ 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778 0.77777778] [ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. ]] [[ 1.41421356 1.26686158 1.1439589 1.05409255 1.0061539 1.0061539 1.05409255 1.1439589 1.26686158 1.41421356] [ 1.26686158 1.09994388 0.95581392 0.84619701 0.7856742 0.7856742 0.84619701 0.95581392 1.09994388 1.26686158] [ 1.1439589 0.95581392 0.7856742 0.64788354 0.56655772 0.56655772 0.64788354 0.7856742 0.95581392 1.1439589 ] [ 1.05409255 0.84619701 0.64788354 0.47140452 0.35136418 0.35136418 0.47140452 0.64788354 0.84619701 1.05409255] [ 1.0061539 0.7856742 0.56655772 0.35136418 0.15713484 0.15713484 0.35136418 0.56655772 0.7856742 1.0061539 ] [ 1.0061539 0.7856742 0.56655772 0.35136418 0.15713484 0.15713484 0.35136418 0.56655772 0.7856742 1.0061539 ] [ 1.05409255 0.84619701 0.64788354 0.47140452 0.35136418 0.35136418 0.47140452 0.64788354 0.84619701 1.05409255] [ 1.1439589 0.95581392 0.7856742 0.64788354 0.56655772 0.56655772 0.64788354 0.7856742 0.95581392 1.1439589 ] [ 1.26686158 1.09994388 0.95581392 0.84619701 0.7856742 0.7856742 0.84619701 0.95581392 1.09994388 1.26686158] [ 1.41421356 1.26686158 1.1439589 1.05409255 1.0061539 1.0061539 1.05409255 1.1439589 1.26686158 1.41421356]] [[ 0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944] [ 0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [ 0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [ 0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [ 0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [ 0.60279818 0.73444367 0.85172308 0.9401382 0.98773022 0.98773022 0.9401382 0.85172308 0.73444367 0.60279818] [ 0.57375342 0.69905581 0.81068432 0.89483932 0.9401382 0.9401382 0.89483932 0.81068432 0.69905581 0.57375342] [ 0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308 0.81068432 0.73444367 0.63331324 0.51979489] [ 0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367 0.69905581 0.63331324 0.54610814 0.44822088] [ 0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818 0.57375342 0.51979489 0.44822088 0.36787944]]","categories":[{"name":"numpy","slug":"numpy","permalink":"http://nlbyd1119.online/categories/numpy/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"numpy-note-1","slug":"numpy-note-1","date":"2020-06-08T23:41:55.000Z","updated":"2020-06-09T00:11:37.797Z","comments":true,"path":"2020/06/09/numpy-note-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/09/numpy-note-1/","excerpt":"numpy笔记一","text":"numpy笔记一 基础语法NumPy的主要对象是含有相同元素的多维数组。在Numpy中纬度被称为axes。 创建数组初始化数组时，数组的大小必须是已知的。 12345import numpy as np# initial an arraya = np.array([2,3,4])a array([2, 3, 4])1a.dtype dtype(&apos;int64&apos;)123456a = np.array( [[1.2, 2, 3], [4, 5, 6], [7, 8, 9],])a array([[1.2, 2. , 3. ], [4. , 5. , 6. ], [7. , 8. , 9. ]])1a.dtype dtype(&apos;float64&apos;)12a = np.array([(1, 2), (3, 4)], dtype=complex)a array([[1.+0.j, 2.+0.j], [3.+0.j, 4.+0.j]])12345def f(x, y): return 10*x + ya = np.fromfunction(f, (5, 4), dtype=int)a array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])特殊矩阵12# 单位阵np.eye(3) array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])12# 零矩阵z = np.zeros((3, 4)) 1z.dtype dtype(&apos;float64&apos;)12# 全部为1的矩阵np.ones((3, 4), dtype=np.int16) array([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], dtype=int16)12# 未初始化的矩阵，输出与当时内存的值相关np.empty((2, 3)) array([[0., 0., 0.], [0., 0., 0.]])12# 随机创建np.random.random((4, 3)) array([[0.78107242, 0.17928388, 0.46105338], [0.73351382, 0.63354025, 0.26412321], [0.62593189, 0.12072879, 0.90923083], [0.76088565, 0.77404881, 0.30561779]])类range初始化1np.arange(5) array([0, 1, 2, 3, 4])1np.arange(5, 10) array([5, 6, 7, 8, 9])1np.arange(1, 10, 2) array([1, 3, 5, 7, 9])1np.arange(0, 2, 0.3) array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])因为float类型有精度的问题，所以每一次使用arange初始化的值可能是不同的(每一次加法都会损失精度）。推荐使用linspace函数解决此类问题 123from numpy import pi# start, end, 要生成多少个np.linspace(0, 2, 9) array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ])123# 非常适合绘图x = np.linspace( 0, 2*pi, 100 )f = np.sin(x) 查看数组的属性12a = np.arange(15).reshape(3, 5)a array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])12# 纬度a.shape (3, 5)1a.shape[0] 31a.shape[1] 512# 有几维a.ndim 212# 所存储的数据类型a.dtype dtype(&apos;int64&apos;)1a.dtype.name &apos;int64&apos;12# 每一个元素所占用内存大小， 单位：字节 bytesa.itemsize 812# a的元素总数量a.size 151type(a) numpy.ndarray打印数组在打印时，一个纬度元素数量超过1000个时，numpy会忽略中间的元素。使用np.set_printoptions(threshold=np.nan)打印所有元素 12a = np.arange(6)print(a) [0 1 2 3 4 5]12b = np.arange(12).reshape(4, 3)print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]]12c = np.arange(24).reshape(2,3,4) print(c) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]]12# 数组太大时，numpy会自动跳过中间的元素print(np.arange(10000)) [ 0 1 2 ... 9997 9998 9999]1print(np.arange(10000).reshape(100,100)) [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]]12345# 强制输出全部的元素np.set_printoptions(threshold=np.nan)print(np.arange(1001*5).reshape(5,1001))# 恢复设置，默认值是1000个以后就跳过np.set_printoptions(threshold=1000) [[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000] [1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001] [2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002] [3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 3751 3752 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003] [4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 4232 4233 4234 4235 4236 4237 4238 4239 4240 4241 4242 4243 4244 4245 4246 4247 4248 4249 4250 4251 4252 4253 4254 4255 4256 4257 4258 4259 4260 4261 4262 4263 4264 4265 4266 4267 4268 4269 4270 4271 4272 4273 4274 4275 4276 4277 4278 4279 4280 4281 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 4333 4334 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 4409 4410 4411 4412 4413 4414 4415 4416 4417 4418 4419 4420 4421 4422 4423 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004]]基础操作123456a = np.array([[10, 20, 30, 40], [50, 60, 70, 80]])b = np.arange(1, 9).reshape((2, 4))print('a:\\n', a)print('b:\\n', b) a: [[10 20 30 40] [50 60 70 80]] b: [[1 2 3 4] [5 6 7 8]]所有的操作都是对应元素之间的算数操作，包括乘法和除法！！！ 1a + b array([[11, 22, 33, 44], [55, 66, 77, 88]])1a - b array([[ 9, 18, 27, 36], [45, 54, 63, 72]])1a * b array([[ 10, 40, 90, 160], [250, 360, 490, 640]])1a / b array([[10., 10., 10., 10.], [10., 10., 10., 10.]])1a + 1 array([[11, 21, 31, 41], [51, 61, 71, 81]])1a - 1 array([[ 9, 19, 29, 39], [49, 59, 69, 79]])1a * 2 array([[ 20, 40, 60, 80], [100, 120, 140, 160]])12# 自动做类型转换a / 2 array([[ 5., 10., 15., 20.], [25., 30., 35., 40.]])1a ** 2 array([[ 100, 400, 900, 1600], [2500, 3600, 4900, 6400]])1np.sin(a) array([[-0.54402111, 0.91294525, -0.98803162, 0.74511316], [-0.26237485, -0.30481062, 0.77389068, -0.99388865]])1a &lt; 40 array([[ True, True, True, False], [False, False, False, False]])矩阵运算12A = np.array([[1, 1], [0, 1]]) 12B = np.array([[2, 0], [3, 4]]) 12# 叉积A * B array([[2, 0], [0, 4]])12# 点积 python &gt;= 3.5支持A @ B array([[5, 4], [3, 4]])12# 点积A.dot(B) array([[5, 4], [3, 4]])类似+=这种形式在数字与矩阵操作时成立，但是矩阵与矩阵之间这种操作不一定成立 12a = np.ones((2,3), dtype=int)a array([[1, 1, 1], [1, 1, 1]])12b = np.random.random((2,3))b array([[0.46030441, 0.55207034, 0.29789345], [0.97779075, 0.97831739, 0.07438167]])12345# b是float类型，不能自动转换为int类型，所以不能做+=操作try: a += bexcept TypeError as e: print(e) Cannot cast ufunc add output from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) with casting rule &apos;same_kind&apos;12a = a + ba array([[1.46030441, 1.55207034, 1.29789345], [1.97779075, 1.97831739, 1.07438167]])123a = np.ones((2,3), dtype=int)b += ab array([[1.46030441, 1.55207034, 1.29789345], [1.97779075, 1.97831739, 1.07438167]])通用函数 Universal FunctionsNumPy提供了常用的数学函数，如sin、cos、exp、sqrt等。在NumPy中这些被称为“universal functions”(ufunc).在内部，函数对矩阵中的每一个元素进行计算。 12A = np.arange(3)A array([0, 1, 2])1np.exp(A) array([1. , 2.71828183, 7.3890561 ])1np.sqrt(A) array([0. , 1. , 1.41421356])12B = np.array([2., -1., 4.])np.add(A, B) array([2., 0., 6.])其他可以使用的函数：all, any, apply_along_axis, argmax, argmin, argsort, average, bincount, ceil, clip, conj, corrcoef, cov, cross, cumprod, cumsum, diff, dot, floor, inner, inv, lexsort, max, maximum, mean, median, min, minimum, nonzero, outer, prod, re, round, sort, std, sum, trace, transpose, var, vdot, vectorize, where 索引、切片、迭代 Indexing, Slicing and Iterating对于向量，这些操作的结果和Python的可迭代类型是相同的。 向量12a = np.arange(10) ** 3a array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])12# 索引 Indexinga[2] 81234# 切片 Slicingprint(a[2:5])print(a[:6:2])print(a[::-1]) [ 8 27 64] [ 0 8 64] [729 512 343 216 125 64 27 8 1 0]123# 迭代 Iteratingfor i in a: print(i) 0 1 8 27 64 125 216 343 512 729二维矩阵12345def f(x, y): return 10*x + ya = np.fromfunction(f, (5, 4), dtype=int)a array([[ 0, 1, 2, 3], [10, 11, 12, 13], [20, 21, 22, 23], [30, 31, 32, 33], [40, 41, 42, 43]])123# 索引 Indexing# 取第2行，第3列，索引从0开始a[2, 3] 2312# 索引一行a[2] array([20, 21, 22, 23])12# 索引一列a[:, 2] array([ 2, 12, 22, 32, 42])12# 取第0、1、2、3行中的第1个元素，索引从1开始a[0:4, 1] array([ 1, 11, 21, 31])1a[:, 1] array([ 1, 11, 21, 31, 41])1a[1:3, :] array([[10, 11, 12, 13], [20, 21, 22, 23]])12# 最后一行a[-1] array([40, 41, 42, 43])12# 倒数第二行a[-2] array([30, 31, 32, 33])12# 最后一列a[:, -1] array([ 3, 13, 23, 33, 43])12# 倒数第二行a[:, -2] array([ 2, 12, 22, 32, 42])多维矩阵123456789# 三维矩阵a = np.array([ [[0, 1, 2], [3, 4, 5]], [[0, 10, 20], [30, 40, 50]]])a array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 0, 10, 20], [30, 40, 50]]])1a.shape (2, 2, 3)1a[0, 0, 0] 012# 与 a[0, :, :]， a[0, ...]等价a[0] array([[0, 1, 2], [3, 4, 5]])1a[0, :, :] array([[0, 1, 2], [3, 4, 5]])1a[0, ...] array([[0, 1, 2], [3, 4, 5]])1a[..., 2] array([[ 2, 5], [20, 50]])1a[:, :, 2] array([[ 2, 5], [20, 50]])123# 迭代for row in a: print(row) [[0 1 2] [3 4 5]] [[ 0 10 20] [30 40 50]]12for element in a.flat: print(element) 0 1 2 3 4 5 0 10 20 30 40 5012# 切片a[0:1] array([[[0, 1, 2], [3, 4, 5]]])Shape manipulationa.ravel(), a.reshape(6,2), a.T都会返回一个新的数组，不会修改原有的数组 123# np.floor向下取整a = np.floor(10*np.random.random((3,4)))a array([[7., 0., 7., 2.], [9., 4., 8., 6.], [2., 8., 3., 8.]])1a.shape (3, 4)12# 转换为向量a.ravel() array([7., 0., 7., 2., 9., 4., 8., 6., 2., 8., 3., 8.])1a array([[7., 0., 7., 2.], [9., 4., 8., 6.], [2., 8., 3., 8.]])1a.reshape(6,2) array([[7., 0.], [7., 2.], [9., 4.], [8., 6.], [2., 8.], [3., 8.]])12# 转置a.T array([[7., 9., 2.], [0., 4., 8.], [7., 8., 3.], [2., 6., 8.]])12# 原地改变矩阵的shapea array([[7., 0., 7., 2.], [9., 4., 8., 6.], [2., 8., 3., 8.]])12a.resize(6, 2)a array([[7., 0.], [7., 2.], [9., 4.], [8., 6.], [2., 8.], [3., 8.]])12# reshape可以自动判断列纬度a.reshape(3, -1) array([[7., 0., 7., 2.], [9., 4., 8., 6.], [2., 8., 3., 8.]])12345# resize不能自动判断纬度try: a.resize(6, -1)except ValueError as e: print(e) negative dimensions not allowed合并矩阵12a = np.arange(0, 4).reshape(2, 2)a array([[0, 1], [2, 3]])12b = np.arange(4, 8).reshape(2, 2)b array([[4, 5], [6, 7]])1np.vstack((a,b)) array([[0, 1], [2, 3], [4, 5], [6, 7]])1np.hstack((a, b)) array([[0, 1, 4, 5], [2, 3, 6, 7]])仅限2纬矩阵使用1np.column_stack((a, b)) array([[0, 1, 4, 5], [2, 3, 6, 7]])1np.row_stack((a, b)) array([[0, 1], [2, 3], [4, 5], [6, 7]])切分矩阵12a = np.arange(0, 16).reshape(4, 4)a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])1np.hsplit(a, 2) [array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]])]123for m in np.hsplit(a, 2): print(m) print() [[ 0 1] [ 4 5] [ 8 9] [12 13]] [[ 2 3] [ 6 7] [10 11] [14 15]]1np.vsplit(a, 2) [array([[0, 1, 2, 3], [4, 5, 6, 7]]), array([[ 8, 9, 10, 11], [12, 13, 14, 15]])]123for m in np.vsplit(a, 2): print(m) print() [[0 1 2 3] [4 5 6 7]] [[ 8 9 10 11] [12 13 14 15]]12a = np.arange(0, 24).reshape(2, 12)a array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])1np.hsplit(a,3) [array([[ 0, 1, 2, 3], [12, 13, 14, 15]]), array([[ 4, 5, 6, 7], [16, 17, 18, 19]]), array([[ 8, 9, 10, 11], [20, 21, 22, 23]])]12# 左闭右开， 切分为包含的列是0-2、 3-4、 4-11的3个矩阵np.hsplit(a,(3,5)) [array([[ 0, 1, 2], [12, 13, 14]]), array([[ 3, 4], [15, 16]]), array([[ 5, 6, 7, 8, 9, 10, 11], [17, 18, 19, 20, 21, 22, 23]])]123for m in np.hsplit(a, (3, 5)): print(m) print() [[ 0 1 2] [12 13 14]] [[ 3 4] [15 16]] [[ 5 6 7 8 9 10 11] [17 18 19 20 21 22 23]]1type(np.hsplit(a,(3,4))) list12# 可以利用这种特性按一列进行分割np.hsplit(a,(3,4)) [array([[ 0, 1, 2], [12, 13, 14]]), array([[ 3], [15]]), array([[ 4, 5, 6, 7, 8, 9, 10, 11], [16, 17, 18, 19, 20, 21, 22, 23]])]123for m in np.hsplit(a, (3, 4)): print(m) print() [[ 0 1 2] [12 13 14]] [[ 3] [15]] [[ 4 5 6 7 8 9 10 11] [16 17 18 19 20 21 22 23]]拷贝没有拷贝1234# no copya = np.arange(12)b = ab is a True12b.shape = 3, 4a.shape (3, 4)Shallow Copy 浅拷贝这是Python的语言特性的概念。拷贝 切片操作返回的是一个浅拷贝 12# view方法创建一个新的array，其包含了相同的数据c = a.view() 1c is a False1c.base is a True12c.shape = 2, 6a.shape (3, 4)12c[0, 4] = 1234c array([[ 0, 1, 2, 3, 1234, 5], [ 6, 7, 8, 9, 10, 11]])1a array([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]])因为是一个浅拷贝，所以当切片s中的元素的值改变后，原来a的值也会被改变。 123s = a[:, 1:3]s[:] = 10a array([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]])Deep Copy 深拷贝1d = a.copy() 1d is a False1d.base is a False12d[0, 0] = 999d array([[ 999, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]])1a array([[ 0, 10, 10, 3], [1234, 10, 10, 7], [ 8, 10, 10, 11]])广播机制 Broadcasting rules广播允许一般的函数去处理不精准的shape的array。拓展较小的array 12a = np.arange(0, 3)a array([0, 1, 2])1a * 3 array([0, 3, 6])上面的代码中3就被拓展为[3, 3, 3]实际执行的是以下的代码 1a * [3, 3, 3] array([0, 3, 6])索引技巧123a = np.arange(10)a = a * 10a array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])123# 要取出元素的序号i = np.array([1, 1, 2, 3, 5, 7])a[i] array([10, 10, 20, 30, 50, 70])1234# 多维序号也支持j = np.array([[3, 4], [5, 6]])a[j] array([[30, 40], [50, 60]])123456789# 以下代码是建立一个3维矩阵，示例是通过调色板建立一个图像palette = np.array([[0,0,0], # black [255,0,0], # red [0,255,0], # green [0,0,255], # blue [255,255,255]]) # whiteimage = np.array([[0, 1, 2, 0], [0, 3, 4, 0]])palette[image] array([[[ 0, 0, 0], [255, 0, 0], [ 0, 255, 0], [ 0, 0, 0]], [[ 0, 0, 0], [ 0, 0, 255], [255, 255, 255], [ 0, 0, 0]]])12a = np.arange(12).reshape(3, 4)a array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])123456i = np.array([[0, 1], [1, 2]])j = np.array([[2, 1], [3, 3]])# 选择（0， 2），（1， 1），（1，3），（2，3）a[i, j] array([[ 2, 5], [ 7, 11]])12# 选择(0, 2), (1, 2), (1, 2), (2, 2)a[i, 2] array([[ 2, 6], [ 6, 10]])1a[:, j] array([[[ 2, 1], [ 3, 3]], [[ 6, 5], [ 7, 7]], [[10, 9], [11, 11]]])12k = (i, j)a[k] array([[ 2, 5], [ 7, 11]])取每一列的最大值的索引序号 123time = np.linspace(20, 145, 5)data = np.sin(np.arange(20).reshape(5, 4))time array([ 20. , 51.25, 82.5 , 113.75, 145. ])1data array([[ 0. , 0.84147098, 0.90929743, 0.14112001], [-0.7568025 , -0.95892427, -0.2794155 , 0.6569866 ], [ 0.98935825, 0.41211849, -0.54402111, -0.99999021], [-0.53657292, 0.42016704, 0.99060736, 0.65028784], [-0.28790332, -0.96139749, -0.75098725, 0.14987721]])123# 每一列的最大值的序号ind = data.argmax(axis=0)ind array([2, 0, 3, 1])1print(data[2, 0], data[0, 1], data[3, 2], data[1, 3]) 0.9893582466233818 0.8414709848078965 0.9906073556948704 0.65698659871878911time[ind] array([ 82.5 , 20. , 113.75, 51.25])12data_max = data[ind, range(data.shape[1])]data_max array([0.98935825, 0.84147098, 0.99060736, 0.6569866 ])1np.all(data_max == data.max(axis=0)) True局部操作 12a = np.arange(5)a array([0, 1, 2, 3, 4])12a[[0, 1, 3]] = 0a array([0, 0, 2, 0, 4])12a[[2, 3]] = [6, 7]a array([0, 0, 6, 7, 4])12a[[0, 1]] += 1a array([1, 1, 6, 7, 4])当索引重复时，会有一些问题 12a = np.arange(5)a array([0, 1, 2, 3, 4])索引重复时，最后一个值操作， 所以第0个元素被赋值为2 12a[[0,0,2]]=[1,2,3]a array([2, 1, 3, 3, 4])这里第0个元素为1的原因是，实际上执行的操作是a += 1，最后一个值操作，所以只加了一次 123a = np.arange(5)a[[0,0,2]] += 1a array([1, 1, 3, 3, 4])使用Boolean索引12a = np.arange(12).reshape(3, 4)a &gt; 4 array([[False, False, False, False], [False, True, True, True], [ True, True, True, True]])12b = a &gt; 4b array([[False, False, False, False], [False, True, True, True], [ True, True, True, True]])1a[b] array([ 5, 6, 7, 8, 9, 10, 11])1a[a &gt; 4] array([ 5, 6, 7, 8, 9, 10, 11])12a[b] = 0a array([[0, 1, 2, 3], [4, 0, 0, 0], [0, 0, 0, 0]])1234a = np.arange(12).reshape(3,4)print(a)b1 = np.array([False, True, True])b2 = np.array([True, False, True, False]) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]]1a[b1, :] array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])1a[b1] array([[ 4, 5, 6, 7], [ 8, 9, 10, 11]])1a[:, b2] array([[ 0, 2], [ 4, 6], [ 8, 10]])1a[b1, b2] array([ 4, 10])ix_()函数1234a = np.array([2,3,4,5])b = np.array([8,5,4])c = np.array([5,4,6,8,3])ax, bx, cx = np.ix_(a, b, c) 1ax array([[[2]], [[3]], [[4]], [[5]]])1bx array([[[8], [5], [4]]])1cx array([[[5, 4, 6, 8, 3]]])1ax.shape (4, 1, 1)1bx.shape (1, 3, 1)1cx.shape (1, 1, 5)12result = ax + bx*cxresult array([[[42, 34, 50, 66, 26], [27, 22, 32, 42, 17], [22, 18, 26, 34, 14]], [[43, 35, 51, 67, 27], [28, 23, 33, 43, 18], [23, 19, 27, 35, 15]], [[44, 36, 52, 68, 28], [29, 24, 34, 44, 19], [24, 20, 28, 36, 16]], [[45, 37, 53, 69, 29], [30, 25, 35, 45, 20], [25, 21, 29, 37, 17]]])线性代数12a = np.array([[1.0, 2.0], [3.0, 4.0]])a array([[1., 2.], [3., 4.]])12# 转置a.transpose() array([[1., 3.], [2., 4.]])1a.T array([[1., 3.], [2., 4.]])12# 矩阵的逆 inversenp.linalg.inv(a) array([[-2. , 1. ], [ 1.5, -0.5]])123# eye 代表的意思就是”I“eye = np.eye(2)np.linalg.inv(eye) array([[1., 0.], [0., 1.]])12# 对角线元素之和np.trace(j) 5技巧和提示 用-1去占位不知道的纬度，numpy会自动计算 123a = np.arange(30)a.shape = 2, -1, 3a array([[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]], [[15, 16, 17], [18, 19, 20], [21, 22, 23], [24, 25, 26], [27, 28, 29]]]) 用纬度相同行向量构建一个2维矩阵 1234x = np.arange(0, 10, 2)y = np.arange(5)print(x)print(y) [0 2 4 6 8] [0 1 2 3 4]12m = np.vstack([x, y])m array([[0, 2, 4, 6, 8], [0, 1, 2, 3, 4]])1m.T array([[0, 0], [2, 1], [4, 2], [6, 3], [8, 4]])12xy = np.hstack([x, y])xy array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])1234# 对x, y进行转置也不能构建一个列向量x = x.Ty = y.Tx array([0, 2, 4, 6, 8])1y array([0, 1, 2, 3, 4])12xy = np.hstack([x, y])xy array([0, 2, 4, 6, 8, 0, 1, 2, 3, 4])创建Array有5种方式创建Array： 从Python的list、tuple等类型中转换 使用内建函数（arange、ones、zeros等）创建 从硬盘中读取数据。 从二进制流的string或buffer中创建 使用特殊的函数建立（如random等） 1import numpy as np 1. 从list或tuple中转换1234x = np.array([1, 2, 3,])# 类型自动转换x = np.array([[1,2.0],[0,0],(1+1j,3.)])x array([[1.+0.j, 2.+0.j], [0.+0.j, 0.+0.j], [1.+1.j, 3.+0.j]])2. 内建函数创建 np.zeros(数组的纬度tuple): 全部为0 np.arange(开始值, 终止值, 要创建的个数n): 创建均匀递增的n个数组成的array，生成的array包含开始值和终止值。 np.eye(n): 创建大小是n的单位矩阵 1np.zeros(3) array([0., 0., 0.])12a = np.zeros((2, 3))a array([[0., 0., 0.], [0., 0., 0.]])1a.dtype dtype(&apos;float64&apos;)1np.arange(10) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])1np.arange(10).reshape(2, 5) array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]])1np.linspace(1, 2, 11) array([1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. ])1np.indices((3, 3)) array([[[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]]])1np.indices((2, 2)) array([[[0, 0], [1, 1]], [[0, 1], [0, 1]]])1np.indices((2, 3)) array([[[0, 0, 0], [1, 1, 1]], [[0, 1, 2], [0, 1, 2]]])3. 从硬盘中读取Array4. 从二进制流的string或buffer中创建12import numpy as npfrom io import StringIO 12data = u\"1, 2, 3\\n4, 5, 6\"np.genfromtxt(StringIO(data), delimiter=\",\") array([[1., 2., 3.], [4., 5., 6.]])comments参数：跳过注释所在行，默认是#。numpy1.7后，当comments=None时，不启用忽略注释的功能 123456789101112data = u\"\"\"## 注释# 我也是注释 需要忽略掉1, 23, 45, 6 # 这是第3行7, 8# 我又回来了9, 0\"\"\"np.genfromtxt(StringIO(data), delimiter=\",\", comments=\"#\") array([[1., 2.], [3., 4.], [5., 6.], [7., 8.], [9., 0.]])1np.genfromtxt(StringIO(data), delimiter=',') array([[1., 2.], [3., 4.], [5., 6.], [7., 8.], [9., 0.]])使用usecols参数选择要初始化的列 123# 选择第1列和最后一列传入data = u\"1 2 3\\n4 5 6\"np.genfromtxt(StringIO(data), usecols=(0, -1)) array([[1., 3.], [4., 6.]])如果列有名字，也可以用名字执行要传入的列 12data = u\"1 2 3\\n4 5 6\"np.genfromtxt(StringIO(data), names=\"a, b, c\", usecols=(\"a\", \"c\")) array([(1., 3.), (4., 6.)], dtype=[(&apos;a&apos;, &apos;&lt;f8&apos;), (&apos;c&apos;, &apos;&lt;f8&apos;)])使用skip_header=n, skip_footer=m忽略掉前n行和后m行数据 12data = u\"\\n\".join(str(i) for i in range(10))np.genfromtxt(StringIO(data),) array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])1np.genfromtxt(StringIO(data), skip_header=1, skip_footer=1) array([1., 2., 3., 4., 5., 6., 7., 8.])1np.genfromtxt(StringIO(data), skip_header=3, skip_footer=5) array([3., 4.])1import numpy as np 12a = np.arange(5)a array([0, 1, 2, 3, 4])1a.dtype dtype(&apos;int64&apos;)1a.dtype.name &apos;int64&apos;强制类型转换 Cast方法11234a = np.arange(5)a = a.astype(float)print(a.dtype)a float64 array([0., 1., 2., 3., 4.])1234a = np.arange(5)a = a.astype(np.float32)print(a.dtype)a float32 array([0., 1., 2., 3., 4.], dtype=float32)方法21234a = np.arange(5)a = np.array(a, dtype=np.float32)print(a.dtype)a float32 array([0., 1., 2., 3., 4.], dtype=float32)方法3123a = np.arange(5)a = np.float32(a)a array([0., 1., 2., 3., 4.], dtype=float32)错误的强制转换做法1234# 错误的强制转换做法a = np.arange(5)a.dtype = np.float64a array([0.0e+000, 4.9e-324, 9.9e-324, 1.5e-323, 2.0e-323])1234# 错误的强制转换做法a = np.arange(5)a.dtype = np.float64()a array([0.0e+000, 4.9e-324, 9.9e-324, 1.5e-323, 2.0e-323])精度 Precisionnumpy的浮点数精度支持到128位， 默认是64位 12345678import numpy as npdef division(a, b): if b == 0: return print('result: ', a / b) print('length of result: ', len(str(a / b))) 1division(np.float(1), np.float(3)) result: 0.3333333333333333 length of result: 181division(np.double(1), np.double(3)) result: 0.3333333333333333 length of result: 181division(np.longdouble(1), np.longdouble(3)) result: 0.33333333333333333334 length of result: 221division(np.float32(1), np.float32(3)) result: 0.33333334 length of result: 101division(np.float128(1), np.float128(3)) result: 0.33333333333333333334 length of result: 2212# 向大精度的float看齐division(np.float128(1), np.float32(3)) result: 0.33333333333333333334 length of result: 221division(np.float32(1), np.float128(3)) result: 0.33333333333333333334 length of result: 2212import numpy as npa = np.array([[1.0, 2.0], [3.0, 4.0]]) 1234# 转置 transposeprint(a.transpose())print()print(a.T) [[1. 3.] [2. 4.]] [[1. 3.] [2. 4.]]12# 逆 inversenp.linalg.inv(a) array([[-2. , 1. ], [ 1.5, -0.5]])123# eye 代表 ”I“， \"eye\" represents \"I\"eye = np.eye(2)np.linalg.inv(eye) array([[1., 0.], [0., 1.]])12345j = np.array([ [0., 1.], [1., 0.],])j array([[0., 1.], [1., 0.]])12# 点积， matrix productj @ j array([[1., 0.], [0., 1.]])1j.dot(j) array([[1., 0.], [0., 1.]])12# 叉积，j * j array([[0., 1.], [1., 0.]])12# 对角线元素之和np.trace(j) 0.01np.trace(eye) 2.0索引 Indexing一些要注意到的点 当使用切片时并没有产生新的array，实际上是在原来的data上产生了一个view。如果原来的data不再使用，推荐明确的调用copy。 1import numpy as np 12345# 举例x = np.arange(10)y = x[:5]y[0] = 10x array([10, 1, 2, 3, 4, 5, 6, 7, 8, 9])1234x = np.arange(10)y = x[:5].copy()y[0] = 10x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])1. 选取一个元素1.1 向量123# 向量x = np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])1x[2] 21x[-2] 81.2 矩阵12x = np.arange(12).reshape(3, 4)x array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])1x[1, 3] 71x[1, -1] 712# 性能更低x[1][3] 72. 选取一行或一列2.1 矩阵12x = np.arange(12).reshape(3, 4)x array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])1x[0] array([0, 1, 2, 3])1x[:, 0] array([0, 4, 8])1x[-1] array([ 8, 9, 10, 11])1x[:, -1] array([ 3, 7, 11])3. 选取一块3.1 向量12x = np.arange(12)x[2: 5] array([2, 3, 4])1x[:7] array([0, 1, 2, 3, 4, 5, 6])1x[1:7:2] array([1, 3, 5])12y = np.arange(35).reshape(5, 7)y array([[ 0, 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12, 13], [14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27], [28, 29, 30, 31, 32, 33, 34]])1y[1:5:2, ::3] array([[ 7, 10, 13], [21, 24, 27]])用数组索引Array返回的是一个原Array的copy 12x = np.arange(10) * 10x array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])1x[[1, 3, 6, 7, 8]] array([10, 30, 60, 70, 80])1x[[1, 2, 2, -1, -2]] array([10, 20, 20, 90, 80])1x[np.array([1, 1, -1, -1,])] array([10, 10, 90, 90])1234# 返回的是原Array的copyy = x[[1, 6, 9]]y[0] = 123x array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])1x[np.array([[1,1],[2,3]])] array([[10, 10], [20, 30]])索引多维Array1234# 用坐标(0, 0), (2, 1), (4, 2)这3个元素构建一个Arrayy = np.arange(35).reshape(5,7)print(y)y[np.array([0,2,4]), np.array([0,1,2])] [[ 0 1 2 3 4 5 6] [ 7 8 9 10 11 12 13] [14 15 16 17 18 19 20] [21 22 23 24 25 26 27] [28 29 30 31 32 33 34]] array([ 0, 15, 30])12# 利用广播机制选取(0, 1), (2, 1), (4, 1)y[np.array([0,2,4]), 1] array([ 1, 15, 29])Boolean表达式索引ArrayBoolean or “mask” index arrays 12x = np.arange(10)x[x &gt; 5] array([6, 7, 8, 9])12y = np.arange(35).reshape(5, 7)y array([[ 0, 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12, 13], [14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27], [28, 29, 30, 31, 32, 33, 34]])12b = y&gt;25b array([[False, False, False, False, False, False, False], [False, False, False, False, False, False, False], [False, False, False, False, False, False, False], [False, False, False, False, False, True, True], [ True, True, True, True, True, True, True]])1b[:, 5] array([False, False, False, True, True])1y[b[:, 5]] array([[21, 22, 23, 24, 25, 26, 27], [28, 29, 30, 31, 32, 33, 34]])12x = np.arange(30).reshape(2,3,5)x array([[[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]], [[15, 16, 17, 18, 19], [20, 21, 22, 23, 24], [25, 26, 27, 28, 29]]])12# 2 * 3b = np.array([[True, True, False], [False, True, True]]) 123# 在选择时只看前两纬度， 将第三个纬度看作是一个元素# 则选择（1， ：， ：）的前两行，（2， ：， ：）后两行x[b] array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [20, 21, 22, 23, 24], [25, 26, 27, 28, 29]])用切片合并索引数组Combining index arrays with slices 12y = np.arange(35).reshape(5, 7)y array([[ 0, 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12, 13], [14, 15, 16, 17, 18, 19, 20], [21, 22, 23, 24, 25, 26, 27], [28, 29, 30, 31, 32, 33, 34]])1y[np.array([0,2,4]), 1:3] array([[ 1, 2], [15, 16], [29, 30]])12b = y &gt; 20b array([[False, False, False, False, False, False, False], [False, False, False, False, False, False, False], [False, False, False, False, False, False, False], [ True, True, True, True, True, True, True], [ True, True, True, True, True, True, True]])1y[b[:,5], 1:3] array([[22, 23], [29, 30]])Structural indexing tools12345y = np.arange(35).reshape(5, 7)print(y)print(y.shape)y = y[:, np.newaxis, :]y [[ 0 1 2 3 4 5 6] [ 7 8 9 10 11 12 13] [14 15 16 17 18 19 20] [21 22 23 24 25 26 27] [28 29 30 31 32 33 34]] (5, 7) array([[[ 0, 1, 2, 3, 4, 5, 6]], [[ 7, 8, 9, 10, 11, 12, 13]], [[14, 15, 16, 17, 18, 19, 20]], [[21, 22, 23, 24, 25, 26, 27]], [[28, 29, 30, 31, 32, 33, 34]]])1y.shape (5, 1, 7)12z = np.arange(81).reshape(3, 3, 3, 3)z array([[[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]], [[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]], [[[54, 55, 56], [57, 58, 59], [60, 61, 62]], [[63, 64, 65], [66, 67, 68], [69, 70, 71]], [[72, 73, 74], [75, 76, 77], [78, 79, 80]]]])12# 以下两个表达式等价z[1, ..., 2] array([[29, 32, 35], [38, 41, 44], [47, 50, 53]])1z[1, :, :, 2] array([[29, 32, 35], [38, 41, 44], [47, 50, 53]])赋值12x = np.arange(10)x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])12x[2:8] = 1x array([0, 1, 1, 1, 1, 1, 1, 1, 8, 9])123# 使用boolean的赋值技巧x = np.arange(0, 50, 10)x array([ 0, 10, 20, 30, 40])12x[np.array([1, 3, 4])] += 1x array([ 0, 11, 20, 31, 41])赋值前，先建立了一个临时Array，再赋值，之后再返回给原Array。所以1被赋值了3次，而不是+=13次 官方文档原文：Where people expect that the 1st location will be incremented by 3. In fact, it will only be incremented by 1. The reason is because a new array is extracted from the original (as a temporary) containing the values at 1, 1, 3, 1, then the value 1 is added to the temporary, and then the temporary is assigned back to the original array. Thus the value of the array at x[1]+1 is assigned to x[1] three times, rather than being incremented 3 times. 123x = np.arange(0, 50, 10)x[np.array([1, 1, 3, 1])] += 1x array([ 0, 11, 20, 31, 40])Dealing with variable numbers of indices within programs12z = np.arange(81).reshape(3, 3, 3, 3)z array([[[[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8]], [[ 9, 10, 11], [12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23], [24, 25, 26]]], [[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]], [[[54, 55, 56], [57, 58, 59], [60, 61, 62]], [[63, 64, 65], [66, 67, 68], [69, 70, 71]], [[72, 73, 74], [75, 76, 77], [78, 79, 80]]]])12indices = (0, 0, 0, 0)z[indices] 012indices = (2, 2, 2, 2)z[indices] 801234# same as [1,1,1,0:2]# slice是python的内建函数indices = (1,1,1,slice(0,2))z[indices] array([39, 40])12indices = (1, Ellipsis, 1) # same as [1,...,1]z[indices] array([[28, 31, 34], [37, 40, 43], [46, 49, 52]])1z[[1,1,1,1]] # produces a large array array([[[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]], [[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]], [[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]], [[[27, 28, 29], [30, 31, 32], [33, 34, 35]], [[36, 37, 38], [39, 40, 41], [42, 43, 44]], [[45, 46, 47], [48, 49, 50], [51, 52, 53]]]])1z[(1,1,1,1)] # returns a single value 40","categories":[{"name":"numpy","slug":"numpy","permalink":"http://nlbyd1119.online/categories/numpy/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"数据解析","slug":"数据解析","date":"2020-06-08T10:04:20.000Z","updated":"2020-06-08T11:11:32.142Z","comments":true,"path":"2020/06/08/数据解析/","link":"","permalink":"http://nlbyd1119.online/2020/06/08/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/","excerpt":"数据获取和一些预处理操作","text":"数据获取和一些预处理操作 需为绘图准备数据，考虑几个来源，直接从csv读取，或者爬取。一、csv文件的读取与写入 读取参考 https://www.cnblogs.com/cloud-ken/p/8432999.htmlhttps://www.jianshu.com/p/7ac36fafebeahttps://www.cnblogs.com/liangxiyang/p/11272155.html以下为两种方式：csv和pandas123456789101112import csvimport pandas as pd# csvwith open(\"./data/g1.csv\", \"r\", encoding=\"utf-8\") as f: reader = csv.reader(f) for row in reader: print(row)# pandasdf = pd.read_csv(\"./data/g1.csv\")print(df) 写入使用pandas123456789101112131415161718192021222324# coding=utf-8import pymysqlimport pandas as pdimport numpy as np# 连接数据库 执行查询操作conn = pymysql.connect(host=\"localhost\", port=3306, user=\"root\",password=\"xxx\",database=\"data_ana\",charset=\"utf8\")cursor = conn.cursor()cursor.execute(\"select * from anime\")data_result = cursor.fetchall()print(len(data_result))# 将查询所得元组转换为列表data_result = list(data_result)for i in range(len(data_result)): data_result[i] = list(data_result[i])data_result = np.array(data_result)print(data_result[:, 1:])# 生成csv文件 注意编码column_name = [\"name\", \"grade\", \"desc\"]result = pd.DataFrame(columns=column_name, data=data_result[:, 1:])result.to_csv(\"g1.csv\", encoding=\"utf_8_sig\") 二、数据解析三种方式：xpath re json，一般是三者互相结合使用的 利用requests库请求的一般方式 12345678910import requestsheader=&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'&#125;url = \"http://www.weather.com.cn/weather/101050703.shtml\"response = requests.get(url, headers=header)html = response.content.decode(\"utf-8\")# 然后可以使用不同的方式解析html 结合xpath helper使用的xpath 1234from lxml import etreeexml = etree.HTML(html)name = exml.xpath(\"//tr[1]/td/h1/text()\")[0] 结合网页源码使用的正则 1234import re# 注意此处的多行正则匹配的写法all_data = re.findall(\"(?s)hour3data=(.*?)&lt;/sc\", html)[0] 在F12下查看得返回json页面或源码中的json字符串解析参考 https://blog.csdn.net/lwg_1540652358/article/details/84111339 1234567import jsonimport jsonpath# 将json字符串转换为python中的json对象jsonobj = json.loads(content)# 注意这个获取某节点下的某种子节点的方法（不包括再下级）confirmed_list = jsonpath.jsonpath(jsonobj,'$.data[*].confirmed') 三、几个小脚本和通用写法1.下载某网站的图片 xpath以下载bangumi的图片为例，当时的做法是先把所有图片的链接写入文本，使用urllib爬取链接 123456789101112131415161718192021222324252627rom urllib.request import urlopenfrom urllib.request import Requestfrom lxml import etreelinks = []for i in range(12, 21): url = \"https://bangumi.tv/person?orderby=collects&amp;type=1&amp;page=\" + str(i) request = Request(url) response = urlopen(request) html = response.read() s = str(html, encoding=\"utf-8\") exml = etree.HTML(s) names = exml.xpath(\"//div[@class='browserCrtList']//div[2]/h3/a[@class='l']/text()\") imgs = exml.xpath(\"//a[@class='avatar']/img[@class='avatar ll']/@src\") cons = exml.xpath(\"//div[@class='browserCrtList']//div[2]/h3/a[@class='l']/@href\") with open(\"name.txt\", \"a\", encoding='utf-8') as f: for n in names: f.write(n + \"\\n\") f.flush() with open(\"img.txt\", \"a\", encoding='utf-8') as f: for i in imgs: f.write(i + \"\\n\") f.flush() with open(\"cons.txt\", \"a\", encoding='utf-8') as f: for c in cons: u = \"https://bangumi.tv\" + c f.write(u + \"\\n\") f.flush() 下载图片 1234567891011121314151617import requestswith open(\"img.txt\", \"r\") as f: links = f.read().split()header=&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'&#125;count = 1for l in links: l = \"http:\" + l response = requests.get(l, headers=header) path = \"v\" + str(count) + \".jpg\" with open(path, \"wb\") as f: f.write(response.content) f.flush() count = count + 1 2.连接数据库 保存与查询查询 123456789101112131415import pymysql# 连接数据库 执行查询操作conn = pymysql.connect(host=\"localhost\", port=3306, user=\"root\",password=\"xxx\",database=\"data_ana\",charset=\"utf8\")cursor = conn.cursor()cursor.execute(\"select * from anime\")data_result = cursor.fetchall()print(len(data_result))# 将查询所得元组转换为列表data_result = list(data_result)for i in range(len(data_result)): data_result[i] = list(data_result[i])data_result = np.array(data_result)print(data_result[:, 1:]) 保存 123456cursor = conn.cursor()# 注意由于pymysql底层的限制，占位只可以写%s 但实际上执行时可用的数据的类型可为其他sql = \"INSERT INTO IMO(aname, link, links) VALUES (%s, %s, %s);\"cursor.execute(sql, [name_list[i], link_list[i], \"\"])conn.commit()cursor.close() 建表建表尤其注意sql语句的写法。 1234567891011insert_video_sql = \"INSERT INTO video(video_name) VALUES (%s);\" cursor.execute(insert_video_sql, [table_name]) conn.commit() # 创建数据表的sql 语句 并设置name_id 为主键自增长不为空sql_createTb = \"\"\"CREATE TABLE `%s`( video_id INT NOT NULL AUTO_INCREMENT, detect_time VARCHAR(100), allp INT,yesp INT,nop INT, PRIMARY KEY(video_id)) \"\"\" % (table_name) 同时有表名变量和字段变量的sql语句 12insert_data_sql = 'insert into `%s`(detect_time,allp,yesp,nop)' % camera_table_name + ' values (%s,%s,%s,%s)'cursor.execute(insert_data_sql, [theTime, all, yes, no]) 3.csv生成中文乱码的解决参考 https://blog.csdn.net/zhuzuwei/article/details/80890007 1df.to_csv(file_name,encoding=\"utf_8_sig\") 4.python多维数组切片只可用numpy 参考https://www.jb51.net/article/138219.htmhttps://blog.csdn.net/qiqicos/article/details/78971406https://www.cnblogs.com/yibeimingyue/p/10936509.htmlnumpy数组与列表转换https://blog.csdn.net/qq_36387683/article/details/993022865.十六进制与字符串的转换 12a = \"\\u9999\\u6e2f\".encode(\"utf-8\").decode(\"utf-8\")print(a) # 香港","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://nlbyd1119.online/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"matplotlib","slug":"matplotlib","date":"2020-06-07T23:50:28.000Z","updated":"2020-06-09T00:56:04.989Z","comments":true,"path":"2020/06/08/matplotlib/","link":"","permalink":"http://nlbyd1119.online/2020/06/08/matplotlib/","excerpt":"matplotlib","text":"matplotlib 一、概述大致学习并练习了matplotlib最基本的四种类型图：折线、散点、条形、直方。首先收集数据费了一定功夫，这点在数据解析部分说明。经过练习，感觉关键点有以下几个： 一种类型的图适合展示何种类型的数据要清楚。折线图的某条折线适合展现同一事物随时间变化的趋势，散点图适合展示数据的集散程度，条形图适合展现不同事物某种类型数据的对比。 明确刻度的范围。折线和散点相对简单。但条形、直方有特殊的地方一定要注意。 二、代码 折线12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 中国天气网 济南 漠河未来六天 气温变化趋势import requestsimport re#获取数据header=&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'&#125;def parse(url): response = requests.get(url, headers=header) html = response.content.decode(\"utf-8\") return html#济南数据html = parse(\"http://www.weather.com.cn/weather/101120101.shtml\")all_data = re.findall(\"(?s)hour3data=(.*?)&lt;/sc\", html)[0]time_data = re.findall(\"\\d\\d日\\d\\d时\", all_data)temp_data = re.findall(\"(\\d+)℃\", all_data)for i in range(len(temp_data)): temp_data[i] = int(temp_data[i])print(temp_data)#漠河数据html = parse(\"http://www.weather.com.cn/weather/101050703.shtml\")all_data_2 = re.findall(\"(?s)hour3data=(.*?)&lt;/sc\", html)[0]time_data_2 = re.findall(\"\\d\\d日\\d\\d时\", all_data_2)temp_data_2 = re.findall(\"(\\d+)℃\", all_data_2)for i in range(len(temp_data_2)): temp_data_2[i] = int(temp_data_2[i])print(temp_data_2)from matplotlib import pyplot as pltfrom matplotlib import font_manager#设置中文字体my_font = font_manager.FontProperties(fname=\"C:/Windows/Fonts/simfang.ttf\")#设置图形大小# plt.figure(figsize=(20,8),dpi=80)plt.figure(figsize=(20, 8))#绘图# plt.plot(range(57), temp_data, label=\"济南温度\", color=\"#F08080\", linestyle=\"--\")plt.plot(range(58), temp_data, label=\"济南温度\", color=\"r\", linestyle=\"-\")plt.plot(range(58), temp_data_2, label=\"漠河温度\", color=\"b\", linestyle=\"-\")#设置x轴刻度_xtick_labels = time_dataplt.xticks(range(58),_xtick_labels,fontproperties=my_font, rotation=30)#设置y轴刻度plt.yticks(range(min(temp_data_2),max(temp_data)+1))#绘制网格plt.grid(alpha=0.9,linestyle=':')#添加图例plt.legend(prop=my_font,loc=\"upper left\")#添加描述信息plt.xlabel(\"时间\",fontproperties=my_font)plt.ylabel(\"温度 单位(℃)\",fontproperties=my_font)plt.title(\"济南、漠河未来六天气温变化趋势\",fontproperties=my_font)#保存图形plt.savefig(\"./plot.png\")#展示图形plt.show() 散点图（一）与折线图的差异仅在于scatter方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 中国天气网 济南 漠河未来六天 气温散点图import requestsimport re#获取数据header=&#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'&#125;def parse(url): response = requests.get(url, headers=header) html = response.content.decode(\"utf-8\") return html#济南数据html = parse(\"http://www.weather.com.cn/weather/101120101.shtml\")all_data = re.findall(\"(?s)hour3data=(.*?)&lt;/sc\", html)[0]time_data = re.findall(\"\\d\\d日\\d\\d时\", all_data)temp_data = re.findall(\"(\\d+)℃\", all_data)for i in range(len(temp_data)): temp_data[i] = int(temp_data[i])print(temp_data)#漠河数据html = parse(\"http://www.weather.com.cn/weather/101050703.shtml\")all_data_2 = re.findall(\"(?s)hour3data=(.*?)&lt;/sc\", html)[0]time_data_2 = re.findall(\"\\d\\d日\\d\\d时\", all_data_2)temp_data_2 = re.findall(\"(\\d+)℃\", all_data_2)for i in range(len(temp_data_2)): temp_data_2[i] = int(temp_data_2[i])print(temp_data_2)from matplotlib import pyplot as pltfrom matplotlib import font_manager#设置中文字体my_font = font_manager.FontProperties(fname=\"C:/Windows/Fonts/simfang.ttf\")#设置图形大小# plt.figure(figsize=(20,8),dpi=80)plt.figure(figsize=(20, 8))#绘图# plt.plot(range(57), temp_data, label=\"济南温度\", color=\"#F08080\", linestyle=\"--\")plt.scatter(range(57), temp_data, label=\"济南温度\", color=\"r\", linestyle=\"-\")plt.scatter(range(57), temp_data_2, label=\"漠河温度\", color=\"b\", linestyle=\"-\")#设置x轴刻度_xtick_labels = time_dataplt.xticks(range(57)[::3],_xtick_labels[::3],fontproperties=my_font, rotation=30)#设置y轴刻度plt.yticks(range(min(temp_data_2),max(temp_data)+1))#绘制网格plt.grid(alpha=0.9,linestyle=':')#添加图例plt.legend(prop=my_font,loc=\"upper left\")#添加描述信息plt.xlabel(\"时间\",fontproperties=my_font)plt.ylabel(\"温度 单位(℃)\",fontproperties=my_font)plt.title(\"济南、漠河未来六天气温变化趋势\",fontproperties=my_font)#展示图形plt.show() 散点图（二）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 读取中国疫情数据 作累计确诊人数 治愈人数的散点图import csv#获取数据confirmed_count = []cured_count = []with open(\"./data/DXYOverall.csv\", \"r\", encoding=\"utf-8\") as f: reader = csv.reader(f) for r in list(reader)[1:]: confirmed_count.append(int(r[8])) cured_count.append(int(r[10]))print(len(confirmed_count))print(confirmed_count)print(confirmed_count[2500])from matplotlib import pyplot as pltfrom matplotlib import font_managermy_font = font_manager.FontProperties(fname=\"C:/Windows/Fonts/simfang.ttf\")x = range(3059)y = confirmed_county_2 = cured_count#设置图形大小# plt.figure(figsize=(20,8),dpi=80)plt.figure(figsize=(40, 8))#绘图# plt.plot(range(57), temp_data, label=\"济南温度\", color=\"#F08080\", linestyle=\"--\")plt.scatter(x, y[::-1], label=\"累计确诊人数\", color=\"r\", linestyle=\"-\")plt.scatter(x, y_2[::-1], label=\"治愈人数\", color=\"b\", linestyle=\"-\")#设置x轴刻度_xtick_labels = xplt.xticks(_xtick_labels[::100], rotation=30)#设置y轴刻度plt.yticks(range(min(y),max(y)+1)[::2000])#绘制网格plt.grid(alpha=0.9,linestyle=':')#添加图例plt.legend(prop=my_font,loc=\"upper left\")#添加描述信息plt.xlabel(\"时间\",fontproperties=my_font)plt.ylabel(\"人数\",fontproperties=my_font)plt.title(\"新冠肺炎相关人数变化\",fontproperties=my_font)#展示图形plt.show() 条形图（json解析 多条形）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import jsonimport jsonpath# 获取数据content = \"\"with open(\"num_json\", \"r\", encoding=\"utf-8\") as f: content = f.read()jsonobj = json.loads(content)confirmed_list = jsonpath.jsonpath(jsonobj,'$.data[*].confirmed')for i in range(len(confirmed_list)): confirmed_list[i] = int(confirmed_list[i])cured_list = jsonpath.jsonpath(jsonobj, '$.data[*].crued')for i in range(len(cured_list)): cured_list[i] = int(cured_list[i])area_list = jsonpath.jsonpath(jsonobj, '$.data[*].area')for i in range(len(area_list)): area_list[i] = area_list[i].encode(\"utf-8\").decode(\"utf-8\")print(confirmed_list)print(cured_list)print(area_list)print(len(confirmed_list), len(cured_list), len(area_list))from matplotlib import pyplot as pltfrom matplotlib import font_manager#设置中文字体my_font = font_manager.FontProperties(fname=\"C:/Windows/Fonts/simfang.ttf\")#设置图形大小# plt.figure(figsize=(20,8),dpi=80)plt.figure(figsize=(20, 8))x_1 = range(len(area_list))x_2 = [i + 0.3 for i in range(len(area_list))]#绘制条形图plt.bar(x_1, confirmed_list, label=\"确认人数\", width=0.3, color=\"r\")plt.bar(x_2, confirmed_list, label=\"治愈人数\", width=0.3, color=\"b\")#设置字符串到x轴plt.xticks(range(len(area_list)), area_list, fontproperties=my_font, rotation=30)# #设置y轴刻度# plt.yticks(range(min(confirmed_list),max(confirmed_list)+1)[::10000]) 这句没必要写# #绘制网格plt.grid(alpha=0.9,linestyle=':')# #添加图例plt.legend(prop=my_font,loc=\"upper left\")# #添加描述信息plt.xlabel(\"地区\",fontproperties=my_font)plt.ylabel(\"人数\",fontproperties=my_font)plt.title(\"各地区疫情相关人数\",fontproperties=my_font)plt.show() 条形图（模拟直方 注意刻度 条形的x轴的0刻度不是原点，而是一个单位处）1234567891011121314151617181920212223# coding=utf-8from matplotlib import pyplot as pltfrom matplotlib import font_managerinterval = [0,5,10,15,20,25,30,35,40,45,60,90]width = [5,5,5,5,5,5,5,5,5,15,30,60]quantity = [836,2737,3723,3926,3596,1438,3273,642,824,613,215,47]print(len(interval),len(width),len(quantity))#设置图形大小plt.figure(figsize=(20,8),dpi=80)plt.bar(range(12),quantity,width=1)#设置x轴的刻度_x = [i-0.5 for i in range(13)]_xtick_labels = interval+[150]plt.xticks(_x,_xtick_labels)plt.grid(alpha=0.4)plt.show() 直方（注意组距应可整除极值）12345678910111213141516171819202122# coding=utf-8from matplotlib import pyplot as plta=[131, 98, 125, 131, 124, 139, 131, 117, 128, 108, 135, 138, 131, 102, 107, 114, 119, 128, 121, 142, 127, 130, 124, 101, 110, 116, 117, 110, 128, 128, 115, 99, 136, 126, 134, 95, 138, 117, 111,78, 132, 124, 113, 150, 110, 117, 86, 95, 144, 105, 126, 130,126, 130, 126, 116, 123, 106, 112, 138, 123, 86, 101, 99, 136,123, 117, 119, 105, 137, 123, 128, 125, 104, 109, 134, 125, 127,105, 120, 107, 129, 116, 108, 132, 103, 136, 118, 102, 120, 114,105, 115, 132, 145, 119, 121, 112, 139, 125, 138, 109, 132, 134,156, 106, 117, 127, 144, 139, 139, 119, 140, 83, 110, 102,123,107, 143, 115, 136, 118, 139, 123, 112, 118, 125, 109, 119, 133,112, 114, 122, 109, 106, 123, 116, 131, 127, 115, 118, 112, 135,115, 146, 137, 116, 103, 144, 83, 123, 111, 110, 111, 100, 154,136, 100, 118, 119, 133, 134, 106, 129, 126, 110, 111, 109, 141,120, 117, 106, 149, 122, 122, 110, 118, 127, 121, 114, 125, 126,114, 140, 103, 130, 141, 117, 106, 114, 121, 114, 133, 137, 92,121, 112, 146, 97, 137, 105, 98, 117, 112, 81, 97, 139, 113,134, 106, 144, 110, 137, 137, 111, 104, 117, 100, 111, 101, 110,105, 129, 137, 112, 120, 113, 133, 112, 83, 94, 146, 133, 101,131, 116, 111, 84, 137, 115, 122, 106, 144, 109, 123, 116, 111,111, 133, 150]#计算组数d = 3 #组距 组距应可整除极差num_bins = (max(a)-min(a))//dprint(max(a),min(a),max(a)-min(a))print(num_bins)#设置图形的大小plt.figure(figsize=(20,8),dpi=80)plt.hist(a,num_bins,normed=True)#设置x轴的刻度plt.xticks(range(min(a),max(a)+d,d)) #注意依据组距的刻度plt.grid()plt.show() 三、关于数据的获取与解析，在数据解析部分进行总结四、其他类型图绘制练习https://matplotlib.org","categories":[{"name":"plot","slug":"plot","permalink":"http://nlbyd1119.online/categories/plot/"}],"tags":[{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"}]},{"title":"flask-study-1","slug":"flask-study-1","date":"2020-06-07T07:21:44.000Z","updated":"2020-06-07T07:55:06.491Z","comments":true,"path":"2020/06/07/flask-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/07/flask-study-1/","excerpt":"Flask的基本学习包括视图、模板、数据库、测试与部署四部分。","text":"Flask的基本学习包括视图、模板、数据库、测试与部署四部分。 大概看了一遍之后，感到用Python写，真的要简化很多，实现一些功能要快很多，而且其项目文件结构和模板语法乃至数据库迁移和springboot项目是类似的。 一、建立一个Flask项目的流程1.如果是一个很简单的，用单文件写的小项目第一步，通用配置 1234567891011121314151617181920212223from flask import Flask, render_template, request, redirect, url_for, jsonifyfrom flask_sqlalchemy import SQLAlchemyfrom flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredapp = Flask(__name__)class Config(object): # sqlalchemy的配置参数 SQLALCHEMY_DATABASE_URI = \"mysql://root:mysql@127.0.0.1:3306/flask\" # 设置sqlalchemy自动更跟踪数据库 SQLALCHEMY_TRACK_MODIFICATIONS = True SECRET_KEY = \"doiso7fd89fyd9^(fsd\"app.config.from_object(Config)db = SQLAlchemy(app) 第二步，定义数据库模型类，并初始化数据库表 1234567891011121314151617181920# 定义数据库的模型class Author(db.Model): \"\"\"作者\"\"\" __tablename__ = \"tbl_authors\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(32), unique=True) books = db.relationship(\"Book\", backref=\"author\")class Book(db.Model): \"\"\"书籍\"\"\" __tablename__ = \"tbl_books\" id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) author_id = db.Column(db.Integer, db.ForeignKey(\"tbl_authors.id\"))db.drop_all()db.create_all() 第三步，定义视图函数框架，定义模板（可能需要定义表单模型类） 123456789101112131415161718192021222324# 创建表单模型类class AuthorBookForm(FlaskForm): \"\"\"作者数据表单模型类\"\"\" author_name = StringField(label=u\"作者\", validators=[DataRequired(u\"作者必填\")]) book_name = StringField(label=u\"书籍\", validators=[DataRequired(u\"书籍必填\")]) submit = SubmitField(label=u\"保存\") &lt;form method=\"post\"&gt; &#123;&#123; form.csrf_token &#125;&#125; &#123;&#123; form.author_name.label &#125;&#125; &lt;p&gt;&#123;&#123;form.author_name&#125;&#125;&lt;/p&gt; &#123;% for msg in form.author_name.errors %&#125; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123; form.book_name.label &#125;&#125; &lt;p&gt;&#123;&#123;form.book_name&#125;&#125;&lt;/p&gt; &#123;% for msg in form.book_name.errors %&#125; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123; form.submit &#125;&#125; &lt;/form&gt; 第四步，完善视图函数逻辑。第五步，测试与部署。 2.如果是较复杂的，需要分为多个模块的项目，就要使用蓝图。根据设计确定好模块，则其后需要在每个模块中创建蓝图对象，创建相关视图对象，其他步骤类似。 12345678910111213141516# 在每个模块中创建蓝图对象from flask import Blueprint# 1. 创建蓝图对象app_goods = Blueprint(\"goods\", __name__)# 2. 创建蓝图的视图函数@app_goods.route(\"/get_goods\")def get_goods(): return \"get goods page\" # 在应用主文件中注册蓝图app.register_blueprint(app_goods, url_prefix=\"/goods\") 二、几个关键点1.关于项目结构根目录下static 存放 js css img等静态资源文件templates 存放html模板文件 通过render_template渲染这两个都是默认目录，在创建app时可自定义2.关于部署使用 gunicorn3.关于模板模板语法4.flask模块、对象与扩展 Flask, render_template, request, redirect, url_for, jsonify, current_app, make_response, session config flask_script &emsp; flask_wtf &emsp; flask-sqlalchemy &emsp; flask_migrate &emsp; flask_mail 5.其他 用到表单和session需要在app.config中设置SECRET_KEY","categories":[{"name":"Flask","slug":"Flask","permalink":"http://nlbyd1119.online/categories/Flask/"}],"tags":[{"name":"PythonWeb","slug":"PythonWeb","permalink":"http://nlbyd1119.online/tags/PythonWeb/"}]},{"title":"视频播放器","slug":"视频播放器","date":"2020-06-04T03:54:38.000Z","updated":"2020-06-04T23:45:50.445Z","comments":true,"path":"2020/06/04/视频播放器/","link":"","permalink":"http://nlbyd1119.online/2020/06/04/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"视频播放器","text":"视频播放器 $(\"#getNameList\").click(function () { alert($(this).attr(\"url\")); $.get($(this).attr(\"url\") + \"/media/findAll.do\", function (data) { alert(data); $(\"#showNameList\").text(data); }); }); $(\"#searchByName\").click(function () { $.get($(this).attr(\"url\") + \"/media/findLinks.do\", { aname: $(\"#selectedName\").val()}, function (data) { alert(data); $(\"#showLinkList\").text(data); }); }); $(\"#setMediaURL\").click(function () { $(\"#media\").css(\"display\", \"none\"); $(\"#media\").prop(\"src\", $(\"#selectedLink\").val()); alert($(\"#media\").prop(\"src\")); $(\"#media\").css(\"display\", \"block\"); }); $(\"#findMediaName\").click(function () { alert($(this).attr(\"url\")); $.get($(this).attr(\"url\") + \"/media/findByAname.do\", { aname: $(\"#selectedName\").val()}, function (data) { alert(data) $(\"#showNameList\").text(data); }); })","categories":[],"tags":[]},{"title":"css-study-1","slug":"css-study-1","date":"2020-06-01T08:09:10.000Z","updated":"2020-06-01T08:39:30.275Z","comments":true,"path":"2020/06/01/css-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/06/01/css-study-1/","excerpt":"黑马前端 学成在线案例（盒子+浮动）","text":"黑马前端 学成在线案例（盒子+浮动） 总体心得 首先，事先根据标准流在纵向分成大致几个部分，如案例中 的header banner goods box footer五个部分；然后对每个行细分列，这些列的排布都是浮动实现的；要仿制网站的话，首先要看情况切图，在visio上画好每个块。 css有一些通用的代码，如去除内外边距、清除浮动、去除链接下划线，可以事先写出来。实际编写时，先写好该部分的html代码，然后写最外层盒子的样式，写好后对其中的每个列块，直接先确定浮动方式、宽高，注意宽高除了内容需要动态变化的移动需要指定。这些确定后，大致布局确定，然后再具体写每个列小盒子内容的样式。 对我而言，一个难点是确定margin，并不能根据设计图准确地确定margin；还有就是当多个类型标签嵌套时，不清楚该给谁样式，如li套a，那么样式该给li还是a，不好确定。 局部问题 nav和subnav样式设置的区别1234567891011121314151617181920212223242526272829303132333435363738394041424344.nav &#123; float: left;&#125;.nav ul li &#123; float: left;&#125;.nav ul li a &#123; display: block; height: 40px; padding: 0 10px; margin-right: 20px; line-height: 40px; font-size: 18px; color: #050505; text-decoration: none;&#125;/*鼠标经过链接 才有底边框*/.nav ul li a:hover &#123; border-bottom: 2px solid #00a4ff;&#125;.subnav &#123; float: left; width: 150px; height: 420px; padding: 0 20px; /*背景半透明*/ background: rgba(0, 0, 0, .3);&#125;.subnav li &#123; height: 45px; line-height: 45px;&#125;.subnav li a &#123; color: #fff; font-size: 14px; text-decoration: none;&#125;.subnav li a:hover &#123; color: #00b4ff;&#125;.subnav span &#123; float: right;&#125; course中多行文本（不同标签）的显示1234567891011121314151617181920212223.course-bd &#123; /*没有宽度的盒子 padding 不会撑开盒子*/ padding: 0 15px;&#125;.course-bd ul &#123; /*外边距塌陷的问题 margin-top: 10px;*/ padding-top: 10px;&#125;.course-bd li &#123; /*行高等与高度 只能让单行文本垂直居中*/ height: 50px; border-bottom: 1px solid #ccc; margin-top: 10px;&#125;.course-bd li h4 &#123; font-size: 14px; color: #4e4e4e;&#125;.course-bd li p &#123; font-size: 12px; color: #a5a5a5;&#125; box-bd细节设置，为保证内容动态添加不设高度，因此必须清楚浮动1234567891011121314151617181920212223242526272829303132.box-bd &#123; /*这个盒子一定不要给高度 因为我们可能放一行 也可能是2行 或者n行*/ /*宽度呢？ 呵呵*/ /*box-bd 宽度 超过了 版心 1200 是可以的，就就解决了问题*/ width: 1215px;&#125;.box-bd li &#123; float: left; width: 228px; height: 270px; margin-right: 15px; margin-bottom: 15px; background-color: #fff; box-shadow: 2px 2px 2px rgba(0, 0, 0, .3);&#125;.box-bd li img &#123; width: 100%;&#125;.box-bd li h4 &#123; margin: 20px; font-size: 14px; color: #050505; font-weight: 400;&#125;.box-bd li p &#123; margin: 0 20px; font-size: 12px; color: #999;&#125;.box-bd p span &#123; color: orange;&#125; 父右子左 links12345678910111213141516171819.links &#123; float: right;&#125;.links dl &#123; float: left; margin-left: 100px;&#125;.links dt &#123; height: 35px; font-size: 16px; color: #333;&#125;.links dd a &#123; font-size: 12px; color: #333;&#125;.links dd a:hover &#123; color: #004aff;&#125; 一些通用写法 通用部分 1234567891011121314151617181920212223242526272829303132333435363738/*清除元素默认的内外边距*/* &#123; margin: 0; padding: 0;&#125;/*清除列表样式*/li &#123; list-style: none;&#125;/*去掉button 默认自带的边框*/button &#123; border: none;&#125;body &#123; background-color: #f3f5f7; /*方便写代码 一会别忘了删除*/ /*height: 3000px;*/&#125;a &#123; text-decoration: none;&#125;/*清除浮动的*/.clearfix:before,.clearfix:after &#123; content: \"\"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125;/*版心 1200 水平居中*/.w &#123; width: 1200px; margin: auto;&#125; 盒子阴影1box-shadow: 2px 2px 2px rgba(0, 0, 0, .2); 透明背景1background: rgba(0, 0, 0, .3);","categories":[{"name":"css","slug":"css","permalink":"http://nlbyd1119.online/categories/css/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"大二下至五月末小结","slug":"大二下至五月末小结","date":"2020-05-31T07:35:25.000Z","updated":"2020-05-31T10:06:04.843Z","comments":true,"path":"2020/05/31/大二下至五月末小结/","link":"","permalink":"http://nlbyd1119.online/2020/05/31/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%87%B3%E4%BA%94%E6%9C%88%E6%9C%AB%E5%B0%8F%E7%BB%93/","excerpt":"学习总结","text":"学习总结 本学期大部分的时间都贡献给几个课程作业了，也就是进行了一些简单程序的实现，可以说是走了几个开发的流程，但对代码能力的提高是很有限的，因为重复的工作做的有些多。完成的几个程序 pyqt开发的gui樱花动漫的客户端（结合爬虫）安全帽检测客户端肺炎依赖影像检测客户端https://github.com/nlby/pyqt_nlby app学习安卓过程中编写的多个小democshelper 信息技术学习辅助工具https://github.com/nlby/cshelper_nlby 后端cshelper 数据存储系统 （ssm）证书信息管理后台 （ssm + spring security）bbs (springboot) 学到的 安卓基本开发 安卓网络通信 安卓MVP模式 文档编写方法 visio基本绘图 QDockWidget与其他控件的结合使用 pyqt多线程实现 python操作数据库 ssm简单项目编写 springboot基本配置与使用 以太坊原理和基本开发 Fabric原理 需要学的 提升java编程能力（算法和底层） pyqt控件的更灵活使用 python web开发 python 爬虫高级使用和数据分析 可视化 深度学习理论与实践 模型训练测试 练习 ssm springboot项目 体会设计方法 从前端基础学起，拥有自制界面的能力 利用网页api的能力 了解并使用Fabric java sdk 学习参考 java学习路线与项目https://github.com/coderzcr/JavaWeb-Project-Source-Sharehttps://github.com/coderzcr/Senior-Java java面试https://www.bilibili.com/video/BV1QE411N7kP?from=search&amp;seid=18316543747122844433https://www.bilibili.com/video/av37602130https://www.bilibili.com/video/BV1zb411M7NQ?from=search&amp;seid=18316543747122844433 springboot springcloudhttps://www.bilibili.com/video/BV1Et411Y7tQhttps://www.bilibili.com/video/BV1yE411x7Ky 物联网https://www.bilibili.com/video/BV1jJ411c7HC 数据分析与可视化https://www.bilibili.com/video/BV1HJ411h7vJ/?spm_id_from=333.788.videocard.1 爬虫https://github.com/facert/awesome-spider live2dhttps://github.com/Eikanya/Live2d-model","categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://nlbyd1119.online/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"jsp-study-6","slug":"jsp-study-6","date":"2020-05-28T11:13:44.000Z","updated":"2020-05-29T00:24:29.448Z","comments":true,"path":"2020/05/28/jsp-study-6/","link":"","permalink":"http://nlbyd1119.online/2020/05/28/jsp-study-6/","excerpt":"JSP中使用XML","text":"JSP中使用XML 一、概述 如果Web应用没有用到数据库独有的一些特性，而仅仅是查询数据而已，并且这些数据可能占用较大的存储空间。在这种情况下，如果选择用数据库来处理数据显然得不偿失，因为使用数据库要付出降低程序运行效率的代价。 当需要查询文件中的某些内容时，显然希望这种文件应当具有某种特殊的形式结构，即文件应当按照一定的标准来组织数据，这就是XML文件。 二、XML文件的基本结构 123456789101112➢XML是eXtensible Markup Language 缩写，称之为可扩展置标语言。➢所谓可扩展是指XML允许用户按照XML的规则自定义标记。➢XML文件是由标记构成的文本文件，使得XML文件能够很好地体现数据的结构和含义。➢W3C推出XML的主要目的是使得Internet上的数据相互交流更方便，让文件的内容更加显而易懂。➢规范的XML文件应当用“XML声明”开始、文件有当且仅有一个根标记，其它标记都必须封装在根标记中.➢根标记可以有若干个子标记，称根标记的子标记。根标记的子标记还可以有子标记，以此类推。➢如果一个标记仅仅包含文本，这样的标记称为叶标记。➢非空标记必须由“开始标记”与“结束标记”组成、空标记没有“开始标记”和“结束标记”等等。➢XML文件的标记必须形成树型结构，即一个标记的子标记必须包含于该标记的开始标记和结束标记之间。简单地说，就是标记之间不允许出现交叉。➢W3C吸取了HTML发展的教训，对XML指定了严格的语法标准。为了检查XML文件是否规范，一个简单的办法就是用浏览器，打开XML文件，如果XML是规范的，浏览器将显示XML源文件，否则，将显示出错信息。 三、XML声明 1234567891011➢一个规范的XML文件应当以XML声明作为文件的第一行，在其前面不能有空白、其他的处理指令或注释。➢XML声明以“&lt;?xml”标识开始、以“?&gt;”标识结束。以下是一个最基本的XML声明：&lt;?xml version=\"1.0\"?&gt;➢一个简单的XML声明中可以只包含属性version（目前该属性的值只可以取1.0），指出该XML文件使用的XML版本。➢XML声明中也可以指定encoding属性的值，该属性规定XML文件采用哪种字符集进行编码。如果在XML声明中没有指定encoding属性的值，那么该属性的默认值是UTF-8。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;➢如果encoding属性的值为“UTF-8”，XML文件必须选择“UTF-8”编码来保存.➢如果在编写XML文件时只准备使用ASCII字符和汉字，也可以将encoding属性的值设置为gb2312.这时XML文件必须使用ANSI编码保存.➢如果在编写XML文件时只准备使用ASCII字符，也可以将encoding属性的值设置为ISO-8859-1.这时XML文件必须使用ANSI编码保存. 四、标记XML文件是由标记构成的文本文件。标记的名称可以由字母、数字、下划线“_”、点号“.”或连字符“-”组成，但必须以字母或下划线开头。标记名称区分大小写。1.空标记 1234567➢空标记就是不含有任何内容的标记，即不含有子标记或文本内容.➢空标记不需要开始标记和结束标记➢空标记以“&lt;”标识开始，用“/&gt;”标识结束&lt;空标记的名称属性列表/&gt;或&lt;空标记的名称/&gt;例如：&lt;chair width=\"24\" height=\"12\" /&gt;&lt;和标记名称之间不要含有空格 2.非空标记 1234➢由“开始标记”与“结束标记”组成，“开始标记”与“结束标记”之间是该标记所含有的内容。&lt;sex&gt;男&lt;/sex&gt;➢开始标记以“&lt;”标识开始，用“&gt;”标识结束➢结束始标记以“&lt;/”标识开始，用“&gt;”标识结束 3.CDATA段 12345678➢标记内容中的文本数据中不可以含有左尖括号、右尖括号、与符号、单引号和双引号这些特殊字符。如果标记内容想使用这些特殊字符，办法之一是通过使用CDATA段。➢CDATA段用“&lt;![CDATA[”作为段的开始，用“]]&gt;”作为段的结束。段开始和段结束之间称为CDATA段的内容，CDATA段中的内容可以包含任意的字符&lt;hello&gt;&lt;![CDATA[booleanboo=true&amp;&amp;false&lt;你好&gt;]]&gt;&lt;/hello&gt; 4.属性属性是一个名值对，即属性必须由名字和值组成。属性必须在非空标记的开始标记或空标记中声明，用“=”为属性指定一个值。 五、DOM解析器（按树形结构解析） 123使用XML解析器可以从XML文件中解析出所需要的数据.➢DOM（Document Object Model，文档对象模型）是W3C制定的一套规范标准。DOM规范的核心是按树型结构处理数据。➢简单地说，DOM解析器必须按着DOM规范在内存中按树型结构组织数据，DOM解析器通过读入XML文件在内存中建立一个“树”，也就是说XML文件的标记、标记的文本内容都会和内存中“树”的某个节点相对应。一个应用程序可以方便地操作内存中“树”的节点来处理XML文档，获取自己所需要的数据。 1.使用DOM解析器的基本步骤 12345678910111213141516① 使用javax.xml.parsers包中的DocumentBuilderFactory类 调 用 其 类 方 法 newInstance () 实 例 化 一 个 DocumentBuilderFactory对象： DocumentBuilderFactory factory= DocumentBuilderFactory. newInstance(); ② factory 对象调用new DocumentBuilder ()方法返回一个 DocumentBuilder对象 （称做DOM解析器）： DocumentBuilder builder = factory. newDocumentBuilder(); ③ builder对象调用public Document parse(File f)方法解 析参数f指定的文件，并返回一个实现了Document接口的实 例，该实例被称做Document对象： Document document= builder. parse(new File(\"price.xml\")) ; 2.Document对象 1234➢DOM解析器负责在内存中建立Document对象，即调用parse方法返回一个Document对象Documentdocument=builder.parse(newFile(\"price.xml\"));➢parse方法将整个被解析的XML文件封装成一个Document对象，即将XML文件和内存中的Document对象相对应.➢Document对象就是一棵“树”，文件中的标记都和Document对象中的某个节点相对应。 对象结构 12➢Element类、Text类和CDATASection类都是实现了Node接口的类，是比较重要的三个类，这些类的对象分别被称作Document对象中的Element节点、Text节点和CDATASection节点.➢一个Element节点中还可含有Element节点、Text节点和CDATASection节点。比如Document对象的根节点就是一个Element节点. Element节点 123456789Element节点经常使用下列方法获取和该节点相关的信息➢String getTagName()返回该节点的名称，该名称就是和此节点相对应的XML中的标记的名称。➢String getTextContent()返回当前节点的所有Text子孙节点中的文本内容（也就是返回相对应的XML文件中的标记及子孙标记中含有的文本内容）。➢String getAttribute(String name)返回节点中参数name的属性值，该属性值是和此节点对应的XML中标记中的属性值。Element节点经常使用下列方法获取和该节点相关的信息➢Boolean hasAttribute(String name) 判断当前节点是否有参数name指定的属性。➢NodeList getElementByTagName(String name)返回一个NodeList对象，该对象由当前节点的Element类型子孙节点组成，这些子孙节点的名字由参数name指定。➢NodeList getChildNodes()返回一个NodeList对象，该对象由当前节点的子节点组成。 Text节点Text节点使用String getWholeText()方法获取节点中的文本（包括其中的空白字符）。CDATASection节点CDATASection节点使用String getWholeText()方法获取该节点中的文本，即CDATA段中的文本（包括其中的空白字符）。 六、SAX解析器 12➢如果XML文件较大，相应的Document对象就要占据较多的内存空间.➢和DOM解析器不同的是，SAX解析器不在内存中建立和XML文件相对应的树型结构数据，SAX解析器的核心是事件处理机制。和DOM解析器相比，SAX解析器占有的内存少，对于许多应用程序，使用SAX解析器来获取XML数据具有较高的效率. 1.使用SAX解析器的基本步骤 12345678910111213① 使用javax.xml.parsers包中的SAXParserFactory类调用其 类方法newInstance ()实例化一个SAXParserFactory对象: SAXParserFactory factory=SAXParserFactory.newInstance(); ② SAXParserFactory对象调用newSAXParser ()方法返回一个 SAXParser对象，称之为SAX解析器: SAXParser saxParser=factory.newSAXParser(); ③ saxParser 对 象 调 用 public void parse(File f,DefaultHandler dh)方法解析参数f指定的XML文件。 saxParser. parse(new File(“price.xml”),handler) ; 2.SAX解析器的工作原理 123➢SAX解析器调用parse方法解析XML文件，parse方法的第2个参数dh是DefaultHandler类型，称为事件处理器。➢parse方法在解析XML文件的过程中，根据从文件中解析出的数据产生相应的事件，并报告这个事件给事件处理器dh，事件处理器dh就会处理所发现的数据，即处理器dh会根据相应的事件调用相应的方法来处理数据。➢parse方法必须等待事件处理器处理完毕后才能继续解析文件、报告下一个事件。 3.事件的产生与处理①文件开始事件与结束事件 12当解析器开始解析器XML文件时，就会报告“文件开始”事件给事件处理器，然后再陆续地报告其他的事件，最后报告“文件结束”事件。解析器报告“文件开始”事件，事件处理器就会调用startDocument()方法；解析器报告“文件结束”事件，事件处理器就会调用endDocument()方法。 ②开始标记事件与结束标记事件 12345678当解析器发现一个标记的开始标记时，报告开始事件给事件处理器，事件处理器调用startElement方法对发现的数据做出处理。startElement(String uri,String localName,String qName,Attribute satts)方法中atts是解析器发现的标记的全部属性，参数uri的取值就是解析器发现的标记的名称空间（如果没有名称空间uri是空字符串），localName是标记的名称，qName是带前缀的标记名称（如果名称空间的前缀）或标记名称（如果没有名称空间的前缀）。解析器报告完该标记的“标记开始”事件后，一定还会报告该标记的“标记结束”事件，事件处理 器就会调用endElement方法进行处理endElement(String uri,String localName,String qName)如果一个标记是空标记，解析器也报告“标记开始”事件和“标记结束”事件. ③文本数据事件 1234567当解析器解析报告“文本数据”事件给处理器，事件处理器就会然后调用characters方法对解析的数据做出处理public void characters(char[] ch,int start,int length)字符数组中ch存放的就是解析器解析出的文本数据，start是数组ch中存放字符的起始位置，length是存放的字符个数。注意：对于文本数据，解析器可能分成几个连续的“文本数据”报告给事件处理器。 七、XML与CSS","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"jsp-study-5","slug":"jsp-study-5","date":"2020-05-28T02:28:36.000Z","updated":"2020-05-29T00:24:22.706Z","comments":true,"path":"2020/05/28/jsp-study-5/","link":"","permalink":"http://nlbyd1119.online/2020/05/28/jsp-study-5/","excerpt":"JSP文件操作","text":"JSP文件操作 一、File类1.File类的对象主要用来获取文件本身的一些信息，例如文件所在的目录、文件的长度、文件读写权限等，不涉及对文件的读写操作。2.创建一个File对象的构造方法有3个： 123File(String filename);File(String directoryPath,Stringfilename);File(File f, String filename); 3.经常使用File类的下列方法获取文件本身的一些信息 123456789101112131415161718192021➢ public String getName() —获取文件的名字 ➢ public boolean canRead() —判断文件是否是可读的 ➢ public boolean canWrite() —判断文件是否可被写入 ➢ public boolean exists() —判断文件是否存在 ➢ public long length() —获取文件的长度 （单位是字节） ➢ public String getAbsolutePath() —获取文件的绝对路径 ➢ public String getParent() —获取文件的父目录 ➢ public boolean isFile() —判断是否是正常文件，而不是目录 ➢ public boolean isDirectory() —判断文件是否是一个目录 ➢ public boolean isHidden() —判定是否隐藏文件 ➢ public long lastModified() —获取最后修改时间 123456789101112131415161718&lt;%@ page contentType=\"text/html;charset=GB2312\" %&gt;&lt;%@ page import=\"java.io.*\"%&gt; &lt;HTML&gt;&lt;body bgcolor=cyan&gt;&lt;font Size=2&gt;&lt;% String jspPage=request.getServletPath(); //请求的页面的名称 String webDir = request.getContextPath();//获取当前Web服务目录的名称 webDir = webDir.substring(1); //去掉名称前面的目录符号：/ jspPage =jspPage.substring(1); //去掉名称前面的目录符号：/ File f= new File(\"\"); //该文件认为在Tomcat引擎启动的目录中，即bin目录中 String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File file=new File(tomcatDir+\"/webapps/\"+webDir,jspPage); %&gt; 文件&lt;%=file.getName()%&gt;是可读的吗？&lt;b&gt;&lt;%=file.canRead()%&gt;&lt;/b&gt; &lt;br&gt;文件&lt;%=file.getName()%&gt;的长度：&lt;b&gt;&lt;%=file.length()%&gt;字节&lt;/b&gt; &lt;br&gt;&lt;%=file.getName()%&gt;的父目录是:&lt;br&gt;&lt;b&gt;&lt;%=file.getParent()%&gt;&lt;/b&gt; &lt;br&gt; &lt;%=file.getName()%&gt;的绝对路径是：&lt;br&gt;&lt;b&gt;&lt;%=file.getAbsolutePath()%&gt;&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt; 4.创建目录 12File对象调用方法public boolean mkdir()创建一个目录如果创建成功就返回true 否则返回false 如果该目录已经存在也将返回false 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=GB2312\" %&gt;&lt;%@ page import=\"java.io.*\"%&gt; &lt;HTML&gt;&lt;body bgcolor=#EEFFAD&gt;&lt;font Size=2&gt;&lt;% String webDir = request.getContextPath();//获取当前Web服务目录的名称 webDir = webDir.substring(1); //去掉名称前面的目录符号：/ File f= new File(\"\"); //该文件认为在Tomcat引擎启动的目录中，即bin目录中 String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File dir=new File(tomcatDir+\"/webapps/\"+webDir+\"/image\");%&gt; &lt;br&gt; 在&lt;%=webDir%&gt;下创建一个新的目录：image,&lt;br&gt;成功创建了吗？ &lt;%=dir.mkdir()%&gt; &lt;br&gt; image是目录吗？&lt;%=dir.isDirectory()%&gt;&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt; 5.列出目录中的文件如果File对象是一个目录，那么该对象可以调用下面的方法获得目录下的文件和子目录 12public String [ ] list() 用字符串形式返回目录下的全部文件. public File [ ] listFiles() 用File对象形式返回目录下的全部文件。 6.列出指定类型的文件 123➢public String [ ] list(FilenameFilter obj) 该方法用字符串形式返回目录下的指定类型的所有文件。 ➢public File [ ] listFiles(FilenameFilter obj) 该方法用File对象返回目录下的指定类型的所有文件。 12345678910111213141516171819202122232425262728293031&lt;%@ page contentType=\"text/html;charset=GB2312\" %&gt;&lt;%@ page import=\"java.io.*\"%&gt; &lt;%! class FileJSP implements FilenameFilter&#123; String str=null; FileJSP(String s)&#123; str=\".\"+s; &#125; public boolean accept(File dir,String name)&#123; return name.endsWith(str); &#125; &#125;%&gt;&lt;HTML&gt;&lt;body bgcolor=#EEFFAD&gt;&lt;font Size=2&gt;&lt;% String name=\"jsp\"; String webDir = request.getContextPath(); webDir = webDir.substring(1); File f= new File(\"\"); String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File dir=new File(tomcatDir+\"/webapps/\"+webDir);%&gt; &lt;br&gt; 在&lt;%=dir%&gt;下&lt;%=name%&gt;文件：&lt;% FileJSP file_jsp=new FileJSP(name); String file_name[]=dir.list(file_jsp); for(int i=0;i&lt;file_name.length;i++) out.print(\"&lt;br&gt;\"+file_name[i]);%&gt;&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt; 7.删除文件和目录 123➢File对象调用方法public boolean delete()删除当前对象代表的文件或目录.➢如果对象表示的是一个目录，则该目录必须是空目录.➢删除成功返回true. 二、读写文件的常用流1.字节输入流 如果对 文 件 读 取 需 求 比 较 简 单，那 么 可 以 使 用FileInputStream类（文件字节输入流），该类是InputStream类的子类（以字节为单位读取文件），该类的实例方法都是从InputStream类继承来的。 使用输入流通常包括4个基本步骤：12341. 设定输入流的源2. 创建指向源的输入流3. 让输入流读取源中的数据4. 关闭输入流。 构造方法12345678910111213FileInputStream(String name);FileInputStream(File file);第一个构造方法使用给定的文件名name创建FileInputStream流，第二个构造方法使用File对象创建FileInputStream流。参数name和file指定的文件称为输入流的源。File f= new File(\"hello.txt\"); //指定输入流的源try &#123; FileInputStream in= new FileInputStream(f); //创建指向源的输入流&#125;catch (IOException e) &#123; System.out.println(\"File read error:\"+e );&#125; 使用输入流读取字节1234567891011➢ 输入流的目的是提供读取源中数据的通道，程序可以通过这 个通道读取源中的数据。文件字节流可以调用从父类继承的 read方法顺序地读取文件，只要不关闭流，每次调用read方 法就顺序地读取文件中的其余内容，直到文件的末尾或文件 字节输入流被关闭。 ➢int read() 读取单个字节的数据，该方法返回字节值 （0~255之间的一个整数），如果未读出字节就返回-1。 ➢int read(byte b[]) 试图读取b.length个字节到字节数组b 中。 ➢int read(byte b[], int off, int len) 试图读取len个字节到字 节数组b 中，参数off指定从字节数组的某个位置开始存放读取 的数据。 关闭流输入流都提供了关闭方法close()，尽管程序结束时会自动关闭所有打开的流，但是当程序使用完流后，显式地关闭任何打开的流仍是一个良好的习惯 2.字节输出流 如果对 文 件 写 入 需 求 比 较 简 单，那 么 可 以 使 用FileOutputStream类（文件字节输出流），它是OutputStream类的子类（以字节为单位向文件写入内容），该类的实例方法都是从OutputStream类继承来的。 使用输出流通常包括4个基本步骤：12341. 给出输出流的目的地2. 创建指向目的地的输出流3. 让输出流把数据写入到目的地4. 关闭输出流 构造方法12345678910111213141516FileOutputStream(String name);FileOutputStream(File file);第一个构造方法使用给定的文件名name创建FileOutputStream流，第二个构造方法使用File对象创建FileOutputStream流。参数name和file指定的文件称为输出流的目的地。如果输出流指向的文件不存在，java就创建该文件，如果已经存在，输出流将刷新该文件，使其长度为0.选择是否具有刷新功能的构造方法FileOutputStream(String name, booleanappend);FileOutputStream(File file, booleanappend);如果append=true，输出流不会刷新所指向的文件，write方法将从文件末尾开始向文件写入数据；如果append=false，输出流将刷新所指向的文件 使用输出流写字节123456789101112131415➢ 输出流的目的是提供通往目的地的通道，程序可以通过这个 通道将程序中的数据写入到目的地。文件字节流可以调用从 父类继承的write方法顺序地写文件。FileOutStream流顺序 地向文件写入内容，即只要不关闭流，每次调用write方法就 顺序地向文件写入内容，直到流被关闭。 ➢ void write(int n) 输出流调用该方法向目的地写入单个字节 ➢ void write(byte b[]) 输出流调用该方法向目的地写入一个字节数组。 ➢ void write(byte b[],int off,int len) 给定字节数组中起始于偏移量off处取len个字节写到目的地。 关闭流在操作系统把程序所写到输出流上的那些字节保存到磁盘上之前，有时被存放在内存缓冲区中，通过调用close()方法，可以保证操作系统把流缓冲区的内容写到它的目的地，即关闭输出流可以把该流所用的缓冲区的内容冲洗掉（通常冲洗到磁盘文件上） 3.字符流 12345678910111213与FileInputStream 、FileOutputStream字节流相对应的是 FileReader、FileWriter字符流 （文件字符输入、输出流）， FileReader和FileWriter分别是Reader和Writer的子类.字符输入流和输出流的read和write方法使用字符数组读写数据， 即以字符为基本单位处理数据。 构造方法分别是： FileReader(String filename); FileReader(File filename); FileWriter (String filename); FileWriter (File filename); FileWriter (String filename,boolean append); FileWriter (File filename,boolean append); 4.缓冲流 BufferedReader类和BufferedWriter的构造方法分别是BufferedReader(Readerin);BufferedWriter(Writerout); BufferedReader流能够读取文本行，方法是readLine().BufferedReader和BufferedWriter类创建的对象称为缓冲输入、输出流，二者增强了读写文件的能力。需要注意的是二者的源和目的地必须是字符输入流和字符输出流12345678FileReader inOne=new FileReader(“studen.txt”); //创建字符输入流BufferReader inTwo=new BufferReader(inOne); //创建缓冲输入流FileWriter tofile=new FileWriter(“hello.txt”); //创建字符输出流BufferWriter out=new BufferWriter(tofile); //创建缓冲输入流readLine ()//读取一行 write(String s,int off, int len)//把字符串s写到流中，参数off是s开始处的偏移量，len是写入的字符数量 newLine()//写入一个回车符 可以把BufferedReader和BufferedWriter称为上层流，把它们指向的字符流称为底层流。 123Java采用缓存技术将上层流和底层流连接。底层字符输入流首先将数据读入缓存，BufferedReader流再从缓存读取数据；BufferedWriter流将数据写入缓存，底层字符输出流会不断地将缓存中的数据写入到目的地。当BufferedWriter流调用flush()刷新缓存或调用close()方法关闭时，即使缓存没有益满，底层流也会立刻将缓存的内容写入目的地 12345678910111213141516171819202122&lt;%@ page contentType=\"text/html;charset=gb2312\" %&gt;&lt;HTML&gt;&lt;BODY bgcolor=cyan&gt;&lt;font size=2&gt; &lt;form action=\"helpReadFile\" method=\"post\" name=\"form\"&gt; 输入文件的路径(如:d:/2000): &lt;input type=\"text\" name=\"filePath\" size=12&gt; &lt;br&gt;输入文件的名字(如:Hello.java): &lt;input type=\"text\" name=\"fileName\" size=9&gt; &lt;br&gt;&lt;input type=\"submit\" value=\"读取\" name=\"submit\"&gt; &lt;/form&gt;&lt;/font&gt;&lt;/BODY&gt;&lt;/HTML&gt;&lt;%@ page contentType=\"text/html;charset=gb2312\" %&gt; &lt;jsp:useBean id=\"fileBean\" type=\"mybean.data.Example8_4_Bean\" scope=\"request\"/&gt;&lt;HTML&gt;&lt;body bgcolor=#EEFFAE&gt;&lt;font size=2&gt; 文件的位置: &lt;jsp:getProperty name=\"fileBean\" property=\"filePath\"/&gt;, 文件的名字：&lt;jsp:getProperty name=\"fileBean\" property=\"fileName\"/&gt;, 文件的长度：&lt;jsp:getProperty name=\"fileBean\" property=\"fileLength\"/&gt; 字节。 &lt;br&gt;文件的内容： &lt;br&gt;&lt;TextArea rows=\"6\" cols=\"60\"&gt; &lt;jsp:getProperty name=\"fileBean\" property=\"fileContent\"/&gt; &lt;/TextArea&gt;&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt; 三、RandomAccessFile类RandomAccessFile类创建的流与前面的输入、输出流不同。RandomAccessFile类既不是输入流类InputStream类的子类，也不是输出流类Outputstream类的子类。习惯上，仍然称RandomAccessFile类创建的对象为一个流。RandomAccessFile流的指向既可以作为源也可以作为目的地。换句话说，当想对一个文件进行读写操作时，可以创建一个指向该文件的RandomAccessFile流，这样既可以从这个流读取文件的数据，也可以通过这个流向文件写入数据。1.构造方法 RandomAccessFile类的两个构造方法RandomAccessFile(String name,String mode)RandomAccessFile(File file,String mode) 参数name用来确定一个文件名，参数file是一个File对象,给出创建的流的源 （也是流的目的地）。参数mode取 “r” （只 读）或 “rw” （可读写），决定创建的流对文件的访问权利。 2.读写方法 12345678readLine()从文件中读取一个文本行readUTF()从文件中读取一个UTF字符串seek(long a) 定位当前流在文件中的读写的位置write(byte b[]) 写b.length个字节到文件writeDouble(double v)向文件写入一个双精度浮点值writeInt(int v)向文件写入一个int值writeUTF(String s)写入一个UTF字符串getFilePointer() 获取当前流在文件中的读写的位置 四、文件上传 用户通过一个JSP页面上传文件给服务器时，该JSP页面必须含有File类型的表单，并且表单必须将ENCTYPE的属性值设成multipart/form-data。1234&lt;form action=\"接受上传文件的页面\" method=\"post\" ENCTYPE=\"multipart/form-data\"&lt;Input type=\"File\" name=\"picture\" &gt;&lt;/form&gt; 实例 例六123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;%@ page contentType=\"text/html;charset=gb2312\" %&gt;&lt;%@ page import =\"java.io.*\" %&gt; &lt;jsp:useBean id=\"fileBean\" class=\"mybean.data.Example8_6_Bean\" scope=\"request\"/&gt;&lt;HTML&gt;&lt;body&gt; &lt;P&gt;选择要上传的文件：&lt;BR&gt; &lt;form action=\"upFile\" method=\"post\" ENCTYPE=\"multipart/form-data\"&gt; &lt;input type=FILE name=\"boy\" size=\"45\"&gt; &lt;br&gt; &lt;input type=\"submit\" name =\"boy\" value=\"提交\"&gt; &lt;/form&gt; &lt;br&gt; 上传的文件名字： &lt;jsp:getProperty name=\"fileBean\" property=\"fileName\"/&gt; &lt;br&gt; 上传反馈： &lt;jsp:getProperty name=\"fileBean\" property=\"mess\"/&gt; &lt;% String name=fileBean.getFileName(); boolean boo =name.endsWith(\".jpg\"); boo = boo||name.endsWith(\".gif\"); if(boo) &#123; %&gt; &lt;image src = \"image/&lt;%=name%&gt;\" width=200 height =200&gt;&lt;%=name %&gt;&lt;/image&gt; &lt;% &#125; else &#123; %&gt; &lt;%=name %&gt; &lt;% &#125; %&gt;&lt;/body&gt;&lt;/HTML&gt;package myservlet.control;import mybean.data.Example8_6_Bean;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class Example8_6_Servlet extends HttpServlet&#123; public void init(ServletConfig config) throws ServletException&#123; super.init(config); &#125; public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; request.setCharacterEncoding(\"gb2312\"); Example8_6_Bean fileBean=new Example8_6_Bean(); //创建Javabean对象 request.setAttribute(\"fileBean\",fileBean); String fileName=null; HttpSession session=request.getSession(true); try&#123; //用客户的session对象的Id建立一个临时文件 String tempFileName=(String)session.getId(); String webDir = request.getContextPath(); webDir = webDir.substring(1); File f= new File(\"\"); String path = f.getAbsolutePath(); int index = path.indexOf(\"bin\"); String tomcatDir = path.substring(0,index);//tomcat的安装目录 File dir=new File(tomcatDir+\"/webapps/\"+webDir+\"/image\"); dir.mkdir(); //建立临时文件f1 File f1=new File(dir,tempFileName); FileOutputStream o=new FileOutputStream(f1); //将客户上传的全部信息存入f1 InputStream in=request.getInputStream(); byte b[]=new byte[10000]; int n; while( (n=in.read(b))!=-1)&#123; o.write(b,0,n); &#125; o.close(); in.close(); //读取临时文件f1，从中获取上传文件的名字和上传文件的内容 RandomAccessFile randomRead=new RandomAccessFile(f1,\"r\"); //读出f1的第2行，析取出上传文件的名字 int second=1; String secondLine=null; while(second&lt;=2) &#123; secondLine=randomRead.readLine(); second++; &#125; //获取f1中第2行中\"filename\"之后“=”出现的位置: int position=secondLine.lastIndexOf(\"=\"); //客户上传的文件的名字是 fileName=secondLine.substring(position+2,secondLine.length()-1); randomRead.seek(0); //再定位到文件f1的开头 //获取第4行回车符号的位置 long forthEndPosition=0; int forth=1; while((n=randomRead.readByte())!=-1&amp;&amp;(forth&lt;=4))&#123; if(n=='\\n')&#123; forthEndPosition=randomRead.getFilePointer(); forth++; &#125; &#125; //根据客户上传文件的名字，将该文件存入磁盘 byte cc[]=fileName.getBytes(\"ISO-8859-1\"); fileName=new String(cc); File f2= new File(dir,fileName); RandomAccessFile randomWrite=new RandomAccessFile(f2,\"rw\"); //确定出文件f1中包含客户上传的文件的内容的最后位置，即倒数第6行 randomRead.seek(randomRead.length()); long endPosition=randomRead.getFilePointer(); long mark=endPosition; int j=1; while((mark&gt;=0)&amp;&amp;(j&lt;=6)) &#123; mark--; randomRead.seek(mark); n=randomRead.readByte(); if(n=='\\n')&#123; endPosition=randomRead.getFilePointer(); j++; &#125; &#125; //将randomRead流指向文件f1的第4行结束的位置 randomRead.seek(forthEndPosition); long startPoint=randomRead.getFilePointer(); //从f1读出客户上传的文件存入f2（读取第4行结束位置和倒数第6行之间的内容） while(startPoint&lt;endPosition-1)&#123; n=randomRead.readByte(); randomWrite.write(n); startPoint=randomRead.getFilePointer(); &#125; randomWrite.close(); randomRead.close(); fileBean.setMess(\"上传成功\"); fileBean.setFileName(fileName); f1.delete(); //删除临时文件 &#125; catch(Exception ee) &#123; fileBean.setMess(\"没有选择文件或上传失败\"); &#125; RequestDispatcher dispatcher= request.getRequestDispatcher(\"example8_6.jsp\"); dispatcher.forward(request, response); &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException&#123; doPost(request,response); &#125;&#125; 五、文件下载 JSP内置对象response调用方法getOutputStream()可以获取一个指向用户的输出流，服务器将文件写入这个流，用户就可以下载这个文件了。 当提供下载功能时，应当使用response对象向用户发送HTTP头信息，这样用户的浏览器就会调用相应的外部程序打开下载的文件，response调用setHeader方法添加下载头的格式如下：1response.setHeader(\"Content-disposition\",\"attachment;filename=\"下载文件名\"); 实例 例七 六、小结 输入流的指向称为源，程序从指向源的输入流中读取源中的数据。而输出流的指向是数据要去的目的地，程序通过向输出流中写入数据把信息送往目的地。 FileInputStream和FileReader流都顺序地读取文件，只要 不关闭流，每次调用read方法就顺序地读取源中其余的内容， 直到源的末尾或流被关闭 。 二者的区别是， FileInputStream 流以字节 （byte）为单位读取文件； FileReader流以字符 （char）为单位读取文件。 RandomAccessFile流的指向既可以作为源也可以作为目的地，在读写文件时可以调用seek方法改变读写位置。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"jsp-study-4","slug":"jsp-study-4","date":"2020-05-21T12:39:22.000Z","updated":"2020-09-03T13:36:14.662Z","comments":true,"path":"2020/05/21/jsp-study-4/","link":"","permalink":"http://nlbyd1119.online/2020/05/21/jsp-study-4/","excerpt":"MVC","text":"MVC MVC工作原理模型Model 用于存储数据的对象视图View 向控制器提交所需数据 以及显示模型中的数据控制器Controller 进行具体的业务逻辑操作 JSP+JavaBean+Servlet的MVC模式 JSP中使用数据库一、概述 DBMSDBMS是(Data Base Management System)的缩写，是管理数据库软件的集合。DBMS包含面向用户接口功能和面向系统维护功能。面向用户接口功能是提供用户访问数据库的一些必要手段。面向系统维护功能是为数据库管理者提供数据库的维护工具。通常通过两层结构来访问数据库，称之为Client/Server结构。 关系型数据库表是用两维关系来反映现实中的实体及它的属性。表的每一列都代表了实体的一项属性。每一列又叫表的一个字段。每一个字段都有一个字段名。每一个字段都只能包含同样数据类型的数据。每一个字段长度是有限的。表的每一行都代表实体的一个实例。 二、数据库系统-MySQL1.mysql2.jdbcJDBC（JavaDataBaseConnectivity）提供了访问数据库的API，即由一些Java类和接口组成，是Java运行平台的核心类库中的一部分。 123456789101112我们经常使用JDBC进行如下的操作：1. 与一个数据库建立连接。2. 向已连接的数据库发送SQL语句。3. 处理SQL语句返回的结果。JDBC-API中重要的接口和类(java.sql包中)DriverManager类 依据数据库的不同,管理JDBC驱动Connection接口 负责连接数据库,并担任传送数据的任务Statement接口 由Connection产生,负责执行SQL语句PreparedStatement接口 创建一个可以编译的SQL语句对象,该对象可以被多次执行,以提高执行的效率ResultSet接口 负责保存Statement执行后所产生的查询结果 JDBC工作原理3.连接MySQL数据库 加载驱动程序 建立连接123456789101112131415161718192021222324252627方式一try&#123; String uri= \"jdbc:mysql://192.168.100.1:3306/warehouse\"; String user =\"root\"; String password =\"99\"; con = DriverManager.getConnection(uri,user,password);&#125; catch(SQLExceptione)&#123;System.out.println(e);&#125;方式二try&#123; String uri= \" jdbc:mysql://192.168.100.1:3306/warehouse?user=root&amp;password=99\";con = DriverManager.getConnection(uri);&#125;catch(SQLExceptione)&#123;System.out.println(e);&#125;如果root用户没有设置密码，那么将上述uri中的&amp;password=99更改为：&amp;password= 方式三 指定字符集String uri = “jdbc:mysql://127.0.0.1/warehouse?”+\"user=root&amp;password=99&amp;characterEncoding=gb2312\";con=DriverManager.getConnection(uri); 4.实例 连接 查询数据 显示 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html;charset=gb2312\" %&gt;&lt;%@ page import=\"java.sql.*\" %&gt;&lt;HTML&gt;&lt;body bgcolor=#EEDDFF&gt; &lt;% Connection con; Statement sql; ResultSet rs; try&#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch(Exception e)&#123; out.println(\"忘记把MySQL数据库的JDBC-数据库驱动程序复制到JDK的扩展目录中\"); &#125; try &#123; String uri= \"jdbc:mysql://127.0.0.1/warehouse\"; String user=\"root\"; String password=\"\"; con=DriverManager.getConnection(uri,user,password); //也可以写成con=DriverManager.getConnection(uri+\"?user=root&amp;password=\"); sql=con.createStatement(); rs=sql.executeQuery(\"SELECT * FROM product \"); out.print(\"&lt;table border=2&gt;\"); out.print(\"&lt;tr&gt;\"); out.print(\"&lt;th width=100&gt;\"+\"产品号\"); out.print(\"&lt;th width=100&gt;\"+\"名称\"); out.print(\"&lt;th width=50&gt;\"+\"生产日期\"); out.print(\"&lt;th width=50&gt;\"+\"价格\"); out.print(\"&lt;/TR&gt;\"); while(rs.next())&#123; out.print(\"&lt;tr&gt;\"); out.print(\"&lt;td &gt;\"+rs.getString(1)+\"&lt;/td&gt;\"); out.print(\"&lt;td &gt;\"+rs.getString(2)+\"&lt;/td&gt;\"); out.print(\"&lt;td &gt;\"+rs.getDate(\"madeTime\")+\"&lt;/td&gt;\"); out.print(\"&lt;td &gt;\"+rs.getFloat(\"price\")+\"&lt;/td&gt;\"); out.print(\"&lt;/tr&gt;\") ; &#125; out.print(\"&lt;/table&gt;\"); con.close(); &#125; catch(SQLException e)&#123; out.print(e); &#125; %&gt;&lt;/body&gt;&lt;/HTML&gt; 5.查询记录（1）结果集与查询 让连接对象con调用方法createStatement()创建执行SQL语句的Statement对象：Statement sql=con.createStatement(); sql对象就可以调用相应的方法，实现对数据库中表的查询和修改，并将查询结果存放在一个ResultSet类声明的对象中：ResultSetrs=sql.executeQuery(“SELECT * FROMproduct”);12345678910111213141516返回类型 方法名称boolean next()byte getByte(int columnIndex) Date getDate(int columnIndex)double getDouble(int columnIndex) float getFloat(int columnIndex)int getInt(int columnIndex)long getLong(int columnIndex)String getString(int columnIndex)byte getByte(String columnName) Date getDate(String columnName)double getDouble(String columnName)float getFloat(String columnName)int getInt(String columnName)long getLong(String columnName)String getString(String columnName) 通过ResultSet接口中的getXxx()方法，可以取出数据，按类型取getInt、getString、getFloat…在开发中往往使用表格对数据显示进行处理(2) 结果集的列名与列的数目 获得元数据123456789程序查询的时候，希望知道数据库表的字段（列）的名字以及表的字段的个数，那么一个办法是使用返回到程序中的结果集来获取相关的信息。(1)得到元数据对象metaDataResultSetMetaDatametaData=rs.getMetaData();(2)得到结果集的列的个数，即共有几列int columnCount=metaData.getColumnCount();(3)结果集rs中的第i列的名字：String columnName= metaData.getColumnName(i); （3）随机查询123456789101112使用Result的next()方法顺序地查询数据，为了得到一个可滚动的结果集，必须使用下述方法先获得一个Statement对象：Statementstmt=con.createStatement(inttype,intconcurrency);然后，根据参数的type、concurrency的取值情况，stmt返回相应类型的结果集：ResultSetre=stmt.executeQuery(SQL语句)concurrency取值决定是否可以用结果集更新数据库ResultSet.CONCUR_READ_ONLY：不能用结果集更新数据库中的表。ResultSet.CONCUR_UPDATETABLE：能用结果集更新数据库中的表。 12345678910111213141516滚动查询经常用到ResultSet的下述方法：方法名 描述public booleanprevious() 将游标向上移动，当移到结果集第一行之前时返回falsepublic void beforeFirst() 将游标移动到结果集的初始位置，即在第一行之前public void afterLast() 将游标移到结果集最后一行之后public void first() 将游标移到结果集的第一行public void last() 将游标移到结果集的最后一行public booleanisAfterLast() 判断游标是否在最后一行之后public booleanisBeforeFirst() 判断游标是否在第一行之前public booleanisFirst() 判断游标是否指向结果集的第一行public booleanisLast() 判断游标是否指向结果集的最后一行public int getRow() 得到当前游标所指行的行号,行号从1开始，如果没有返回0public booleanabsolute(int row) 将游标移到参数row指定的行号。如果row取负值，就是倒数的行数 （4）条件查询（5）排序查询 4.更新、添加、删除记录5.用结果集操作数据库中的表6.预处理语句 7.6 表单上传更新javabean为什么那样写 是为了普适性7.事务 123456789事务是保证数据库中数据完整性与一致性的重要机制。事务处理步骤如下：1．连接对象使用setAutoCommit(boolean autoCommit)方法,将参数autoCommit取值为false来关闭自动提交模式：con.setAutoCommit(false);2．commit()方法con调用commit()方法就是让事务中的SQL语句全部生效。3．rollback()方法只要事务中任何一个SQL语句没有生效,就抛出SQLException异常。在处理SQLException异常时,必须让con调用rollback()方法。 8.数据库连接的常用方式ODBC","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"jsp-study-3","slug":"jsp-study-3","date":"2020-04-28T09:20:54.000Z","updated":"2020-05-29T00:24:10.496Z","comments":true,"path":"2020/04/28/jsp-study-3/","link":"","permalink":"http://nlbyd1119.online/2020/04/28/jsp-study-3/","excerpt":"Java Servlet基础","text":"Java Servlet基础 一、Servlet概述 Servlet程序具备以下的基本功能12345获取客户端HTML的FORM表单提交的数据和URL后面的参数信息创建和客户端的响应消息内容访问服务器端的文件系统连接数据库并开发基于数据库的应用调用其他JAVA类 Servlet的特点 二、Servlet工作原理 Servlet的工作原理 Servlet引擎访问Servlet Servlet的Service方法 Servlet生命周期1234创建Servlet实例调用init方法进行初始化设置调用service方法处理浏览器请求调用destroy方法销毁Servlet实例并释放占用资源 小结 三、Servlet的部署、创建与运行注意：这个地方教的是单独的servlet的处理 编写一个创建Servlet对象的类12编写javax.servlet.http包中的HttpServlet类的子类。将Tomcat子目录lib中的servlet-api.jar复制到Tomcat使用的JDK的扩展目录中，例如D:\\jdk1.7\\jre\\lib\\ext 保存编译这个类所得到的字节码文件12保存到：\\WEB-INF\\classes\\myservlet\\control编译源文件：class&gt;javacmyservlet\\control\\Servlet源文件 编写部署文件web.xml 运行Servlet匹配规则：同一个servlet指定多个不同的url，四种不同的url形式 向Servlet传递参数 四、通过JSP页面访问servlet注意：不可以写成“/xxx”否则将变成请求root服务目录下的servlet 通过表单向Servlet提交数据 通过超链接访问Servlet 五、共享变量 12Servlet类是HttpServlet的子类，可以声明成员变量Servlet类的成员变量是被所有线程共享的数据 六、doGet和doPost方法 123Servlet类中重写doPost()或doGet()方法来响应用户的请求如果不同请求类型进行相同的处理，可在doGet()中调用有处理过程的doPost()方法，反之一样如果不同请求类型进行不同的处理，需在两个方法中编写不同的处理过程 七、重定向与转发 请求转发123456得到RequestDispatcher对象Request Dispatcherdispatcher = request.getRequestDispatcher(\"a.jsp\");转发dispatcher.forward(request,response);RequestDispatcher.forward方法只能在同一个Web应用程序内的资源之间转发请求 重定向1234重定向response.sendRedirect(\"a.jsp\");sendRedirect方法还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源 JSP与Javabean一、概述与工作原理 概述感觉是service + dao + domain123JavaBean是一个可重复使用的软件组件是遵循一定标准、用Java语言编写的一个类一般实现网页中的业务逻辑或数据库操作 Javabean特点123可以实现代码的重复利用易编写、易维护、易使用跨平台 JavaBean工作原理 二、编写Javabean和使用Javabean 编写Javabean123456如果类的成员变量的名字是xxx，类中提供两个方法： getXxx() 用来获取属性xxx setXxx() 用来修改属性xxx对于boolean类型的成员变量，允许使用“isXxx”类中声明的方法的访问属性都必须是public的。类中声明的构造方法必须是public、无参数的。 Bean字节码的保存12345①在当前Web服务目录下建立如下目录结构： Web服务目录\\WEB-INF\\classes②根据类的包名，在目录classes下建立相应的子目录： Web服务目录\\WEB-INF\\classes\\tom\\jiafei③将Bean字节码保存在相应的子目录. 使用Javabean 注意bean名由id标识4. Bean的加载原理 123当JSP页面使用JSP需要使用一个bean时，JSP引擎将首先根据JSP动作标记给出的bean的id,以及scope，查找JSP引擎内置pageContent对象中是否含有这样的bean，如果这样的bean存在，JSP引擎就分配这样的bean给用户。如果在pageContent中没有查找到JSP动作标记要求的bean，就根据class指定的字节码创建一个JSP动作标记要求的bean，并将所创建的bean添加到pageContent内置对象中。 Bean的有效范围（生命周期）scope取值范围给出了bean的存活时间(生命周期)，即scope取值决定了JSP引擎分配给用户的bean的存活时间。12345678page有效范围是当前页面.不同用户的scope取值是page的bean也是互不相同的.requestbean的有效范围是request期间。不同用户的scope取值是request的bean也是互不相同的session有效范围是用户的session(会话)期间。不同用户(即不同浏览器)的scope取值是session的bean是互不相同的（占有不同的内存空间）applicationbean的有效范围是application期间。JSP引擎为Web服务目录下所有的JSP页面分配一个共享的bean，不同用户的scope取值是application的bean也都是相同的一个 三、获取和修改bean的属性 123可以使用动作标记getProperty、setProperty；必须保证bean有相应的getXxx和setXxx方法；在程序片中直接用bean调用方法就不需要方法命名遵守getXxx和setXxx规则 getProperty动作标记 setProperty动作标记使用setProperty动作标记可以设置bean的属性值。使用这个标记之前，必须使用useBean标记得到一个相应的bean。（1）将bean属性的值设置为一个表达式的值或字符串 id就是bean的名字（2）通过HTTP表单的参数的值来设置bean的相应属性的值 四、bean的辅助类","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"jsp-study-2","slug":"jsp-study-2","date":"2020-04-21T08:21:17.000Z","updated":"2020-05-29T00:24:04.327Z","comments":true,"path":"2020/04/21/jsp-study-2/","link":"","permalink":"http://nlbyd1119.online/2020/04/21/jsp-study-2/","excerpt":"第三章 JSP内置对象","text":"第三章 JSP内置对象 概述有些对象不用声明就可以在JSP页面的Java程序片和表达式部分使用，这就是JSP的内置对象。 12345678910 变量名 真实类型 作用* pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象* request HttpServletRequest 一次请求访问的多个资源(转发)* session HttpSession 一次会话的多个请求间* application ServletContext 所有用户间共享数据* response HttpServletResponse 响应对象* page Object 当前页面(Servlet)的对象 this* out JspWriter 输出对象，数据输出到页面上* config ServletConfig Servlet的配置对象* exception Throwable 异常对象 一、request 对象 HTTP通信协议是用户与服务器之间一种提交( 请求)信息与响应信息(request/response)的通信协议。 在JSP中，内置对象request封装了用户提交的信息，那么该对象调用相应的方法可以获取封装的信息，即使用该对象可以获取用户提交的信息。 1.获取用户提交的信息JSP页面可以让request对象使用getParameter(String s)方法获取表单提交的信息。2.处理中文字符编码使用两种方式避免request对象获取的信息出现乱码 12345678910111．对信息重新编码 request将获取的信息重新编码，即用ISO-8859-1进 行编码，并将编码存放到一个字节数组中，然后再将这 个数组转化为字符串。如下列所示： Stringstr=request.getParameter(\"message\"); byteb[]=str.getBytes(\"ISO-8859-1\"); str=newString(b);2．request设置编码 request在获取信息之前使用setCharacterEncoding 方法设置自己的编码为gb2312： request.setCharacterEncoding(\"gb2312\"); 3.常用方法 1234567getProtocol() 获取用户向服务器提交信息所使用的通信协议，比如http/1.1等。getServletPath() 获取用户请求的JSP页面文件的目录。getContextPath()获取用户请求的当前Web服务目录。getRemoteAddr() 获取用户的IP地址。getRemoteHost() 获取用户机的名称（如果获取不到，就获取IP地址）。getServerName() 获取服务器的名称。getServerPort() 获取服务器的端口号。 4.处理HTML标记5.处理超链接二、response 对象 当用户访问一个服务器的页面时，会提交一个HTTP请求，服务器收到请求时，返回HTTP响应。响应和请求类似，也有某种结构，每个响应都由状态行开始，可以包含几个头及可能的信息体（网页的结果输出部分）。 与request对象相对应的对象是response对象。可以用response对象对用户的请求作出动态响应，向用户端发送数据。比如，当一个用户请求访问一个JSP页面时，该页面用page指令设置页面的contentType属性的值是text/html，那么JSP引擎将按着这种属性值响应用户对页面的请求，将页面的静态部分返回给用户，用户浏览器接收到该响应就会使用HTML解释器解释执行所收到的信息。 1.动态响应contentType属性 12由于page指令只能为contentType指定一个值来决定响应的MIME类型，如果想动态的改变这个属性的值来响应用户，就需要使用response对象的setContentType(String s)方法来改变contentType的属性值，该方法中的参数s可取值：text/html、text/plain、image/gif等当用setContentType方法动态改变了contentType的属性值，即响应的MIME类型，JSP引擎就会按着新的MIME类型将JSP页面的输出结果返回给用户. 2.response的HTTP文件头 1响应也包括一些头。response对象可以使用方法addHeader(String head,Stringvalue);或setHeader(Stringhead,Stringvalue)动态添加新的响应头和头的值，将这些头发送给用户的浏览器。如果添加的头已经存在，则先前的头被覆盖。 3.response重定向 12某些情况下，当响应用户时，需要将用户重新引导至另一个页面。例如，如果用户输入的表单信息不完整，就会再被引导到该表单的输入页面。可以使用response的sendRedirect(URL url)方法实现用户的重定向。 4.response的状态行 12345678当服务器对用户请求进行响应时,它发送的首行称为状态行。1yy (１开头的３位数)：主要是实验性质的。2yy：用来表明请求成功的，例如，状态代码200可以表明已成功取得了请求的页面。3yy：用来表明在请求满足之前应采取进一步的行动。4yy：当浏览器做出无法满足的请求时，返回该状态代码，例如404表示请求的页面不存在5yy：用来表示服务器出现问题。例如，500说明服务器内部发生错误。一般不需要修改状态行，在出现问题时，服务器会自动响应，发送相应的状态码。我们也可以使用response对象的setStatus(int n)方法来改变响应的状态行的内容 三、session对象 HTTP协议是一种无状态协议。一个用户向服务器发出请求（request），然后服务器返回响应（response），在服务器端不保留连接的有关信息，因此当下一次连接时，服务器已没有以前的连接信息了，无法判断这一次连接和以前的连接是否属于同一用户。 当一个用户访问一个Web服务目录时，可能会在这个服务目录的几个页面反复连接、反复刷新一个页面或不断地向一个页面提交信息等，服务器应当通过某种办法知道这是同一个用户。 Tomcat服务器可以使用内置session对象（会话）记录有关连接的信息。 1.session对象的id 121.session对象被分配了一个String类型的id号，Tomcat服务器同时将这个id号发送到用户端，存放在用户的Cookie中。这样，session对象和用户之间就建立起一一对应的关系，即每个用户都对应着一个session对象（称作用户的会话），不同用户的session对象互不相同，具有不同的id号码。2.简单地说，用户在访问一个Web服务目录期间，服务器为该用户分配一个session对象（称作用户的会话），服务器可以在各个页面使用这个session记录当前用户的有关信息。而且服务器保证不同用户的session对象互不相同。 2.session对象与URL重写 123如果用户不支持Cookie，JSP页面可以通过URL重写来实现session对象的唯一性。所谓URL重写，就是当用户从一个页面重新连接到一个页面时，通过向这个新的URL添加参数，把session对象的id传带过去，这样就可以保障用户在该网站各个页面中的session对象是完全相同的。可以使用response对象调用encodeURL()或encodeRedirectURL（）方法实现URL重写。 3.session对象存储数据 123456session对象驻留在服务器端，该对象调用某些方法保存用户在访问某个web服务目录期间的有关数据。session对象使用下列方法处理数据：1.publicvoidsetAttribute(String key,Object obj)session对象可以调用该方法将参数Object指定的对象obj添加到session对象中，并为添加的对象指定了一个索引关键字。2.publicObjectgetAttribute(Stringkey)获取session对象索引关键字是key的对象。 4.session对象的生存期限 12session对象的生存期限依赖于session对象是否调用invalidate()方法使得session无效或session对象达到了设置的最长的“发呆”状态时间以及是否关闭服务器。如果关闭服务器，那么用户的session消失，所谓“发呆”状态时间是指用户对某个Web服务目录发出的两次请求之间的间隔时间（默认的发呆时间是30分钟）。 5.application对象application由服务器负责创建，每个Web服务目录下的application对象被访问该服务目录的所有的用户共享，但不同Web服务目录下的application互不相同。application 对象的常用方法 1234(1)publicvoidsetAttribute(String key,Object obj)application对象可以调用该方法将参数Object指定的对象obj添加到application对象中，并为添加的对象指定了一个索引关键字。(2)publicObjectAttribute(Stringkey)获取application对象含有的关键字是key的对象。 五、out 对象out对象是一个输出流，用来向用户端输出数据。在前面的许多例子里曾多次使用out对象进行数据的输出。out对象可调用如下的方法用于各种数据的输出： 123456out.print(char)， out.println(char) out.print(double)， out.println(double) out.print(fload)， out.println(float) out.print(long)， out.println(long) out.print(String)， out.println(String) out.newLine() , out.flush() 六、总结➢HTTP通信协议是用户与服务器之间一种提交（请求）信息与响应信息（request/response）的通信协议。在JSP中，内置对象request封装了用户提交的信息，request对象获取用户提交信息的最常用的方法是getParameter(String s)；内置对象response对象对用户的请求作出动态响应，向用户端发送数据。➢HTTP协议是一种无状态协议。一个用户向服务器发出请求（request），然后服务器返回响应（respons），但不记忆连接的有关信息。所以，Tomcat服务器必须使用内置session对象（会话）记录有关连接的信息。同一个用户在某个Web服务目录中的session是相同的；同一个用户在不同的Web服务目录中的session是互不相同的；不同用户的session是互不相同的。➢一个用户在某个Web服务目录的session对象的生存期限依赖于用户是否关闭浏览器、session对象是否调用invalidate()方法使得session无效或session对象是否达到了设置的最长的“发呆”状态时间。➢内置对象application由服务器负责创建，每个Web服务目录下的application对象被访问该服务目录的所有用户共享；不同Web服务目录下的application互不相同。七、问题解决 iso-8859-1与gb2312与utf8参考https://zhidao.baidu.com/question/26613602.htmlhttps://www.cnblogs.com/x_wukong/p/3675832.html可得结论：设置utf-8/ gbk2312为jsp charset且确定其request response字符集为utf-8/ gbk2312时，中文英文都不会有问题，意思就是在charset与必须手动设置的编码格式统一下，utf-8 gbk2312皆可正确处理所有字符，若没有手动设置，必须将传入的iso请求编码成iso，这关系就像gbk2312 utf-8可单向转成iso 而iso不能转成另两种处理，必须单独编码处理。 各种内置对象的生命周期","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"block_paper_2","slug":"block_paper_2","date":"2020-04-02T23:59:04.000Z","updated":"2020-05-29T00:23:35.968Z","comments":true,"path":"2020/04/03/block_paper_2/","link":"","permalink":"http://nlbyd1119.online/2020/04/03/block_paper_2/","excerpt":"1ps: 注意查 许可区块链 HyperledgerFabric：用于许可区块链的分布式操作系统","text":"1ps: 注意查 许可区块链 HyperledgerFabric：用于许可区块链的分布式操作系统 摘要Fabric是一个模块化和可扩展的开源系统，用于部署和操作许可区块链，是Linux基金会（www.hyperledger.org）托管的Hyperledger项目之一。Fabric是用于运行分布式应用程序的第一个真正可扩展的区块链系统。它支持模块化共识协议，该协议允许系统针对特定用例和信任模型进行定制。 Fabric也是第一个运行以标准通用编程语言编写的分布式应用程序的区块链系统，而无需依赖系统性的native加密货币。这与现有的区块链平台形成鲜明对比，现有的区块链平台要求以领域特定的语言或依赖加密货币来编写“智能合约”。 Fabric使用可移植的成员身份概念来实现许可模型，该成员身份可以与行业标准的身份管理集成在一起。为了支持这种灵活性，Fabric引入了一种全新的区块链设计，并改进了区块链应对非确定性，资源枯竭和性能攻击等问题的方式。本文介绍了Fabric的架构，各种设计决策的基本原理，其最突出的实现方面以及其分布式应用程序编程模型。我们通过实现和基准化受比特币启发的数字货币来进一步评估Fabric。我们证明，在某些流行的部署配置中，Fabric可以实现每秒3500多个端到端事务的吞吐量，而亚秒级的延迟可以很好地扩展到100多个节点。 1ps: peers 译为客户端即可 此处翻译成了对等方 对等端 为统一，先用notepad替换一下 但为了省事，译为节点 一、介绍区块链可以定义为用于记录交易的不可变分类账，并在相互不信任的节点组成的分布式网络中维护。每个节点都维护一个分类帐的副本。节点执行共识协议以验证交易，将交易分组为块，并在这些块上构建哈希链。该过程通过对交易进行排序（ordering the transactions）来形成分类帐，这是保持一致性所必需的。区块链随比特币一起出现，被广泛认为是在数字世界中运行可信交易所的技术。在公共或未经许可的区块链中，任何人都可以在没有特定身份的情况下参与。公共区块链通常涉及native加密货币，并使用基于“工作量证明”（PoW）和经济激励措施的共识。而许可区块链在一组已知的，已认证的参与者之间运行一个区块链。许可区块链提供了一种方法来保证一组具有共同目标但彼此之间并不完全信任的实体之间的交互的安全性，例如交易资金，商品或信息的企业。通过依靠peers的身份，许可区块链可以使用传统的拜占庭容错（BFT）共识。区块链可以以智能合约的形式执行任意的，可编程的交易逻辑，如以太坊那样。比特币中的脚本是该概念的前身。智能合约充当可信任的分布式应用程序，并从区块链和基本共识中获得peers间的安全性。这非常类似于使用状态机复制（SMR）构建弹性应用程序的著名方法。然而，区块链与传统的SMR不同，有着拜占庭式的缺陷，主要表现在：（1）不仅有一个，而是有许多分布式应用程序同时运行；（2）应用程序可能被动态部署或被任何人部署；（3）应用程序代码不可信，甚至可能是恶意的。这些差异需要新的设计。许多现有的智能合约区块链遵循SMR的蓝图，并实现所谓的主动复制：一个用于共识或原子广播的协议首先排序事务并将其传播到所有peers；其次，每个peer依次执行事务。我们称之为order execute（排序执行）架构；它要求所有peers执行每个事务，并且所有事务都是确定性的。顺序执行架构可以在几乎所有现有的区块链系统中找到，从以太坊（基于PoW的共识）等公共区块链系统到Tendermint、Chain和Quorum等每一个被授权区块链系统（基于BFT的共识）。虽然顺序执行设计在所有系统中并不明显，因为附加事务验证步骤可能会使其模糊，但它的局限性是固有的：每个peer执行每个事务，并且事务必须是确定的。先前的许可区块链受到许多限制，这些限制通常来自于它们的无许可的relatives或使用顺序执行体系结构。特别地： 12ps: order-execute architecture 应为排序执行(order-execute )架构，此处均错误翻译成订单执行架构，为统一，先用notepad替换一下 再把word里全部替换此处的执行事务即验证事务，验证交易 123456共识机制被硬编码到平台中，这与公认的理解是矛盾的，即应当没有“一刀切”的共识协议。交易验证的信任模型需要共识机制确认，并且不能适应智能合约的要求；智能合约必须以固定的，非标准的或特定领域的语言编写，这影响了其广泛的适用性并可能导致编程错误。所有peers顺序执行所有事务会限制性能，并且需要采取复杂的措施来防止源自不受信任合同的针对平台的服务dos攻击(denial-of-service attacks)（例如，以太坊中的gas机制）；事务必须是确定性的，这可能很难以编程方式确保；每个智能合约都在所有peers上运行，这与机密性不符，并且禁止将合约代码和状态散布给peers的子集。 在本文中，我们描述了Hyperledger Fabric或简称Fabric，它是克服了这些限制的开源区块链平台。Fabric是Linux Foundation主持下的Hyperledger项目之一。在不同的行业和用例中，Fabric用于400多个原型，概念验证以及生产分布式账本系统中。这些用例包括但不限于诸如分歧解决，贸易物流，外汇结算，食品安全，合同管理，钻石产地，奖励积分管理，低流动性证券交易和结算，身份管理以及通过数字结算的领域货币。 Fabric引入了一种新的区块链架构，旨在实现弹性，灵活性，可扩展性和保密性。Fabric被设计为模块化和可扩展的通用许可区块链，是第一个支持执行以标准编程语言编写的分布式应用程序的区块链系统，从而使它们可以在多个节点上一致地执行，给人一种在单一的全球分布的区块链计算机上执行的印象。这使得Fabric成为**许可区块链的第一个分布式操作系统**。 Fabric的体系结构遵循一种**新颖的execute-order-validate范式**，用于在不可信untrusted环境中分布式执行不可信代码。它将交易流程分为**三个步骤**，可以在系统中的不同实体上运行：（1）执行交易并检查其正确性，从而认可交易（对应于其他区块链中的“交易验证”）；（2）通过共识协议进行排序，而与交易语义无关；（3）根据特定应用程序的信任假设进行交易验证，这也防止了由于并发引起的竞争情况。此设计与顺序执行范式完全不同，Fabric通常会在达成最终一致的排序之前执行（验证）交易。它结合了两种众所周知的复制方法，即被动复制和主动复制，如下所示。 首先，Fabric使用被动或主备份复制[21,27]，这种复制在分布式数据库中很常见，但是具有基于中间件的不对称更新处理[40,41]，并被移植到具有拜占庭式错误的不受信任的环境中。在Fabric中，每个事务仅由peers的一个子集（即部分peers）执行，这允许并行执行并利用“执行-验证” BFT复制来解决潜在的不确定性[37]。灵活的背书策略指定了哪个或哪些peers需要保证已正确执行给定的智能合约。 其次，Fabric包含主动复制，因为在每个peer分别执行的确定性验证步骤中，交易对账本状态的影响只有在它们之间的总顺序达成共识后才会写入。这使Fabric可以根据交易背书遵守特定应用程序的信任假设。而且，将状态更新的顺序委托给用于共识（即原子广播）的模块化组件，该组件是无状态的，并且与**执行事务并维护分类帐的对等方在逻辑上是分离**的。由于共识是模块化的，因此可以根据特定部署的信任假设量身定制其实现。尽管也可以使用区块链对等体来实现共识，但两个角色的分离增加了灵活性，并允许人们依靠完善的工具包进行CFT（崩溃容错）或BFT排序。 总的来说，这种混合复制设计在拜占庭模型中混合了被动复制和主动复制，以及执行排序验证范式，代表了Fabric体系结构的主要创新。他们解决了前面提到的问题，并为Fabric可伸缩系统提供了支持``可靠信任''假设的受许可区块链。为实现此体系结构，Fabric为以下每个组件都包含模块化构件： 12345•排序服务自动向peers广播状态更新，并就交易顺序建立共识。•成员资格服务提供者负责将peer与加密身份相关联。它保持了Fabric的许可性质。•可选的peer-to-peer gossip服务通过向所有peers进行排序服务来分发区块输出。•Fabric中的智能合约在容器环境中运行以进行隔离。它们可以用标准编程语言编写，但不能直接访问分类账状态。•每个peer以仅追加区块链的形式本地维护分类账，并将其作为键值存储中最新状态的快照。 本文的其余部分描述了Fabric的体系结构以及我们的经验。第2节总结了现有技术，并解释了各种设计决策背后的原理。第3节详细介绍了Fabric的体系结构和执行排序验证方法，说明了事务执行流程。在第4节中，特别定义了Fabric的关键组件，包括排序服务，成员服务，点对点gossip，分类帐数据库和智能合约API。在第5节中给出了在商品公共云VM上的集群和WAN环境中部署的具有比特币启发式加密货币的Fabric性能评估中获得的结果和见解。它们显示，Fabric在流行的部署配置中实现了3500 tps以上的吞吐量，以几百毫秒的延迟实现了[nality] [57]，并且可以很好地扩展到100多个peers。在第6节中，我们讨论了Fabric的一些实际生产用例。最后，第7节讨论了相关工作。 **二、背景** **1. 区块链的顺序执行架构** 以前所有的区块链系统（无论是否许可）都遵循排序执行架构。这意味着区块链网络首先**使用共识协议对交易进行排序**，然后**在所有peers上按相同顺序执行（验证）它们**。 例如，基于PoW的无权限区块链如以太坊将结合共识和执行交易如下：（1）每个peer（即参与共识的节点）将一个包含有效事务的块组合在一起（为了确定有效性，该peer已经预先执行了这些事务）；（2）peer试图解决PoW难题；（3）如果其中有一个peer很幸运并且解决了难题，则它通过gossip协议将该块传播到网络；（4）收到该区块的每个peer均会验证难题的解决方案以及该区块中的所有交易。实际上(effectively)，每个peer都会从第一步开始重复解决了Pow的peer的执行（验证）过程。此外，所有peers都顺序执行事务（在一个块内和跨块）。排序执行架构如图1所示。 ![](/block_paper_2/20200404075739094.png) **2. 排序执行的局限性** 排序执行架构在概念上很简单，因此也被广泛使用。但是，当在通用的许可区块链中使用时，它有几个缺点。接下来我们讨论最重要的三个： **排序执行** 在所有peers上顺序执行交易会**限制区块链可以实现的有效吞吐量**。特别是，由于吞吐量与执行延迟成反比例，因此这可能成为除最简单的智能合约之外的所有智能合约的性能瓶颈。此外，回想一下，与传统的SMR相比，区块链形成了通用计算引擎，其**有效载荷应用程序可能会被对手部署**。denial-of-service（DoS）攻击会严重降低此类区块链的性能，可能只是引入智能合约就需要花费很长时间才能执行。例如，执行无限循环的智能合约具有致命错误，但由于无法解决停止问题而无法自动检测到。 为了解决这个问题，使用加密货币的公共可编程区块链会承担执行成本。例如，以太坊引入了交易执行所消耗的gas的概念，该概念将gas price转换为数字加密货币的成本，并记入交易提交者的账单中。 以太坊在支持这一概念方面做了很多工作，为每个级别的计算步骤分配了成本，引入了自己的虚拟机来控制执行。虽然这似乎是公共区块链的可行解决方案，但对于没有native加密货币的通用系统来说，这在许可模型中是不够的。 有关分布式系统的文献提出了许多方法来改进与顺序执行相比的性能，例如通过不相关操作的并行执行。不幸的是，这些技术仍有待于在智能合约的区块链环境中成功应用。例如，有一个挑战是，需要确定地推断智能合约的所有依赖项，这在与可能的一致性约束结合时尤其具有挑战性。此外，这些技术对于对抗来自不可信开发人员合约代码的DoS攻击毫无帮助。 **非确定性代码** 排序执行体系结构的另一个重要问题是不确定性事务。在active（主动）SMR中达成共识后执行的操作必须是确定性的，否则分布式账本会“分叉”并违反区块链的基本前提，即所有peers都处于同一状态。这通常可以通过使用领域特定语言对区块链进行编程来解决（例如，以太坊Solidity）足以表达其应用，但仅限于确定性执行。但是，此类语言很难为实现者设计，并且需要程序员进行其他学习。相反，用通用语言（例如Go，Java，C / C ++）**编写智能合约会吸引更多人，并加速采用区块链解决方案**。 不幸的是，**通用语言给确定性执行带来了许多问题**。即使应用程序开发人员没有明显引入不确定性的操作，隐藏的实现细节也可能具有相同的破坏性影响（例如，在Go中amap迭代器不是确定性的）。更糟糕的是，在区块链上，创建确定性应用程序的负担落在了潜在的不受信任的程序员身上。仅创建一个带有恶意意图的非确定性合同就足以使整个区块链陷入停顿。此外，还研究了区块链上过滤器分散操作的模块化解决方案，但在实践中成本高昂。 **执行的机密性** 根据public blockchain的蓝图，许多许可的系统在所有对等点上运行所有智能合约。但是，**许可的区块链的许多预期用例都需要保密**，即可以限制对智能合约逻辑，交易数据或分类帐状态的访问。尽管从数据加密到先进的零知识证明[18]和可验证计算[42]等加密技术可以帮助实现一致性，但这通常会带来相当大的开销，在实践中不可行。 幸运的是，它将相同状态传播给所有peers，而不是在任何地方运行相同的代码。因此，可以将智能合约的执行限制为该任务所信任的peers的子集（部分peers），该子集保证执行的结果。这种设计从主动复制转向被动复制的变体[21]，适应了区块链的信任模型。 **3. 现有架构的其他限制** **固定信任模型** 大多数获得许可的区块链都依赖于异步BFT复制协议来建立共识[57]。这样的协议通常基于一个安全假设，即在n > 3f个对等节点中，最多可以容忍f的不当行为并表现出所谓的拜占庭式错误[20]。同样的peers也经常在相同的安全性假设下执行应用程序（即使实际上可以将BFT执行限制为更少的peers）[59]。但是，无论peers在系统中的角色如何，这种量化的信任假设都可能与智能合约执行所需的信任不匹配。在灵活的系统中，**不应将应用程序级别的信任固定为协议级别的信任**。通用区块链应将这两个假设解耦，并允许应用程序具有灵活的信任模型。 **硬编码的共识** Fabric是引入**可插拔共识**的第一个区块链系统。在使用Fabric之前，几乎所有的区块链系统（无论是否为许可链）都带有硬编码的共识协议。但是，数十年来对共识协议的研究表明，**没有这样的“一刀切”的解决方案**。例如，当部署在潜在的对抗环境中时，**BFT协议的性能差异很大**[52]。具有“链式”通信模式的协议在具有对称和同质链接的LAN群集上表现出可证明的最佳吞吐量[34]，但在广域异构网络上性能严重下降。此外，在给定部署中，诸如负载，网络参数以及实际故障或攻击之类的外部条件可能会随时间而变化。由于这些原因，BFT共识**应该具有固有的可重构性，并且理想地动态地适应不断变化的环境**[17]。另一个重要的方面是将**协议的信任假设与给定的区块链部署方案**相匹配。确实，人们可能想用基于替代信任模型的协议（例如XFT [43]）或CFT协议（例如Paxos / Raft [45]和ZooKeeper [36]）甚至是无许可协议替换BFT共识。 **4. 排序执行区块链的经验** 在实现Fabric的执行排序验证架构之前，我们获得了在排序执行模型中使用PBFT [26]构建许可区块链平台的经验。也就是说，Fabric的**早期版本**（2016年9月发布的v0.6之前的版本）是按照“传统”排序执行架构进行架构的。 从许多概念证明应用中获得的反馈来看，这种方法的局限性立即变得很明显。例如，用户经常在不同的peers观察到不同的状态，并重新报告了共识协议中的错误。在所有情况下，仔细检查后发现，罪魁祸首是不确定的事务代码。其他原因涉及性能有限，例如“每秒仅进行一次事务处理”，用户承认其平均事务处理需要200毫秒才能执行。我们已经了解到，区块链系统的关键属性（即一致性，安全性和性能）一定不能取决于其用户的知识和信誉，尤其是因为区块链应该在不可信的环境中运行。 **三、架构** 在本节中，我们介绍三阶段（three-phase）的执行排序验证架构，然后说明事务流程。 **1. Fabric概述** Fabric是用于许可区块链的分布式操作系统，该操作系统执行以通用编程语言（例如Go，Java，Node.js）编写的分布式应用程序。它在只追加复制的分类账数据结构中安全地跟踪其执行历史，并且没有内置加密货币。 Fabric引入了执行排序验证区块链架构（如图2所示），并且不遵循标准的排序执行设计，原因在第2节中进行了解释。简而言之，Fabric的分布式应用程序由两部分组成： 12一种智能合约，称为chaincode，它是实现应用程序逻辑并在执行阶段运行的程序代码。链码是Fabric中分布式应用程序的中心部分，可能由不可信的开发人员编写。存在用于管理区块链系统和维护参数的特殊链代码，统称为系统链代码（第4.6节）。在验证阶段评估的背书策略。不可信的应用程序开发人员不能选择或修改背书策略。背书策略充当Fabric中用于交易验证的静态库，只能通过链码进行参数化。只有指定的管理员才可以通过系统管理功能修改背书策略。典型的背书策略允许链代码以背书所需的一组peers的形式指定交易的背书人（执行人，进行共识的部分节点）。它在集合上使用单调逻辑表达式，例如“五分之三”或“（A∧B）∨C”。自定义背书政策可以实施任意逻辑（例如，第5.1节中我们的比特币启发式加密货币）。 ![](/block_paper_2/20200404092429562.png) 客户将交易发送给背书策略指定的peers。然后，每个事务由特定的peers执行，并记录其输出；此步骤也称为**背书（执行，认证交易）**。执行后，交易进入排序阶段，该阶段使用**可插拔的共识协议**生成以区块为单位的认可交易的完全有序序列。在gossip（可选）的帮助下，将这些广播给所有peers。与标准的主动复制完全根据输入的事务进行排序不同，Fabric进行事务排序还要**结合状态依赖**，在执行阶段进行计算。然后，每个peer都会在验证阶段验证与背书策略有关的状态变化以及背书交易的执行一致性。所有peers都以相**同的顺序验证交易**，并且验证是确定性的。从这个意义上讲，Fabric在拜占庭模型中引入了一种新颖的**混合复制范式**，该模型将被动复制（**状态更新的共识前计算**）和主动复制（**执行结果和状态更改的共识后验证**）组合在一起。 Fabric区块链由形成网络的一组节点组成（请参见图3）。当Fabric经过许可时，网络中的所有节点都有一个身份，是模块化的成员资格服务提供程序（MSP）提供的（第4.1节）。Fabric网络中的节点扮演三个角色： + 客户端提交交易建议以供执行，帮助或安排执行阶段，最后广播交易以排序 + peers执行交易建议并验证交易。所有peers都维护区块链分类帐，这是一个仅追加的数据结构，以一条hash链的形式记录所有交易，以及状态（最新分类帐状态的简洁表示）。**并非所有的peers都执行所有交易。根据交易所属链代码的策略（背书策略），只有提案中的一个子集称为背书peers（或简称为背书人）。** + 排序服务节点（OSN）（或简称为排序者）是共同构成排序服务的节点。简而言之，排序服务会在Fabric中建立所有交易的有序序列，其中每个交易都包含状态更新和在执行阶段计算的依赖关系以及背书peers的加密签名。**排序者完全不了解应用程序状态，并且不参与执行或交易验证中**。这种设计选择使Fabric中的共识尽可能地**模块化**，并简化了Fabric中共识协议的替换。 Fabric网络实际上支持连接到同一排序服务的多个区块链。每个这样的区块链都称为一个通道，并且可能有不同的peers作为其成员。可以使用Channel来划分区块链网络的状态，但是不协调跨通道的共识，并且每个通道中的总交易顺序是相互独立的。将所有排序者都视为受信任的某些部署也可以实现peers的按通道访问控制。在下文中，我们仅提及Channel，仅关注一个Channel。在接下来的三个部分中，我们将解释Fabric中的事务流程（如图4所示）并说明执行，排序和验证阶段的步骤。然后，我们总结了Fabric的信任和故障模型（第3.5节）。2. 执行阶段在执行阶段，客户端签名并将交易提议（或简称为提议）发送给一个或多个背书人(ps:部分peers)以执行。回想一下，每个链码都通过背书策略隐式指定了一组背书人。提议包含提交客户端的身份（根据MSP），执行操作形式的事务有效负载，参数以及链码的标识符，每个客户端只能使用一次的随机数（例如计数器）（或随机值），以及从客户标识符和随机数派生的交易标识符。背书人通过在已安装在区块链上的指定链码上执行操作来模拟提案proposal。链码在Docker容器中运行，与主背书进程隔离。针对背书人的本地区块链state模拟了提案proposal，而无需与其他peers进行同步。此外，背书人不会将模拟结果保留到分类账状态ledger state。区块链的状态由peer事务管理器（PTM）以版本化键值存储的形式维护，其中键的连续更新具有单调递增的版本号（4.4）。由一个链码创建的状态仅适用于该链码，并且不能被另一个链码直接访问。请注意，链码不应该维护程序代码中的本地状态，而只能维护通过GetState，PutState和DelState操作访问的区块链状态中维护的内容。给定适当的权限，链码可以调用另一个链码以在同一通道内访问其状态。作为模拟的结果，每个背书者都会产生一个值写入集，该值写入集由模拟产生的状态更新（即修改后的键及其新值）以及一个代表提案模拟的版本依赖性的读取集（即在模拟过程中读取的所有键及其版本号）。模拟之后，背书者加密签名一条称为背书endorsement的消息，其中包含readset和writeset（以及元数据，例如交易ID，背书者ID和背书者签名），并在提案响应中将其发送回客户端。客户收集背书endorsements，直到满足交易所调用的链码的背书策略（即要收集到所有背书人返回的endorsement消息）。特别地，这要求由策略确定的所有背书者都产生相同的执行结果（即相同的读集和写集）。然后，客户继续创建交易并将其传递给排序服务。讨论设计选择当背书人在不与其他背书人同步的情况下模拟提案时，两个背书人可能会在分类账的不同状态下执行该提案，并产生不同的输出。对于要求多个背书人产生相同结果的标准背书策略，这意味着在访问相同键的操作竞争激烈的情况下，客户端可能无法满足背书策略。这是一个与通过中间件（客户端？？）进行同步的复制数据库中的主备份复制相比的新考虑因素：假设在区块链中没有一个peer可被信任以正确执行。我们有意识地采用了这种设计，因为它极大地简化了架构，并且足以满足典型的区块链应用。正如比特币的方法所证明的那样，分布式应用程序可以制定为在正常情况下减少或完全消除访问同一状态的操作的争用（例如，在比特币中，不允许两个修改相同“对象”的操作，如双重支出攻击[44]）。将来，我们计划逐步增强争用contention中的Fabric的活动性语义，尤其是为了支持CRDT [51]以补充当前版本的依赖项检查，以及将用作交易定序器的按链代码的主签注者。在排序阶段之前执行事务对于tolerating非确定性链码至关重要（ps:个人理解是，在非确定性情形出现时，fabric可以很好处理，因而说可以“容忍”这种情况）。具有不确定事务的Fabric中的链码只会危及其自身操作的活跃性，客户可能因此而无法收集足够数量的背书。与排序执行架构相比，这是一个根本优势，在排序执行架构中，不确定性操作会导致peers状态不一致。（ps：理解就是，fabric架构中，不一致就会不满足背书策略，就不会排序，相比无法保证事务确定性的排序执行架构，这点是优势）最终，容忍非确定性执行还解决了来自不受信任链码的DoS攻击，因为背书人可以怀疑是否有DoS攻击，可以根据本地策略简单地中止执行。这不会危及系统的一致性，而且，在单执行结构中不可能单方面中止执行(ps:个人理解，是一点终止，全部终止，所以保持一致吗）。3. 排序阶段当客户端在提案中收集到足够的背书时，它会组装交易并将其提交给排序服务。该交易包含交易有效负载（即包含参数的链式代码操作），交易元数据和一组背书。排序阶段会针对每个渠道的所有已提交交易建立总体的有序序列。而即便排序者有问题时，排序仍然以原子方式广播背书endorsements，从而建立了交易共识。此外，排序服务将多个事务批处理为多个块，并输出包含事务的块的哈希链序列。将事务分组或成批处理可以提高广播协议的吞吐量，这是一种用于容错广播的众所周知的技术。在较高的层次上，排序服务的接口仅支持以下两个操作，这些操作由peer调用并由通道标识符隐式参数化： broadcast（tx）：客户端调用此操作以广播任意交易tx，该交易通常包含事务处理有效负载和客户端签名以进行分发 B←deliver(s)：客户端调用它以获取非负序号s的对应区块blockB。该块包含交易清单[tx1,…,txk]和序列中其前一区块的哈希。由于客户端可能会多次调用并且总是返回相同的块（如果有），我们假设peer在调用deliver（s）时第一次接收到blockB时，其序列号为s。 根据论文的上下文，上面两条中的客户端client都是指peer，要严格和fabric架构中的client节点区分排序服务可确保一个通道上已交付的区块全部被排序。更具体地说，排序可确保每个通道具有以下安全性能： 一致性：对于在正确的peers处以序列号s和s’分别获取分发的两个区块B和B’，使得s = s’，则可确定B = B’。 哈希链完整性：如果某个正确peer递送序号为ｓ的区块blockB，而另一个正确peer递送序号为s+1的区块blockB’=（[tx1，。。。txk]，h’），则必定有h’= H（B），其中H（·）表示密码哈希函数。 No skipping：如果正确peer递送序号为s &gt; 0的区块，则对i = 0，。。。，s -1，peer均已递送了编号为i的区块。 No creation：当正确peer交付了具有编号的blockB时，则对于每个tx∈B，某些client已经广播了tx。对于活动性，排序服务至少支持以下“最终”属性： 有效性：如果正确的client(peer)调用了广播（tx），那么每个正确的peer最终都会递送一个包含tx的BlockB，并带有序列号。 然而，每个单独的排序实现都允许在客户机client请求方面有自己的活跃性和公平性保证由于区块链网络中可能存在大量对等点peers，但是预计只有相对较少的节点才能实现排序服务，因此可以将Fabric配置为使用内置的gossip服务，以排序服务中的交付区块传播给所有peers（第4.3节）。gossip的实现可扩展且与排序服务的特定实现无关，因此它可与CFT和BFT排序服务一起使用，从而确保Fabric的模块化。排序服务还可以执行访问控制检查，以查看是否允许客户端client在给定频道上广播消息或接收块。排序服务的此功能和其他功能将在第4.2节中进一步说明。 讨论设计选择排序服务不维护区块链的任何状态，并且既不验证也不执行交易，这一点非常重要。这种架构是Fabric至关重要的定义功能，并使Fabric成为首个可将共识与执行和验证完全分开的区块链系统。这使共识尽可能地模块化，并实现了实施排序服务的共识协议生态系统。散列链完整性属性和块链接的存在仅是为了使peers对块序列的完整性验证更加有效。最后，请注意，我们不需要排序服务来防止交易重复。这简化了其实现，因此无需担心，因为在验证期间，peers会在重复的读写检查中过滤重复的事务。4. 验证阶段区块由排序服务节点（OSN)直接或通过gossip传递给peers。然后，一个新块进入验证阶段，该阶段包括三个连续步骤：（1）对该块内的所有事务并行执行背书策略评估。评估是所谓的验证系统链码（VSCC）的任务，该系统是区块链配置的一部分，是一个静态库，负责验证针对链码配置策略的签注（请参阅第4.6节）。如果不满足背书，则该交易被标记为无效，并且其影响不予理会。（2）顺序对块中的所有事务进行读写冲突检查。对于每笔交易，它会将读取集字段中的键版本与分类账的当前状态中的键版本（由peers本地存储）进行比较，并确保它们仍然相同。如果版本不匹配，则交易被标记为无效，并且其影响被忽略。（3）分类账更新阶段最后运行，在该阶段，将区块追加到本地存储的分类账中，并更新区块链状态。特别是，在将块添加到分类帐中时，前两个步骤中的有效性检查结果也以位掩码的形式保留，表示块中有效的交易。这有利于以后的状态重建。此外，通过将writeset中的所有键值对写入本地状态来应用所有状态更新。讨论设计选择Fabric的分类帐包含所有事务，包括那些被视为无效的事务。这是从总体设计得出的，因为与链码状态无关的排序服务会生成块链，并且验证是由peers共识后完成的。在某些需要在后续审核期间跟踪无效交易的用例中需要此功能，并且与其他区块链（例如，比特币和以太坊）相反，在其他区块链中，分类账仅包含有效交易。此外，由于Fabric的允许性质，检测通过试图用无效事务填充网络来尝试发起DoS攻击的客户端很容易。一种方法是根据可以实施的政策将此类客户列入黑名单。此外，特定的部署可能会收取交易费用（使用我们的5.1节中的货币实现或其他方法）以收取交易调用费用，这将使DoS攻击的成本过高。5. 信任与故障模型Fabric可以适应灵活的信任和错误假设。通常，任何客户端都可能被认为是恶意的或拜占庭式的。peers可以划分到不同组织，每个组织形成一个可信域。这样一个peer将信任其组织内的所有peers，但不信任另一个组织的peers。排序服务将所有peers（和客户端）视为潜在的拜占庭式。Fabric网络的完整性取决于排序服务的一致性。排序服务的信任模型直接取决于其实现（ps:具体使用的共识协议）（请参见第3.3节）。从v1.0.6版本开始，Fabric支持在开发和测试中使用的集中式单节点实施，以及在集群上运行的CFT排序服务。第三种实现是基于BFT-SMaRt的概念证明[19]，最多可容纳三分之一的拜占庭OSN [53]。请注意，Fabric将应用程序的信任模型与共识的信任模型解耦。即分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传达，并且独立于由排序服务实施的共识假设（另请参见第3.4节）。 四、Fabric组件Fabric是用Go编写的，它使用gRPC框架在clients、peers和orders之间进行通信。下面我们将更详细地描述一些重要的组件。图5显示了peer的组件。1. 成员服务成员资格服务提供程序（MSP）维护系统中所有节点（客户端，peers和OSN）的身份，并负责发布用于身份验证和授权的节点凭据。由于Fabric区块链为许可链，因此节点之间的所有交互都是通过经过身份验证的消息进行的，通常使用数字签名。成员资格服务在每个节点上都包含一个组件，该组件可以在其中验证交易，验证交易的完整性，签署和验证背书以及增强其他区块链操作。MSP还包含用于密钥管理和节点注册的工具。MSP是一个抽象定义，可以使用不同的实例。Fabric中的默认MSP实现基于数字签名的标准PKI方法进行身份验证，并且可以适应商业证书颁发机构（CA certification authorities）.Fabric还提供了一个独立的CA，称为Fabric-CA。此外，还设想了替代的MSP实现，例如依靠匿名凭证授权客户端调用交易而不将其链接到身份的交易。Fabric允许两种模式来建立区块链网络。在离线模式下，凭据由CA生成并分发到所有节点。peers和osn只能在离线模式下注册。对于注册clients，Fabric-CA提供了一种在线模式，向其颁发加密凭据。 MSP配置必须确保所有节点（尤其是所有对等peers）都使用相同的有效的身份和身份验证。例如，当多个组织运营区块链网络时，MSP允许身份联合。每个组织都向其自己的成员发出身份，每个peer都认可所有组织的成员。这可以通过多个MSP实例来实现，通过在每个组织和MSP之间创建映射。2. 排序服务排序服务管理多个channel。在每个channel上，它提供以下服务： 原子广播，用于建立交易顺序，实现广播和传递调用。 当channel的成员通过广播配置更新事务来修改channel时，对channel进行重新配置 可选地，在排序服务充当受信任实体的那些配置中，访问控制将交易的广播和块的接收限制为指定的clients和peers。排序服务由系统channel上的创世区块引导。此块包含一个配置事务，该事务定义了排序服务的功能。当前的作业实现由排序服务节点（OSN）组成，这些节点实施本文所述的操作并通过系统channel进行通信。实际的原子广播功能由Apache Kafka的一个实例提供，该实例基于ZooKeeper可以提供可伸缩的发布-订阅消息传递，并且即使节点崩溃也具有强一致性。Kafka可以在与OSN分离的物理节点上运行。OSN充当peers和Kafka之间的代理。OSN直接将新接收的事务注入原子广播（例如，注入Kafka代理）。OSNs批处理从原子广播接收的事务及形成的区块。一旦满足以下三个条件之一，便会切断该块：（1）该块包含指定的最大交易数；（2）块已达到最大大小（以字节为单位）；或（3）自收到新区块的第一笔交易起已经经过了一段时间，如下所述。1ps: 理解，就是 client把交易发过来，先用kafka打包区块，实现原子广播，再到osn进行处理 此批处理过程是确定性的，因此会在所有节点上产生相同的块。很容易看出，考虑到原子广播接收到的交易流，前两个条件是确定性的。为了确保在第三种情况下确定性的块产生，当节点从原子广播中读取块中的第一个事务时，它将启动计时器。如果在计时器到期时仍未切割该块，则OSN在该channel上广播特殊的切割时间事务，该操作指示它打算切割的块的优先级编号。另一方面，每个OSN在收到给定块编号号的第一个切割时间事务后立即切出新块。由于此事务是原子传递给所有连接的OSN，因此它们都在区块中包含相同的交易清单。OSN将一系列最新交付的区块直接保留到其系统中，因此它们可以通过传递使peers可以获取区块。 基于Kafka的排序服务是当前可用的三种实现之一。称为Solo的集中式订购器在一个节点上运行，并用于开发。基于BFT-SMaRt [19]的概念验证订购服务也已可用[53]；它可以确保原子广播服务，但尚未重新配置和访问控制。这说明了Fabric中共识的模块化。3. Peer Gossip将执行，排序和验证阶段分离的一个优势是，它们可以独立变化规模。但是，由于大多数共识算法（在CFT和BFT模型中）都是受带宽限制的，因此排序服务的吞吐量受到其节点网络容量的限制。无法通过增加更多的节点来扩大共识[28,57]，相反，吞吐量将降低。但是，由于排序和验证是分离的，因此我们对将执行结果有效地广播到所有peers以进行验证很有兴趣。这点，与向新加入的peers和长时间断开连接的peers的状态转移恰恰是gossip组件的目标。Fabric gossip为此目的利用了流行性多播epidemic multicas[29]。块由排序服务签名。这意味着peers可以在接收所有块后独立组装区块链并验证其完整性。gossip通信层基于gRPC，并使用具有相互认证的TLS，这使得双方可以将TLS凭证绑定到远程peers的身份。gossip组件维护系统中在线peers的最新成员视图。所有peers均会根据定期分发的成员身份数据独立构建本地视图。此外，崩溃或网络中断后，peer可以重新连接到视图。Fabric gossip分两个阶段进行信息分发：在push过程中，每个peer从成员资格视图中选择一组随机的活动邻居，并转发消息给它们。在pull期间，每个peer会定期探测一组随机选择的对peers，并请求丢失消息。已经显示[29,38]，同时使用这两种方法对于最佳利用可用带宽并确保所有peers以高概率接收所有消息至关重要。为了减轻从排序节点向网络发送数据块的负担，该协议还选择了一个leader peer，代表它们从排序服务中提取区块并发起gossip分发。4. 分类帐每个peer的分类帐组件在持久性存储上维护分类帐和状态，并启用模拟simulation, 验证validation和分类帐更新ledger-update阶段。大致来说，它由一个区块存储和一个peer事务管理器组成。 分类账块存储区ledger block store保留事务区块，并实现为一组仅追加文件。由于块是不可变的并以确定的顺序到达的，仅追加结构可提供最佳性能。另外，块存储区维护一些索引，用于随机访问块或块中的事务。 peer事务管理器（PTM）在版本化的键值存储中维护最新状态。它为任何链码存储的每个唯一入口键存储一个形式为（key，val，ver）的元组，其中包含其最近存储的值val和最新版本的ver。版本由块序号和块内事务（存储条目）的序列号组成。PTM使用本地键值存储来实现其版本化的变体，并使用LevelDB（在Go中）[10]和ApacheCouchDB [1]来实现。 在模拟simulation过程中，PTM为事务提供最新状态的稳定快照。如第3.2节所述，PTM在GetState访问的每个条目的readset中记录一个元组（key，ver），而在该交易中用PutState更新的每个条目的writeset中记录一个tuple（key，val）。此外，PTM支持范围查询，为此它计算查询结果的加密哈希（一组元组（key，版本）），并将查询字符串本身和哈希添加到readset中。为了进行交易验证（第3.4节），PTM依次验证一个区块中的所有交易。这将检查事务是否与任何先前的事务冲突（在块内或更早的时间内）。对于readset中的任何键，如果readset中记录的版本与最新状态下存在的版本不同（假定已提交所有先前的有效事务），则PTM将该事务标记为无效。对于范围查询，PTM将重新执行查询并将哈希与readset中存在的哈希进行比较，以确保不发生幻像读取。这种读写冲突语义促成了单拷贝可序列化性[39]。分类账组件在分类账更新期间容忍peers崩溃，如下所示。收到新块后，PTM已经使用第3.4节中提到的位掩码在块内执行了验证并将事务标记为有效或无效事务。现在，分类账将块写入分类账块存储，将其刷新到磁盘，然后更新块存储索引。然后，PTM将所有有效交易的写入集的状态更改应用于本地版本存储。最后，它计算并保留一个值保存点，该值表示成功应用的最大块数。从崩溃中恢复时，值保存点用于从持久块中恢复索引和最新状态。5. 链码执行Chaincode在与peer松耦合的环境中执行，该环境支持用于添加新链码编程语言的插件。当前支持Go，Java和Node。每个use-level或应用程序链码都在Docker容器环境中的单独进程中运行，该进程将链码彼此隔离，并与peers隔离。这也简化了链码生命周期的管理（即启动，停止或中止链码）。链码和peers使用gRPC消息进行通信。通过这种松散的耦合，peers不了解链码所使用的实际语言。与应用程序链码相反，系统代码在peer进程中直接运行。系统链码可以实现Fabric所需的特定功能，并且可以用于用户链码之间的隔离过于严格的情况。下一节将提供有关系统链码的更多详细信息。6. 配置和系统链码Fabric可以通过channel配置和特殊的链码（称为系统链码）来定制。Fabric中的每个channel都形成一个逻辑区块链。通道的配置在元数据持久的特殊配置块中维护。每个配置块都包含完整的通道配置，并且不包含任何其他事务。每个区块链都以配置块（称为创世块）开头，用于引导通道。通道配置包括：（1）定义参与节点的MSP，（2）OSN的网络地址，（3）共享配置，用于共识实现和排序服务，例如批处理大小和超时；（4）控制访问排序服务操作（广播和传递）的规则，以及（5）控制如何修改通道配置的每个部分的规则。可以使用通道配置更新事务来更新信道的配置。此事务包含对要进行的配置更改的重新表示，以及一组签名。排序服务节点通过使用当前配置来评估更新是否有效，以验证使用签名对修改进行了授权。然后排序者生成一个新的配置块，其中嵌入了新的配置和配置更新事务。接收此块的peers验证是否根据当前配置对配置更新进行了授权；如果有效，他们会更新其当前配置。部署应用程序链码时要参考背书系统链码（ESCC）和验证系统链码（VSCC）。选择这两个链码，以便可以验证ESCC的输出（背书）作为VSCC输入的一部分。ESCC将提案和提案模拟结果作为输入。如果结果令人满意，则ESCC会做出回应，其中包含结果和认可。对于默认的ESCC，这种认可只是peers的本地签名身份的签名。VSCC将交易作为输入并输出该交易是否有效。对于默认的VSCC，将根据针对链码指定的背书策略收集并评估认可。进一步的系统链码实现了其他支持功能，例如链码生命周期。五、评估即使尚未对Fabric进行性能调整和优化，我们还是在本节中报告一些初步的性能数据。Fabric是一个复杂的分布式系统。它的性能取决于许多参数，包括对分布式应用程序的选择和交易规模，排序服务和共识实现及其参数，网络中节点的网络参数和拓扑，节点运行的硬件，节点和通道的数量，其他配置参数以及网络动态。因此，对Fabric的深入性能评估在以后的工作中进行。在没有针对区块链的标准基准的情况下，我们使用最杰出的区块链应用程序来评估Fabric，这是一种使用比特币数据模型的权威授权的加密货币，我们将其称为Fabric coin（以下简称Fabcoin）。在其他许可区块链的背景下，Fabric的性能通常来自比特币或以太坊。例如，它也是应用程序使用其他许可区块链的基准[35，50]。在下文中，我们首先介绍Fabcoin（第5.1节），它还演示了如何自定义验证阶段和背书策略。在5.2节中，我们介绍基准并讨论我们的结果。1. Fabric Coin (Fabcoin)UTXO加密货币比特币引入的数据模型已被称为“未使用的交易输出”或UTXO，并且还被许多其他加密货币和分布式应用程序使用。UTXO将数据对象演化的每个步骤表示为分类账上的单独原子状态。这种状态是通过事务创建的，并被稍后发生的另一个唯一事务破坏（或“消耗”）。每个给定的事务都会破坏许多输入状态，并创建一个或多个输出状态。Bitcoin中的coin最初是通过奖励该区块“矿工”的coinbase交易创建的。这在分类账上显示为coin状态，将矿工指定为所有者。可以用任何coin消费的意义，即通过一种交易将硬币分配给新的所有者，该交易会从原子上破坏指定前一个所有者的当前coin状态并创建代表新所有者的另一个coin状态。我们在Fabric的键值存储中捕获UTXO模型。每个UTXO状态都对应于一个唯一的KVS条目，该条目创建一次（coin状态为“unspent”）并销毁一次（coin状态为“spent”）。同样，创建后，每个状态都可以视为逻辑版本为0的KVS条目；当它再次被销毁时，它会收到版本1。不应对此类条目进行任何并发更新（例如，尝试以不同的方式更新coin状态等同于将coin花费两次）。UTXO模型中的值是通过事务转移的，这些事务引用了多个输入状态，这些状态都属于发出事务的实体。实体拥有一个状态，因为该实体的公钥包含在状态本身中。每笔交易都会在KVS中创建一个或多个代表新所有者的输出状态，删除KVS中的输入状态，并确保输入状态中的值之和等于输出状态值之和。还有一个策略决定如何创造value（例如，比特币中的币库交易或其他系统中的特定造币厂交易）或销毁value的方式。Fabcoin实现Fabcoin中的每个状态都是一个形式为（key，val）=（txid.j，（amount，owner，label））的元组，表示作为标识为txid并分配金额单位的交易的第j个输出创建的币态带有标签的实体公钥是所有者。标签是用于识别coin的给定类型的字符串（例如，“ USD”，“ EUR”，“ FBC”）。事务标识符是短值，可唯一标识每个Fabric事务。Fabcoin实现包括三个部分：（1）客户钱包，（2）Fabcoin链码，（3）用于Fabcoin实施其认可策略的自定义VSCC。（1）Client钱包默认情况下，每个Fabric客户端维护一个Fabcoin钱包，该Fabcoin钱包在本地存储一组允许客户花费coin的加密密钥。为了创建转移一个或多个coin的支出交易，客户钱包会创建一个Fabcoin请求request = (inputs, outputs, sigs)，包含：（1）投入coin状态列表，inputs = [in…]指定客户希望花费的coin状态，以及（2）输出coin状态的列表，outputs = [(amount, owner, label),…]，客户端钱包使用的签名是由输入coin状态相对应的私钥，Fabcoin请求和nonce随机数（每笔Fabric交易的一部分）串联而成，将该签名添加到一组sig中。当输入coin状态中的金额之和至少等于输出中金额的总和且输出金额为正时，交易有效。对于创建新coin的铸币交易，输入仅包含称为中央银行Central Bank（CB）的特殊实体的标识符（即对公共密钥的引用），而输出包含任意数量的coin状态。挖矿交易签名必须是在Fabcoin请求和上述随机数串联后在CB公钥下的加密签名。可以将Fabcoin配置为使用多个CB或从一组CB中指定阈值签名数。最后，客户端钱包将Fabcoin请求包含在交易中，并将其发送到其选择的peers。Fabcoin链码一个peer运行Fabcoin的链码，以模拟交易并创建读取集和写入集。简而言之，在一笔支出交易的情况下，对于coin state输入集合inputs中的一个输入in，链码先执行GetState（in）获取readset及其当前版本。然后，链码将为每个输入状态执行DelState（in），还将添加到写入集中并地将coin状态标记为“已用”。最后，forj = 1，…，|| outputs ||，链码以输出的第j个outputout =(amount, owner, label)执行executePutState（txid.j，out）。另外，peers可以按照下面在Fabcoin的VSCC步骤中所述运行交易验证代码；这不是必需的，因为Fabcoin VSCC实际上可以验证交易，但是它允许（正确的）peers过滤出潜在的格式错误的交易。在我们的实现中，链码无需加密验证签名即可运行Fabcoin VSCC（仅在实际VSCC中进行了验证）(???)。定制VSCC最后，每个peer都使用自定义VSCC验证Fabcoin交易。这将在相应的一个或多个公共密钥下验证sigs中的一个或多个密码签名，并按以下方式执行语义验证。对于铸币交易，它将检查是否在匹配的交易标识符（txid）下创建了输出状态，并且所有输出金额均为正。对于一次花销交易，VSCC会额外验证（1）对于所有输入币态，已经在readset中创建了一个条目，并且该条目也已添加到writeset中并标记为已删除，（2）所有输入coin状态的数量等于所有输出coin状态的数量之和，并且（3）输入和输出coin标签匹配。在这里，VSCC通过从分类账中检索输入的coin数量来获得输入的coin数量。请注意，Fabcoin VSCC不会检查交易是否存在双重支出，因为这是通过Fabric的标准验证完成的，该验证在自定义VSCC之后运行。特别是，如果两个事务试图将相同的未使用coin状态分配给新所有者，则两个事务都将通过VSCC逻辑，但随后将被PTM执行的读写冲突检查所捕获。根据第3.4节和第4.4节，PTM验证存储在分类帐中的当前版本号与读取集中的版本号匹配；因此，在第一笔交易更改coin状态的版本后，第二笔交易将被视为无效。2. 实验设定除非有不同的明确说明，否则在我们的实验中：（1）节点运行在Fabric版本v1.1.0-preview2上，用于通过本地日志记录进行性能评估，（2）节点托管在单个IBM Cloud（SoftLayer）数据中心中（DC）专用虚拟机与1Gbps（标称）网络互连，（3）所有节点均为运行GHz的2.0 GHz 16-vCPU VM，Ubuntu具有8GB RAM和SSD作为本地磁盘，（4）单通道排序服务运行典型Kafka排序程序设置，具有3个ZooKeeper节点，4Kafka代理和3个Fabric排序程序，它们都位于不同的VM上，（5）共有5个peers，均属于不同的组织（org），都是Fabcoin背书人，以及（6）签名使用默认的256位ECDSA方案。为了测量和分阶段跨越多个节点的事务流中的延迟，在整个实验过程中，将节点时钟与NTP服务进行同步。Fabric节点之间的所有通信均配置为使用TLS。方法在每个实验中，在第一个阶段中，我们调用仅包含Fabcoin铸币操作的交易以生成coin，然后运行实验的第二阶段，在该阶段中，我们对先前铸造的coin调用Fabcoin支出操作（有效地运行单输入，单输入-输出支出交易）。在报告吞吐量测量时，我们使用在单个VM上运行的越来越多的Fabric CLI客户端（已修改以发出并发请求），直到端到端吞吐量达到饱和，并声明吞吐量刚好低于饱和度。吞吐量报告为在实验稳定状态下测得的平均值，而无视“tail”，在此“tail”中某些客户端线程已经停止提交其交易份额。在每个实验中，客户端线程共同调用至少50万个铸币并花费交易。实验1：选择区块大小影响吞吐量和延迟的关键光纤网配置参数是块大小。为了固定块大小以进行后续实验，并评估块大小对性能的影响，我们进行了实验，将块大小从0.5MB更改为4MB。结果如图6所示，显示了在对等端测得的峰值吞吐量以及相应的平均端到端（e2e）延迟。我们可以看到，超过2MB的块大小后，吞吐量并没有显着提高，但是延迟变得更糟（如预期的那样）。因此，在以下实验中，我们采用2MB作为块大小，目的是最大化测得的吞吐量，假设大约500ms的端到端延迟是可以接受的。选择事务大小在此实验中，我们还观察了铸币和支出交易的大小。特别是，这2MB的区块包含473个铸币或670个支出交易，即平均交易大小支出交易为3.06kB，铸币交易为4.33kB。一般而言，Fabric中的事务量很大，因为它们带有证书信息。此外，Fabcoin的铸币交易比支出交易大，因为它们带有CB证书。这是将来改善Fabric和Fabcoin的途径。实验2：peer CPU的影响Fabric peers运行许多CPU密集型加密操作。为了估算CPU功率对吞吐量的影响，我们进行了一组实验，其中4个peers分别在4、8、16和32个vCPU VM上运行，同时还进行了块验证的粗粒度延迟分阶段以识别瓶颈。我们的实验集中在验证阶段，因为使用Kafka排序服务进行排序从未成为我们集群实验（在一个数据中心内）的瓶颈。验证阶段，尤其是Fabcoin的VSCC验证，由于其许多数字签名验证，因此在计算上非常耗费时间。我们根据peers本地的验证阶段延迟来计算peers的吞吐量。图2显示了使用2MB块的结果，其中包含了铸币（图7a）和支出（图7b）操作的块。对于这两种操作，所测量的吞吐量和等待时间与vCPU数量相同。我们可以看到，验证方法明显限制了可实现的（端到端）吞吐量。而且，Fabric VSCC的验证性能与CPU呈近似线性关系，因为Fabric的VSCC的背书策略验证是并行的。但是，读写检查和分类帐访问阶段是顺序的，并以大量的内核（vCPU）为主。对于支出交易而言，这一点尤其明显，因为支出超过了铸币交易可以进入2MB的块，从而延长了顺序验证阶段的时间（即读写检查和分类帐访问）（从最下面两条几乎水平的线，图二的纵轴值高于图一可以看出）。这个实验表明，未来版本的Fabric可以通过流水线验证阶段（现在是顺序的）而受益，从而消除了客户端的顺序开销。验证端到端吞吐量，优化稳定存储访问以及并行化读写依赖性检查之间存在明显差异。最后，在此实验中，我们测量了32-vCPU对等方每秒超过3560笔事务（tps）的平均花费（端到端）吞吐量。总体而言，铸币吞吐量略低于支出，但相差不到10％，其中32个vCPU对等节点的平均薄荷吞吐量达到3420tps以上。延迟分析我们在之前的实验中以峰值报告的吞吐量进一步执行了延迟的粗粒度分析。结果如表1所示。在验证开始之前，排序阶段包括peers内部的广播传递延迟和内部延迟。该表报告了铸币和支出的平均延迟，标准偏差和尾部延迟。 1注意这个表，很有意思，很清楚的写明了验证阶段的步骤 我们观察到排序主导了整体延迟。我们还看到，平均延迟在550毫秒以下，并具有次秒级延迟。特别是，我们的实验中最高的端到端延迟来自负载增加期间的第一个块。可以使用排序者的切割时间参数来调节和减少较低负载下的延迟（请参阅3.3），因为我们将其设置为较大的值，所以我们在实验中基本不使用它。实验3：SSD与RAM磁盘为了评估与稳定存储相关的潜在收益，我们重复了先前的实验，将RAM磁盘（tmpfs）安装为所有对等VM上的稳定存储。好处是有限的，因为tmpfs仅有助于在peers进行验证的分类账阶段。我们在32-vCPU对等端测量了3870 SPEND tps的持续峰值吞吐量，比SSD大约提高了9％。实验4：LAN的可伸缩性在本实验及后续实验中，我们增加了peers的数量（每个peer具有16个vCPU）来评估Fabric的可伸缩性。在此实验中，我们在单个IBM Cloud DC（香港）中托管的每个组织中，只有一个peer。所有peers都直接从排序服务接收区块，而不会产生gossip。我们从20个peers开始（其中10个是Fabcoin认可方），并将peers的数量增加到100个。图8中描绘了可实现的最大吞吐量，该峰值吞吐量取决于peers数量（“LAN”后缀）。 1ps: 怎么感觉图和结论不符 强行理解 可伸缩性，就是要保证peers增加 吞吐量还可不变 实验5：两个DC-数据中心的可伸缩性以及gossip的影响在后续实验中，我们将排序服务，10个背书人和客户端移至附近的东京（TK）数据中心，将不背书的peers留在了香港特区。此实验（及下一个实验）的目标是评估系统的网络带宽成为瓶颈。我们将香港的非背书peers的数量从20个改变为80个，除了固定的10个背书peers之外，还保持了与排序服务的直接连接（即每个组织一个peer）。在TK和HK中的两个VM之间报告的单TCP netperf吞吐量平均为240 Mbps。在图8中示出了根据（总数）peers的数量的峰值吞吐量（“2DC”后缀）。我们清楚地看到，吞吐量与先前对30个peers进行的实验基本相同，但是当peers数目增加时，吞吐量会下降。因为满足了TK中3个OSN的网络连接，所以吞吐量降低了。我们测量了1910tps 铸币和2190tps 支出吞吐量（在香港peers中），总共90个peers。为了解决此问题并提高WAN上的可伸缩性，Fabric可能会使用gossip（第4.3节）。我们与香港的80个peers（总共90个peers）重复了最后一次评估，但将这些peers重新配置为8个组织，每个组织10个peers。在这种配置中，每个组织中只有一个领导者leader peers直接连接到排序服务，并向组织中的其他人散布gossip。该实验（1个gossip7个输出）在香港同行中达到了2544/2753 tps的铸币/支出 平均峰值流量，这意味着gossip很好地发挥了它的预期功能。吞吐量比LAN实验中的要低一些，因为组织负责人的peer（在两个实验中都直接连接到OSN）现在也需要管理gossip。实验6：在多个数据中心（WAN）上的性能最后，我们将最后一个实验扩展到5个不同的数据中心：东京（TK），香港（HK），墨尔本（ML），悉尼（SD）和奥斯陆（OS），每个数据中心有20个peers，共有100个peers。与之前的实验一样，排序服务，10个背书人和所有客户都在TK中。我们在没有gossip（每个组织一个peer）和有gossip（分为10个组织，每个数据中心2个组织，输出7个）的情况下运行此实验。结果汇总在表2中，属于同一数据中心的averaged across peers。供参考，表的首行显示了给定数据中心中的VM与TK之间的netperf吞吐量。结果再次清楚地显示了当对等点分散在WAN上时使用gossip的好处。与HK和ML相比，我们在OS和SD上看到了有趣的结果。SD gossip的吞吐量较低是由于VM在SD中的CPU限制所致；在相同的规格下，它们的验证吞吐量要比HK和ML的peers低。在OS中，总吞吐量要低得多。但是，瓶颈不是排序服务的带宽，而是我们的netperf测量表明，从OS到TK的单TCP连接带宽。因此，无法观察到OS中gossip的真正好处。我们将实验中的操作系统吞吐量稍有提高归因于gossip，减少了从操作系统到TK的TCP连接数量。 六、应用和使用案例主要的云运营商包括Oracle，IBM和Microsoft已经运行（或宣布）Fabric的“区块链即服务”。此外，Fabric目前为分布式账本技术的400多个原型和概念验证提供支持以及跨不同行业和用例的多种生产系统[47]。示例包括食品安全网络[16]，用于银行的云服务区块链平台[31]和数字全球航运贸易[33]解决方案。在本节中，我们将说明已部署Fabric的一些实际用例。1. 外汇交易网络Foreign exchange (FX) netting在Fabric上运行用于双边结汇的系统。它为每对涉及的客户机构使用fabric通道来保护隐私。负责结网和结算的专门机构（“结算员”）是所有通道的成员，并负责运行排序服务。区块链有助于解决未结算的交易，并在分类账中维护所有必要的信息。客户可以实时访问此数据，并有助于流动性，解决纠纷，减少风险敞口并最大程度地降低信用风险[49]。2. 企业资产管理（EAM）该解决方案跟踪硬件资产从制造到部署，最终到处置的过程，另外捕获与硬件相关的软件资产的许可证。区块链记录资产的各种生命周期事件和相关证据。分类帐是与资产有关的所有参与者之间的透明记录系统，从而提高了传统解决方案所面临的数据质量。多方财团区块链在制造商，托运人，收货人，客户和安装人员之间运行。它使用3层架构，其用户界面通过Fabric客户端连接到peers。在线提供了第一个版本的详细说明[56]。3. 全球跨货币支付Global cross-currency payments自2017年10月起，IBM与Stellar.organd KlickEx Group合作，运营了一种跨货币支付解决方案，该解决方案处理了太平洋地区APFII组织中的合作伙伴之间的交易[15]。The Fabric区块链以参与者认可的交易形式记录金融付款，以及双方同意的条件。所有有关方面均有权了解金融交易的清算和结算。该解决方案适用于所有付款类型和值，并允许金融机构选择结算网络。特别是，结算可以使用不同的方法，Fabric会根据参与者的配置来决定如何结算付款。一种可能的结算方式是通过Lumens（Stellar的加密货币）进行结算，其他方式则基于交易的金融工具的类型。 七、相关工作Fabric的架构类似于Kemme和Alonso [40]率先开发的中间件复制数据库的架构。但是，与此相关的所有现有工作仅解决了崩溃失败，而不是与BFT系统相对应的分布式信任的设置。例如，具有非对称更新处理的复制数据库[41，2.[6.3]依靠一个节点来执行每个事务，这不会在区块链上工作。 Fabric的执行顺序验证体系结构可以解释为这项工作对拜占庭模型的概括，并可以实际应用于分布式分类帐。从BFT数据库复制的角度来看，Byzantium [32]和HRDB [55]是Fabric的另外两个前身。Byzantium允许事务并行运行并使用主动复制，但是使用BFTmiddleware完全命令BEGIN和COMMIT / ROLLBACK。在其乐观模式下，每个操作都由一个主副本进行协调。如果怀疑该主服务器是拜占庭，则所有副本都将对该主服务器执行事务操作，并触发昂贵的协议来更改该主服务器。HRDB以一种更强大的方式依赖于正确的主机。与Fabric相比，这两个系统都使用主动复制，无法处理灵活的信任模型，并且依赖确定性操作。在Eve [37]中，还探索了BFT SMR的相关架构。它的peers同时执行事务，然后使用共识协议验证它们都达到了相同的输出状态。如果状态不同，它们将回滚并顺序执行操作。Eve包含独立执行的元素，该元素也存在于Fabric中，但没有其他功能。近来出现了大量的permissioned模型中的分布式分类帐平台，一些著名的平台是Tendermint [14]，Quorum [13]，Chain Core [4]，Multichain）。[12]，Hyperledger Sawtooth[9]，Volt proposal[50]等，请参阅最近概述中的参考文献[24,30]。所有平台都遵循第2节中讨论的顺序执行架构。作为代表示例，以Quorum平台[35]（以太坊为企业版本）为基础。基于Raft [45]的共识，它传播了使用gossip和Raft leader（称为Minter）将交易传播到所有peers，然后将有效交易组装到一个区块上，并使用Raft将其分配给所有peers。所有peers都按照领导者决定的顺序执行交易，因此它受到上述限制的困扰在1-2中。 八、总结Fabric是用于运行许可区块链的模块化且可扩展的分布式操作系统。它介绍了一种新颖的体系结构，该体系结构将事务执行与共识分开，并实现了基于策略的，这让人联想到中间件复制的数据库。通过其模块化，Fabric非常适合许多进一步的改进和研究。未来的工作将通过（1）探索基准和优化来解决性能问题;（2）对大型部署进行可伸缩性;（3）保证一致性和更通用的数据模型;（4）通过不同的共识协议保证其他弹性（5））通过密码技术等进行交易和分类账数据的隐私和机密性。","categories":[{"name":"论文","slug":"论文","permalink":"http://nlbyd1119.online/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://nlbyd1119.online/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"block_paper_1","slug":"block_paper_1","date":"2020-04-02T01:44:28.000Z","updated":"2020-05-29T00:23:22.981Z","comments":true,"path":"2020/04/02/block_paper_1/","link":"","permalink":"http://nlbyd1119.online/2020/04/02/block_paper_1/","excerpt":"数据流测试调查","text":"数据流测试调查 零、概述1.数据流测试定义数据流测试（DFT）是一系列测试策略，旨在验证每个程序变量的定义及其用途之间的相互作用。这种感兴趣的测试目标称为“ def-use”对。2.DFT发展DFT根据各种测试充足性标准（即数据流覆盖标准）选择测试数据，以练习每一对。 DFT的最初概念是由Herman于1976年提出的。从那时起，已经进行了许多理论和经验研究，以分析DFT的复杂性和有效性。在过去的四十年中，DFT一直受到关注，并且提出了来自不同方面的各种方法来追求自动和高效的数据流测试。3.论文工作这项调查对数据流测试进行了详细的概述，包括执行和自动化数据流的挑战和方法： 12345（1）介绍了用于识别def-use对的数据流分析技术； （2）分类并讨论了基于数据流的测试数据生成技术，例如基于搜索的测试，随机测试，基于抵押品覆盖率的测试，基于符号执行的测试以及基于模型检查的测试； （3）讨论了跟踪数据流覆盖范围的技术； （4）提出了几种DFT应用程序，包括软件故障定位，Web安全测试和规范一致性检查； （5）总结了最近的进展，并讨论了对更实际的数据流测试的未来研究方向。 一、介绍 DFT概念数据流测试（DFT）是一系列测试策略，它们选择**程序路径**来行使与数据对象有关的**定义使用关系**。它在所有路径测试和分支/语句测试之间进行定位，以查明潜在的数据流异常。当用作测试选择标准时，DFT可以提供更全面的测试方法，以确保某个软件的测试充分性，并检测要求不高的标准未必发现的错误。 DFT研究数据流测试的概念源自编译器优化中使用的**数据流分析**[Allen and Cocke 1976]，最初是由Herman [1976]在1976年提出的。从那时起，各种基于数据流的覆盖率的概念略有不同。准则[RappsandWeyuker1982; Laski and Korel 1983； Rapps和Weyuker 1985；弗兰克和韦尤克（Frankl and Weyuker）1988；克拉克等。 1989年； Harrold and Rothermel 1994]已经提出并进行了研究。这种**多样性的主要原因在于行使定义-使用关系的方式不同**，以及在过程和面向对象的**编程语言**中的不同适应方式。后来，通过一些实证研究证明了DFT的有效性[Frankl and Weiss 1993; Foreman and Zweben 1993； Weyuker 1993；哈钦斯等。 1994年；（Frankl and Iakounenko 1998），这表明**基于数据流的覆盖标准优于基于控制流的标准**（例如，语句或分支覆盖）。此外，由Khannur [2011]组织的在线软件测试知识中心报告说，在实践中，“通过将90％的数据覆盖率作为标准所检测到的错误数量能够发现缺陷的数量是90％所检测到的缺陷的两倍。分支机构的覆盖标准（控制流）。 在过去的四十年中，对数据流测试进行了持续的研究（如图1所示）。为了实现实用且有效的DFT，已经进行了大量研究工作。但是，很少有文献对它的技术水平进行过深入的调查或分析，这使学术研究人员和软件从业人员不了解该领域的**成熟度**。例如，关于数据流测试的介绍性章节可以在许多软件测试教程中找到，例如Beizer [1990]，Pezze和Young [2007]以及Ammann和Offutt [2008]的书。他们介绍了基本概念并确定了挑战，但没有讨论其**自动化**。此外，DFT提供了一种更密集的选择测试用例的方法，这是其执行中最耗费人力的任务之一（对于其他结构测试标准也是如此），并且对其测试有效性和效率产生了重大影响科学。但是，尚未专门研究DFT的**自动测试数据生成技术**。尽管有Edvardsson [1999]和Anand等人。[2013]调查了自动测试数据生成的各种技术，他们主要在基于控制流的覆盖标准的背景下讨论了这些技术。 本文研究内容尽管DFT具有检测数据交互故障的能力，但实际程序与所提出的DFT技术的实用性之间仍然存在很大差距。从而，我们认为，对于学术研究人员和工业从业人员，都非常需要审查当前的研究状态，认识到其**应用中的困难**，并指出未来的**研究方向**以缩小差距。为了提供DFT的系统概述，我们从DFT的三个基本阶段开始：（1）数据流分析，（2）数据流测试数据生成和（3）数据流覆盖率计算。在本文中，我们主要集中在后两个步骤中使用的技术，并提供了一个相对简短的DFT中数据流分析技术的摘要，因为Kennedy [1979]已经对数据流分析本身进行了研究。 此外，我们提出了关于数据流测试的首次调查：我们建立了DFT发布资料库，其中包含1976年至2015年期间的97篇论文。几个流行的在线数字图书馆（例如ACM数字图书馆，IEEE搜索Xplore，Springer Online，ElsevierOnline，Wiley Online和ScienceDirect）以收集有效的论文，这些论文的标题或摘要均包含以下关键字（在搜索过程中不断完善）：“def-use对”，“数据流关系”，“数据流测试+分析”，“数据流测试+测试生成”，“数据流覆盖范围”和“停用测试”。然后，遵循这些相同的关键字规则，我们遍历了这些论文的每个参考文献以收集缺失的出版物。现在可以在线获取该信息库。1我们将其分为七个主要类别： 1234567-测试数据生成。研究通用方法或技术以自动化基于数据流的测试生成-数据流分析。在不同编程语言及其特征的背景下研究用于分析数据流关系（即def-use对）的技术—覆盖率跟踪（计算）。对用于跟踪数据流覆盖范围的技术的研究，即确定满足哪些使用定义对-实证分析。分析执行数据流测试的复杂性并将其故障检测有效性与其他覆盖标准进行比较的研究-应用。将数据流测试应用于其他研究领域的研究，例如软件故障定位，Web安全测试和规范一致性检查-理论。数据流覆盖标准的基础理论和理论分析研究-工具。有关构建，说明和评估数据流测试工具的研究 请注意，有些论文可能涉及多个类别。例如，一篇论文可以介绍一种工具，也可以提出一种新的覆盖率计算方法。我们**根据其主要目标将每篇论文归为一类**。因此，我们的分类在某种程度上可能是**主观**的。尽管如此，我们相信图2中显示的每个研究主题的百分比仍可以公平地代表DFT中的当前研究状态。 本调查的其余部分安排如下。 12345678第2部分通过示例说明对DFT进行了概述，然后介绍了DFT的基本测试过程以及其应用中的各种挑战。第3节总结了用于查找def-use对的数据流分析技术。第4部分研究了DFT测试数据生成的一般方法，并讨论了它们的原理，优点和缺点。第5节介绍了DFT的覆盖率跟踪技术和工具。第6节讨论了最新的研究进展，第7节讨论了DFT的应用程序。第8节介绍了我们对数据流测试的新见解和未来的研究方向。第9节得出结论。 **二、数据流测试概述** 本节介绍数据流测试中的一些基本概念。然后讨论了DFT的基本测试过程及其遇到的困难。 **1. 基本概念** 程序路径可以表示为控制点的序列，形式为l1，l2，...，ln。我们区分两种类型的路径。**控制流路径是沿着程序的控制流图的一系列控制点；执行路径是由程序输入驱动的一系列执行控制点。** 定义2.1（使用定义对def-use）。按照Herman [1976]的经典定义，当变量的赋值（即定义或def）中至少**存在一个控制流路径时**，会出现def-use对**du（ld，lu，x）**。在控制点ld处的x到在控制点lu处的语句，其中**使用了相同的变量x**（即use），在该变量上**没有出现x的重新定义**（即，从def到use的路径是def-clear）。 尤其是，在数据流测试中区分了两种类型的变量用途[Rapps和Weyuker1982，1985]。如果x在计算或输出语句中使用，则将该使用称为**计算使用（或c使用）**，并将该对表示为**dcu（ld，lu，x）**，其中x在ld处定义并使用在lu。如果在条件语句中使用x，则其使用称为**谓词使用（或p-使用）**。此时，出现了两个def-use对，分别表示为**dpu（ld，（lu，lt），x）和dpu（ld，（lu，lf），x）**，其中x在ld处定义，在lu处使用，但是具有两个相反的流向（lu，lt）和（lu，lf）：前者表示使用x的条件语句的真实边；后者是错误边。 在整篇文章中，我们专注于动态数据流测试，这是大多数研究工作中的目标问题。下面，我们给出（动态）数据流测试的定义。 定义2.2（动态数据流测试）给定程序P中的使用对du（ld，lu，x），数据流测试的目的是找到一个输入t，该**输入t诱导执行路径p穿过ld，然后不经过中间重新定义就穿过lu**（即，在ld和lu之间杀死x。我们说这个**测试用例t满足du对**。 覆盖标准Rapps和Weyuker [1982，1985]首先[5]定义了**所有def-use对至少覆盖一次的要求**，这是**所有def-use覆盖标准（或全部用途覆盖率）的标准**，这意味着每对至少应有一个def-clear路径被掩盖。特别是，对于c型使用对，p应该覆盖ld和lu；对于p用法对，p应该覆盖ld和真或假边缘，即（lu，lt）或（lu，lf）。 2. 例子上图图显示了一个示例程序power，它以两个整数x和y作为输入并输出x y。其控制流图（CFG）显示在图3的右列中。遵循Rapps和Weyuker[1982]的定义，下图显示了power中变量的定义和使用以及相应的def-use对。 。我们可以看到该示例程序总共有19条语句，8个分支和20个def-use对。 1ps:关于控制点 就是输入返回 条件判断 变量定义赋值 例如，以下是关于变量res的两个def-use对：du1=（l8，l17，res）， （1）du2=（l8，l18，res）。 （2）这里，du1是一个def-use对，因为关于变量res的定义（在第8行）可以通过控制流达到相应的用途（在第17行），路径为pathl8, l9, l13, 114, l17。这对可行因为可以找到满足该对的测试输入。. For example, t = ( x \u0002→1, y \u0002→0) can induce an execution path p（4 6 7 8 9 13 14 16 17).对于du2，它是一个def-use对，因为它的定义（在第8行）可以通过路径18、19、113、118到达相应的用途（在18行）。但是，du2是不可行的：如果有测试可以使用的输入，在l13必须满足y&gt; 0。由于y尚未在代码中修改，因此y&gt; 0在l4处也成立。结果，由于19处的环路保护为true，因此将在10处重新定义res。显然，这一对没有这样的输入，既可以避免循环中的重新定义，也可以使用。 123ps:由此可见，所谓重新定义是变量重新赋值 du2因为最后use点需要输入必须满足一定条件，而满足该条件必定会进入改变变量res值的分支，因此不会存在满足条件的输入还有个问题，定义必须是赋值才可是吗 比如double res;就不算定义 res = 1;才算还有个问题，def必须是初次赋值的点对吧，不能是中间的再次赋值作为def 3. 基本测试流程数据流测试包括三个基本阶段：数据流分析，测试数据生成和覆盖范围跟踪（如图所示），如调查结果所示，它们总共占研究工作的近50％。 123—数据流分析阶段。数据流分析算法将被测程序P作为输入来计算测验目标（即使用定义对）。—测试数据生成阶段。采用一种测试方法来生成测试输入t，以满足目标限定使用对du。—覆盖率跟踪阶段。针对覆盖对du的程序P执行测试输入t。如果du被覆盖且未重新定义，则将t合并到测试套件T中。 整个测试过程将继续进行，直到满足所有对或测试预算（例如测试时间）用完为止。最后，将针对程序P重放生成的测试套件T，以使用测试预告片检查正确性。4. 难点尽管DFT能够检测数据流故障，但仍然存在一些困难[Weyuker 1990； 2003； 3。 Denaro等。 [2013]阻止了它在工业实践中的广泛应用。 123不可扩展的数据流分析。 DFT中需要一种数据流分析算法，以从被测程序中识别使用定义对。但是，数据流分析过程很难针对大型实际程序进行扩展，尤其是在考虑了所有程序功能（例如别名，数组，结构和类对象）的情况下。必须做出适当的近似以在精度和可伸缩性之间进行权衡。数据流测试设计的复杂性。与程序中的数据流标准相关的测试目标数量远比简单的控制流准则要大得多。6此外，需要付出更多的努力才能得出数据流测试用例：测试人员必须涵盖了变量定义及其相应的用途，而没有变量的重新定义，而不仅仅是覆盖语句或分支。不可行的测试目标。由于将静态数据流分析技术应用于确定测试目标时比较保守，因此，def-use对可能包括不可行的对。如果存在可以通过的执行路径，则一对是可行的。否则，它是不可行的（例如，第2.2节中的对（18、18，res）是不可行的）。在没有关于目标对是否可行的事先知识的情况下，测试方法可能徒劳地花费大量时间来覆盖不可行的停用使用对。 在这里，确定不可行的测试目标的问题实际上是不确定的，并且没有任何技术可以可靠地给出可行性的明确结论。它在DFT中不是唯一的，但在结构测试中也存在。尽管存在上述困难，但如本调查所示，借助现有技术和最新进展，DFT可以实现自动化，并且可以缓解这些问题。 三、经典数据流分析–提取def-use对的研究为了识别DFT中的测试目标（即使用定义对），通常使用达到定义的程序[Allen and Cocke 1976]（它也启发了数据流覆盖标准的定义），实际上回答了这个问题。 ：对于每种变量使用，哪些定义可以潜在地为其提供值？Harrold和Soffa [1994]使用标准的迭代数据流分析来计算高级语言的定义-使用关系。通过控制流图为每个过程提取过程内定义和使用信息，然后将其用于计算跨越过程边界的过程间定义使用对。 Pande等。 [1994]扩展了到达定义分析，以处理具有C语言单级指针的程序。该算法考虑了特定于程序点的指针引起的别名，并且具有多项式时间复杂度。为了应对传统的穷举式和增量式数据流分析的复杂性，Duesterwald等人。 [1996，1997]提出了一种需求驱动的数据流分析技术，以在集成测试用于验证程序接口时辅助DFT。该分析是作为面向目标的搜索执行的，而不是使用详尽的信息传播。它可以在每个自下而上的集成步骤中高效地计算新建立的数据流信息，而无需在每个步骤之间存储到达定义解决方案。Harrold and Rothermel[1994]扩展了面向对象语言的数据流分析，它不仅考虑了方法内的定义-使用关系（即，方法内部定义使用对），还通过实例变量（即方法间和类内部定义使用对）计算数据流关系。 Chatterjee和Ryder [1999]提出了一种基于指向分析的流和上下文敏感算法，以计算面向对象库的定义使用对。该算法解决了参数之间的未知混叠，参数的未知具体类型以及动态分配和异常的难题。 Souterand Pollock[2003]和Denaro等。[2008]也将经典的数据流分析扩展到了面向对象的程序，尤其是考虑了由类对象创建的上下文def-use对的构造。为了提高静态def-use对分析的精度，Bod´ik等人。 [1997]提出了一种方法，通过利用在编译时可以检测到的一些不可行路径的信息来排除部分不可行的def-use对（请注意，识别所有不可行路径的问题尚不确定）。该方法检测静态分支相关性以标识不可行的程序子路径，然后排除跨越这些不可行子路径的定义使用对。该算法在过程内和过程间级别均以需求驱动方式实现，适用于回归测试和集成测试中的DFT。经典的数据流分析属于静态分析，在实践中可能必须通过别名分析以不同的精度级别（例如，对流和/或上下文敏感）进行增强。实际上，应该做出适当的近似以在精度和可伸缩性之间进行权衡。四、基于数据流的测试数据生成方法本节介绍了各种自动化基于数据流的测试数据生成的方法，这些方法对DFT的有效性和效率有很大的影响。从出版物存储库中，我们发现测试生成问题是数据流测试研究中最活跃的研究主题，并且在过去20年中一直受到关注。共有27篇技术研究论文与该主题相关。根据他们的测试技术，我们将它们分为五个主要组：基于搜索的测试，随机测试，基于抵押物覆盖的测试，基于符号执行的测试以及基于模型检查的测试。我们计算了这些论文中使用的每种测试方法的百分比7（如图6所示）。我们发现基于搜索的测试方法（包括遗传算法和优化算法）是研究最广泛的方法，它占了近50％研究工作。基于抵押物覆盖的方法和随机测试也很流行。但是，很少研究更复杂的测试方法，例如符号执行和模型检查。在下文中，我们将在独立的部分中详细介绍这些方法，从研究最广泛的到研究最少的部分，即基于搜索的测试（4.1节），随机测试（4.2节），基于抵押物覆盖率的测试（第4.3节），基于符号执行的测试（第4.4节）和基于模型检查的测试（第4.5节）。最后，在4.6节中讨论了其他一些方法。1. 基于搜索的数据流测试方法基于搜索的软件测试[Harman等。 [2015年]，作为基于搜索的一般软件工程领域的一个实例，在过去的几十年中一直受到广泛的研究兴趣。 1.1基于搜索的方法原理基于搜索的方法包括各种**元启发式技术**[McMinn2004]，并利用它们来识别诸如测试用例生成之类的组合问题的解决方案。通常，测试数据生成的问题是无法确定的，但是可以将其**解释为搜索问题**，在该问题中，它会**从程序输入域中搜索所需的值来满足测试要求**。 遗传算法1975年提出的**遗传算法（GA）**[荷兰，1992年]是元启发式搜索技术的代表，它受到遗传学和自然选择的启发。在测试数据生成期间，GA从**一组候选个体（即测试用例）**开始，然后使用**搜索运算符**（例如选择，交叉和变异）来生成下一个有希望的测试用例。选择**从种群中选择有效的个体进行重组**（即交叉和突变）。两个独立个体之间的交叉产生了两个新的测试案例，这些案例共享了父母的遗传物质，而突变使部分人口的变化很小。 已经提出了几种**基于GA的测试方法**来解决DFT问题[Girgis 2005; Ghiduk等。 2007年； Vivanti等。 2013]。 （一） Girgis [2005]首先使用GA进行数据流测试所有用途的覆盖范围。在Girgis [2005]中，GA使用**长度为m的二进制字符串s作为染色体（即测试用例）来表示输入变量的值**。假设被测程序有k个输入变量（例如v1，...，vi，...，vk，1ik），vi的输入范围是[ai，bi]，而di是期望的精度。vi的值。然后，通过公式建立从二进制字符串si到具有域[ai，bi]的变量值vi的映射： ![](/block_paper_1/20200402113226764.png) 其中vij是二进制字符串si的十进制值。以图3（第2节）中的程序为例，并假设x和y的输入范围分别为[-2，9]和[-4，13]。**染色体是长度为9的二进制字符串**，其中从左起的前4位代表x的值，接下来的5位代表x的值y。例如，二进制字符串s 010100110表示一个x 5和y 6的测试用例。在生成测试之前，GA使用Michalewicz [1994]提出的这种编码方法来生成测试用例的**初始填充**。 在Girgis [2005]中，GA**使用涵盖的def-use路径数与总的def-use路径数之间的比率作为适应度函数，该函数专门使用覆盖率信息来确定单个测试用例的有效性**。这种基于GA的方法的**工作原理**如下。首先，它生成一组以二进制字符串形式编码的测试用例。然后，它使用基于轮盘算法的选择方法[Michalewicz 1994]根据适合度的个体来选择有前途的个体。接下来，GA使用搜索运算符（即交叉和变异）产生新的选定亲本的染色体。在预定义的迭代次数之后，GA可以输出一组可以覆盖目标def-use路径的所需测试用例（由于此搜索问题的不确定性，可能仍然存在未发现的def-use路径）。 （二） Ghiduk等[2007]后来发现，Girgis[2005]使用的适应度函数内部存在**一些缺陷**，这些缺陷可能过于粗糙，无法在以下情况下确定测试用例的接近性：（1）如果两个测试用例覆盖相同的数字对于def-use路径，它们将被赋予相同的适用性值；（2）如果一个测试用例没有涵盖任何def-use路径，则其适应性值将被赋予“ 0”。结果，当选择有前途的个体进行重组时，它可能会丢失有用的信息。为了解决这个问题，他们遵循Girgis [2005]中的类似程序，提出了一种**新的多目标适应度函数**。该功能根据其支配性（Lengauer和Tarjan 1979）与数据流需求的定义和使用之间的关系，来评估测试数据的适用性。特别是，它将def-use对视为**def和use这两个目标**。为了评估测试用例相对于目标def-use对的接近程度，它针对这两个目标使用了优势路径的遗漏节点。该功能的建立基于两个观察结果：（1）覆盖def的测试用例比不覆盖def和use或仅覆盖use的测试用例更近，以及（2）遗漏但包含但不存在的测试用例尝试覆盖def或使用比未命中且不尝试覆盖def或使用的测试用例更接近（尝试覆盖目标语句的测试用例意味着，在随后的搜索中，其变体接近目标。 ）。他们遵循这样一种测试方法：一次针对一个使用期限对，一次可以满足特定的测试要求。在评估中，他们发现这种GA方法比随机测试花费更少的搜索时间并且需要更少的程序迭代。但是，目前尚不清楚该技术在性能上比Girgis [2005]有多少，因为没有提供相关结果。 （三） Vivanti等。[2013]使用遗传算法来处理**面向对象程序**的数据流测试。对于面向对象程序中的类测试，测试用例以一系列方法调用的形式表示[Tonella 2004]。按照对类进行测试的概念[Harrold andRothermel 1994]，他们确定了**三种def-use对：方法内对，方法间对和类内对**。他们使用**“节点-节点”适应度函数**[Wegener等。[2001]，其中搜索首先被导向到达第一个节点（即def节点），然后从那里导向到达第二个节点（即使用节点）。但是，作者发现，一次针对单个测试目标时，测试人员面临在所有测试目标之间合理分配测试资源的问题。此外，对于不可行的测试目标，将浪费在其上的测试资源。为了克服这些问题，他们没有使用一次一次定位一对对象的经典方法，而是将整个测试套件[Fraser andArcuri 2013]应用于数据流测试，从而优化了涵盖所有测试的测试用例集目标。预期该方法受不可行的测试目标的影响较小。通过对SF100类语料库的评估[Fraser和Arcuri2012]，他们确认数据流测试的测试目标远比分支测试的目标要大，但最终的测试套件在故障检测方面更有效。 （四） Denaro等。 [2015]也使用类似的遗传算法在面向对象系统中使用基于数据流的测试数据来扩展**初始测试套件**。Liaskos等。 [2007]和Liaskos和Roper[2008]将GA与人工免疫系统（AIS）混合[Liaskos和Roper 2007]算法来完成针对Java库类的数据流测试。这种组合技术显示了其在提高测试性能方面的潜力。 （五） Baresi等。开发基于GA的测试工具Testful [Baresi等。 2010; Baresi and Miraz 2010]，用于Java类的结构测试。这个GA变体使用了**多目标适应度函数**，并且在类级别以及方法级别上都可以工作。前者为类对象生成有用的状态，后者使用它们到达未发现的状态类中的代码。在Miraz [2010]中，Matteo应用了该GA变体来覆盖定义使用对。作者指出，对面向对象的程序明确使用def-use对通常会有所收获，因为它可以正确地关联通过交换数据（例如，对象的字段）相互协作的方法。其他工作包括Oster [2005]和Deng等。 [2009]，他们也使用GA来自动化数据流测试，但只评估了一些小例子。 还尝试使用基于优化的搜索技术来解决DFT问题。 Nayak和Mohapatra [2010]和Singla等。 [2011a，2011b]使用粒子群优化，而Ghiduk[2010]使用蚁群优化。受自然行为的启发，这些优化算法模拟了这些行为，以在DFT的上下文中找到最佳解决方案。但是，这些方法仅在玩具程序上进行了评估。它们在大型程序上的有效性仍不清楚。 1.2讨论基于搜索的技术已经被用于执行简单的覆盖标准（例如，语句和分支测试[Anand等，2013]）以及一些高级覆盖标准[Ammann等。 2003; Inc 1992]（例如逻辑覆盖率[Awedikian等，2009； Ghani和Clark，2009]）和数据流覆盖率，如前所述。这种方法将测试数据生成视为一个**域搜索问题**，因此，它在**解决非线性约束和查找浮点输入方面更有能力**[Lakhotia等。 2009年，2010年； Bagnara等。 2013]，而不是那些基于约束的方法（例如，符号执行）。 但是，仍然存在一些需要注意和研究的问题：首先，基于搜索的技术的**测试性能在很大程度上取决于基础的适应度函数**（可能需要很长时间才能找到好的解决方案），因此要足够谨慎在设计和优化中需要。其次，与遗传算法相比，一些基于优化的算法（例如，粒子群优化和菌落优化）研究较少，它们在现实程序中的**可扩展性**仍然不清楚。第三，尽管多目标适应功能[Lakhotia等。2007年； Fraser andArcuri 2013]可以减轻不可行对的影响，但仍然**无法检测到不可行对**。 **2. 基于随机测试的数据流测试方法** 随机测试[Bird andMunoz 1983]是使用最广泛且最具成本效益的测试方法之一。在其经典实现中，从程序**规范的值范围中随机选择测试输入**，然后针对测试中的程序执行测试输入。 这种经典的随机测试技术已被用作易于执行但相当有效的基线方法，用于几项工作中的数据流测试[Girgis 2005; Ghiduk等。 2007年； Su等。 2015]。对于面向对象的系统，测试用例是一系列的类构造函数调用和方法调用的序列[Pacheco等。 2007]。适应于随机产生这些序列以行使被测类别的随机测试也已用于数据流测试领域[Alexander等。2010;Denaro等。 2015]。此外，其他形式的随机测试[Girgis等。[2014]，例如，从程序图中随机选择测试路径以覆盖定义使用对（然后使用测试生成器从那些测试路径中导出相应的测试用例），用于实现数据流测试。 讨论随机测试具有成本效益低并且易于实现，但是只能区分**有限的程序行为集**。结果，在没有任何优化的情况下，随机测试通常**无法实现令人满意的数据流覆盖范围**。但是，借助一些优化技术，随机测试可以成为DFT的一种**竞争性测试**生成方法。 例如，研究人员发现，如果先前选择的测试无法揭示程序错误，那么应该选择新的测试，使其远离已执行的测试。 从而提高触发故障的机会。自适应随机测试[Chen2008; Ciupa等。 2008年； Lin等。 2009年； Arcuri and Briand 2011]，例如增强传统随机测试，将测试用例平均分布在其输入域中，可以提高数据流测试的效率。此外，反馈导向的随机测试[Pacheco等。 2007]）通过合并从创建测试用例时获得的反馈信息来改善随机测试，也可以使DFT受益。 **3. 基于抵押品覆盖率的数据流测试方法** 1ps:应该是附带覆盖的含义 在软件测试中，已利用抵押物覆盖范围来优化测试套件的生成[Harman等。 2010; Fraser and Arcuri 2013]。它基于以下观察结果：满足测试目标的测试用例可以**“意外地”涵盖其他测试目标**。因此，如果我们**排除这些涵盖的测试目标**，并将测试预算投入到其余未发现的目标中，则可以减少所得测试套件的大小以及测试执行和Oracle检查的成本。同样，在执行程序以满足给定的测试标准（例如分支覆盖范围）时，与**其他覆盖标准**（例如数据流覆盖范围）有关的测试目标也可能被意外覆盖，这是附带覆盖的另一种形式[Malevris and Yates 2006]。 形式上，如果对于所有程序P，满足P的所有测试目标（针对C1）的测试用例也满足针对C2的那些测试用例，则测试标准C1包含另一个标准C2。例如，下图（在Rapps和Weyuker [1982，1985]中给出）显示了**不同测试覆盖率标准之间的包含关系**。8箭头尾部的标准包含了箭头头的标准（例如，分支标准包含了）声明标准）。由于包含关系是传递性的，因此它实际上定义了各种覆盖标准之间的关系。阴影标准是七种类型的数据流测试标准（有关详细定义，请参见Rapps和Weyuker [1982，1985]），这些标准强调了行使定义-使用关系的不同方法。所有用途的覆盖范围是所有实际用途的覆盖范围（请参阅第2.1节中的定义2.2），它包含所有c用途和所有p用途覆盖范围。此外，所有用途的覆盖范围也包含分支机构的覆盖范围。 ![](/block_paper_1/20200402022553498.png) **尝试基于附带覆盖的想法来解决数据流测试** （一） ing[Malevris and Yates 2006; Santelices和Harrold 2007；梅洛和安东尼奥1999； Marre和Bertolino 1996，2003;Santelices等。2006]。 Malevris和Yates[2006]在打算进行分支测试时研究了数据流覆盖的水平。在实证研究中，他们从控制流图中选择路径，以用不同的编程语言（包括Fortran，Pascal，C和Java）编写的59个单元来满足所有分支的覆盖范围，并**衡量同时实现的数据流覆盖范围到七个数据流标准**（上图中的阴影）。在他们的实验中，执行分支测试并选择平均每单位6.44条路径时，平均可以实现超过35％的所有du路径覆盖和超过40％的所有用途覆盖。该研究还表明，可以**将实际数据流覆盖范围建模为一个函数**，该函数将有关分支测试的选定路径数和其中的可行路径数作为参数。此外，他们还发现（1）数据流覆盖范围与单位使用的语言无关；（2）可以根据抵押覆盖范围来估计DFT所需的可能的测试预算，以及（3）在数据流测试之前进行分支测试可能更具成本效益，因为在分支测试期间将涵盖部分使用数据对。 （二） Merlo和Antoniol [1999]利用def-use对和节点（即语句）之间的覆盖率含义来实现过程内数据流测试。前支配器和后支配器分析用于识别一组节点，这些节点的覆盖范围可能暗示def-use对子集的覆盖范围。他们在16KLOC Gnu查找工具上评估了该方法，发现当覆盖每个例程的节点时，平均而言，肯定有75％的def-use对被覆盖。 （三） Santelices等。[2006]提出了一种**基于谓词条件的任何类型的程序实体（例如分支，定义使用对和调用序列）的包含算法**。此谓词条件是路径条件的特殊形式[Robschink and Snelting 2002]，从系统依赖图计算得出，以表示实体对其覆盖范围的必要但不充分的条件。构建包括每个实体的所有这些谓词条件的表，以创建实体的包含关系以进行有效的覆盖范围跟踪。 后来，Santelices和Harrold [2007]提出了一种**从分支结构覆盖范围自动推断数据流覆盖范围的方法**。在静态分析阶段，使用可推断性分析将def-use对分为三类：可推断的（覆盖范围始终可以从分支覆盖范围中推断出来），有条件的可推断性（可以从某些但不是全部的分支覆盖范围中推断出覆盖范围）程序执行）和不可推断的（无法从分支覆盖率推断出覆盖率）。在动态测试套件执行阶段，将针对三种类型的实体记录分支覆盖范围：定义，用途和定义用途对的销毁。最后，覆盖率跟踪阶段将静态和动态分析的结果作为输入，并报告已明确覆盖，可能覆盖或未覆盖的def-use对。尽管这种方法可能会损失一些覆盖精度，但是显着的好处是，由于该程序是在分支覆盖级别而不是数据流覆盖级别进行检测的，因此可以大大减轻覆盖跟踪的开销。 （四） Marre和Bertolino [1996，2003]提出了一种方法，用于识别最小数量的def-use对，以便覆盖这些对的路径可以覆盖程序中的所有对。换句话说，可以通**过集合中那些对的覆盖范围来推断集合外的那些对的覆盖范围**。该集合称为扩展集合，其中的对称为无约束对。该集合的基数实际上是实现所有用途覆盖范围所需的测试套件大小的上限。结果，它可以帮助估计数据流测试的成本。 Harrold等。[1993]提出了一种从测试套件中生成具有代表性的测试用例集的技术，该方法可以达到与原始整个测试套件相同的覆盖率。该技术通过利用抵押物覆盖范围来最小化测试套件的大小，并且独立于测试方法。它仅需要测试需求和满足以下条件的测试案例之间的关联这个要求。对数据流测试的评估表明，该技术可以有效地删除多余的测试用例，但又不影响覆盖率，这在回归测试中特别有用，可以降低测试成本。 讨论借助现有的测试数据，基于抵押物覆盖范围的方法在数据流测试中具有多个优点：（1）仅考虑非约束对，它可以减少测试套件的大小以及开销。覆盖范围跟踪； （2）可以通过无约束对的数量来估计应该分配多少测试预算； （3）它可以帮助理解程序中不同级别的实体（例如，语句，分支和def-use对）之间的关系。 但是，由于此方法**使用低级程序实体（例如，语句或分支）的覆盖范围来推断高级实体（例如，def-use对）的覆盖范围**，因此可能无法为其覆盖范围不易推断。而且，它也不能区分不可行的对。 **4. 基于符号执行的数据流测试方法** 符号执行由金[1976]首次提出，是一种经典的程序分析技术，已**广泛应用于软件测试**中[Cadar andSen 2013]。 **符号执行原理** 符号执行**使用符号值而不是具体值作为程序输入**。结果，由这些**输入组成的符号表达式可用于表示程序变量的值**。在符号执行期间，程序状态在任何时候都包括（1）程序变量的符号表达式（值），（2）符号输入上的布尔约束形式的路径约束（pc），需要满足以下条件：到达该程序点，并且（3）一个程序计数器，表示要执行的下一个程序语句。 该技术的**工作原理**如下：在执行过程中，将使用每个分支点上输入的新约束来更新pc。如果新PC不满足要求，则将停止对相应路径的探索。否则，执行将沿着该分支点继续，这样pc的任何解决方案都将执行相应的路径。特别是，当条件语句的两个方向（即分支）都可行时，路径探索将继续进行下去。搜索策略[Cadar等。 2008年； Burnim and Sen 2008； Cadar等。 2006]将被指定搜索方向的优先顺序。符号执行的这种经典方法也称为静态符号执行（SSE）。在图8中，我们说明了在图3（第2节）中的示例程序上的符号执行。在这里，探索了三个程序路径，并通过**解决所收集的路径约束来生成测试输入**（如图8（a）所示）。执行树在图8（b）中给出。 ![](/block_paper_1/20200402023706520.png) **基于静态符号执行的方法** Girgis [1993]首先使用了类似的静态符号执行系统来生成基于数据流的测试数据。该方法首先从被测试程序的CFG到特定的控制流标准（例如分支覆盖范围）生成一组程序路径。由于来自CFG的循环可能会生成无限的程序路径，因此它通过使用称为ZOT子集的路径子集，通过要求路径遍历循环零次，一次和两次来近似整个路径空间。然后，将重点放在可以覆盖感兴趣的def-use对的那些可执行路径上。在该系统中，测试人员可以通过检查沿该路径收集的路径约束是否可满足来确定路径可行性。通过**解决可行路径的路径约束，该系统可以生成满足给定数据流测试标准的测试套件**。 对于图3中的示例程序，该方法首先相对于控制流标准（例如分支覆盖）静态地探索尽可能多的路径。假设它找到一个静态路径p = l4，l5，l8，l9，l10，l11，l9，l13，l18。在此，p遍历循环（位于19和12之间）一次并静态覆盖dua（l10，l18，res）。对应的pc（即y==1 y> 0）的解（x›→0，y›→1）可以满足该对。 **基于动态符号执行的方法** Godefroid等。 [2005]和Sen等。 [2005]**将符号执行与具体执行交织**在一起，以提高静态符号执行的可伸缩性。这种混合技术（称为**动态符号执行或约束测试**[Godefroid et al。2005; Sen et al。2005]）沿执行路径（与静态符号执行相同）收集路径约束，该约束由具体程序触发输入。如果路径约束变得过于复杂并且超出了约束求解器的范围，则可以使用这些具体值通过值替换来简化它。 Su等。 [2015]首先采用了这种**动态符号执行技术**，以在称为CAUT的DSE引擎之上进行数据流测试。 2009年； Yu等。 2011; Sun等。 2009年； Su等。 2014]。在他们的方法中，数据流测试被视为目标搜索问题。它首先找出一组切点，任何切入点都必须经过这些切点才能覆盖一对定义使用对。这些切点可以缩小路径搜索空间，并引导路径探索尽快到达该对。为了进一步提高测试性能，它使用了有向符号执行方法的最短距离分支优先启发式方法（优先级最高的指令距离指定目标的分支方向）[Zamfir andCandea 2010; Ma等。 2011]）和重新定义路径修剪技术（def和使用之间的子路径上不能出现重新定义）。 对于图3中的示例程序，假设目标def-use对为du（8,17，res）。DSE通过获取任意测试输入t开始，例如，t=（x›→0，y›→42）。这个测试输入触发执行路径p ![](/block_paper_1/20200402024221388.png) 它已经涵盖了du1的定义。为了涵盖其使用，经典的DSE方法 （例如，使用深度优先或随机路径搜索[Burnim and Sen 2008]），系统地对p上的分支节点进行翻转，以探索新路径，直到覆盖使用为止。但是，路径爆炸的问题（路径p上的数百个分支节点（包括来自p的新生成路径的节点）可以翻转为派生新路径）可能会使探索非常缓慢。 ![](/block_paper_1/20200402024437802.png) **讨论** 经典的符号执行是**基于路径的测试方法，可以系统地探索路径以覆盖目标定义使用对**。在早期工作中[Girgis 1993]，Girgis使用控制流标准作为覆盖率度量标准来指导路径探索，这可以缓解路径爆炸问题，但**可能会带来无法覆盖某些使用期限对**的风险。例如，图8（a）中的三个路径已经覆盖了功能函数中的所有分支，但是不满足使用定义对du（l10，l17，res）（新的测试输入（x 1，y 1））对应于路径l4，l7，l8，l9，l10，l11，l9，l13，l14，l17的路径可以覆盖这对）。原因是控制流准则可能不包含数据流准则。此外，使用符号推理时，经典的符号执行必须做出一些近似，这**可能会丢失数据流测试的精度**。例如，当x的具体值未知时（一种方法是将a[x]视为整个数组的使用a）。相反，基于动态符号执行的方法可以更加精确和高效。例如，使用动态执行信息可以更轻松，更准确地检测到由别名引起的变量重新定义，并且动态程序执行比静态程序执行快得多。 但是，基于SSE的方法和基于DSE的方法都无法识别不可行的对，因为基于符号执行的测试是基于显式路径的方法，在所有程序路径都被确定之前，无法得出对的可行性的结论。探索。在没有关于目标对是否可行的事先知识的情况下，这些测试方法可能徒劳地花费大量时间来覆盖不可行的对。 **5. 基于模型检查的数据流测试方法** **模型检查原理** 模型检查[Clarke等。 [1999]是一种经典的形式验证方法。**进行属性检查时，模型检查器可以构造见证人或找到反样本。**在较高的层次上，模型检查器将系统规范和感兴趣的属性作为输入；然后检查是否违反了该属性。如果该属性被违反，则会生成一个反例来证明该违反。否则，该财产被认定为满意（即未违反）。结果，这种模型检查方法可用于测试目的[Fraser等。 [2009]，尤其是当这些反例被解释为测试用例时，这可以帮助分析人员识别并修复故障。 **基于WCTL的模型检查** ![](/block_paper_1/20200402025101268.png) ![](/block_paper_1/20200402025132180.png) **讨论** 这种基于Kripke结构的模型检查方法具有以下优点：（1）由于它适用于**抽象模型**，因此该方法与语言无关。它甚至可以扩展规范模型上的数据流测试[Hong等。 2000;乌拉尔等。 2000]。（2）这种方法将数据流测试问题转化为**模型检查问题**，这可以从模型检查器的未来发展中受益。 但是，它也可能会受到一些限制：（1）从理论上讲，此方法中最常用的定义使用对数可以是O（n2），其中n是图中顶点（即语句）的数目G。因此，相对于G，公式的数量可以是二次的。如果将其应用于基于过程间程序的测试，则由所有函数构建的整个图G将包含大量顶点。此方法的**可伸缩性**可能会受到影响。（2）此外，这种方法无法轻松检测不可行的对，因为它所基于的抽象模型并不了解潜在的路径约束。 **基于CEGAR的模型检查** 另一种软件模型检查方法称为CounterExample-Guided基于**抽象提炼**（CEGAR）模型检查[Ball and Rajamani2002; Henzinger等。 2002年；Chaki等。 [2003年]是在2002年提出的。给定程序源代码和时间安全规范，CE-GAR**要么静态地证明程序满足该规范，要么生成一个程序。** 反例路径以证明违规。从那时起，它被应用于自动检查OS设备驱动程序的安全属性[Ball and Rajamani 2002; Beyer等。 2007年； Beyer和Keremoglu 2011]以及生成测试用例[Beyer等。 [2004]。 Beyer等。[2004]提出了一种基于CEGAR的两阶段方法，即从反例进行模型检查和测试，以自动生成结构测试用例。它首先检查感兴趣的程序位置q是否可到达，以使q处的谓词p（即安全性）为真。从在q处显示p的程序路径，基于CEGAR的模型检查器可以生成一个测试用例，以证明p在q处的真相。类似地，它也可以产生一个测试用例，以表明p在q处的虚假性。如果在谓词p设置为true的情况下检查了所有程序位置或分支，则可以很好地实现语句或分支的覆盖范围。 Su等。[2015]进一步调整了这种基于CEGAR的模型检查方法，以针对所有使用定义标准进行数据流测试。提出了一种简单但功能强大的程序转换方法，将测试需求直接编码到被测程序中。它将原始程序P插入Pj，并将数据流测试的问题减少到对Pj的可达性检查。在目标定义使用对的定义位置之前，引入了一个变量cover_flag并将其初始化为false。该标志在def之后立即设置为true。为了找到从def位置到使用位置的def-clear路径，在相同变量的其他定义之后，将cover_flag变量立即设置为false。在使用之前，它将目标谓词p设置为cover_flag true。结果，如果可以到达使用位置，我们将得到一个很好的例子，并得出结论，该对在测试案例中是可行的。否则，将证明该对是不可行的（或者，由于问题无法确定，该算法不会在受约束的时间预算内终止，并且会将结果报告为未知）。 对于图3中的示例程序以及方程式（1）中的两对du1和du2和（2），用这两个测试要求编码的转换程序分别如图10（a）和图10（b）所示。对于du1（18,17，res）对，图10（a）在突出显示的语句中显示了du1的变换函数功效和编码测试要求。变量cover_flag在l2处引入。初始化为false并在l7的def之后立即将其设置为true，并在l10的变量res的其他定义之后立即将其设置为false。在使用之前，在14点设置检查点以验证cover_flag是否可以为true。如果检查点不可达，则可以证明这对不可行。否则，可能会产生反例（即涵盖该对的测试用例）。在该示例中，模型检查器可以找到可能的路径l2，l3，l4，l6，l7，l8，l9，l13，l14，l16，l17。但是对于图10（b）中的du2（l8，l18，res）对，模型检查器可以快速得出结论：没有路径可以到达检查点并见证cover_flag的真实性。因此，du2是不可行的。 **讨论** 这种基于CEGAR的模型检查方法具有以下优点：（1）数据流测试问题可以轻松**转换为路径可达性检查问题。** CEGAR可以为可行的def-use对生成反例（即测试用例），还可以检测没有误报的不可行对。这项技术本身甚至可以受益于基于CEGAR的模型检查器的未来发展。 （2）在CEGAR中，可以**将测试要求直接编码到被测程序中**，而无需手动编写诸如CTL / WCTL公式的时间属性。与其他基于模型检查的方法相比，它更加灵活且易于实现。 但是，一般而言，CEGAR无法确定所有def-use对的可行性，因为检查路径可行性本身的问题尚不确定。在这种情况下，CEGAR可能不会终止，只能得出未知结论。另外，CEGAR本质上是静态方法。生成可行对的测试用例时，其**测试性能可能不及其他动态测试方法**（例如，基于动态符号执行的方法[Su等人2015]）高。 **6. 其他方法** Khamis等。 [2011]增强动态域减少程序[Offutt等。 1999]（DRR）对Pascal程序执行数据流测试。 DDR技术基本上**集成了符号执行和基于约束的测试的思想**。它从输入变量的初始域以及程序流程图开始，并通过指定的路径动态驱动执行，以达到目标测试目标。在路径探索过程中，采用符号执行来减小输入变量的范围。然后使用搜索算法来找到可以满足路径约束的一组值。作者还通过一些处理循环和数组的方法来增强此技术。但是它仅通过一些概念证明示例来说明该想法，其实用性尚不清楚。 Buy 等。 [2000]结合数据流分析，**静态符号执行和自动演绎来执行数据流测试**。符号执行首先确定类中每种方法的输入和输出值之间的关系，然后从可行且清晰的路径（包括目标对）收集方法的前提条件。后来，使用一种自动向后推导技术来找到满足这些先决条件的方法调用（例如，测试用例）的顺序。但是，几乎没有证据表明这种方法的实用性。后来，Martena等人。 [2002]将该技术从单个类扩展到多个类，即测试类间的交互。它从简单的类到更复杂的类逐步生成测试用例。 Baluda等。 [2010]，Baluda[2011]和Baluda等人。 [2011]提出了一种称为抽象提炼和粗化（ARC）的新颖方法，通过**识别不可行的分支来提高分支覆盖率测试的准确性**。这种方法源于属性检查算法[Beckman等。 2008年； Gulavani等。 [2006年]，其目的是证明错误的陈述不可达或产生执行该陈述的测试用例。 Baluda等。将该算法用于结构测试并通过“粗化”对其进行增强，以提高其可扩展性。 Baluda [2011]声称这种方法独立于覆盖标准，并且特别适用于这样的覆盖标准，这些覆盖标准由于存在不可行的测试目标（如数据流测试标准）而遭受了极大的折磨。 **总结** 尽管在识别基于数据流的测试数据方面遇到了许多挑战，但研究人员已经开发出各种使该过程自动化的通用方法。**基于搜索的测试和基于附带覆盖的测试是用于自动生成测试数据的两种研究最为广泛的技术**（如图6所示）。合理的解释是，这两种技术对于DFT而言**相对容易实现**。基于符号执行和基于模型检查的技术相当早就引起了人们的注意，但是直到最近它们还没有应用于大型的现实程序，而仅应用于实验室程序。这些技术比其他方法**更难以实施，而且在很大程度上依赖于其他技术的进步**（例如约束解决），这一事实可以解释这种现象。另外，对于过程语言（例如，C）和面向对象的语言（例如，Java），都存在几种学术工具。但是，根据我们的调查，仍然**没有支持DFT的商业工具**。开发高效且易于实现的技术需要付出更多的努力。 我们还需要注意的是，由于存在根本的不确定性问题，**没有任何现有的测试技术能够可靠地识别出不可行的线对（其他结构测试也是如此）**。当应用其中任何一个时，一个人可能总是无法覆盖某些对，并且不知道是因为没有进行足够的测试还是因为它们永远无法覆盖。 **五、覆盖跟踪的方法** 本节讨论了现有文献中用于**跟踪数据流覆盖范围**的一些方法，并总结了可用的数据流覆盖范围工具。 **1. 覆盖跟踪技术** 测试覆盖率是衡量**软件测试的彻底程度以及软件开发人员对其可靠性的信心程度**的常用工具。几种技术[Frankl 1987; Ostrand和Weyuker 1991a； Horgan and London 1992； Misurda等。 2005b； Santelices和Harrold 2007； Harrold和Soffa（1994）的开发是为了追踪def-use对的覆盖范围。 （一） 弗兰克（Frankl）（1987）提出了一种基于确定性有限自动机的方法来跟踪定义使用对的覆盖状态。在她的方法中，一对du与一个正则表达式相关，该正则表达式描述了覆盖它的控制流路径。与du关联的每个自动机都针对所有执行路径进行检查。一旦某个路径被某个自动机接受，就将du对设置为覆盖。但是，当被测过程递归调用自身时，此方法必须进行特殊处理。 （二） Ostrand和Weyuker [1991a]使用记忆跟踪技术来精确确定覆盖了哪些对，而Kamkar等人（1991年）则采用了这种方法。 [1993]使用动态切片来提高覆盖精度。一些工作[Harrold and Malloy 1992; Su等。 [2015]利用动态数据流分析提高跟踪数据流覆盖率的精度。 （三） Horgan和London [1992]利用代码工具来跟踪DFT覆盖范围，此后称为最后定义技术。在他们的方法中，从数据流图生成一张停用关系表，并在每个代码块处插入一个探针。运行时例程记录每个已定义的变量以及定义该变量的块。执行使用该已定义变量的块时，将验证该变量的最后定义，并将该对设置为覆盖。 （四） Misurda等。 [2005b]提出了一种以需求为导向的策略来跟踪def-use对的覆盖，其目的是提高静态检测方法的性能（例如Horgan和London [1992]）。该方法的工作方式如下：首先，确定测试区域中的所有可变定义，并将种子探针插入其位置；第二，达到定义后，将按其所有可能的用途按需插入覆盖范围探针；第三，达到用途后，将立即删除该用途的探测，并将由最近访问的定义和该用途组成的配对标记为已覆盖。 （五） Santelices和Harrold [2007]开发了一种有效的基于矩阵的策略来直接跟踪数据流覆盖范围。在此策略中，将创建一个coverage矩阵并将其初始化为零，其中每一列代表一个变量用途（与用途ID关联），并且列中的每个单元格记录该用途的定义（与定义ID关联）（也就是说，一个单元对应于一个def-use对。在这种结构中，可以通过使用ID和定义ID快速访问矩阵单元，以减少探针的运行时成本。在运行时，探针跟踪变量的最后定义。每次使用时，都会插入一个探针，该探针使用用途ID和最后定义ID更新矩阵中该对的覆盖状态。 在Santelices和Harrold [2007]中，设计了一种新颖的覆盖率推断策略，该策略使用分支覆盖率来推断数据流覆盖率。通过在动态执行之前使用静态分析，将对分为树类型，即可推断的，有条件可推断的和不可推断的对。在运行时，此方法跟踪分支覆盖，这是一种成本较低的代码工具。**测试套件执行后，它输出实际覆盖和有条件覆盖的对**。有关详细信息，请参阅第4.3节中基于抵押物覆盖率的测试方法。 为了使覆盖范围跟踪更具可扩展性，Harrold [1994]开发了一种在多处理器系统上接受测试的技术，并产生了可并行的覆盖范围跟踪工作量。工作负载可以静态或动态地调度到不同的平台上。对多处理器系统的评估表明，与单处理器系统相比，它具有良好的加速性能。 **讨论** 数据流覆盖在跟踪其覆盖范围时会**增加高昂的开销**。主要原因是：（1）基于数据流的**测试目标通常比语句或分支要多得多**；（2）数据流覆盖范围将约束（即，满足清晰清晰的路径）置于**程序路径**上，而不是简单地编写程序实体，这会使跟踪更加昂贵。现有方法主要诉诸有效的数据结构或利用覆盖推断来减轻开销。 1ps: 覆盖到底指的是什么呢 **2. 覆盖工具** 有很多健壮的覆盖工具[Yang等。 [2009年]进行报表和分支机构的覆盖，但是只**有少数几个可用于数据流覆盖**。表一总结了用于数据流测试的覆盖工具，包括ASSET [Frankl and Weyuker 1985;弗兰克（Frankl）等人。 1985年；弗兰克（Frankl）1987； Frankl和Weyuker 1988年（第一个数据流覆盖工具），ATAC [Horgan and London 1992年]，Coverlipse，DaTec[Denaro等人。2008，2009]，DuaF [Santelices andHarrold 2007]，TACTIC [Ostrand and Weyuker 1991b]，POKE-TOOL [Chaim1991]，JaBUTi [Vincenzi等。 2005]，JMockit和Jazz [Misurda等。2005a]，DFC[Bluemke和Rembiszewski 2009、2012]和BA-DUA [Chaim和de Araujo2013a；de Araujo and Chaim 2014]。对于每种工具，该表列出了其支持的语言，是否跟踪过程内或过程间对或两者，基于它的分析基础结构，所使用的覆盖率跟踪技术及其可用性。在总共12种工具中，有6种是公开可用的，但它们都不是商业工具，Hassan和Andrews[2013]以及de Araujo和Chaim [2014]最近也对此进行了报道。 ![](/block_paper_1/20200402031648506.png) **六、近期进展** 本节讨论数据流测试的最新进展的三个方面：（1）新的覆盖标准，（2）动态数据流分析和（3）有效的覆盖跟踪。 **1. 新的覆盖标准** Hassan和Andrews[2013]引入了一个新的覆盖标准系列，称为多点跨度覆盖率（MPSC）。具有间隙g和p点的MPSC的仪器记录所取分支的元组（b1，b2，...，bp）的覆盖范围，其中元组中的每个分支是在前一个之后的g个分支。经验评估表明，从分支机构的覆盖范围概括出的MPSC覆盖范围，在衡量测试有效性时，可以达到比所有常规使用覆盖范围更高的准确性。而且MPSC覆盖的工具也比数据流覆盖的工具更有效。 亚历山大等。 [2010]扩展了经典的数据流标准，以测试和分析面向对象系统中的多态关系。新的覆盖标准考虑了类的状态变量之间的定义和使用，特别是在存在继承，动态绑定以及状态变量和方法的多态覆盖的情况下。目的是提高面向对象程序中DFT的故障检测能力。 **2. 动态数据流分析** Denaro等。 [2014]和Vivanti [2014]研究了DFT中使用的传统静态数据流分析的局限性。他们使用动态数据流分析技术，通过**观察具体的程序执行来识别相关的数据流关系**。这种方法利用了可从具体执行中获得的精确别名信息，以将内存数据和类状态变量相互关联。结果，它比考虑静态计算的别名关系要精确得多。 对五个Java项目的评估表明，传统的静态数据流分析遗漏了大量数据流关系，这破坏了以前DFT方法的有效性。这种动态技术为数据流测试的新方向提供了启示，该方向可以更好地涵盖基于数据流的测试目标。 Denaro等。 [2015]将该动态数据流分析技术调整为测试面向对象的系统。这种方法不是先验地计算所有对，而是运行一些带有动态分析的测试，合并跟踪以推断从未执行过的对，生成新的测试以覆盖它们，然后进行迭代，直到找不到新的东西为止。结果比现有分支机构覆盖率测试套件的变异分数高出约30％。 **3. 高效的覆盖率追踪** 阻碍DFT广泛采用的一个因素是通过测试跟踪def-use对的覆盖范围的成本。由于DFT旨在实现更全面的程序测试，因此由代码工具施加的运行时成本大大高于其他结构标准。一些技术[Misurda等。 2005b； Santelices和Harrold [2007]提出了基于昂贵的计算和数据结构来解决此问题的建议。 Chaim andAraujo [Chaim anddeAraujo 2013a; 1998年；对数据流问题的经典解决方案（例如，达到定义[Aho et al。1986]）的启发。 de Araujo and Chaim 2014]发明了一种按位算法（BA）算法，该算法使用具有按位运算的位向量来跟踪Java字节码程序的数据流覆盖率。对于每条指令，此方法都使用已知的数据流分析技术来计算定义和使用的变量（局部变量或字段）。之后，它将在每个指令（或块）处检测BA代码，该代码用于确定线对的覆盖范围。 BA代码跟踪三个工作集，即活动对，覆盖对和当前困对，它们在测试执行期间进行更新。这些工作集以位向量实现，并通过有效的按位运算进行操作，其大小由被测方法对的数量给出。 作者还给出了正确性证明[Chaim and de Araujo 2013b]和理论分析，表明他们的算法比以前的需求驱动和基于矩阵的方法[Misurda等人，要求的内存和执行时间更少。 2005b； Santelices and Harrold 2007]。在他们的评估中[Chaim and de Araujo 2013a]，通过模拟这些仪器策略进一步证实了这一结论[Chaim等。 2011]。在de Araujo和Chaim [2014]中，此方法适用于处理具有200KLOC和300K对的大型系统，其执行开销可与流行的控制流测试工具强加。 **七、应用领域** 本节讨论了DFT应用程序的三个方面：（1）软件故障定位，（2）Web应用程序测试和（3）规范一致性检查。 **1. 软件故障定位** 在程序调试中，软件故障定位是一项繁琐且耗时的工作，以查找程序错误和错误。 Agrawal等。 [1995]提出了一种将DFT和执行切片结合在一起以实现更有效的故障定位的新颖方法。他们的工作基于这样一个假设，即错误在于测试用例的一部分，该部分无法执行而不是成功执行。结果，测试人员可以将语句集中在失败的片段上。称为ATAC的数据流测试工具[Horgan and London 1992]用于生成数据流测试。这些测试后来被用来检测种子故障并从Unix排序程序中计算执行片段。他们发现数据流测试可以有效地检测出那些种子错误，并且骰子可以显着提高故障定位性能。 Santelices等。 [2009]提出了一种轻量级的故障定位技术，该技术使用不同的覆盖标准来检测程序中的可疑错误语句。在他们的方法中，他们使用针对轻量级覆盖实体（包括语句，分支和def-use对）的测试来调查不同覆盖类型在故障定位中的好处。研究表明，通过不同的覆盖类型可以发现不同的故障，但是将这些不同的覆盖类型进行组合可以实现总体最佳性能。 **2. Web应用测试** 近年来，网络应用的快速发展丰富了人们的日常生活。但是，当体系结构和实现变得越来越复杂时，测试Web应用程序将变得艰巨。已经做出了一些努力来针对Web应用程序进行数据流测试。 由于Web应用程序中的数据可以存储在HTML文档中，因此可能会影响服务器和客户端之间的数据交互。刘等。 [2000]扩展了DFT方法用于Web应用程序，以检查此类数据交互的正确性。在他们的方法中，他们提出了一个Web应用程序测试模型来描述被测应用程序，并提出了一种DFT结构模型来捕获数据流信息。在WATM中，应用程序中的每个部分都将被建模为一个对象，该对象可以是HTML文档的客户端页面，Common GatewayInterface脚本的服务器页面以及Java applet或ActiveX工具的组件等等。这些模型中的每个模型都由属性和操作组成，以存储基本信息。 DFT结构模型使用四个流程图来捕获相关的数据流信息。在获得数据流信息之后，将生成测试用例以涵盖对象内，对象间和客户间方面。通过这种方式，DFT被扩展为测试Web应用程序。 Qi等。[2006]开发了一种基于多重代理的DFT方法来测试Web应用程序。他们将测试任务分为三个级别：方法级别，对象级别和对象群集级别。这些级别的每个测试代理将构建一个带有数据流信息的相应程序模型。数据流测试的整个任务可以分为子任务，并由这些测试代理执行。 Mei等。 [2008]利用DFT测试面向服务的工作流应用程序，例如WS-BPEL应用程序。他们发现XPath在工作流集成中起着重要作用，但可能包含从XML消息中提取的错误数据，这破坏了这些应用程序的可靠性。因此，他们将XPath重写图开发为一种数据结构，以对WS-BPEL中的XPath进行建模。然后，他们从概念上确定了XRG中的def-use对，并提出了一组数据流测试标准来测试WS-BPEL应用程序。 Alshahwan和Harman [2012]提出了一种基于状态的DFT技术用于Web应用程序，该技术会生成HTTP请求的新序列，以增强现有测试套件的覆盖范围和故障检测。新测试旨在执行状态变量（例如，会话变量）的定义，并确保这些值不变地达到相应的用途。他们发现，结果测试套件确实可以提高测试套件的质量。 **3. 规格一致性检查** 在软件开发中广泛使用各种规范模型来构建可靠的系统，这有助于自动生成一致的实现。因此，**检查模型的一致性**是确保实现正确性的重要手段。 Wang和Cavarra [2009]提出了一种基于DFT的方法来检查需求模型的一致性。该方法可以概括为四个过程： （1）根据系统需求构建需求模型；（2）构建相关的调用序列以覆盖这些模型中的方法间用法；（3）从这些调用序列中获取布尔约束，并得出测试套件；（4）检查模型con -通过应用基于DFT的测试套件来保持一致性。此外，开发人员可以通过检查此测试套件将其最初的理解与要求进行比较。 还有一些工作可以从诸如SDL（规范和描述语言）之类的规范模型中生成基于数据流的测试套件。 2000]和状态图[Hong等。 2000]。生成的测试套件提供了测试实现是否符合高级规范模型的功能。 **4. 其他应用** DFT也已应用于测试其他程序或应用程序。 Zhao [2003]使用DFT**测试面向方面的程序**。 Harrold和Malloy [1992]使用DFT**检查并行化的代码**。 DFT也已应用于**测试面向对象的库**[Chatterjee and Ryder 1999]和**服务编排**[Mei等。 2009]。 此外，我们调查了已应用DFT的每种语言的百分比（如图11所示）。我们可以观察到以下情况：首先，DFT最初应用于过程语言（例如Fortran，Pascal，C），但是近年来，面向对象的程序得到了更多的重视，因为DFT可以在检查对象状态时帮助发现更多细微的错误。。其次，在执行数据流测试时，面向对象的语言（例如C ++和Java）是最受欢迎的语言。第三，规范语言和Web服务也吸引了研究兴趣。 图12显示了1990年以来出版物每年报告的评估程序数量（我们在1990年之前省略了论文，因为它们主要关注理论和形式分析）。我们可以观察到（1）DFT在在过去的10年中，受评估程序的数量不断增加，并且（2）DFT逐渐应用于除实验室程序之外的实际程序。此外，我们发现数据流分析和覆盖跟踪技术（最大规模为200KLOC）比测试生成技术（最大规模为15KLOC）具有更高的可扩展性。这表明需要更多的研究工作来缩小这一差距。 **八、新见解和未来工作** 本节介绍了我们在此次调查中获得的新见解。遵循DFT的三个基本测试过程，即数据流分析，测试数据生成和覆盖率跟踪，我们建议以下未来研究方向。 **数据流分析：数据流分析负责识别使用定义对** 1234(1) 为了更好地涵盖测试目标，可以将已知的静态数据流分析技术与动态数据流分析技术相结合[Denaro等。2014、2015]，并在可扩展性和精度之间取得平衡。(2) 数据流分析过程可以利用抵押物覆盖的概念来推断在def-use对本身之间或在def-use对与其他程序结构（例如，语句和分支）之间的覆盖关系。目的是确定对最小的对，其覆盖范围暗示其他对的覆盖范围，以便数据流测试可以专注于这些关键对，从而可以降低测试成本。(3) 数据流分析技术的类型应根据测试方案确定。例如，对于单元测试，可以使用传统的详尽数据流分析。但是对于回归测试或集成测试，需求驱动的数据流分析技术更合适，因为它可以避免不必要的开销。(4) 可以开发新的数据流分析技术并将其适应于不同的编程语言。例如，过程语言和面向对象语言在def-use对的构造上有很大不同。 **测试数据生成：测试数据的生成旨在有效地为def-use对生成合适的测试用例。** 1234(1) 可以组合各种动态测试方法，包括随机测试，基于遗传/优化的测试和基于符号执行的测试，以满足定义使用对。尽管它们无法处理不可行的配对，但它们在测试生成方面具有不同的优势。(2) 基于模型检查的方法可用于补充动态测试方法。它可以为可行的de-use对生成测试，并处理不可行对的一部分。可以将成对的测试需求转换为可接受的模型检查器形式，然后可以使用模型检查器检查路径可行性并作为测试用例输出反例。(3) 基于符号执行的方法在基于路径的测试生成中有效，但面临路径爆炸问题，而模型检查方法（CEGAR）在检查路径可行性时有效。结果，CEGAR的运行时信息可以通知符号执行，从而避免不必要的路径探索并提高其在DFT中的性能。(4) 基于搜索和基于符号执行的测试技术的结合已经被用于实现更有效的分支测试[Inkumsah and Xie 2008; Baars等。 2011]。它们的组合也可以改善DFT。 **覆盖范围跟踪：可以提出有效的覆盖率跟踪** 123算法来提高大型现实系统中数据流测试的可用性。可以采用诸如BA算法[de Araujo and Chaim 2014]之类的仪器方法。基于前面提到的新见识和研究方向，可以提出一种新颖的混合数据流测试框架（如图13所示）以实现更实用的数据流测试。它由三个基本组件组成：数据流分析仪，测试数据生成器和覆盖率监视器。给定一个程序作为输入，此混合框架（1）输出用于可行测试目标的测试数据，（2）消除不可行的测试目标。它介于动态测试方法和静态模型检查器之间，以最大化数据流覆盖范围。希望它可以通过结合其组件方法的优势来获得更好的性能，并从数据流分析，测试数据生成和覆盖范围跟踪的未来发展中受益。此外，该框架可以从两个方面促进DFT研究。一种是在更公平的基础上评估和比较不同的测试技术。另一个是对更多实际程序执行数据流覆盖率测试，以更深入地了解其有效性和复杂性[Namin和Andrews 2009； Inozemtseva和Holmes，2014年]。此外，未来的研究工作可能会努力开发新的具有成本效益的覆盖标准，以补充数据流覆盖标准。新标准应该易于执行，并且具有与DFT相当的故障检测能力（例如，Hassan和Andrews [2013]和Li等人[2013]）。数据流覆盖标准也可以扩展到各种测试场景（例如，面向对象的系统，Web应用程序和移动应用程序），以检查数据操作的正确性。 **九、结论** 在过去的40年中，数据流测试已经得到越来越广泛的研究。鉴于其检查数据交互的能力，已开发出各种方法和技术来追求高效和自动化的数据流测试。据我们所知，这是第一个针对数据流测试的系统调查。我们已经建立了包含97篇研究论文的出版物资料库，展示了研究的现状，并提供了该领域的综合分析。我们将基于数据流的测试生成方法分为五类。对于每个类别，我们都解释了其技术原理并讨论了其优缺点。技术还概述了覆盖跟踪和数据流分析。基于此调查，我们提出了新的见解和未来的研究方向，旨在使DFT更加有效和实用。 1ps: 覆盖率是如何计算的","categories":[{"name":"论文","slug":"论文","permalink":"http://nlbyd1119.online/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://nlbyd1119.online/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"version-control","slug":"version-control","date":"2020-03-26T13:31:48.000Z","updated":"2020-05-29T00:24:35.970Z","comments":true,"path":"2020/03/26/version-control/","link":"","permalink":"http://nlbyd1119.online/2020/03/26/version-control/","excerpt":"版本控制工具","text":"版本控制工具 gitsvn","categories":[{"name":"版本控制工具","slug":"版本控制工具","permalink":"http://nlbyd1119.online/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"通用","slug":"通用","permalink":"http://nlbyd1119.online/tags/%E9%80%9A%E7%94%A8/"}]},{"title":"android基本概念（六）","slug":"a-study-6","date":"2020-03-25T13:07:46.000Z","updated":"2020-09-12T06:15:50.212Z","comments":true,"path":"2020/03/25/a-study-6/","link":"","permalink":"http://nlbyd1119.online/2020/03/25/a-study-6/","excerpt":"安卓常用画图类","text":"安卓常用画图类 一、概述 123• Bitmap：相当于我们绘制出来的图像，获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Paint：相当于我们绘图所用的画笔，绘制几何，文本，位图的风格与颜色信息。• Canvas：相当于我们绘图所用的画布，调用方法进行图像绘制。 二、BITMAP1.作用 123• Bitmap在Android中指的是一张图片，可以是png，也可以是jpg等其他图片格式。• Bitmap是Android系统中的图像处理中最重要类之一。Bitmap可以获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。• Bitmap是一个final类，因此不能被继承。Bitmap只有一个构造方法，且该构造方法是没有任何访问权限修饰符修饰，也就是说该构造方法是friendly。 2.内部枚举类 123456789101112• Bitmap中有两个内部枚举类：• Config是用来设置颜色配置信息的。• CompressFormat是用来设置压缩方式的。• Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。• Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。• Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。• Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。• Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是\".jpg\"或者\".jpeg\"，是一种有损压缩。• Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是\".png\"，是一种无损压缩。• Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是\".webp\"，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。 3.构造 1234567891011121314151617• Bitmap的类构造函数是私有的，因此不能直接通过构造方法实例化。• 一般利用Bitmap的静态方法createBitmap()和BitmapFactory的decode系列静态方法创建Bitmap对象。• BitmapFactory类提供了4类方法用来加载Bitmap：• decodeFile()：从文件系统加载。• String sd_patch= “/sdcard/test.png”;• Bitmap bm= BitmapFactory.decodeFile(sd_path);• decodeResource()：以R.drawable.xxx的形式从本地资源中加载。• Bitmap bm = BitmapFactory.decodeResource(this.getContext().getResources(), R.drawable.pop);• decodeStream()：从输入流加载。• FileInputStream = new FileInputStream(“/sdcard/test.png”);• Bitmap bm= BitmapFactory.decodeStream(fis);• decodeByteArray()：从字节数组中加载。• Bitmap bm = BitmapFactory.decodeByteArray(myByte,0,myByte.length); 二、PAINT1.构造 1234567• Paint有3个构造方法，可以通过这3个构造方法创建Paint对象：• Paint()：用默认设置创建一个Paint对象。• Paint(int flags)：用特殊标记创建一个Paint对象：• Paint.FILTER_BITMAP_FLAG：使位图过滤的位掩码标志。• Paint.ANTI_ALIAS_FLAG：使位图抗锯齿的标志。• Paint.DITHER_FLAG：使位图进行有利的抖动的位掩码标志。• Paint(Paint paint)：用指定Paint对象的参数初始化一个新的Paint对象。 2.常用方法 123456789101112131415161718192021• Paint常用方法：• setARGB(int a, int r, int g, int b)：设置画笔颜色。• setAntiAlias(booleanaa)：设置是否抗锯齿。• setColor(int color)：设置画笔颜色。• setAlpha(int a)：设置画笔透明度。• setTextSize(float textSize)：设置字体大小。• setUnderlineText(booleanunderlineText)：设置文本带有下划线效果。• setStrikeThruText(booleanstrikeThruText)：设置文本带删除线效果。• setTextSkewX(float skewX)：设置文本倾斜度。• setTextScaleX(float scaleX)：设置文本缩放大小。• setTextAlign(Paint.Alignalign)：设置文本对齐方式。• setTypeface(Typeface typeface)：设置字体。• setStyle(Paint.Stylestyle)：设置画笔样式，画笔样式有3种：Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图• Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图• Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框，从表面看它画出来的也是实心图，不过比一般画出来的实心图多了一层外边框。• setStrokeWidth(float width)：设置画笔外边框的宽度，可以想象成画笔“画出线条的宽度”。• setXfermode(Xfermodexfermode)：设置图像重叠时的处理方式。• setShader(Shadershader)：设置着色器。• setPathEffect(PathEffecteffect)：设置或者清除路径效果。 三、CANVAS1.概述 123456• Canvas拥有“绘制”调用，可以调用方法进行图像绘制。• 画图时需要4个基本元素：• 拥有像素的Bitmap。• 可以进行绘制调用的Canvas。• 图元（比如：Rect, Path, text, Bitmap）。• 描述风格与颜色的Paint。 2.构造 123• Canvas有两个构造方法，可以通过这两个构造方法创建Canvas对象：• Canvas()：创建一个空的Canvas对象。• Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象。 3.常用方法 12345678910111213141516• drawARGB()：用指定ARGB颜色填充画布上面的位图• drawRGB()：用指定RGB颜色填充画布上面的位图• drawColor()：用指定颜色填充画布上面的位图• drawArc()：画圆弧• drawBitmap()：画位图• drawCircle()：画圆• drawLine()：画直线• drawLines()：画折线• drawOval()：画椭圆• drawRect()：画矩形• drawRoundRect()：画圆角矩形• drawPoint()：画点• drawPoints()：画一组点• drawPath()：画路径• drawText()：画文本 ANIMATION一、概述Android Animation分为两类 12• 传统动画：包括帧动画（Frame Animation）和补间动画（Tween Animation），又称为DrawableAnimation和View Animation。• 属性动画（Property Animation）。 二、传统动画Frame Animation 123• Frame Animation（DrawableAnimation）是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源。• Frame Animation的原理是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果。• 这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。 TweenAnimation 12345678910111213141516171819202122232425262728293031323334• TweenAnimation（View Animation）可以在一个视图容器内执行一系列简单变换。譬如，有一个TextView对象，可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。• TweenAnimation 具体有4种形式：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。• 补间动画通过XML或Android代码定义，建议使用XML文件定义，因为它更具可读性、可重用性。--------------------关于配置anime--------------------相关类名：• AlphaAnimation：渐变透明度动画效果，对应XML中的&lt;alpha&gt;，放置在res/anim/目录。• RotateAnimation：画面转移旋转动画效果，对应XML中的&lt;rotate&gt;，放置在res/anim/目录。• ScaleAnimation：渐变尺寸伸缩动画效果，对应XML中的&lt;scale&gt;，放置在res/anim/目录。• TranslateAnimation：画面转换位置移动动画效果，对应XML中的&lt;translate&gt; 放置在res/anim/目录。• AnimationSet：一个持有其它动画元素alpha、scale、translate、rotate或者其它set元素的容器，对应XML中的&lt;set&gt;，放置在res/anim/目录。Animation属性：• android:detachWallpaper：是否在壁纸上运行，对应setDetachWallpaper(boolean)。• android:duration：动画持续时间，毫秒为单位，对应setDuration(long)。• android:fillAfter：控件动画结束时是否保持动画最后的状态，对应setFillAfter(boolean) 。• android:fillBefore：控件动画结束时是否还原到开始动画前的状态，对应setFillBefore(boolean)。• android:fillEnabled：与android:fillBefore效果相同，对应setFillEnabled(boolean) 。• android:interpolator：设定插值器（指定的动画效果，譬如回弹等），对应setInterpolator(Interpolator)。• android:repeatCount：重复次数，对应setInterpolator(Interpolator)。• android:repeatMode：重复类型有两个值，reverse表示倒序回放，restart表示从头播放，对应setInterpolator(Interpolator) 。• android:startOffset：调用start函数之后等待开始运行的时间，单位为毫秒，对应setStartOffset(long)。• android:zAdjustment：表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal ，对应setZAdjustment(int)。• Interpolator 主要作用是可以控制动画的变化速率，就是动画进行的快慢节奏：• @android:anim/accelerate_decelerate_interpolator：动画始末速率较慢，中间加速。• @android:anim/accelerate_interpolator：动画开始速率较慢，之后慢慢加速。• AnticipateInterpolator@android:anim/anticipate_interpolator开始的时候从后向前甩。• @android:anim/anticipate_overshoot_interpolator类似上面AnticipateInterpolator。• @android:anim/bounce_interpolator：动画结束时弹起。• @android:anim/cycle_interpolator：循环播放速率改变为正弦曲线。• @android:anim/decelerate_interpolator：动画开始快然后慢。• @android:anim/linear_interpolator：动画匀速改变。• @android:anim/overshoot_interpolator：向前弹出一定值之后回到原来位置。 逐帧动画&amp; 补间动画存在一定的缺点： 123• 作用对象局限。有些情况下的动画效果只是视图的某个属性&amp; 对象而不是整个视图。• 没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，而不会真正去改变View的属性。• 动画效果单一。补间动画只能实现平移、旋转、缩放&amp; 透明度这些简单的动画需求，一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现。 三、属性动画（Property Animation） 1234• 为了解决补间动画的缺陷，在Android 3.0（API 11）开始，系统提供了一种全新的动画模式：属性动画（Property Animation）。• 作用对象：任意Java 对象，不再局限于视图View对象。• 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放&amp; 透明度。• 工作原理：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。 四、ANIMATION LISTENER 12345678910• anim.setAnimationListener(new AnimationListener() &#123;• @Override• public void onAnimationCancle(Animation animation) &#123;…&#125;• @Override• public void onAnimationStart(Animation animation) &#123;…&#125;• @Override• public void onAnimationRepeat(Animation animation) &#123;…&#125;• @Override• public void onAnimationEnd(Animation animation) &#123;…&#125;• &#125;); MEDIAPLAYER一、功能与设置源 123456789101112• Android可以通过Mediaplayer类提供的API，实现以下音频、视频文件的播放：• 自带resource资源：MediaPlayer.create(this, R.raw.test);• SD卡或其他文件路径下的媒体文件：mp.setDataSource(“/sdcard/test.mp3”);• 网络媒体文件：mp.setDataSource(\"http://www.citynorth.cn/music/confucius.mp3\");• setDataSource一共四个方法：• setDataSource(String path) ；//文件系统路径• setDataSource(FileDescriptorfd)；//assets文件• setDataSource(Context context, Uri uri)；//网络虚拟路径• setDataSource(FileDescriptorfd, long offset, long length)；• 若URI中包含网络资源，需在AndroidManifest.xml中申请Internet访问权限：• &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 二、生命周期 123456789101112• Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。• End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。• Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。• Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。• Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。MediaPlayer准备资源调用prepare()时，会执行一段稍长的时间，因为它在解码媒体数据，如果解码时间过长那么会出现主线程阻塞，从而触发ANR异常，导致程序运行很慢，所以框架提供了prepareAsync()异步准备方法并提供资源准备监听，当资源准备完成会触发MediaPlayer.OnPreparedListener的onPrepared()方法。• Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。• PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。• Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。• 通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。 三、常用方法 123456789101112131415161718192021• int getCurrentPosition()：获取当前播放的位置。• int getAudioSessionId()：返回音频的session ID。• int getDuration()：得到文件的时间。• TrackInfo[] getTrackInfo()：返回一个track信息的数组。• booleanisLooping()：是否循环播放。• booleanisPlaying()：是否正在播放。• void pause ()：暂停。• void start ()：开始。• void stop ()：停止。• void prepare()：同步的方式装载流媒体文件。• void prepareAsync()：异步的方式装载流媒体文件。• void reset()：重置MediaPlayer至未初始化状态。• void release ()：回收流媒体资源。• void seekTo(int msec)：指定播放的位置（以毫秒为单位时间）。• void setAudioStreamType(intstreamtype)：指定流媒体类型。• void setLooping(booleanlooping)：设置是否单曲循环。• void setNextMediaPlayer(MediaPlayernext)：当这个MediaPlayer播放完毕后，MediaPlayernext开始播放。• void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。• void setScreenOnWhilePlaying(Boolean screenOn)：播放时是否保持屏幕常亮，是否阻止屏幕自动休眠。 四、展示控件–SurfaceView 1234567• View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms。在一些需要频繁刷新，执行很多逻辑操作的时候，超过了16ms，就会导致卡顿.• SurfaceView继承自View，但拥有独立的绘制表面，即它不与其宿主窗口共享同一个绘图表面，可以单独在一个线程进行绘制，并不会占用主线程的资源。这样，绘制就会比较高效，游戏，视频播放，还有最近热门的直播，都可以用SurfaceView。SurfaceView和View的区别：• View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新。• View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面的刷新。• View在绘图时没有使用双缓冲机制，而SufaceView在底层实现机制中就已经实现了双缓冲机制。","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"a-case-1","slug":"a-case-1","date":"2020-03-24T10:20:37.000Z","updated":"2020-05-29T00:23:50.506Z","comments":true,"path":"2020/03/24/a-case-1/","link":"","permalink":"http://nlbyd1119.online/2020/03/24/a-case-1/","excerpt":"数据库记事本","text":"数据库记事本 一、系统分析二、系统设计1.系统目标2.系统功能结构3.系统业务流程三、系统实施1.开发及运行环境2.项目创建3.项目工程结构4.主界面实现（1）导航界面布局activity_menu.xml（2）编辑界面布局activity_note_edit.xml（3）列表页面布局activity_note_list.xml5.逻辑实现（1）菜单MenuActivity.java（2）MainActivity.java（3）（4）数据库NoteDBAdapter类 数据库设计 类实现","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"jsp-study-1","slug":"jsp-study-1","date":"2020-03-24T02:40:57.000Z","updated":"2020-05-29T00:23:57.423Z","comments":true,"path":"2020/03/24/jsp-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/03/24/jsp-study-1/","excerpt":"第一章 JSP简介","text":"第一章 JSP简介 一、什么是JSP 123+ JSP是Java Server Pages的缩写，是由Sun公司倡导、许多公司参与，于1999年推出的一种动态网页技术标准。+ JSP是基于Java Servlet以及整个Java体系的Web开发技，利用这一技术可以建立安全、跨平台的先进动态网站。+ JSP和ASP技术非常相似，ASP的编程语言是VBScript和JavaScript，JSP使用的是Java。与ASP相比，JSP以Java技术为基础，又在许多方面做了改进，具有动态页面与静态页面分离，能够脱离硬件平台的束缚，以及编译后运行等优点，完全克服了ASP的脚本级执行的缺点。 二、JSP页面 12+ 在传统的HTML页面文件中加入java程序片和JSP标签就构成了一个JSP页面文件,简单地说，一个JSP页面除了普通的HTML标记符外，再使用标记符号“&lt;%”，“%&gt;”加入Java程序片。+ 一个JSP页面文件的扩展名是jsp，文件的名字必须符合标识符规定，需要注意的是，JSP技术基于Java语言，名字区分大小写。 123456789101112&lt;%@ page contentType=\"text/html;charset=GB2312\" %&gt;&lt;HTML&gt;&lt;BODY BGCOLOR=cyan&gt;&lt;h3&gt;这是一个简单的JSP页面&lt;/h3&gt;&lt;% int i, sum = 0;for(i= 1; i &lt;= 100;i++)&#123;sum = sum+i;&#125;%&gt;&lt;h5&gt; 1到100的连续和是：&lt;% = sum %&gt; &lt;/h5&gt;&lt;/BODY&gt;&lt;/HTML&gt; 三、JSP的运行原理1.当服务器上的一个JSP页面被第一次请求执行时，服务器上的JSP引擎首先将JSP页面文件转译成一个java 文件，再将这个java 文件编译生成字节码文件，然后通过执行字节码文件响应客户的请求，而当这个JSP页面再次被请求执行时，JSP引擎将直接执行这个字节码文件来响应客户，这也是JSP比ASP速度快的一个原因。 1JSP -- java -- 字节码 2.JSP页面的首次执行往往由服务器管理者来执行。这个字节码文件的主要工作是： 1234(1) 把JSP页面中普通的HTML标记符号（页面的静态部分）交给客户的浏览器负责显示。 (2) 执行“&lt;%”和“%&gt;”之间的java 程序片（JSP页面中的动态部分），并把执行结果交给客户的浏览器显示。 (3) 当多个客户请求一个JSP页面时，JSP引擎为每个客户启动一个线程而不是启动一个进程，这些线程由JSP引擎服务器来管理，与传统的CGI为每个客户启动一个进程相比较，效率要高的多。 (4) 当多个客户请求一个JSP页面时，Tomcat服务器为每个客户启动一个线程，该线程负责执行常驻内存的字节码文件来响应相应客户的请求。这些线程由Tomcat服务器来管理，将CPU的使用权在各个线程之间快速切换，以保证每个线程都有机会执行字节码文件 3.jsp编译生成的java文件解析四、安装配置JSP运行环境 环境 Web服务目录 五、JSP与Java Servlet的关系 123+ Java Servlet是Java 语言的一部分，提供了用于服务器编程的API。Java Servlet就是编写在服务器端创建对象的Java类，习惯上称之为Servlet类，Servlet类的对象习惯上称之为一个servlet。+ JSP技术就是以JavaServlet为基础，提供了JavaServlet的几乎所有好处，当客户请求一个JSP页面时，Tomcat服务器自动生成Java文件（如first1$jsp.java）、编译Java文件，并用编译得到的字节码文件在服务器端创建一个servlet。但是JSP技术不是Java Servlet技术的全部，它只是JavaServlet技术的一个成功应用。+ 对于某些Web应用，就可能需要JSP+Javabean+servlet来完成，即需要服务器再创建一些servlet对象，配合JSP页面来完成整个Web应用程序的工作。 第二章 JSP语法一、JSP页面的基本结构在传统的HTML页面文件中加入Java程序片和JSP标签，就构成了一个JSP页面。JSP页面可由5种元素组合而成： 12345①普通的HTML标记符；②JSP标记，如指令标记、动作标记；③变量和方法的声明；④Java程序片；⑤Java表达式 二、变量和方法的声明声明变量（类变量，所有用户共享） 1234567在“&lt;%!”和“%&gt;”标记符号之间声明变量和方法。在“&lt;%!”和“%&gt;”标记符之间声明变量，即在“&lt;%!”和“%&gt;”之间放置Java的变量声明语句。变量的类型可以是Java语言允许的任何数据类型，将这些变量称为JSP页面的成员变量。“&lt;%!”和“%&gt;”之间声明的变量在整个JSP页面内都有效，与“&lt;%!”、“%&gt;”标记符在JSP页面中所在的书写位置无关。JSP引擎将JSP页面转译成Java文件时，将“&lt;%!”、“%&gt;” 标记符之间声明的变量作为类的成员变量，这些变量占有的内存空间直到JSP引擎关闭才释放。当多个用户请求一个JSP页面时，JSP引擎为每个用户启动一个线程，这些线程由JSP引擎来管理，这些线程共享JSP页面的成员变量，因此任何一个用户对JSP页面成员变量操作的结果，都会影响到其他用户。 定义方法（类方法） 123在“&lt;%!”和“%&gt;”标记符号之间定义方法，所定义的方法在整个JSP页面有效，可以在Java程序片中被调用。方法内声明的变量只在该方法内有效，当方法被调用时，方法内声明的变量被分配内存，方法被调用完毕即可释放这些变量所占的内存。 三、Java程序片 123456789在“&lt;%”和“%&gt;”之间插入Java程序片。一个JSP页面可以有许多程序片,这些程序片将被JSP引擎按顺序执行。程序片中声明的变量称为JSP页面的局部变量。多个客户请求一个JSP页面时,Java程序片将被执行多次，分别在不同的线程中执行。如果一个用户在执行Java程序片时调用JSP页面的方法操作成员变量，可能不希望其他用户也调用该方法操作成员变量，以免对其产生不利的影响,那么就应该将操作成员变量的方法用synchronized关键字修饰。一个JSP页面中的Java程序片会按其在页面中的顺序被执行,而且某个Java程序片中声明的局部变量在其后继的所有Java程序片以及表达式部分内都有效。利用Java程序片的这个性质,有时候可以将一个Java程序片分割成几个Java程序片,然后在这些Java程序片之间再插入其他标记元素。 四、Java表达式 12345可以在“&lt;%=”和“%&gt;”之间插入一个表达式，这个表达式必须能求值。表达式的值由服务器负责计算，并将计算结果用字符串形式发送到用户端显示。注意：不可插入语句，“&lt;%=”是一个完整的符号，“&lt;%”和“=”之间不要有空格在JSP页面中，表达式的值被表示成一个字符串的形式，即Tomcat引擎将表达式的结果转换成字符串，然后发送给用户的浏览器。因此，在编写JSP页面时，要把Java表达式按普通的文本来使用。 五、JSP中的注释注释可以增强JSP页面的可读性，使JSP页面易于维护。JSP页面中的注释可分为两种。（1）HTML注释 12在标记符号“&lt;!--”和“--&gt;”之间加入注释内容：&lt;!-- 注释内容 --&gt;JSP引擎把HTML注释交给用户，因此用户通过浏览器查看JSP页面的源文件时，能够看到HTML注释。 （2）JSP 注释 12在标记符号“&lt;%--”和“--%&gt;”之间加入注释内容：&lt;%-- 注释内容--%&gt;JSP引擎忽略JSP注释，即在编译JSP页面时忽略JSP注释。 六、JSP 指令标记1.page 指令标记 page指令用来定义整个JSP页面的一些属性和这些属性的值，属性值用单引号或双引号括起来。可以用一个page指令指定多个属性的值,也可以使用多个page指令分别为每个属性指定值。 page指令的作用对整个JSP页面有效，与其书写的位置无关，习惯把page指令写在JSP页面的最前面。 page 指令标记可以指定如下属性的值contentType、import、language、session、buffer、auotFlush、isThreadSafe. （1）contentType属性 123456当用户请求一个JSP页面时，Tomcat服务器负责解释执行JSP页面，并将某些信息发送到用户的浏览器，以便用户浏览这些信息。Tomcat服务器同时负责通知用户的浏览器使用怎样的方法来处理所接收到的信息。contentType 属性值确定JSP 页面响应的MIME（MultipurposeInternetMailExtention）类型和JSP页面字符的编码。属性值的一般形式是\"MIME类型”或\"MIME类型;charset=编码\"如果不使用page指令为contentType指定一个值，那么contentType属性的默认值是\"text/html ; charset=ISO-8859-1“注：不允许两次使用page 指令给contentType属性指定不同的属性值contentType类型对照表（2）language属性 123language属性定义JSP页面使用的脚本语言，该属性的值目前只能取\"java\"。例如:&lt;%@pagelanguage=\"java\"%&gt;注：JSP页面默认有如上page指令。 （3）import属性 12345该属性的作用是为JSP页面引入Java运行环境提供的包中的类，这样就可以在JSP页面的程序片部分、变量及函数声明部分、表达式部分使用包中的类。使用page指令可以为import属性指定多个值，这些值用逗号分隔。该属性的值可以是某包中的所有类或一个具体的类。注：JSP页面默认import属性已经有\" java.lang.*\"、\"javax.servlet.*\"、\"javax.servlet.jsp.*\"、\"javax.servlet.http.*\"等值。 （4）session属性 123session 属性用于设置是否需要使用内置的session对象。session的属 性 值可 以 是true或false。session属性默认的属性值是true。 （5）buffer属性 12345内置输出流对象out负责将服务器的某些信息或运行结果发送到用户端显示。buffer属性用来指定out设置的缓冲区的大小或不使用缓冲区。例如：&lt;%@ page buffer= \"24kb\" %&gt;buffer属性的默认值是8kb。buffer属性可以取值\"none\"，即设置out不使用缓冲区。 （6）autoFlush属性 1234autoFlush 属性指定out的缓冲区被填满时，缓冲区是否自动刷新。autoFlush可以取值true或false。autoFlush属性的默认值是true。当autoFlush属性取值false时，如果out的缓冲区填满，就会出现缓存溢出异常。当buffer的值是\"none\"时，autoFlush的值就不能设置成false （7）isThreadSafe属性 12345isThreadSafe属性用来设置JSP页面是否可多线程访问。isThreadSafe的属性值可取true或false。当isThreadSafe属性值设置为true时，JSP页面能同时响应多个用户的请求；当isThreadSafe属性值设置成false时，JSP页面同一时刻只能响应一个用户的请求，其他用户须排队等待。isThreadSafe属性的默认值是true。 （8）info属性 123456info属性的属性值是一个字符串，其目的是为JSP页面准备一个常用且可能要经常修改的字符串。例如，&lt;%@page info=\"wearestudents\"%&gt;可以在JSP页面中使用方法：getServletInfo();获取info属性的属性值。注意：当JSP页面被转译成Java文件时，转译成的类是Servlet的一个子类，所以在JSP页面中可以使用Servlet类的方法：getServletInfo()。 2.include 指令标记 语法格式 &lt;%@include file=”文件的URL”%&gt; include指令标记的作用是在JSP页面出现该指令的位置处，静态插入一个文件。 所谓静态插入，就是当前JSP页面和插入的文件合并成一个新的JSP页面，然后JSP引擎再将这个新的JSP页面转译成Java文件。因此，插入文件后，必须保证新合并成的JSP页面符合JSP语法规则，即能够成为一个JSP页面文件。比如，被插入的文件是一个JSP页面，该JSP页面使用page指令为contentType 属性设置了的值：&lt;%@ page contentType=”application/msword”%&gt; 那么，合并后的JSP页面就两次使用page指令为contentType属性设置了不同的属性值，导致出现语法错误。因为JSP页面中的page指令只能为contentType指定一个值。 使用include指令可以实现代码的复用。 七、动作标记动作标记是一种特殊的标记，它影响JSP运行时的功能。1.include 动作标记 include动作标记语法格式为&lt;jsp:include page=&quot;文件的URL&quot;&gt;或&lt;jsp:include page=&quot;文件的URL&quot;&gt;param子标记&lt;/jsp:include&gt; include动作标记告诉JSP页面动态包含一个文件，即JSP页面运行时才将文件加入。 与静态插入文件的include指令标记不同，当JSP引擎把JSP页面转译成Java文件时，不把JSP页面中动作指令include所包含的文件与原JSP页面合并为一个新的JSP页面，而是告诉Java解释器，这个文件在JSP运行时才包含进来。 如果包含的文件是普通的文本文件，就将文件的内容发送到用户端，由用户端的浏览器负责显示；如果包含的文件是JSP文件，JSP引擎就执行这个文件，然后将执行的结果发送到用户端，并由用户端的浏览器负责显示这些结果。 2.param 动作标记 param标记以“名字—值”对的形式为其他标记提供附加信息，param标记不能独立使用，需作为jsp:include、jsp:forward、jsp:plugin标记的子标记来使用。 param动作标记语法格式是：&lt;jsp:param name=&quot;名字&quot;value=&quot;指定给param的值&quot;&gt; 当该标记与jsp:include动作标记一起使用时，可以将param标记中的值传递到include动作标记要加载的文件中去，被加载的JSP文件可以使用Tomcat服务器提供的request内置对象获取include动作标记的param子标记中name属性所提供的值。因此include动作标记通过使用param子标记来处理加载的文件，比include指令标记更为灵活。 3.forward 动作标记 forward动作标记的语法格式是：&lt;jsp:forwardpage=&quot;要转向的页面&quot;/&gt;或&lt;jsp:forwardpage=&quot;要转向的页面&quot;&gt;param子标记 &lt;/jsp:forward&gt; 该指令的作用是：从该指令处停止当前页面的执行，而转向执行page属性指定的JSP页面。需要注意的是，当forward动作标记不需要param子标记时，必须使用第一种形式。 forward标记可以使用param动作标记作为子标记，向转向的页面传送信息。forward动作标记指定的要转向的JSP文件可以使用Tomcat服务器提供的request内置对象获取param子标记中name属性所提供的值。 注意: 当前页面使用forward动作标记转向后，尽管用户看到了转向后的页面的效果，但浏览器地址栏中显示的仍然是转向前的JSP页面的URL地址，因此，如果刷新浏览器的显示，将再次执行当前浏览器地址栏中显示的JSP页面。 4.useBean 动作标记 该标记用来创建并使用一个Javabean，是非常重要的一个动作标记。 Sun公司倡导的是：Javabean负责存储数据，JSP页面显示Javabean中的数据，而servlet负责管理Javabean中的数据。 九、总结➢一个JSP页面可由普通的HTML标记、JSP标记、成员变量和方法的声明、Java程序片和Java表达式组成。JSP引擎把JSP页面中的HTML标记交给用户的浏览器执行显示，负责处理JSP标记、变量和方法，同时负责运行Java程序片、计算Java表达式，并将需要显示的结果发送给用户的浏览器。➢JSP页面中的成员变量是被所有用户共享的变量。Java程序片可以操作成员变量，任何一个用户对JSP页面成员变量操作的结果，都会影响到其他用户。➢如果多个用户访问一个JSP页面，那么该页面中的Java程序片就会被执行多次，分别运行在不同的线程中，即运行在不同的时间片内。运行在不同线程中的Java程序片的局部变量互不干扰，即一个用户改变Java程序片中的局部变量的值不会影响其他用户的Java程序片中的局部变量。➢page指令用来定义整个JSP页面的一些属性和这些属性的值。比较常用的两个属性是contentType和import。page指令只能为contentType指定一个值，但可以为import属性指定多个值。➢include指令标记是在编译阶段就处理所需要的文件，被处理的文件在逻辑和语法上依赖于当前JSP页面，其优点是页面的执行速度快；而include动作标记是在JSP页面运行时才处理文件，被处理的文件在逻辑和语法上独立于当前JSP页面，其优点是可以使用param子标记更灵活地处理所需要的文件。","categories":[{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"}]},{"title":"android基本概念（五）","slug":"a-study-5","date":"2020-03-19T14:20:08.000Z","updated":"2020-03-23T12:12:19.587Z","comments":true,"path":"2020/03/19/a-study-5/","link":"","permalink":"http://nlbyd1119.online/2020/03/19/a-study-5/","excerpt":"Android网络编程基础","text":"Android网络编程基础 一、基于TCP协议的网络通信1.ServerSocket建立服务端 1234567891011121314151617ServerSocket serverSocket = new ServerSocket(8888);while (true) &#123; try &#123; Socket socket = serverSocket.accept(); System.out.println(\"新增连接\" + server.getInetAddress() + \":\" + socket.getPort()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.客户端程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;import java.net.SocketTimeoutException;public class Main2Activity extends AppCompatActivity &#123; private Context context; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; textView = (TextView)findViewById(R.id.textView); new Thread() &#123; @Override public void run() &#123; try &#123; Socket socket = new Socket(\"192.168.1.49\", 9999); socket.setSoTimeout(3000); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String info = br.readLine(); textView.setText(\"Client received: \" + info); br.close(); socket.close(); &#125; catch (SocketTimeoutException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;&#125; 3.服务端程序 12345678910111213141516171819package com.n;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class help1 &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket &#x3D; new ServerSocket(9999); while (true) &#123; Socket socket &#x3D; serverSocket.accept(); OutputStream os &#x3D; socket.getOutputStream(); os.write(&quot;This is Server!&quot;.getBytes(&quot;utf-8&quot;)); os.close(); socket.close(); &#125; &#125;&#125; 二、使用URL访问网络1.访问URL网络资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.widget.ImageView;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ImageView imageView; private Bitmap bitmap; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; imageView = findViewById(R.id.imageView); showPicture(\"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3063886216,124952448&amp;fm=26&amp;gp=0.jpg\"); &#125; public void showPicture(String url) &#123; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; try &#123; URL url = new URL(strings[0]); InputStream is = url.openStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); imageView.setImageBitmap(bitmap); &#125; &#125;.execute(url); &#125;&#125; 2.URLConnection + TomcatJavaWeb服务器端 123456789101112131415161718192021222324252627package servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class LoginServlet extends HttpServlet&#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html; charset=utf-8\"); req.setCharacterEncoding(\"utf-8\"); PrintWriter out = resp.getWriter(); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); if (username.equals(\"admin\") &amp;&amp; password.equals(\"123\")) &#123; out.print(\"登录成功\"); &#125; else &#123; out.print(\"登录失败\"); &#125; out.flush(); out.close(); &#125;&#125; 12345678&lt;servlet&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; URLConnection客户端（访问不成功） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.os.StrictMode;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main4Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main4); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = \"http://10.0.2.2:8080/servlet\"; final String param = \"username=\" + username + \"&amp;\" + \"password=\" + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = null; try &#123; URL url = new URL(strings[0]); URLConnection conn = url.openConnection(); conn.setRequestProperty(\"accept\", \"*/*\"); conn.setRequestProperty(\"connection\", \"Keep-Alive\"); conn.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36\"); conn.setDoInput(true); conn.setDoOutput(true); out = new PrintWriter(conn.getOutputStream()); out.print(param); in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 3.HttpURLConnection客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.example.app_net;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;public class Main5Activity extends AppCompatActivity &#123; private Context context; private EditText editText, editText2; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; editText = findViewById(R.id.editText); editText2 = findViewById(R.id.editText2); textView = findViewById(R.id.textView4); button = findViewById(R.id.button5); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; loginCheck(editText.getText().toString(), editText2.getText().toString()); &#125; &#125;); &#125; private void loginCheck(String username, String password) &#123; final String url = \"http://10.0.2.2:8080/servlet\"; final String param = \"username=\" + username + \"&amp;\" + \"password=\" + password; new AsyncTask&lt;String, Void, String&gt;() &#123; @Override protected String doInBackground(String... strings) &#123; PrintWriter out = null; BufferedReader in = null; String result = \"\"; try &#123; URL url = new URL(strings[0]); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestProperty(\"accept\", \"*/*\"); conn.setRequestProperty(\"connection\", \"Keep-Alive\"); conn.setRequestProperty(\"user-agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36\"); conn.setDoInput(true); conn.setDoOutput(true); conn.setRequestMethod(\"POST\"); conn.setUseCaches(false); out = new PrintWriter(conn.getOutputStream()); out.print(param); out.flush(); out.close(); int responseCode = conn.getResponseCode(); System.out.println(responseCode); if (responseCode == HttpURLConnection.HTTP_OK) &#123; in = new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(String s) &#123; if (s != null) &#123; textView.setText(s); &#125; super.onPostExecute(s); &#125; &#125;.execute(url); &#125;&#125; 4.注意点 123（1）Google在API23之后就不自带HttpClient了，原因是Apache不再维护HttpClient了，官方推荐使用的就是HttpURLConnection。（2）在对Tomcat的servlet进行访问时，暂时发现只有一级路由可以访问到，二级就找不到，原因未明。而且更奇怪的是，通用的路由，URLConnection访问不到，HttpURLConnection可以访问到。（3）Async有警告暂时不处理。 三、WebService 1234浏览器基本功能：地址栏 前进后退刷新 加载本地网页： file:///android_asset/与javascript交互：使用场景为加载本地网页，其中有与系统交互的逻辑网络编程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 private Context context; private WebView wv; private EditText editText; private String url; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; editText = findViewById(R.id.editText); initWeb(); &#125; private void initWeb() &#123; wv = findViewById(R.id.webView); //加载本地网页 wv.loadUrl(\"file:///android_asset/templates/all-admin-index.html\"); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new CustomWebViewClient()); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); //设置可以访问文件 ws.setAllowFileAccess(true); //设置支持缩放 ws.setBuiltInZoomControls(true); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125; //实现地址栏跳转、后退、前进、刷新功能 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; url = editText.getText().toString(); editText.setText(\"\"); if (url != null &amp;&amp; url.length() &gt; 0) &#123; wv.loadUrl(url); &#125; break; &#125; case R.id.button2: &#123; wv.goBack(); break; &#125; case R.id.button3: &#123; wv.goForward(); break; &#125; case R.id.button4: &#123; wv.reload(); break; &#125; &#125; &#125; private class CustomWebViewClient extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;// view.loadUrl(url);// //返回为true是在wv中打开，false则使用其他浏览器// return true; if (url.endsWith(\".apk\")) &#123; return true; &#125; else if (url.startsWith(\"tel:\")) &#123; return true; &#125; else if (url.startsWith(\"mailto:\")) &#123; return true; &#125; else if (url.startsWith(\"baidu\")) &#123; return true; &#125; view.loadUrl(url); return true; &#125; &#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"android基本概念（四）","slug":"a-study-4","date":"2020-03-17T13:30:55.000Z","updated":"2020-03-21T14:33:00.444Z","comments":true,"path":"2020/03/17/a-study-4/","link":"","permalink":"http://nlbyd1119.online/2020/03/17/a-study-4/","excerpt":"CONTENT PROVIDER","text":"CONTENT PROVIDER 一、ContentProvider内容提供者1.概述 123• ContentProvider即内容提供者，是Android四大组件之一。• ContentProvider为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。• Android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等)。 123• ContentProvider提供了对底层数据存储方式的抽象。• Android框架中的一些类需要ContentProvider类型数据。• ContentProvider为应用间的数据交互提供了一个安全的环境。 2.方法 1234567• ContentProvider提供以下方法：• query：查询；• insert：插入；• update：更新；• delete：删除；• getType：得到数据类型；• onCreate：创建数据时调用的回调函数。 3.配置属性 123456789• 授权(android:authorities)：用于在系统内标识整个提供程序的符号名称。• 提供程序类名( android:name)：实现ContentProvider的类。• 启动和控制属性：这些属性决定Android 系统如何以及何时启动提供程序、提供程序的进程特性以及其他运行时设置：• android:enabled：允许系统启动提供程序的标志。• android:exported：允许其他应用使用此提供程序的标志。• android:initOrder：此提供程序相对于同一进程中其他提供程序的启动顺序。• android:multiProcess：允许系统在与调用客户端相同的进程中启动提供程序的标志。• android:process：应在其中运行提供程序的进程的名称。• android:syncable：指示提供程序的数据将与服务器上的数据同步的标志。 二、ContentResolver内容解析者1.概述 12• ContentResolver即内容解析器，程序通过ContentResolver可以访问ContentProvider提供的数据。• 使用ContentResolver对ContentProvider进行增、删、改、查的操作，应用程序开发者不需要知道ContentProvider的内部实现，ContentResolver可统一管理与不同ContentProvider间的操作。 2.URI 123• 每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。• Android所提供的ContentProvider都存放在android.provider包当中。• ContentResolver通过URI来区别不同的ContentProvider。 12345• URI（Universal Resource Identifier, 统一资源定位符）代表要操作的数据，Android上可用的每种资源，图像、视频片段等都可以用URI来表示：• 所有联系人的URI ：content://contacts/people • 某个联系人的URI : content://contacts/people/5 • 所有图片URI : content://media/external • 某个图片的URI：content://media/external/images/media/4 三、案例代码1.自定义UserContentProvider，并用ContentResolver增加和获取数据UserContentProvider.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.example.app_data;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.net.Uri;import android.util.Log;public class UserContentProvider extends ContentProvider &#123; public UserContentProvider() &#123; &#125; //自定义uri private static final String TAG = \"UserContentProvider\"; static final String PROVIDER_NAME = \"com.example.app_data.UserContentProvider\"; static final String URL = \"content://\" + PROVIDER_NAME + \"/user\"; static final Uri CONTENT_URI = Uri.parse(URL); //定义uri匹配码 private static final UriMatcher MATCHER = new UriMatcher(UriMatcher.NO_MATCH); // 若不匹配采用UriMatcher.NO_MATCH(-1)返回 private static final int CODE_NOPARAM = 1; //无参 // 匹配码 private static final int CODE_PARAM = 2; //带参数 //自定义uri匹配模式 static &#123; // 对等待匹配的URI进行匹配操作，com.example.app_data.UserContentProvider/user格式 // 匹配返回CODE_NOPARAM，不匹配返回-1 无参的情况 MATCHER.addURI(\"com.example.app_data.UserContentProvider\", \"user\", CODE_NOPARAM); // #表示数字 com.example.app_data.UserContentProvider/user/10 // 匹配返回CODE_PARAM，不匹配返回-1 有参的情况 MATCHER.addURI(\"com.example.app_data.UserContentProvider\", \"user/#\", CODE_PARAM); &#125; //UserSQLiteOpenHelper中预先建好user表 private UserSQLiteOpenHelper helper; //操作数据库 private final String user_TABLE = \"user\"; //所用表名 @Override public boolean onCreate() &#123; // TODO Auto-generated method stub helper = new UserSQLiteOpenHelper(getContext(), \"userdb\"); //以上下文 和 所用数据库名为参数，此处写死了 return true; &#125; @Override public Uri insert(Uri uri, ContentValues cv) &#123; // TODO Auto-generated method stub Log.i(TAG, \"insert()\"); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; //插入的uri无参才是正确情况 case CODE_NOPARAM: //调用sqlite的插入方法 long id = db.insert(user_TABLE, null, cv); //若主键是自增的，则返回主键值；否则为行号 Uri insertUri = ContentUris.withAppendedId(uri, id); return insertUri; default: throw new IllegalArgumentException(\"This is unknow uri: \" + uri); &#125; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, \"delete()\"); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: //无参删除所有记录 return db.delete(user_TABLE, selection, selectionArgs); //删除所有记录 case CODE_PARAM: //有参删除uri指明的记录 long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = \"_id = \" + id; if(null != selection &amp;&amp; !(selection.trim()).equals(\"\"))&#123; where += \"and \" + selection; &#125; return db.delete(user_TABLE, where, selectionArgs); default: throw new IllegalArgumentException(\"This is unknow uri: \" + uri); &#125; &#125; @Override public int update(Uri uri, ContentValues cv, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub Log.i(TAG, \"update()\"); SQLiteDatabase db = helper.getWritableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.update(user_TABLE, cv, selection, selectionArgs); //更新所有记录 case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = \"_id = \" + id; if(null != selection &amp;&amp; !(selection.trim()).equals(\"\"))&#123; where += \" and \" + selection; &#125; return db.update(user_TABLE, cv, where, selectionArgs); default: throw new IllegalArgumentException(\"This is unknow uri: \" + uri); &#125; &#125; /** * 返回对应的内容类型 * 如果返回集合的内容类型，必须以com.example.android.cursor.dir开头 * 如果是单个元素，必须以com.example.android.cursor.item开头 */ @Override public String getType(Uri uri) &#123; // TODO Auto-generated method stub Log.i(TAG, \"getType()\"); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return \"com.example.android.cursor.dir/user\"; case CODE_PARAM: return \"com.example.android.cursor.item/user\"; default: throw new IllegalArgumentException(\"This is unknow uri: \" + uri); &#125; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String orderBy) &#123; // TODO Auto-generated method stub Log.i(TAG, \"query()\"); SQLiteDatabase db = helper.getReadableDatabase(); switch (MATCHER.match(uri)) &#123; case CODE_NOPARAM: return db.query(user_TABLE, projection, selection, selectionArgs, null, null, orderBy); case CODE_PARAM: long id = ContentUris.parseId(uri); //取得Uri后面的数字 String where = \"_id = \" + id; if(null != selection &amp;&amp; !(selection.trim()).equals(\"\"))&#123; where += \"and \" + selection; &#125; return db.query(user_TABLE, projection, where, selectionArgs, null, null, orderBy); default: throw new IllegalArgumentException(\"This is unknow uri: \" + uri); &#125; &#125;&#125; UserSQLiteOpenHelper.java 123456789101112131415161718192021222324252627package com.example.app_data;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import androidx.annotation.Nullable;public class UserSQLiteOpenHelper extends SQLiteOpenHelper &#123; public UserSQLiteOpenHelper(Context context, String name) &#123; super(context, name, null, 1); &#125; public UserSQLiteOpenHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override //首次创建数据库时调用，一般可写建表建库的操作 public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; sqLiteDatabase.execSQL(\"create table if not exists user (_id integer primary key autoincrement, name text not null, password text not null)\"); &#125; @Override //当数据库的版本发生变化时，会自动执行 public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; &#125;&#125; Activity文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.app_data;import androidx.appcompat.app.AppCompatActivity;import android.content.ContentValues;import android.database.Cursor;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.EditText;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); &#125; //增加用户 public void onClickAddUser(View view) &#123; ContentValues values = new ContentValues(); //以下的字段名是自定义表中写死的字段名，而系统提供的是static final String 需要通过相关provider调用（在里面定义） values.put(\"name\", ((EditText)findViewById(R.id.editText)).getText().toString()); values.put(\"password\", ((EditText)findViewById(R.id.editText2)).getText().toString()); //当前上下文的内容提供者通过uri与指定的provider建立联系 Uri uri = getContentResolver().insert(UserContentProvider.CONTENT_URI, values); Toast.makeText(getBaseContext(), uri.toString(), Toast.LENGTH_LONG * 3).show(); &#125; //获取用户信息 public void onClickRetrieveUser(View view) &#123; Cursor cursor = getContentResolver().query(UserContentProvider.CONTENT_URI , new String[]&#123;\"name\", \"password\"&#125;, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123;// Log.i(\"info\", \"_id:\" + cursor.getInt(cursor.getColumnIndex(\"_id\"))); 此处绝对不能多写id 因为上面的projection就没写id字段，返回结果也不会有 Log.i(\"info\", \"name:\" + cursor.getString(cursor.getColumnIndex(\"name\"))); Log.i(\"info\", \"password:\" + cursor.getString(cursor.getColumnIndex(\"password\"))); &#125; cursor.close(); &#125; &#125;&#125; 2.动态获取权限 SharedPreferences一、概述 12• SharedPreferences对象指向包含键值对的文件并提供读写这些文件的简单方法。每个SharedPreferences文件由框架进行管理并且可以专用或共享。• SharedPreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/&lt;package name&gt;/shared_prefs目录下。 二、保存key-value对 步骤123• 使用Activity类的getSharedPreferences方法获取到SharedPreferences对象，指定文件名和访问权限。• 获得SharedPreferences.Editor对象，并使用该对象的putXXX方法保存key-value对。• 通过SharedPreferences.Editor的commit方法保存（提交）key-value对。 getSharedPreferences(String name, int mode)使用getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法第一个参数为实例名称（不带后缀），第二个参数为操作模式，共四种：1234• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取；• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。 SharedPreferences.Editor1234567891011121314151617• 获取SharedPreferences实例之后，需要创建SharedPreferences.Editor以实现修改功能：• SharedPreferencespref = getSharedPreferences(\"myPref\", MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• 在SharedPreferences.Editor中使用putXXX方法存储键值对，并使用commit方法提交数据：• editor.putString(“name”, “刘全有\");• editor.putInt(\"age\", 25);• editor.putLong(\"time\", System.currentTimeMillis());• editor.putBoolean(\"default\", true);• …• editor.commit();• 使用remove方法删除SharedPreferences实例中某个键值对：• SharedPreferencespref = getSharedPreferences(\"myPref\", MODE_PRIVATE);• SharedPreferences.Editoreditor = pref.edit();• Editor.remove(“name”);• editor.commit(); File一、Android系统文件路径说明Android应用可能访问以下文件系统路径 12345678910111213• /data/app：该文件夹存放着系统中安装的第三方应用的apk文件。Android 中应用的安装就是将应用的安装包原封不动地拷贝到/data/app 目录下，• 每个应用安装包本质上就是一个zip 格式的压缩文件。为了提升应用的启动效率，Android 会将解压出来的dex格式的应用代码文件解析提取后，缓存在/data/dalvik-cache 目录下。• /data/data：该文件夹存放存储包私有数据，对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。• 用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。• /system：通过Environment.getRootDirectory() 访问，该目录下也有一个app 目录，存放的是系统应用的apk文件。• /system/app 和/data/app 的区别为：• /system/app 里的软件获取了所有权限。• /system/app 只能root 后删除。• /system/app 文件夹有大小限制，卸载/system/app 目录下的文件并不会增加系统空间，即可用ROM 空间。• /mnt：这个目录专门用来当作挂载点挂在外部设备，如SD 卡，将会被系统视作一个文件夹，这个文件夹将会被系统嵌入到文件系统的mnt目录中，所以在/mnt目录下也会看到一个sdcard的快捷方式： 二、apk组成1.在Android APK中，除了被编译的代码以外，还可以允许存储两种资源文件： 123res：文件会被映射到R.java文件中，访问的时候直接通过资源ID即可访问，而且不能有目录结构，即不能再创建文件夹。assets：不会映射到R.java文件中，通过AssetManager来访问，能有目录结构，即可以自行创建文件夹。注意：res和assets只能读取，不能修改，每个文件大小不能超过1MB。 2.读文件 123456• 读res资源文件：• InputStreamis = getResources().openRawResource(R.drawable.pop);• 读assets资源文件：• AssetManageram = getAssets(); • InputStreamis = am.open(\"filename\"); 三、data/data 目录对于设备中每一个安装的App，系统都会在内部存储空间的data/data 目录下以应用包名为名字自动创建与之对应的文件夹。 123456789101112用户卸载App 时，系统自动删除data/data 目录下对应包名的文件夹及其内容。该目录下又把存储内容进行了分类：• data/data/包名/cache：存放的APP 的缓存信息。• data/data/包名/databases：存放APP 的数据库信息。• data/data/包名/files：存放APP 的文件信息。• data/data/包名/shared_prefs：存放APP内的SharedPreferences。• 若需要访问内部存储器data/data/包名/路径上的资源文件，可使用FileOutputStream和FileInputStream。• 若需要访问SD卡存储空间，需要先获取READ_EXTERNAL_STORAGE 或WRITE_EXTERNAL_STORAGE系统权限。• 外部存储在Android 文件系统中是sdcard目录，这里只是一个快捷方式，真正的目录是/storage/emulated/legacy 文件夹。• 仅能对data/data/包名/路径上的资源文件使用openFileOutput和openFileInput两个方法，不可进行其他操作。• 在AndroidMainfset.xml中获取SD卡文件写入、创建与删除权限： 四、上下文API 1234567891011121314151617181920212223242526272829303132333435Environment 常用方法：• getDataDirectory()：获取Android 数据目录。• getDownloadCacheDirectory()：获取Android 下载/缓存内容目录。• getExternalStorageDirectory()：获取外部存储目录即SDCard。• getExternalStorageState()：获取外部存储设备的当前状态。• getRootDirectory()：获取Android 的根目录。getExternalStorageState()：获取SD卡存储状态，返回值可能为以下一种：• MEDIA_BAD_REMOVAL：在没有挂载前存储媒体已经被移除。• MEDIA_CHECKING：正在检查存储媒体。• MEDIA_MOUNTED：存储媒体已经挂载，并且挂载点可读/写。• MEDIA_MOUNTED_READ_ONLY：存储媒体已经挂载，挂载点只读。• MEDIA_NOFS：存储媒体是空白或是不支持的文件系统。• MEDIA_REMOVED：存储媒体被移除。• MEDIA_SHARED：存储媒体正在通过USB共享。• MEDIA_UNMOUNTABLE：存储媒体无法挂载。• MEDIA_UNMOUNTED：存储媒体没有挂载。getExternalStoragePublicDirectory(String type)：提供十个公共目录用来存储相对应的文件，返回值如下：• DIRECTORY_MUSIC：/storage/emulated/0/Music• DIRECTORY_PODCASTS：/storage/emulated/0/Podcasts• DIRECTORY_RINGTONES：/storage/emulated/0/Ringtones• DIRECTORY_ALARMS：/storage/emulated/0/Alarms• DIRECTORY_NOTIFICATIONS：/storage/emulated/0/Notifications• DIRECTORY_PICTURES：/storage/emulated/0/Pictures• DIRECTORY_MOVIES：/storage/emulated/0/Movies• DIRECTORY_DOWNLOADS：/storage/emulated/0/Downloads• DIRECTORY_DCIM：/storage/emulated/0/Dcim• DIRECTORY_DOCUMENTS：/storage/emulated/0/DocumentsAndroid2.2 引入了基于扩展存储器的应用缓存目录，该目录指向大容量的扩展存储器。与应用的内存私有目录一样，缓存目录会随着应用的卸载一并删除。• 和内部存储一样，会在SD 卡的Android/data 目录下生成对应包名的文件夹：• getExternalFilesDir(type)：返回/storage/emulated/0/Android/data/包名/files。• getExternalCacheDir()：返回/storage/emulated/0/Android/data/应用包名/cache。• getObbDir()：返回/storage/emulated/0/Android/obb/包名。 五、文件API 1234567891011121314151617181920212223242526272829303132333435363738394041424344对象实例化：• File file= new File (\"/mnt/sdcard/test.txt\");• File file= new File(\"/mnt/sdcard/temp\", \"test.txt\");判断文件是否存在：• file.exists();删除文件：• file.delete();创建文件夹：• file=new File(\"/mnt/sdcard/temp\");• file.mkdir();创建文件：• File file= new File (\"/mnt/sdcard/temp/test.txt\");• file.createNewFile();• booleanisDirectory() ：测试此File对象表示的文件是否是目录。• booleanmkdirs() ：创建包括父目录的目录。• String getAbsolutePath()：返回此对象表示的文件的绝对路径名。• String getName() ：返回此对象表示的文件的名称。• String getParent() ：返回此File对象的路径名的上一级,若路径名没有上一级，则返回null。• openFileOutput(String name,intmode);打开应用程序私有目录下的指定私有文件以写入数据，返回一个FileOutputStream对象，如果文件不存在就创建这个文件。• openFileInput(String fileName); 打开应用程序私有目录下的指定私有文件以读入数据，返回一个FileInputStream对象。openFileOutput()方法的第一参数用于指定文件名称，不能包含路径分隔符“/” ，如果文件不存在，Android 会自动创建它。openFileOutput()方法的第二参数用于指定操作模式，有四种模式：• Context.MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，写入的内容会覆盖原文件的内容。• Context.MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。• MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。• MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。• MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE：既可以读又可以写。写文件：• FileOutputStreamfos = openFileOutput(fileName,MODE_PRIVATE);• byte[] bytes = message.getBytes();• fos.write(bytes);• fos.close();读文件：• FileInputStreamfin = openFileInput(fileName);• int length = fin.available();• byte[] buffer = new byte[length];• fin.read(buffer);• result = EncodingUtils.getString(buffer,ENCODING);• fin.close();","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"区块链论文（一）","slug":"block_paper_0","date":"2020-03-16T10:18:28.000Z","updated":"2020-03-16T10:34:48.331Z","comments":true,"path":"2020/03/16/block_paper_0/","link":"","permalink":"http://nlbyd1119.online/2020/03/16/block_paper_0/","excerpt":"说明：第一篇对区块链在教育领域已有的应用、优势、挑战进行全面地介绍；第二篇详细介绍了基于区块链的高等教育学分平台EduCTX，但这个是一个起源于欧洲适合西方教学模式的平台；第三篇具体介绍了区块链在学历信息管理、学习成果评估方面的应用。","text":"说明：第一篇对区块链在教育领域已有的应用、优势、挑战进行全面地介绍；第二篇详细介绍了基于区块链的高等教育学分平台EduCTX，但这个是一个起源于欧洲适合西方教学模式的平台；第三篇具体介绍了区块链在学历信息管理、学习成果评估方面的应用。 基于区块链的教育应用：系统回顾一、说明 本文是对基于区块链的教育应用进行调查研究的系统综述。它着重于三个主要主题：（1）用区块链技术开发的教育应用程序；（2）区块链技术可以为教育带来的好处；（3）在教育中采用区块链技术的挑战。 区块链在教育中的应用仍处于早期阶段。 只有少数教育机构已开始使用区块链技术。这些机构中的大多数都将其用于验证和共享其学生已取得的学历证书和/或学习成果的目的。 但是，该领域的研究人员认为，区块链技术可以提供更多的功能，并且实际上可以彻底改变该领域。根据Nespor，区块链可能削弱教育机构作为认证代理的核心作用，并为学生提供更多的学习机会。 本文通过研究区块链技术在教育中的利用方式，为教育技术文献做出了及时的原创性贡献，即针对近年关于区块链技术在教育领域应用的零散的论文作出总结。 二、论文调查统计的几个结论（第三节） 区块链在教育中的应用 出于教育目的已开发了多种区块链应用程序。这些应用程序可分为十二类：证书管理，能力和学习成果管理，评估学生的专业能力，保护学习对象，确保协作学习环境，费用和学分转移，获得数字监护权同意，竞赛管理，版权管理，增强学生在电子学习，考试复习和支持终身学习中的互动。 区块链可以带给教育的好处 10种好处：安全性、更好地控制如何访问学生的数据以及由谁访问、增强了责任感和透明度、增强信任、降低了成本、验证学生身份及其数字证书方面非常有用、可以改善评估学习成果和学生表现的方式、提高了数据交换和学生记录管理的效率、增强了学习者的交互性和系统互操作性、在支持学习者的职业决策方面可能非常有帮助 在教育中采用区块链技术的挑战(9) 可扩展性：区块链网络中交易数量的增加导致区块大小的增加。这最终将增加事务延迟 与区块链的隐私和安全性有关：利用区块链技术时可能遇到的不同类型的安全性和隐私问题，例如恶意攻击和数据泄漏。 采用这项技术的成本：例如：计算能力成本，更改当前基础结构的成本，因事务缓慢而造成的时间成本以及管理大数据的成本。 与信任有关：教育机构仍然不愿意在区块链网络上共享其数据 设定区块链技术采用的界限困难：，教育机构可能会发现很难决定应通过区块链网络提供哪些数据和服务 不可变性：这是区块链的主要特征，可能对在教育领域采用区块链技术构成挑战。这些文章解释说，不变性可能会使教育机构难以应用新的信息存储法律或纠正不正确的数据 区块链技术的不成熟：区块链仍然遭受一些不成熟的问题，例如可用性差和设置复杂 数据不可用：将数据管理交给用户自己可以使这些数据不可用，并可能影响依赖于此数据的应用程序 削弱传统学校证书的价值：区块链可以允许学生充当他们自己终身的教育成就注册者，并且可能削弱教育机构作为认证代理人的核心作用。 三、具体分析三个问题（第四节) 区块链技术已经为教育目的开发了哪些应用程序？ 第一类重点关注与证书管理有关的某些应用程序:此类别涉及处理所有形式的学历证书，成绩单，学生证书或任何其他形式的成绩记录。在教育领域，许多应用程序都使用区块链来发行数字证书。这些证书的大多数应用受益于使用区块链技术提供的高度信任和隐私。 第二类集中在能力和学习成果管理上：人们更加重视构建一些区块链应用程序，以改善学习目标并提高教育范围内的能力。这将有助于增强学习过程并丰富广泛的教育领域。由于区块链的高效率，许多应用程序可以基于定性和定量参数来测量和评估学生的表现。 第三类涵盖与确保协作学习环境有关的应用程序：该类别侧重于使用区块链支持学习环境的重要性。由于区块链提供了一个分散的网络，可以高度安全和完整性地轻松访问它，因此它为包括学生，教职员工和主管部门在内的所有各方建立了协作氛围。 第四类与费用和积分转移有关：由于区块链的高安全性和信任度，它包括一些具有类似功能的应用程序，用于在机构，组织甚至大学之间转移凭证记录或费用。通常，教育机构依靠第三方/中介机构来处理和批准学分或费用的转移。幸运的是，基于区块链的高安全级别，它可以用作交换信息和消除此类第三方或中间方需求的有效方式。 第五类讨论了一些与获得数字监护权同意有关的应用程序：区块链有助于增强传统的收集父母同意的方式，以电子方式收集。由于区块链技术可以提供信任，因此高度反映了这一点。区块链的去中心化性质有助于加快收集同意的过程，而不会损害其隐私。这对减轻大量学生，家长和教育机构之间的收集和通勤过程具有很大的影响。 第六类涉及竞争管理：利用区块链技术来促进对竞争运营的管理并提高其效率和透明度。 第七类是评估学生的专业能力，将学生的专业能力与特定行业联系在一起的另一类，以提供就业建议。 第八类是为版权管理的类别保留所有权。 第九类：在电子学习系统中增强学生的互动性被归类为采用区块链技术解决与学生在电子学习环境中的交互性相关的一些问题的另一应用类别。 第十类：考试复习是此复习中确定的另一个应用程序类别。通过实施许可的区块链技术，可以使用受信任的分类帐极大地提高审计试卷的安全性。 第十一类：支持终身学习是最后的应用类别。区块链技术在增强终身学习方面（例如提高技能，知识和效率）发挥了重要作用。 区块链技术可以为教育带来什么好处？区块链技术可以为教育带来重大好处，包括高安全性，低成本，增强学生的评估，更好地控制数据访问，增强问责制和透明度，身份认证，增强信任，提高学生记录管理的效率，支持学习者的职业决策，并增强学习者的互动性。 在教育中采用区块链技术面临哪些挑战？ 安全性问题： 尽管安全性是区块链技术的主要特征，但无法消除恶意攻击的风险 可扩展性问题：区块链交易速度慢，被称为区块链的可扩展性问题，是使用区块链时教育系统可能面临的问题之一。 成本：区块链是一项新兴技术，需要与旧系统集成。但是，采用和实施的成本可能很高。除了这种实现成本，区块链的许多技术的交易或计算成本也很高。 信任与共享：对于证书验证，需要所有机构都同意共享其数据。但是，问题是所有机构将如何准备好共享其数据？ 定义法律实体的边界不够清晰：有些组织可能不想在其所有业务流程中采用区块链技术。在不定义传统系统中区块链的潜在利益的情况下，将面临关键挑战 产品的可用性差，尤其是早期产品。在术语和技术的不成熟方面也缺乏明确性：有必要通过简化区块链产品的接口来提高可用性，以使没有技术专长的个人可以轻松理解和使用该系统，有必要在现场进行可用性测试方面的进一步工作。良好的设计和简单的术语可以帮助教育行业适应区块链。 区块链的不变性使其更难以编辑数据：于政府机构来说，这种不可变性会给他们的公民数据提供法律和秩序上的麻烦。 分散的区块链技术可能会影响任何教育系统流程的集中性。就像在区块链中一样，连续汇总的分类帐的可用性会影响传统学校凭证的价值 四、未来研究领域 区块链可以带来巨大好处的一个主要领域是教育机构之间的合作与伙伴关系。 职务驱动教育是可以使用区块链技术的另一个领域。工作驱动型教育的主要重点是提供满足当前和未来招聘需求并可以为参与计划的学生提供就业机会的教育和培训计划。 区块链技术在认证和提高在线教育质量中的应用。尽管在线教育具有许多优点，例如成本较低，可访问性和灵活性，但它也有许多缺点。这些缺点最严重的是认证和低质量。大量的教育机构声称已获得认证，并提供高质量的在线课程。区块链有可能解决这个问题。 EduCTX：基于区块链的高等教育学分平台一、概述（文章的摘要） 基于区块链技术，我们提出了一个全球高等教育信用平台，名为EduCTX。该平台基于欧洲信用转移和累积系统（ECTS）的概念。它构成了一个全球信任的，分散式的高等教育学分和评分系统，可以为学生和高等教育机构（HEIs）以及其他潜在的利益相关者（例如公司，机构和组织）提供全球统一的观点。 作为概念证明，我们提出了环境的原型实现，基于开源方舟区块链平台。EduCTX基于全球分布的对等网络，将处理，管理和控制ECTX令牌，这些令牌代表学生在完成课程（例如ECTS）中获得的学分。HEI是区块链网络的对等点。该平台是迈向更加透明和技术先进的高等教育系统形式的第一步。（令牌：token 可译为通证；HEI表示高等教育机构） EduCTX平台代表了EduCTX计划的基础，该计划期望各种HEI齐心协力，以创建一个全球高效，简化且无处不在的环境，从而避免语言和管理障碍。因此，我们邀请并鼓励HEI加入EduCTX计划和EduCTX区块链网络。 二、建立该平台的背景与动机（论文第一节） 现存问题（即目前HEI数据库存储方式的问题） 互操作性小：大多数高等教育机构（HEI）均以专有格式保留其学生的完整课程记录。这些数据库的结构可以由机构的工作人员专用并且可以在专用的在线系统中访问，因此互操作性很小或没有。 访问受限：通常，这些数据库托管在HEI内部的数据中心中，但对其IT专业人员的访问受到限制。学生可以以受限的，受密码保护的方式从外部访问其数据，而只能查看或打印其完整的课程记录（某些系统启用并记录学生的在线签入和签出考试）。关于此类系统，有几个关键点，包括数据标准化，存储位置，安全性以及如何过滤，分析和安全共享此类数据。与这些问题相关，HEI会无限期地维护学生的完整课程记录。由于法律原因，这是必需的，具体取决于国家/地区的政策。 共享困难：大多数情况下，机构不会共享学生的数据，甚至不会共享完整的课程记录。因此，学生在转移到另一所HEI的过程中可能会遇到困难，同时仍保留并证明其先前学校提供的课程的完整性。当学生想转移到存在语言，文字和行政障碍的另一个国家时，这个问题更加明显。而且，这些记录通常以不同的标准存储， 上述存在的访问、共享、安全性问题给学生后续的学习和工作带来困难尽管存在诸如ECTS之类的学术学分系统的统一标准，但采用和实施全球分散，可信赖，安全的学分平台仍然是一个挑战。许多障碍来自以下事实：学生的学业成绩敏感，并制定了复杂的管理规定。 论文提出的EduCTX 一个基于区块链的去中心化高等教育信用平台，名为EduCTX。它建立在分布式对等（P2P）网络系统上。该系统由于在全球范围内的存储容量和资源共享而具有灵活性，安全性和弹性 EduCTX平台将基于区块链技术的高等教育学分和评分系统从模拟和物理世界转换为全球高效，简化，无所不在的版本。 论文的EduCTX计划：EduCTX平台是我们的EduCTX计划的基础（更多信息，请访问：eductx.org），该计划设想了一个统一，简化且全球无所不在的高等教育学分和评分系统。通过该计划，我们计划进一步推进和发展EduCTX概念。 三、先前其他的做法与本系统的区别（第二节） 封闭专用： 高等教育领域中的上述大多数项目都依赖于封闭的概念或想法，并且经常不讨论细节，甚至不停留在想法层面。一些相关项目专门提供给实体的封闭圈子。 开放：本文提出的想法依赖于开源技术（即实施的开源公共代码），其目的是将全球利益相关者纳入EduCTX计划，因此对于任何HEI的参与和包容性都是开放的。通过公开可用的平台和网络形象。所展示的平台基于ARK区块链技术，可通过Github软件开发平台获得原型实现。因此，拟议的EduCTX区块链平台是EduCTX计划的基础，该计划向所有HEI全球开放，以为学生的学分分配构建高效，简化，无所不在的解决方案，同时消除语言和管理障碍。 四、相关技术基础（第三节） 欧洲学分转移和积累系统欧洲学分转移和累积系统（ECTS）是由欧洲委员会开发并得到欧盟成员国同意的高等教育分级系统的框架。它于1989年在Erasmus（学生交换）计划中成立。这个以学习者为中心的系统的目的是通过认可先前的学习成就，资格，经验和学习时间，促进学习计划的规划，交付和评估，以及促进学生的流动性[39]。ECTS学分表示学习量，它基于定义的学习结果和与学习相关的工作量。学习结果表示为个人的知识（他/她所知道，理解和能够做的事情），而工作量则是个人完成所有学习活动所需的估计时间。用60个ECTS学分评估学习结果和全日制学年的相关工作量。积分以整数表示。考虑到预期的学习成果和估计的工作量，会将不同数量的学分分配给不同的教育组成部分（课程）。一学分相当于25到30个小时的工作时间[39]。 区块链-分布式账本技术 分布式共识 网络节点 多重签名协议 五、EduCTX平台的架构描述（第四节） 概述EduCTX区块链平台将以学术学分的形式处理，管理和控制ECTX令牌，并依赖于全球分布的P2P网络，其中区块链网络的对等方是HEI，平台的用户是学生和组织（例如，公司作为潜在雇主） 。 架构中的四种重要方案，这些方案将在EduCTX中发挥作用。每个方案都由业务流程管理（BPM）图表表示 HEI加入EduCTX网络（学校注册） 学生注册 学生课程完成情况 组织验证学生的信用记录 六、EduCTX平台的原型实现（第五节） 基础是使用ARK区块链ARK不仅是一种加密货币，而且还是一个旨在大规模采用区块链的生态系统。通过在高度安全和快速的ARK核心区块链之上构建EduCTX平台，集成关键的去中心化技术，该平台成为用户大学友好的生态系统，从而整体上提高了区块链技术的采用率。选择ARK技术作为代码库的主要原因是它的灵活性和开源性，以及客户端API实施的总体可用性。在撰写本文时，ARK提供了超过12种不同的客户端实现编程语言，从而使其他参与者（HEI，学生，雇主）以他们选择的编程语言加入该平台。 要点 EduCTX生态系统构建基块 加入EduCTX生态系统 七、分析平台的应用和缺陷（第六节） EduCTX计划 期望其周围的社区将进一步发展。所有确定的利益相关者（即高等教育机构，学生，公司）都可以受益于全球受信任的，分散的高等教育学分和评分系统，该系统易于使用且没有任何行政，脚本和语言障碍，因此为一个非常频繁的过程，遍及全球。 倡议的目的不是完全改变和改变各国建立的现行学分和等级制度，而是通过增加透明度和自动化程度来促进其发展，以优化与高等教育系统有关的行政程序。实际上，由于法律原因（国家或跨国法律和法规），这两种系统在开始时并存是很可能的情况。 问题区块链的私钥和公钥造成的使用和安全问题 八、结论与未来工作（第七节） 结论 EduCTX被提议为基于全球区块链的高等教育信用平台。拟议的平台利用了区块链的优势，以创建全球信任的高等教育学分和评分系统。作为概念验证，我们介绍了基于开源Ark区块链平台的EduCTX平台的原型实现。拟议的EduCTX平台针对学生和组织提出了全球统一的观点。 方案基于分布式P2P网络系统。它将基于区块链技术的高等教育评分系统从当前的实际物理记录或传统数字记录（例如数据库）转换为高效，简化，无所不在的版本。可以预料，这样的系统可能会演变成一个统一的，简化的且在全球范围内普遍存在的高等教育学分和等级系统. 未来工作扩展到基于智能合约和适当版本的区块链技术的基础上 **探索区块链技术及其在教育中的潜在应用** **一、当前教育中的区块链应用** 如今，一些大学和学院已将区块链技术应用于教育中，其中大多数都将其用于支持学位管理和学习成果的总结评估。 1. 学历信息（文凭）管理 + 区块链技术可以制定整个成绩单。在正式学习环境中，这包括学习内容和成果，以及学生的成绩和学历证书。随后，在非正式学习环境中，包括有关研究经验，技能，在线学习经验以及个人兴趣的信息。这些数据可以通过适当的方式安全地存储和访问在区块链网络上。**举例：** 尼科西亚大学是第一所使用区块链技术管理从MOOC平台收到的学生证书的学校（Sharples and Domingue 2016）。索尼全球教育还使用区块链技术创建了一个全球评估平台，以提供用于存储和管理学位信息的服务（Hoy 2017）。此外，麻省理工学院（MIT）和Learning Machine公司合作，设计了基于区块链技术的在线学习数字徽章。参加麻省理工学院媒体实验室项目并通过评估的学生将获得证书，并将其存储在区块链网络中（Skiba 2017）。此外，霍尔伯顿学校是第一家将区块链技术用于存储学位的学院，并声称他们将从2017年开始共享此信息。 + 区块链分类账本可以将各种教育信息与用户的唯一ID相匹配。它包括课堂学习行为，微观学术项目经验和宏观教育背景等。 + 区块链技术有助于减少程度欺诈。过去，有很多学位欺诈案件。但是，现在可以通过使用区块链来授予和管理学生学位来避免这种情况。来自世界各地的矿工会检查，验证和维护与用户ID匹配并存储在区块链中的数据。区块链分布式账本是一成不变且值得信赖的。因此，可靠性和权威性都得到了保证，这将大大减少学位欺诈。 2. 学习成果评估 + 区块链可以用作“容量-货币转换银行”。具体而言，区块链学习分类账记录有关用户学习经历的详细信息，并跟踪其知识和技能的发展。所有这些都可以根据一系列全面的标准转换为一种数字货币，并存储在区块链网络中。通过努力学习，学生将获得奖励，这被称为“学习就是收益”（Sharples和Domingue，2016年）。 + 举例：Sharples和Domingue（2016）声称一种名为“荣誉”的教育声誉货币。它可以用来衡量学习成果并存储在虚拟钱包中。 二、使用区块链技术的未来创新教育应用区块链技术还可以通过许多创新方式应用于教育。对于学习者和教师而言，区块链技术在形成评估，学习活动设计和实施以及跟踪整个学习过程方面都具有广阔的应用前景。 激发学生学习积极性 从学生的角度来看，仍然有一些负面的主观或客观因素导致学习效果不佳，例如缺乏动力和财务压力。由于货币属性的特性，区块链可用于通过实施“学习即赚钱”来激励学生（Sharples和Domingue，2016年）。老师和学生之间的智能合约可以应用于教育场景。实时的奖励可以通过教师的简单点击就可以授予学生。学生将根据智能合约获得一定数量的数字货币作为奖励。这种钱可以存储在教育钱包中，用作学费，甚至可以用真实货币兑换。 形成性评估 现存问题：难以跟踪教学细节和保证公平性形成性评估已被提倡很长时间，但由于追踪教学的每个细节并不容易，因此尚不成熟。应用区块链和智能合约可以应对这一挑战。值得注意的是，区块链的不可变性，可追溯性和可靠性意味着记录在区块链上的数据更加具体，真实和防盗。以“合作学习”为例，这是进行建构主义教学和培养学生与他人合作能力的一种极好的方式。但是，它常常伴随着搭便车的问题，妨碍了公平评估。区块链技术可以缓解这种现象。 区块链如何做到每个学生都通过其独特的帐户将其作品提交到学习平台，在该平台上运行的智能合约将审核学生的表现，并将结果记录在块中。协作期间的所有行为也将保存为块，以作为评估的依据。而且，公共区块链具有去中心化的特征。这意味着分布式分类帐可确保大多数节点的一致性。因此，作为区块链网络中的节点，在评估学生的意见时会考虑他们的意见。在这种情况下，区块链可确保评估的公平性。 教师的学习活动设计 问题教师的教学活动难以得到正确评估，传统的基于学生反馈的方法往往是单方面的，缺乏主观性，对教师的进步无济于事。 区块链的做法可以基于区块链网络和智能合约构建新的评估系统。首先，教师需要向学校提交预先计划的教学活动，作为明确的合约。在教学过程中，所有教学活动都将记录在区块链网络中。智能合约将验证教学设计和实践的一致性，这将成为重要的教学评估指标。而且，教师与学校之间的智能合约 以及师生之间的相互验证和补充。符合标准的老师将获得数字货币作为奖励。它既是对教师教学技能的赞赏，也是对他们的鼓励。 学生的学习活动的实施与监督 问题：未能得到有效监督从学生发展的角度来看，主管或学术顾问直接负责对学生课程的监督。他们有责任协助学生制定学习计划，并随时了解学生的研究活动和进度。但是，在实践中，这些问题没有得到检查和监督，因此，如果将来发生某些负面事件，区分责任是有争议的。 区块链的做法如果在该领域使用智能合约和区块链技术，这种情况将会改变。所有细节均应通过智能合约平台进行监控，并记录到区块链分类账本中。例如，上学期导师与学生讨论了多少次？主管以草稿和最终形式审查了论文几次？他们是否在选课和研究设计方面为学生提供适当的指导？由于区块链技术的可追溯性和不变性，学生和主管的行为都将记录在区块链分类账中。这种创新的应用程序可以保护双方的利益。 总结 区块链可用于构建衡量学习过程和结果的平衡。它是每个人的可靠和平等的价值证明。从理论上讲，由于区块链的去中心化和不变性，可以解决陌生人之间的信息不对称和信任问题。因为信息和价值是集体发布和维护的，所以它确保了真实性。它为人才投资提供了一种值得信赖的方式。 区块链分类帐本跟踪您所学的一切。雇主可以使用此信息为您提供与您的技能相匹配的工作。另一方面，想要优秀员工的用户也可以求助于区块链账本。这将大大降低投资偏差和失败的风险。一言以蔽之，区块链最大化了双方的利益。 三、在教育中应用区块链技术的潜在问题 需要主观审查的学习行为和成果，智能合约难以评估作为一个复杂的系统，一些学习行为和学习成果需要教师进行主观审查，例如论文和课堂演示。在没有人工干预的情况下，很难通过预编程的智能合约来评估这种学习活动。 消除了正当理由修改记录的可能性如果在学校使用教育性区块链系统，则所有学生的教育数据都将集成到区块链分类帐中。区块链技术的不变性功能将充当一把双刃剑。它消除了某些学生出于正当理由修改教育记录的可能性。 区块链的效率用于教育的区块链未解决许多技术问题或障碍。例如，工作机制达成共识浪费能源的经典证据并有以每秒事务（Vukolić数量方面表现欠佳2015年），这将花费额外的费用，并阻碍了其在学校的应用。 结论 区块链本质上是一种分布式账本技术，它使用密码技术和分布式共识算法来创建去中心化，可追溯性，不变性和货币属性的特征。它的货币属性有可能引发许多创新的教育应用。例如，通过实现“学习就是收益”，区块链技术可以培养学生的学习动力。它可以存储一套完整，可信赖的教育活动记录集，包括正式和非正式学习环境中的过程和结果。它还可以记录教师的教学行为和表现，从而为教学评估提供参考。简而言之，对于学习者和教师而言，区块链在教学设计，行为记录，分析以及形成性评估。同时，它给研究人员，开发人员和教育工作者带来了挑战和机遇。 对于研究人员而言，区块链具有广阔的潜力，可广泛应用于教育领域。但是，很少进行研究。在诸如教育革命能为其提供哪些机会等主题上进行更深入的研究将是一项挑战。如何更好地利用数字货币资产来增强学习动机和成就？ 对于开发人员来说，这些创意只是将区块链应用于教育的第一步。这也是开发教育平台和软件的重要组成部分，这给开发人员带来了挑战。如何构建满足用户个性化需求的区块链平台？如何将硬件与区块链结合以创建数据采集和记录环境？如何维护海量的教育交易数据并将区块链技术集成到现有的教育工具和系统中？ 对于教育者来说，采用区块链技术来设计基于智能联系的学习活动的一些好处是基于智能合约的学习活动可以被验证，健壮和可追溯。这种透明性功能为做得好的老师提供了强有力的保护。此外，关于教学绩效评估的学校管理也应改变以采用这项新技术。 21的实现ST世纪的安全，隐私，信任和平等可以通过blockchain技术来实现。 ** 安全是指对有价值的属性和信息的保护**。如今，有些人拥有财产，但无法证明所有权，例如知识产权纠纷。它可能导致与他人的冲突。可以通过检查数据库中的记录以证明属性来使用区块链技术。一些商业信息，例如设计图纸，公司计划，可能被工业间谍窃取。区块链技术可以通过在区块链网络中记录数据来保护这些贵重物品业务。区块链技术可以保护教师的教学设计免遭篡改，从而提高了保护知识产权的安全性。 隐私意味着每个节点都保存完整的分类帐本，包括除真实身份之外的所有信息。为了隐私起见，所有用户标识均以ID号表示。这意味着区块链技术可以保护交易者的隐私，因为没有其他人拥有私钥。在教育场景中，记录在区块链上的所有有关学习经历的信息只能通过其唯一用户的私钥来获取。其他人无法访问，这意味着可以很好地保证区块链用户的隐私。 至于信任，区块链技术可以将人们建立信任的方式从第三方机构建立信任转变为技术建立信任。当应用智能合约和区块链时，教师和学生的行为都将被记录和监控。主题之间的信任基于技术本身，而不是第三方。 平等是指每个人在区块链网络上享有的平等权利和机会。区块链技术的开放性，无边界和无许可的性质可以使每个人都平等地使用该技术以及使用该技术构建的网络。任何人都可以在区块链网络上申请电子钱包。区块链技术没有为用户设置任何限制。所有学校，老师和学生都可以每天将其应用，从而避免了权威偏见。","categories":[{"name":"论文","slug":"论文","permalink":"http://nlbyd1119.online/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://nlbyd1119.online/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Android Studio 使用（五）","slug":"as-use-5","date":"2020-03-15T08:05:36.000Z","updated":"2020-03-15T08:24:33.247Z","comments":true,"path":"2020/03/15/as-use-5/","link":"","permalink":"http://nlbyd1119.online/2020/03/15/as-use-5/","excerpt":"代码","text":"代码 （0）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/button4\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面4\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面3\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.1\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.25\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.4\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面1\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面2\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline17\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.55\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline18\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;Button android:id=\"@+id/button7\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面5\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.483\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button8\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面6\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button9\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面7\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.677\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt; &lt;Button android:id=\"@+id/button10\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面8\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （1）ScollView 滚动文本视图（未解决排版问题）布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main5Activity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.92\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;ScrollView android:id=\"@+id/scrollView\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:scrollbars=\"none\" app:layout_constraintBottom_toTopOf=\"@+id/guideline5\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:singleLine=\"false\" /&gt; &lt;/ScrollView&gt; &lt;Button android:id=\"@+id/button5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"up\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@+id/guideline6\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline5\" /&gt; &lt;Button android:id=\"@+id/button6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"down\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline6\" app:layout_constraintTop_toTopOf=\"@+id/guideline5\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 注意onTouchListner需要加注解压警告 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.content.Context;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.Button;import android.widget.ScrollView;import android.widget.Scroller;import android.widget.TextView;@SuppressLint(\"ClickableViewAccessibility\")public class Main5Activity extends AppCompatActivity implements View.OnTouchListener &#123; private Context context; private TextView tv1; private ScrollView sv1; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; tv1 = findViewById(R.id.textView); tv1.setText(R.string.textView_text); sv1 = findViewById(R.id.scrollView); sv1.setOnTouchListener(this); bt1 = findViewById(R.id.button5); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, -30); &#125; &#125;); bt2 = findViewById(R.id.button6); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sv1.scrollBy(0, 30); &#125; &#125;); &#125; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; switch (motionEvent.getAction()) &#123; case MotionEvent.ACTION_MOVE: &#123; if (sv1.getScrollY() &lt;= 0) &#123; Log.i(\"Main\", \"顶部状态\"); &#125; if (sv1.getChildAt(0).getMeasuredHeight() &lt;= sv1.getHeight() + sv1.getScrollY()) &#123; Log.i(\"Main\", \"底部状态\"); tv1.append(getString(R.string.textView_text)); &#125; break; &#125; &#125; return false; &#125;&#125; （2）Gallery 缩略图 + ImageSwitcher 大图浏览布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main6Activity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.18\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline8\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.52\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline9\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.02\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline10\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.86\" /&gt; &lt;Gallery android:id=\"@+id/gallery\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline7\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline9\" /&gt; &lt;ImageSwitcher android:id=\"@+id/imageSwitcher\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline8\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline7\" /&gt; &lt;ImageSwitcher android:id=\"@+id/imageSwitcher2\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline10\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@+id/imageSwitcher\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.view.animation.AnimationUtils;import android.widget.AdapterView;import android.widget.Gallery;import android.widget.ImageSwitcher;import android.widget.ImageView;import android.widget.ViewSwitcher;import com.example.app_z.custom.ImageAdapter;public class Main6Activity extends AppCompatActivity implements ViewSwitcher.ViewFactory &#123; private Context context; private Gallery gallery; private ImageAdapter adapter; private ImageSwitcher imageSwitcher1; private ImageSwitcher imageSwitcher2; private int[] res = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; gallery = findViewById(R.id.gallery); adapter = new ImageAdapter(res, context); gallery.setAdapter(adapter); imageSwitcher1 = findViewById(R.id.imageSwitcher); imageSwitcher2 = findViewById(R.id.imageSwitcher2); imageSwitcher1.setFactory(this); imageSwitcher2.setFactory(this); imageSwitcher1.setInAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher1.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_in)); imageSwitcher2.setOutAnimation(AnimationUtils.loadAnimation(context, android.R.anim.fade_out)); gallery.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; imageSwitcher1.setBackgroundResource(res[i % Integer.MAX_VALUE]); imageSwitcher2.setBackgroundResource(res[res.length - 1 - (i % Integer.MAX_VALUE)]); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125; @Override public View makeView() &#123; ImageView imageView = new ImageView(context); imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); return imageView; &#125;&#125; （3）Log输出类型，确认/单选/复选/列表/自定义对话框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.os.Bundle;import android.text.Layout;import android.util.Log;import android.view.Gravity;import android.view.LayoutInflater;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.Toast;public class Main7Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private String[] single_dialog = &#123;\"金星\", \"木星\", \"火星\", \"水星\", \"土星\"&#125;; private String[] muti_dialog = &#123;\"saber\", \"violet\", \"mikasa\", \"yui\"&#125;; private String[] item_dialog = &#123;\"paworks\", \"bone\", \"whitefox\", \"京都\", \"madhouse\"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //最后日志输出结果说明，颜色并没有那么多，而且还有一种assert Log.v(\"tag\", \"verbose模式，打印最详细的日志 黑色\"); Log.d(\"tag\", \"debug级别 蓝色\"); Log.i(\"tag\", \"info级别 绿色\"); Log.w(\"tag\", \"warn级别 橙色\"); Log.e(\"tag\", \"error级别 红色\"); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast toast = Toast.makeText(context, \"显示一条消息\", Toast.LENGTH_LONG * 6); toast.setGravity(Gravity.CENTER, 0, 100); //自定义位置 LinearLayout toast_layout = (LinearLayout)toast.getView(); //设置图片 ImageView imageView = new ImageView(context); imageView.setBackgroundResource(R.drawable.v1); toast_layout.addView(imageView); toast.show(); &#125; &#125;); button3 = findViewById(R.id.button3); button3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //自定义Toast布局，事实证明约束布局无法显示 Toast toast = Toast.makeText(context, \"显示一条消息\", Toast.LENGTH_LONG * 6); LayoutInflater inflater = LayoutInflater.from(context); View toast_layout = inflater.inflate(R.layout.toast_layout, null); toast.setView(toast_layout); toast.show(); &#125; &#125;); button4 = findViewById(R.id.button4); button4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"确认对话框\"); builder.setIcon(R.drawable.v1); builder.setMessage(\"确认对话框提示内容\"); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, \"点击了确认按钮\", Toast.LENGTH_LONG * 10).show(); &#125; &#125;); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, \"点击了取消按钮\", Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button5 = findViewById(R.id.button7); button5.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //注意只有确认对话框可以设置message 其他若设置会影响项的显示 AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"单选对话框\"); builder.setIcon(R.drawable.v1); //builder.setMessage(\"单选对话框提示内容\"); builder.setSingleChoiceItems(single_dialog, 0, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, \"选择了\" + single_dialog[i], Toast.LENGTH_LONG * 10).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button6 = findViewById(R.id.button8); button6.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"多选对话框\"); builder.setIcon(R.drawable.v1); builder.setMultiChoiceItems(muti_dialog, null, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i, boolean b) &#123; if (b) &#123; Toast.makeText(context, \"选择了\" + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; else &#123; Toast.makeText(context, \"取消选择了\" + muti_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125; &#125;); builder.setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; dialogInterface.dismiss(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button7 = findViewById(R.id.button9); button7.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"多选对话框\"); builder.setIcon(R.drawable.v1); builder.setItems(item_dialog, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(context, \"选择了\" + item_dialog[i], Toast.LENGTH_LONG * 3).show(); &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); button8 = findViewById(R.id.button10); button8.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\"自定义对话框\"); builder.setIcon(R.drawable.v1); LayoutInflater inflater = LayoutInflater.from(context); View dialog_lagout = inflater.inflate(R.layout.toast_layout, null); builder.setView(dialog_lagout); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125;); &#125;&#125; （4）notification状态栏 选项菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.Toast;import java.util.Locale;public class Main8Activity extends AppCompatActivity &#123; private Context context; private Button button1; private Button button2; private Button button3; private Button button4; private Button button5; private Button button6; private Button button7; private Button button8; private NotificationManager notificationManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; notificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); button1 = findViewById(R.id.button); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0); Notification.Builder builder = new Notification.Builder(context); builder.setSmallIcon(R.drawable.v1); //设置图标 builder.setTicker(\"状态栏的提示\"); builder.setWhen(System.currentTimeMillis()); //设置时间 builder.setContentTitle(\"状态栏标题\"); builder.setContentText(\"状态栏通知内容\"); builder.setContentIntent(pendingIntent); //点击后的意图// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置指示灯// builder.setDefaults(Notification.DEFAULT_SOUND); //设置提示声音// builder.setDefaults(Notification.DEFAULT_LIGHTS); //设置振动 builder.setDefaults(Notification.DEFAULT_ALL); Notification notification = builder.build(); notificationManager.notify(1, notification); &#125; &#125;); button2 = findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override //通过自定义的通知id即可取消通知 public void onClick(View view) &#123; notificationManager.cancel(1); &#125; &#125;); &#125; /* 创建选项菜单 */ @Override public boolean onCreateOptionsMenu(Menu menu) &#123; menu.add(0, 100, 1, \"菜单项一\"); //参数依次表示：分组序号、自定义id、优先级、项内容 menu.add(0, 101, 1, \"菜单项二\"); menu.add(0, 102, 1, \"菜单项三\"); return true; &#125; /* 给选项菜单列表项添加点击事件 */ @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 100: &#123; Toast.makeText(context, \"点击了菜单项一\", Toast.LENGTH_LONG * 3).show(); break; &#125; case 101: &#123; Toast.makeText(context, \"点击了菜单项二\", Toast.LENGTH_LONG * 3).show(); break; &#125; case 102: &#123; Toast.makeText(context, \"点击了菜单项三\", Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （5）上下文菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.ContextMenu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;import com.example.app_z.Data;public class Main9Activity extends AppCompatActivity &#123; private Context context; private ListView listView; private ArrayAdapter&lt;String&gt; adapter; private String[] vname = Data.vname; private String selected; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main9); context = this; listView = findViewById(R.id.listView); adapter = new ArrayAdapter&lt;&gt;(context, android.R.layout.simple_list_item_1, vname); listView.setAdapter(adapter); this.registerForContextMenu(listView); //注册 listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; selected = vname[i]; &#125; &#125;); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(\"上下文菜单\"); menu.setHeaderIcon(R.drawable.v1); menu.add(1, 1, 1, \"百度百科\"); menu.add(1, 2, 1, \"bangumi\"); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case 1: &#123; Intent intent = new Intent(context, Main2Activity.class); intent.putExtra(\"url\", \"https://baike.baidu.com/item/\" + selected); startActivity(intent); break; &#125; case 2: &#123; Toast.makeText(context, \"通过利用全局变量实现菜单和上下文的关联\", Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; return true; &#125;&#125; （6）子菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.widget.Toast;import javax.security.auth.Subject;public class Main10Activity extends AppCompatActivity &#123; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main10); context = this; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; SubMenu file = menu.addSubMenu(\"文件\"); SubMenu edit = menu.addSubMenu(\"编辑\"); file.setHeaderTitle(\"文件操作\"); file.setIcon(R.drawable.v1); file.add(1, 1, 1, \"新建\"); file.add(1, 2, 1, \"打开\"); file.add(1, 3, 1, \"保存\"); edit.setHeaderTitle(\"文本操作\"); edit.setIcon(R.drawable.v2); edit.add(2, 1, 1, \"复制\"); edit.add(2, 2, 1, \"粘贴\"); edit.add(2, 3, 1, \"剪切\"); return true; &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; if (item.getGroupId() == 1) &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, \"item.getTitle()不能用\", Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; else &#123; switch (item.getItemId()) &#123; case 1: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 2: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; case 3: &#123; Toast.makeText(context, item.getTitle(), Toast.LENGTH_LONG * 3).show(); break; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"android基本概念（三）","slug":"a-study-3","date":"2020-03-15T07:38:41.000Z","updated":"2020-03-15T08:05:24.486Z","comments":true,"path":"2020/03/15/a-study-3/","link":"","permalink":"http://nlbyd1119.online/2020/03/15/a-study-3/","excerpt":"Activity生命周期","text":"Activity生命周期 一、Activity与状态改变 123456• Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。• 每个Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。• 一个应用通常由多个彼此松散联系的Activity 组成。一般会指定应用中的某个Activity 为“主”Activity，即首次启动应用时呈现给用户的那个Activity。而且每个Activity 均可启动另一个Activity，以便执行不同的操作。每次新Activity 启动时，前一Activity 便会停止，但系统会在堆栈（“返回栈”）中保留该Activity。• 当新Activity 启动时，系统会将其推送到返回栈上，并取得用户焦点。返回栈遵循基本的“后进先出”堆栈机制，因此，当用户完成当前Activity 并按“返回”按钮时，系统会从堆栈中将其弹出（并销毁），然后恢复前一Activity。• 当一个Activity 因某个新Activity 启动而停止时，系统会通过该Activity 的生命周期回调方法通知其这一状态变化。• Activity 因状态变化—系统是创建Activity、停止Activity、恢复Activity 还是销毁Activity—而收到的回调方法可能有若干种，每一种回调都会为您提供执行与该状态变化相应的特定操作的机会。例如，停止时，您的Activity 应释放任何大型对象，例如网络或数据库连接。当Activity 恢复时，您可以重新获取所需资源，并恢复执行中断的操作。这些状态转变都是Activity 生命周期的一部分。 状态 1234567• onCreate：Activity创建时调用。• onStart：可见未获取焦点，无法与之交互。• onResume：可见已获取焦点，可与之交互。• onPause：可见，失去焦点。• onStop：不可见。• onRestart：Activity重启。• onDestory：Activity被销毁。 二、生命周期 123456789• Activity 的整个生命周期发生在onCreate() 调用与onDestroy() 调用之间。• 您的Activity 应在onCreate() 中执行“全局”状态设置（例如定义布局），并释放onDestroy() 中的所有其余资源。• 例如，如果您的Activity 有一个在后台运行的线程，用于从网络上下载数据，它可能会在onCreate() 中创建该线程，然后在onDestroy() 中停止该线程。• Activity 的可见生命周期发生在onStart() 调用与onStop() 调用之间。• 在这段时间，用户可以在屏幕上看到Activity 并与其交互。例如，当一个新Activity 启动，并且此Activity 不再可见时，系统会调用onStop()。您可以在调用这两个方法之间保留向用户显示Activity 所需的资源。• 例如，您可以在onStart() 中注册一个BroadcastReceiver以监控影响UI 的变化，并在用户无法再看到您显示的内容时在onStop() 中将其取消注册。在Activity 的整个生命周期，当Activity 在对用户可见和隐藏两种状态中交替变化时，系统可能会多次调用onStart() 和onStop()。• Activity 的前台生命周期发生在onResume() 调用与onPause() 调用之间。• 在这段时间，Activity 位于屏幕上的所有其他Activity 之前，并具有用户输入焦点。Activity 可频繁转入和转出前台—例如，当设备转入休眠状态或出现对话框时，系统会调用onPause()。• 由于此状态可能经常发生转变，因此这两个方法中应采用适度轻量级的代码，以避免因转变速度慢而让用户等待。 三、注意点常见行为与调用方法 事件处理一、概述 123456• 在Android 系统中，从用户与应用的交互中截获事件的方法不止一种。如考虑截获用户界面内的事件，则可从用户与之交互的特定视图对象中捕获事件。为此，View 类提供了多种方法。• 在您将用于构建布局的各种View 类中，您可能会注意到几种看起来适用于UI 事件的公共回调方法。当该对象上发生相应的操作时，Android 框架会调用这些方法。• 例如，在触摸一个视图对象（例如“按钮”）时，对该对象调用onTouchEvent() 方法。不过，为了截获此事件，您必须扩展View 类并重写该方法。然而，为了处理此类事件而扩展每个视图对象并不现实。• 正因如此，View 类还包含一系列嵌套接口以及您可以更加轻松定义的回调。这些接口称为事件侦听器，是您捕获用户与UI 之间交互的票证。• 尽管您通常会使用事件侦听器来侦听用户交互，但有时您确实需要扩展View 类以构建自定义组件。也许，您想扩展Button 类来丰富某些内容的样式。在这种情况下，您将能够使用该类的事件处理程序为类定义默认事件行为。• 事件侦听器是View 类中包含一个回调方法的接口。当用户与UI 项目之间的交互触发已注册此视图的侦听器时，Android 框架将调用这些方法。 二、Android事件侦听器的回调方法 1234567891011• onClick()：在View.OnClickListener中。当用户触摸项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按适用的“Enter”键或按下轨迹球时，将调用此方法。• onLongClick()：在View.OnLongClickListener中。当用户触摸并按住项目（处于触摸模式下）时，或者使用导航键或轨迹球聚焦于项目，然后按住适用的“Enter”键或按住轨迹球（持续一秒钟）时，将调用此方法。• onFocusChange()：在View.OnFocusChangeListener中。当用户使用导航键或轨迹球导航到或远离项目时，将调用此方法。• onKey()：在View.OnKeyListener中。当用户聚焦于项目并按下或释放设备上的硬按键时，将调用此方法。• onTouch()：在View.OnTouchListener中。当用户执行可视为触摸事件的操作时，其中包括按下、释放或屏幕上的任何移动手势（在项目边界内），将调用此方法。• onCreateContextMenu()：在View.OnCreateContextMenuListener中。当（因持续“长按”而）生成上下文菜单时，将调用此方法。请参见菜单开发者指南中有关上下文菜单的阐述。• onClick() 回调没有返回值，但是其他某些事件侦听器方法必须返回布尔值。具体原因取决于事件。• 对于这几个事件侦听器，必须返回布尔值的原因如下：• onLongClick()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何点击侦听器，则返回false。• onKey()：此方法返回一个布尔值，表示您是否已处理完事件，以及是否应该将它继续传下去。也就是说，返回true 表示您已经处理事件且事件应就此停止；如果您尚未处理事件和/或事件应该继续传递给其他任何按键侦听器，则返回false。• onTouch()：此方法返回一个布尔值，表示侦听器是否处理完此事件。重要的是，此事件可以拥有多个分先后顺序的操作。因此，如果在收到关闭操作事件时返回false，则表示您并未处理完此事件，而且对其后续操作也不感兴趣。因此，您无需执行事件内的任何其他操作，如手势或最终操作事件。 三、事件侦听实现的三种方式 1234• 使用匿名类需要编写额外代码，安全性最高。• 使用Activity 类更为方便，可以避免加载额外的类和分配对象，但需要对View的ID进行识别，可能引入安全风险。• 使用布局文件最为简单，但无法实现比较复杂的功能。• 需要根据项目实际情况进行选择。","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"android基本概念（二）","slug":"a-study-2","date":"2020-03-15T04:09:57.000Z","updated":"2020-03-15T07:38:34.862Z","comments":true,"path":"2020/03/15/a-study-2/","link":"","permalink":"http://nlbyd1119.online/2020/03/15/a-study-2/","excerpt":"Service","text":"Service 一、概述 可见不可交互：Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。 服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信(IPC)。例如，服务可以处理网络事务、播放音乐，执行文件I/O或与内容提供程序交互，而所有这一切均可在后台进行。 二、服务的两种状态与生命周期 两种状态 Started启动当应用组件（如Activity）通过调用startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。操作完成后，服务会自行停止运行。 Bound绑定当应用组件通过调用bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信(IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 回调方法 onStartCommand()：当另一个组件（如Activity）通过调用startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。如果您实现此方法，则在服务工作完成后，需要由您通过调用stopSelf() 或stopService() 来停止服务。（如果您只想提供绑定，则无需实现此方法。） onBind()：当另一个组件想通过调用bindService() 与服务绑定（例如执行RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回IBinder提供一个接口，供客户端用来与服务进行通信。请务必实现此方法，但如果您并不希望允许绑定，则应返回null。 onUnbind()：当组件中断所有与服务绑定的连接时，系统调用该方法。 onRebind()：当新的组件与服务绑定，且此前它已经通过onUnbind(Intent)通知断开连接时，系统调用该方法。 onCreate()：首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法。 生命周期12341.服务的整个生命周期从调用onCreate() 开始起，到onDestroy() 返回时结束。与Activity 类似，服务也在onCreate() 中完成初始设置，并在onDestroy() 中释放所有剩余资源。例如，音乐播放服务可以在onCreate() 中创建用于播放音乐的线程，然后在onDestroy() 中停止该线程。2.无论服务是通过startService() 还是bindService() 创建，都会为所有服务调用onCreate() 和onDestroy() 方法。3.服务的有效生命周期从调用onStartCommand() 或onBind() 方法开始。每种方法均有&#123;Intent 对象，该对象分别传递到startService() 或bindService()。4.对于启动服务，有效生命周期与整个生命周期同时结束（即便是在onStartCommand() 返回之后，服务仍然处于活动状态）。对于绑定服务，有效生命周期在onUnbind() 返回时结束。 三、代码（1）布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.1\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.25\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.4\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"StartService\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"StopService\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;Button android:id=\"@+id/button4\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"UnBindService\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"BindService\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline17\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.55\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline18\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;Button android:id=\"@+id/button5\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"播放\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.483\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button6\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"暂停\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button7\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"上一首\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.677\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt; &lt;Button android:id=\"@+id/button8\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"下一首\" android:textSize=\"24sp\" android:onClick=\"onClick\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.example.app_service;import androidx.appcompat.app.AppCompatActivity;import android.app.Service;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.Bundle;import android.os.IBinder;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private Intent intent1; private Intent intent2; private ServiceConnection serviceConnection; private CustomBindService service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; service = ((CustomBindService.CustomBinder) iBinder).getService(); &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; intent1 = new Intent(context, CustomStartService.class); startService(intent1); break; &#125; case R.id.button2: &#123; stopService(intent1); break; &#125; case R.id.button3: &#123; intent2 = new Intent(context, CustomBindService.class); bindService(intent2, serviceConnection, Service.BIND_AUTO_CREATE); break; &#125; case R.id.button4: &#123; unbindService(serviceConnection); break; &#125; case R.id.button5: &#123; service.play(); break; &#125; case R.id.button6: &#123; service.pause(); break; &#125; case R.id.button7: &#123; service.previous(); break; &#125; case R.id.button8: &#123; service.next(); break; &#125; &#125; &#125; @Override protected void onDestroy() &#123; stopService(intent1); unbindService(serviceConnection); super.onDestroy(); &#125;&#125; （3）CustomStartService 123456789101112131415161718192021222324252627282930313233343536package com.example.app_service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;public class CustomStartService extends Service &#123; public CustomStartService() &#123; &#125; @Override public void onCreate() &#123; Log.i(\"service\", \"执行onCreate\"); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(\"service\", \"执行onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; Log.i(\"service\", \"执行onDestroy\"); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(\"service\", \"执行onBind\"); // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(\"Not yet implemented\"); &#125;&#125; （4）CustomBindService 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.app_service;import android.app.Service;import android.content.Intent;import android.content.ServiceConnection;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class CustomBindService extends Service &#123; public CustomBindService() &#123; &#125; public class CustomBinder extends Binder &#123; public CustomBindService getService() &#123; return CustomBindService.this; &#125; &#125; @Override public void onCreate() &#123; Log.i(\"service\", \"执行onCreate\"); super.onCreate(); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(\"service\", \"执行onBind\"); return new CustomBinder(); &#125; @Override public void unbindService(ServiceConnection conn) &#123; Log.i(\"service\", \"执行unbindService\"); super.unbindService(conn); &#125; @Override public void onDestroy() &#123; Log.i(\"service\", \"执行onDestroy\"); super.onDestroy(); &#125; public void play() &#123; Log.i(\"music\", \"执行play\"); &#125; public void pause() &#123; Log.i(\"music\", \"执行pause\"); &#125; public void previous() &#123; Log.i(\"music\", \"执行previous\"); &#125; public void next() &#123; Log.i(\"music\", \"执行next\"); &#125;&#125; BroadCast Receiver一、概述 Broadcast Receiver本质上是一个全局的监听器，属于Android四大组件之一。 Android广播分为两个方面：广播发送者、广播接收者（BroadcastReceiver） Broadcast Receiver用于监听（接收）应用发出的广播消息，并做出响应。 不同组件之间通信（包括应用内/ 不同应用之间），Android系统在特定情况下与App之间的消息通信，多线程通信。 二、实现原理 12345678• 自定义广播接收者BroadcastReceiver子类，并复写onRecvice（）方法；• 通过Binder机制向AMS（Activity Manager Service）进行注册；• 广播发送者通过Binder机制向AMS发送广播；• AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；• 消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。• 广播接收器接收到相应广播后，会自动回调onReceive()方法。• 一般情况下，onReceive方法会涉及与其他组件之间的交互，如发送Notification、启动service等。• 默认情况下，广播接收器运行在UI线程，因此，onReceive方法不能行耗时操作，否则将导致ANR（Application Not Responding）。 三、两种注册方式 静态注册：在AndroidManifest.xml里通过标签声明。 动态注册：动态注册，在代码中通过调用Context的registerReceiver（）方法进行动态注册BroadcastReceiver。 注意：Android Oreo已限制App在后台接收Intent广播信息，需要修改build.gradle中targetSdkVersion的值，使其小于等于25。 动态广播的注册销毁的时机12345• 动态广播最好在Activity的onResume()注册、onPause()注销。• 在onResume()注册、onPause()注销是因为onPause()在App死亡前一定会被执行，从而保证广播在App死亡前一定会被注销，从而防止内存泄露。• 不在onCreate() &amp; onDestory() 或onStart() &amp; onStop()注册、注销是因为：当系统因为内存不足要回收Activity占用的资源时，Activity在执行完onPause()方法后就会被销毁，有些生命周期方法onStop()，onDestory()就不会执行。当再回到此Activity时，是从onCreate方法开始执行。• 假设我们将广播的注销放在onStop()，onDestory()方法里的话，有可能在Activity被销毁后还未执行onStop()，onDestory()方法，即广播仍还未注销，从而导致内存泄露。• 但是，onPause()一定会被执行，从而保证了广播在App死亡前一定会被注销，从而防止内存泄露。 两种方式的比较 四、系统广播与接收 系统广播123• Android中内置了多个系统广播（System Broadcast），只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播。• 当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播。• 每个广播都有特定的Intent -Filter（包括具体的action），Android系统广播action如下： 静态注册系统广播接收器 动态注册系统广播接收器 五、应用间广播和应用内广播 应用间广播的问题123• Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true）。可能出现的问题：• 其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理；• 其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 App应用内广播（Local Broadcast）12• App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。• 相比于全局广播（普通广播），App应用内广播优势体现在：安全性高、效率高。 123• 注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收；• 在广播发送和接收时，增设相应权限permission，用于权限验证；• 发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 12• 使用封装好的LocalBroadcastManager类：• 使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例。 六、注意事项 对于不同注册方式的广播接收器回调OnReceive（Context context，Intent intent）中的context返回值是不一样的：1234• 对于静态注册（全局+应用内广播），回调onReceive(context, intent)中的context返回值是：ReceiverRestrictedContext；• 对于全局广播的动态注册，回调onReceive(context, intent)中的context返回值是：Activity Context；• 对于应用内广播的动态注册（LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Application Context；• 对于应用内广播的动态注册（非LocalBroadcastManager方式），回调onReceive(context, intent)中的context返回值是：Activity Context。 其他参考（关于广播类型与特点）12345678910111213# 普通广播 同级别收到先后随机 指定优先级 是在 intent filter 里指定 android: priority 范围是-1000到1000指定优先级后，数值大的先收到截断广播（不能）也不能处理静态注册 在清单文件中 是全局有效的动态注册 优先级高于静态 缺点是 只有当前Activity在运行时才生效# 有序广播 同级别随机先收到的可以截断处理 可以传输数据之类# 异步广播 可以先发送 后注册接收者 需要加权限 七、代码（1）Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.example.app_bcr;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.view.View;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private MyReceiver3 myReceiver3; private MyReceiver6 myReceiver6; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //动态注册与注销 @Override protected void onResume() &#123; super.onResume(); IntentFilter intentFilter = new IntentFilter(\"com.example.app_bcr\"); myReceiver3 = new MyReceiver3(); registerReceiver(myReceiver3, intentFilter); &#125; @Override protected void onPause() &#123; super.onPause(); unregisterReceiver(myReceiver3); unregisterReceiver(myReceiver6); &#125; //静态注册在清单文件中 @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button: &#123; Intent intent = new Intent(); intent.putExtra(\"msg\", \"这是一条普通广播\"); intent.setAction(\"com.example.app_bcr\"); sendBroadcast(intent); break; &#125; case R.id.button2: &#123; Intent intent = new Intent(); intent.putExtra(\"msg\", \"这是一条有序广播\"); intent.setAction(\"com.example.app_bcr_o\"); sendOrderedBroadcast(intent, null); break; &#125; case R.id.button3: &#123; Intent intent = new Intent(); intent.putExtra(\"msg\", \"这是一条异步广播\"); intent.setAction(\"com.example.app_bcr_a\"); sendStickyBroadcast(intent); IntentFilter intentFilter = new IntentFilter(\"com.example.app_bcr_a\"); myReceiver6 = new MyReceiver6(); registerReceiver(myReceiver6, intentFilter); break; &#125; &#125; &#125;&#125;// MyReceiver MyReceiver2 MyReceiver3接收的是 普通广播// 前两个输出的先后体现了优先级设置的作用，第三个和前两个比较体现了动态注册优先级高于静态// MyReceiver4 MyReceiver5接收的是 有序广播 在设置了优先级之后，可以实现广播的有序处理和传播// MyReceiver6接收的是 异步广播 可以看出已经不推荐使用 它能够先发送广播再注册// 注意动态注册与注销分别在onResume 和 onPause中进行// 至于系统广播，应用内广播可直接参考写 （2）清单文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.app_bcr\"&gt;&lt;uses-permission android:name=\"android.permission.BROADCAST_STICKY\"/&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;receiver android:name=\".MyReceiver6\" android:enabled=\"true\" android:exported=\"true\"&gt;&lt;/receiver&gt; &lt;receiver android:name=\".MyReceiver5\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter android:priority=\"100\"&gt; &lt;action android:name=\"com.example.app_bcr_o\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\".MyReceiver4\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter android:priority=\"200\"&gt; &lt;action android:name=\"com.example.app_bcr_o\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\".MyReceiver3\" android:enabled=\"true\" android:exported=\"true\" /&gt; &lt;receiver android:name=\".MyReceiver2\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter android:priority=\"100\"&gt; &lt;action android:name=\"com.example.app_bcr\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\".MyReceiver\" android:enabled=\"true\" android:exported=\"true\"&gt; &lt;intent-filter android:priority=\"200\"&gt; &lt;action android:name=\"com.example.app_bcr\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"to love","slug":"to-love","date":"2020-03-07T23:42:21.000Z","updated":"2020-03-07T23:47:47.607Z","comments":true,"path":"2020/03/08/to-love/","link":"","permalink":"http://nlbyd1119.online/2020/03/08/to-love/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《出包王女》改编自长谷见沙贵负责脚本、矢吹健太朗作画的同名漫画。2007年7月26日透露出《出包王女》TV动画化的消息。电视动画于2008年4月3日开始在TBD、MBS、CBC、BS-i等电视台播放，全26集；OVA则随漫画单行本第13~18卷初回限定版推出，全6集。电视动画第二期《更多出包王女》于2010年10月5日开始播放。电视动画第三期《出包王女Darkness》则是改编自同名的漫画《出包王女Darkness》。电视动画第四期《出包王女DARKNESS 2nd》于2015年7月6日开始播出。 播放第一季http://www.imomoe.in/view/4910.html第二季http://www.imomoe.in/view/5101.html第三季http://www.imomoe.in/view/6267.html第四季http://www.imomoe.in/view/1106.htmlOVAhttp://www.imomoe.in/view/4842.html","categories":[{"name":"2008","slug":"2008","permalink":"http://nlbyd1119.online/categories/2008/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"灰色系列","slug":"灰色系列","date":"2020-03-07T23:32:40.000Z","updated":"2020-03-07T23:41:12.090Z","comments":true,"path":"2020/03/08/灰色系列/","link":"","permalink":"http://nlbyd1119.online/2020/03/08/%E7%81%B0%E8%89%B2%E7%B3%BB%E5%88%97/","excerpt":"概述","text":"概述 &emsp;&emsp;《灰色系列》是Frontwing发行的系列视觉小说游戏。其作品分为“灰色三部曲”（第1部《灰色的果实》、第2部《灰色的迷宫》、最终部《灰色的乐园》）以及完全新作《灰色：幻影扳机》。 播放&emsp;&emsp;灰色的果实http://www.imomoe.in/view/1823.html灰色的迷宫http://www.imomoe.in/view/1469.html灰色的乐园http://www.imomoe.in/view/1466.html幻影扳机http://www.imomoe.in/view/7084.html","categories":[{"name":"2014","slug":"2014","permalink":"http://nlbyd1119.online/categories/2014/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"Another","slug":"Another","date":"2020-03-07T23:28:47.000Z","updated":"2020-03-07T23:32:29.237Z","comments":true,"path":"2020/03/08/Another/","link":"","permalink":"http://nlbyd1119.online/2020/03/08/Another/","excerpt":"概述","text":"概述 &emsp;&emsp;《替身》是根据日本推理作家绫辻行人的推理小说《Another（アナザー）》改编的同名电视动画，由动画公司P.A.WORKS制作，2012年1月9日开始在北日本放送播放，播放至2012年3月26日结束，共12话（已完结）。 剧情简介&emsp;&emsp;那个学校的那个班级，有着对谁都不能说的”秘密”——。1998年春天。转学到夜见山北中学的的榊原恒一（15岁）对班级里那种害怕着某物的气氛抱有违和感。恒一被拥有不可思议的存在感的美少女见崎鸣所吸引，不禁想试着接近她，但却就此陷入更深的谜团之中。在这种情况下，意想不到的惨剧发生了！这个“世界”到底发生了什么……？ 播放http://www.imomoe.in/view/5038.html","categories":[{"name":"2012","slug":"2012","permalink":"http://nlbyd1119.online/categories/2012/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"寄生兽","slug":"寄生兽","date":"2020-03-07T03:43:58.000Z","updated":"2020-03-07T03:47:32.774Z","comments":true,"path":"2020/03/07/寄生兽/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E5%AF%84%E7%94%9F%E5%85%BD/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《寄生兽 生命的准则》改编自日本漫画家岩明均原作的科幻漫画《寄生兽》。2013年11月宣布TV动画化。作品主要描写了平凡的高中生泉新一和寄生在他体内、与其右手同化的生物MIGI共存的坎坷命运。2014年10月9日起每周四0：29在日本电视台首播，全24话。 剧情简介&emsp;&emsp;某天于地球上凭空出现许多孢子，其中诞生的幼虫侵入身体后，以寄生脑部为目标，寄生完成后与脑部细胞同化，管理这个“死掉的身体”。它们能任意变形，其食物便是寄生体相同的物种。&emsp;&emsp;由于寄生生物的出现，到处频传残忍的杀人事件，但人类却淡漠地忽视这种仍属少数的案件，而寄生生物逐渐了解人类世界，学会开始计划组织并利用政治的力量，使世界陷入恐慌中。&emsp;&emsp;泉新一，普通的高中生，但他却是被寄生生物寄生的人类之一，但是由于某种意外，寄生在他体内的生物并没有吃掉他的大脑，而只是取代了他的右手。本性善良正直的泉新一没有被这突如其来的残酷命运击倒，为了被寄生生物杀死的亲友以及所有人类的未来，他决心与其他完全体寄生兽进行殊死搏斗。 播放http://www.imomoe.in/view/2040.html","categories":[{"name":"2014","slug":"2014","permalink":"http://nlbyd1119.online/categories/2014/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"心理测量者","slug":"心理测量者","date":"2020-03-07T03:34:46.000Z","updated":"2020-03-07T03:42:51.958Z","comments":true,"path":"2020/03/07/心理测量者/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E5%BF%83%E7%90%86%E6%B5%8B%E9%87%8F%E8%80%85/","excerpt":"概述","text":"概述 &emsp;&emsp;《心理测量者（Psycho-Pass）》是由noitaminA频道企划、Production I.G制作、虚渊玄编剧的原创动画作品。动画于2012年10月11日放送，全22话，已完结。该作品另有官方的小说、漫画、游戏等衍生作品。&emsp;&emsp;TV动画《心理测量者新编集版》是在原有的22话基础上重新剪辑精简为11话，再加入全新画面的再放送。该作品于2014年7月10日开始播出。2013年9月官方宣布动画第二季与剧场版制作决定。2014年10月9日《PSYCHO-PASS 心理测量者 2》放送开始。2015年1月9日《剧场版 PSYCHO-PASS 心理测量者》公映。2019 年1月25 日、2月 15 日、3月8日《PSYCHO-PASS 心理测量者 Sinners of the System》上映。2019年10月17日《PSYCHO-PASS 心理测量者 3》首播。 剧情简介&emsp;&emsp;在人类的心理状态和性格倾向都能被数值化的未来。所有的感情、欲望、社会病态心理倾向等全部被记录并管理，大众以“好的人生”作为目标，竭力于数值性地实现它。&emsp;&emsp;所有的监控摄像头都已经被升级和联网到一体，通过监视人类的色相浑浊程度和声音、视频等信息用来计算人类的每个心理状态和个性倾向所衡量的值，通称：（即片名：心理测量者PSYCHO-PASS），它被用作判定人们的思想应有PSYCHO-PASS状态、个人精神本身。通过计算这些数值，系统可以自主断定一个人最理想的工作，感情，心理压力，甚至犯罪意图。&emsp;&emsp;因此，为让大众达到“理想的人生”这个指标，人们实现这些数值就变得非常积极。然而，有关犯罪的数值，也就是“犯罪指数”也会被测量，当然犯罪者亦是如此。因此，人们需要不断地保证自己的指数在正常范围，否则会被系统认为是潜在犯，将会被”矫正”。&emsp;&emsp;而同在监视下维持治安的工作的刑警被分为抓捕犯人们的行动部队“执行官”、以及监视指挥执行官们的“监视官”一起合作执行任务。优秀的“执行官”自身就有着相当高的犯罪系数，从矫正设施挑选出来除了当执行官别无其他选择，但正是因为这样才能够接近犯罪根源。因为“执行官”也有着可能孕育成犯罪者的危险倾向，所以就需要对搜查行动有着冷静的判断力的精英“监视官”来监视。&emsp;&emsp;安全局刑事课第一分队的成员各怀想法，虽然发现自己的所作所为常常会与真正的正义相悖却不得不在监视下继续执行任务。同时在处理案件时正在一步步地发觉和探索管理人类这些数值的系统——Sibyl System的真面目。他们所面临的彼岸将会有着什么？ 播放第一季http://www.imomoe.in/view/6271.html第二季http://www.imomoe.in/view/2034.html第三季http://www.imomoe.in/view/7656.html剧场版http://www.imomoe.in/view/7732.html","categories":[{"name":"2012","slug":"2012","permalink":"http://nlbyd1119.online/categories/2012/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"Code Geass 反叛的鲁路修","slug":"Code-Geass-反叛的鲁路修","date":"2020-03-07T03:26:51.000Z","updated":"2020-03-07T03:33:27.368Z","comments":true,"path":"2020/03/07/Code-Geass-反叛的鲁路修/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/Code-Geass-%E5%8F%8D%E5%8F%9B%E7%9A%84%E9%B2%81%E8%B7%AF%E4%BF%AE/","excerpt":"概述","text":"概述 &emsp;&emsp;《Code Geass 反叛的鲁路修》（日文：コードギアス 反逆のルルーシュ，英文：CODE GEASS Lelouch of the Rebellion）是由日本日升公司（SUNRISE）制作的原创电视动画，于2006年10月5日在日本TBS电视台播出，至2007年7月28日结束，全25话+2话总集篇。播出后立刻大受好评，为日本最热门的连载动画之一，连续排名《月刊Newtype》最受欢迎的动画。已被改编成小说和漫画等衍生物，并于2010年推出姊妹篇《Code Geass 亡国的阿基德》。&emsp;&emsp;作品描述被神圣不列颠帝国侵略而亡国的日本——11区中，在生死边缘获得神秘魔女c.c.赋予的Geass力量，立志要粉碎帝国的黑色王子鲁路修·兰佩路基，与坚持公理的白色骑士枢木朱雀所掀起的巨大变化。&emsp;&emsp;电视动画第2期《Code Geass 反叛的鲁路修R2》于2008年4月6日开始播出，全25话。 剧情简介&emsp;&emsp;皇历2010年，超级大国·神圣不列颠尼亚帝国为了夺取日本的地下资源而侵略日本。在欧洲帝国强大的拟人兵器Knightmare进攻下，日本在不到一个月的时间内被征服，被剥夺了自由、权利甚至是国家的名字，神圣不列颠帝国将“日本”改称为“11区”，“日本人”这名词则被11这数字所取代。表面上看来帝国的贵贱阶级统治似乎牢不可破，但其中早已出现了裂痕。&emsp;&emsp;七年后的2017年，在生死边缘获得“Geass”的力量，立志要粉碎神圣不列颠帝国的黑色皇子鲁鲁修，以及获得第七代人型机甲兰斯洛特，立志从帝国内部进行改革的白色骑士枢木朱雀，影响了整个世界。 播放第一季http://www.imomoe.in/view/4692.html第二季http://www.imomoe.in/view/5116.html复活的鲁路修http://www.imomoe.in/view/6753.html","categories":[{"name":"2006","slug":"2006","permalink":"http://nlbyd1119.online/categories/2006/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"来自风平浪静的明天","slug":"来自风平浪静的明天","date":"2020-03-07T03:22:07.000Z","updated":"2020-03-07T03:54:10.891Z","comments":true,"path":"2020/03/07/来自风平浪静的明天/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E6%9D%A5%E8%87%AA%E9%A3%8E%E5%B9%B3%E6%B5%AA%E9%9D%99%E7%9A%84%E6%98%8E%E5%A4%A9/","excerpt":"概述","text":"概述 &emsp;&emsp;《来自风平浪静的明天》是由动画制作公司P.A.WORKS与漫画杂志《电击大王》合作的跨媒体企划，以陆地上与大海中进行着交流的世界为舞台，描写五位中学生和两个小学生在成长过程中经历恋爱、友情、亲情等的治愈故事。动画于2013年10月3日开始，陆续在TOKYO MX、ANIMAX、SUN电视台、KBS京都、爱知电视台等日本各大电视台放送，首播电视台ANIMAX。 剧情简介&emsp;&emsp;由于人口渐少，海洋村落“汐鹿生”中的波路中学被迫废校，学生们都转校到了陆地上的美滨中学。在海中生活的四名少年少女——先岛光、向井户爱花、比良平千咲、伊佐木要，在那里遇到了陆地上的少年——木原纺。以此为契机，青梅竹马的几人彼此之间原本安定的关系也荡起了涟漪…… 播放&emsp;&emsp;","categories":[{"name":"2013","slug":"2013","permalink":"http://nlbyd1119.online/categories/2013/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"狼与香辛料","slug":"狼与香辛料","date":"2020-03-07T03:15:51.000Z","updated":"2020-03-07T03:55:40.046Z","comments":true,"path":"2020/03/07/狼与香辛料/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E7%8B%BC%E4%B8%8E%E9%A6%99%E8%BE%9B%E6%96%99/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《狼与香辛料》改编自日本轻小说家支仓冻砂原作的同名轻小说。2007年8月10日，正式宣布了《狼与香辛料》动画化的决定。电视动画于2008年1月8日起开始播放，全13话，其中TV未放送的第7话收录在DVD第三卷中。而电视动画的第2期《狼与香辛料Ⅱ》则于2009年7月8日开始播放。 剧情简介&emsp;&emsp;到处旅行靠贩卖一些小商品为生的商人罗伦斯，从因为收获祭而沸腾的帕斯罗村回来后，发现貌似有什么东西在自己的运货马车里。罗伦斯把麦束拨开一看，发现里面睡着一只长有狼耳和狼尾巴的少女。这位少女自称是“掌控丰收的贤狼——赫萝”，靠麦子为生的她，如果脖子上挂的帕斯罗麦子遗失了就会死。赫萝死缠着罗伦斯，希望他能够带自己回到遥远的北方故乡，见到少女的一只手变化成狼爪的罗伦斯，虽然仍对赫萝的身份抱有怀疑，但也答应了让想回到出生地的少女一同旅行。于是，狼女与商人“完全没有剑与魔法的”旅行由此展开…… 播放&emsp;&emsp;","categories":[{"name":"2008","slug":"2008","permalink":"http://nlbyd1119.online/categories/2008/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"乒乓","slug":"乒乓","date":"2020-03-07T03:09:25.000Z","updated":"2020-03-07T03:55:28.906Z","comments":true,"path":"2020/03/07/乒乓/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E4%B9%92%E4%B9%93/","excerpt":"概述","text":"概述 &emsp;&emsp;《乒乓》是由日本动画公司龙之子工作室制作的电视动画，于2014年4月10日起在富士电视台“noitaminA”时段播出，全11话。动画整体风格另类，色彩鲜明。作品改编自漫画家松本大洋创作的体育题材类同名漫画。 剧情简介&emsp;&emsp;星野裕（Peko）是乒乓球天才，月本诚（Smile）则是极具天赋的乒乓球好手。他们俩从小一起长大，同为片濑高中乒乓球队队员。在高校联赛中，遇上来自中国上海的孔文革、上届冠军风间龙一，关于乒乓联赛的成长的故事拉开序幕…… 播放&emsp;&emsp;","categories":[{"name":"2014","slug":"2014","permalink":"http://nlbyd1119.online/categories/2014/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"黑之契约者","slug":"黑之契约者","date":"2020-03-07T02:57:59.000Z","updated":"2020-03-07T03:56:06.493Z","comments":true,"path":"2020/03/07/黑之契约者/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E9%BB%91%E4%B9%8B%E5%A5%91%E7%BA%A6%E8%80%85/","excerpt":"概述","text":"概述 &emsp;&emsp;DARKER THAN BLACK -黑之契约者-》是由日本动画公司BONES制作的原创电视动画作品，动画剧情围绕着超能力和间谍活动展开，故事的舞台设定于喧嚣繁华的都市——东京。2007年4月6日起在每日放送首播，全26话。中国大陆由bilibili独家正版。动画第2期《DARKER THAN BLACK -流星之双子-》于2009年10月8日播出。 剧情简介&emsp;&emsp;某日，东京突然出现了异象——无法解析的领域“地狱门”。在那里，有着人们从未见过并持有着超能力的来访者。人们称这些来访者为“契约者”，他们有的失去心智，甚至会残酷地杀害人类……“契约者”们来到东京，究竟意欲何为？ 播放&emsp;&emsp;","categories":[{"name":"2007","slug":"2007","permalink":"http://nlbyd1119.online/categories/2007/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"玉响","slug":"玉响","date":"2020-03-07T02:50:50.000Z","updated":"2020-03-07T03:54:44.219Z","comments":true,"path":"2020/03/07/玉响/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E7%8E%89%E5%93%8D/","excerpt":"概述","text":"概述 &emsp;&emsp;《玉响》是HAL FILM MAKER制作的原创OVA作品，以广岛现实中存在的竹原市为舞台，描写高中生通过照相机感受每日幸福生活的故事。OVA碟片于2010年11月26日、2010年12月23日公开发售，共4话。于2011年1月22日决定TV动画化，第1期《玉响～hitotose～》于2011年10月3日播放；第2期《玉响～more aggressive～》于2013年7月3日播放；完结篇剧场版动画《玉响～毕业写真～》分为四部，分别于2015年4月4日、8月29日、11月28日和2016年4月2日上映。在电视动画放送前，OVA于2011年9月5日－10月2日于网络上配信。 剧情简介&emsp;&emsp;这是一个描写喜欢摄影的高中一年级生泽渡枫和她周围的人的日常琐事的梦物语。泽渡枫是一个喜欢摄影的高中一年级生。这年春天，她搬到了濑户内海一个被青山和大海所包围的宁静小镇——广岛县竹原市。这是她去世的父亲童年生活的地方。这里有陈旧的街道，美丽的海景和善良的居民，当然，还有泽渡枫交到的新朋友们。在枫所拍摄的她所钟爱的这座城市的照片里，偶尔会看到玉响的存在。玉响是枫在拍摄时感受到幸福时候的光芒。幸福好像在一瞬间变成了具体的形状……而且这些照片总是能给大家带来幸福的感受。 播放&emsp;&emsp;","categories":[{"name":"2011","slug":"2011","permalink":"http://nlbyd1119.online/categories/2011/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"好想告诉你","slug":"好想告诉你","date":"2020-03-07T02:42:25.000Z","updated":"2020-03-07T03:56:16.777Z","comments":true,"path":"2020/03/07/好想告诉你/","link":"","permalink":"http://nlbyd1119.online/2020/03/07/%E5%A5%BD%E6%83%B3%E5%91%8A%E8%AF%89%E4%BD%A0/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《好想告诉你》改编自日本漫画家椎名轻穗原作的同名漫画。作品是关于友情和爱情的成长故事，描写外表阴暗，被周围的人称作“贞子”的女高中生黑沼爽子通过自我努力逐渐消除身边的人对她的误解。在漫画杂志《别册玛格丽特》2009年3月号（2月13日发售）上，发表了《好想告诉你》TV动画化的决定。电视动画第1期于2009年10月6日首播，全26话，而第2期《好想告诉你 2ND SEASON》则于2011年1月4日播出，全13话。 剧情简介&emsp;&emsp;传说中的“贞子”浓黑的长发，就算是在盛夏也惨白的皮肤，阴沉的脸，连笑容都让人感到恐惧，只要与她对视3秒就会石化。更不用说接近她，令人发毛的阴森感。就是她——黑沼爽子，一个早已经被遗忘的名字，被大家称做“贞子”的女生，从小学到高中都是如此。几乎没有人知道她的本名，天天都被人害怕着。其实，她只是阴沉了一点点而已，只是而已啦。笑起来有点恐怖，周围的空气流动比较诡异点而已。《好想告诉你》是日本漫画家椎名轻穗创作的一部少女漫画，在集英社旗下的漫画杂志《别册玛格丽特》上连载。2008年获得宝岛社“这本漫画真厉害！”奖… 播放&emsp;&emsp;","categories":[{"name":"2009","slug":"2009","permalink":"http://nlbyd1119.online/categories/2009/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"android基本概念（一）","slug":"a-study-1","date":"2020-03-05T08:21:35.000Z","updated":"2020-03-15T07:38:31.804Z","comments":true,"path":"2020/03/05/a-study-1/","link":"","permalink":"http://nlbyd1119.online/2020/03/05/a-study-1/","excerpt":"一、概述","text":"一、概述 （1）概述：Intent的中文意思是“意图，意向”，在Android中提供了Intent机制来协助应用间的交互与通讯，Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。Intent不仅可用于应用程序之间，也可用于应用程序内部的Activity/Service之间的交互。因此，可以将Intent理解为不同组件之间通信的“媒介”专门提供组件互相调用的相关信息。（2）功能：Intent 是一个将要执行的动作的抽象的描述，一般来说是作为参数来使用，由Intent来协助完成android各个组件之间的通讯。比如说调用startActivity()来启动一个activity,或者由broadcaseIntent()来传递给所有感兴趣的broadcastReceiver, 再或者由startService()/bindservice()来启动一个后台的service。Intent可以启动一个Activity，也可以启动一个Service，还可以发起一个广播Broadcast。二、属性和方法: 12345678910111213141516171819202122 • component(组件) ：目的组件。 • action （动作）：用来表现意图的行动。 • category （类别）：用来表现动作的类别。 • data （数据）：表示与动作要操纵的数据。 • type （数据类型）：对于data范例的描写。 • extras （扩展信息）：扩展信息。 • Flags （标志位）：期望这个意图的运行模式。 • setClass(Context packageContext,Classcls)：设置该Intent将要启动的组件对应的类。• setClassName(Context packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。• setClassName(String packageContext,StringclassName)：设置该Intent将要启动的组件对应的类。 （1）Component属性： 123456789101112131415• Component属性明确指定Intent的目标组件的类名称。 • ComponentName对象包含的构造器 ： • ComponentName(String pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,String cls) ：创建在pkg所在包下的 cls类所对应的组件 • ComponentName(Context pkg,Class cls)创建在pkg所在包下的cls 类所对应的组件 • 一个ComponentName需要指定包名和类名，这就可以唯一确定一 个组件类。 （2）Action属性： Action 是一个用户定义的普通字符串，代表该Intent索要完成的一个抽象“动作”。用于描述一个Android 应用程序组件，一个Intent Filter 可以包含多个Action。在AndroidManifest.xml 的Activity 定义时，可以在其节点指定一个Action列表用于标识Activity 所能接受的“动作”。 Action要完成的只是一个抽象的动作，这个动作具体由哪个组件(Activity,Service,BroadcastReceiver)来完成，Action这个字符不管。比如Android提供的标准Action：Intent.ACTION_VIEW，它只表示一个抽象的查看动作，但具体什么，启动哪个Activity来看，Intent.ACTION_VIEW并不知道—这取决于Activity的配置，只要某个Activity的配置中包含了该ACTION_VIEW，该Activity就有可能被启动。 常见的ActivityAction： 常见的Broadcast Action：（3）Category属性： Category是要执行动作的目标所具有的特质或行为归类，在Intent对象中可添加任意多个category。 常见的category（4）Data和Type: Data，也就是执行动作要操作的数据。Android中采用指向数据的一个URI来表示，如在联系人应用中，一个指向某联系人的URI可能为：content://contacts/1。 Type，即数据类型，显式指定Intent的数据类型（MIME）。一般Intent的数据类型能够根据数据本身进行判定，但是通过设置这个属性，可以强制采用显式指定的类型而不再进行推导。 在AndroidManifest.xml的标签中包含了以下几种子元素，他们定义了url的匹配规则：12345678910111213141516• android:scheme：匹配url中的前缀，除了“http”、“https”、“tel”...之外，我们可以定义自己的前缀。• android:host：匹配url中的主机名部分，如“google.com”，如果定义为“*”则表示任意主机名。• android:port：匹配url中的端口。• android:path：匹配url中的路径。&lt;activity android:name=\".TargetActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.scott.intent.action.TARGET\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"scott\" android:host=\"com.scott.intent.data\" android:port=\"7788\" android:path=\"/target\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; Intent的Action和Data组合例子：（5）Extras属性 Extras属性主要用于传递目标组件所需要的额外的数据。通过putExtras()方法设置。 常用值如下所示：1234567EXTRA_BCC：存放邮件密送人地址的字符串数组。EXTRA_CC：存放邮件抄送人地址的字符串数组。EXTRA_EMAIL：存放邮件地址的字符串数组。EXTRA_SUBJECT：存放邮件主题字符串。EXTRA_TEXT：存放邮件内容。EXTRA_KEY_EVENT：以KeyEvent对象方式存放触发Intent的按键。EXTRA_PHONE_NUMBER：存放调用ACTION_CALL时的电话号码。 （6）Flag（标记） Flag（标记）用于为Intent添加额外控制标记。 常用值如下所示：123456789• FLAG_ACTIVITY_BROUGHT_TO_FRONT：这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。• FLAG_ACTIVITY_CLEAR_TOP：如果目标Activity已经运行于当前的Task中，则关闭Activity Stack中在此Activity上方的所有Activity，然后将此Intent传递到该Activity实例内。• FLAG_ACTIVITY_NEW_TASK：将使Activity成为一个新Task的开始。• FLAG_ACTIVITY_NO_ANIMATION：这个标志将阻止系统进入下一个Activity时应用Acitivity迁移动画。• FLAG_ACTIVITY_NO_HISTORY：新的Activity将不再历史stack中保留。一旦离开，此Activity就关闭了。 三、显式INTENT和隐式Intent 显式：直接指明Intent的接收者，可以利用Bundle传输多对数据。（Bundle bundle = getIntent().getExtras();） 隐式：不指定接收者，指定Action + Data等，因未指定接收者，其意图需要经过过滤，即需要配置INTENT FILTER来确定Intent的接收者（其实这样实现了一个Intent多个接受者，只要满足条件） INTENT FILTER：在清单文件中的接收组件中注册&emsp;（0）概述：未指定接收者的隐式Intent，需要经过Action,Category,Data三种过滤联合筛选出可以接收意图的应用或组件。接收者是其他的应用，那么配置都用android提供的应该即可，但要指定自己应用中的组件接收，则需要通过自定义Action等来具体指定注意一定是完全匹配才可接收。&emsp;（1）意图过滤器 IntentFilter翻译成中文就是“意图过滤器”，主要用来过滤隐式意图。当用户进行一项操作的时候，Android系统会根据配置的“意图过滤器”来寻找可以响应该操作的组件，服务。 例如当用户点击PDF文件的时候，Android系统就会通过设定好的意图过滤器，进行匹配测试。找到能够打开PDF文件的APP程序。（2）三重过滤 Android系统会根据我们配置的Intent Filter（意图过滤器），来进行匹配测试。匹配的时候，只会考虑三个方面：动作、数据（URI以及数据类型）和类别。 也就是说Android系统会进行“动作测试”，“数据测试”，“类别测试”，来寻找可以响应隐式意图的组件或服务。 另外，当对其他App程序开放组件和服务的时候也需要配置IntentFilter（意图过滤器），一个Activity可以配置多个。（3）具体规则:123456789101112131415161718192021对应&lt;intent-filter&gt;中的&lt;action/&gt;标签1.如果&lt;intent-filter&gt;标签中有多个&lt;action/&gt;，那么Intent请求的Action，只要匹配其中的一条&lt;action/&gt;就可以通过了这条&lt;intent-filter&gt;的动作测试。 2.如果&lt;intent-filter&gt;中没有包含任何&lt;action/&gt;，那么无论什么Intent请求都无法和这条&lt;intent-filter&gt;匹配。3.如果Intent请求中没有设定Action(动作)，那么这个Intent请求就将顺利地通过&lt;intent-filter&gt;的动作测试（前提是&lt;intent-filter&gt;中必须包含有&lt;action/&gt;，否则与第二条冲突）。对应&lt;intent-filter&gt;中的&lt;category /&gt;标签1.Intent中的类别必须全部匹配&lt;intent-filter&gt;中的&lt;category /&gt;，但是&lt;intent-filter&gt;中多余的&lt;category /&gt;将不会导致匹配失败。例如：Intent中有3个类别，而意图过滤器中定义了5个，如果Intent中的3个类别都与过滤器中的匹配，那么过滤器中的另外2个，将不会导致类别测试失败。2.注意有一个例外，Android把所有传给startActivity()的隐式意图当作他们包含至少一个类别：\"android.intent.category.DEFAULT\" （CATEGORY_DEFAULT常量）。因此，想要接收隐式意图的活动必须在它们的意图过滤器中包含\"android.intent.category.DEFAULT\"。对应&lt;intent-filter&gt;中的&lt;data&gt;标签1. &lt;data&gt;元素指定了可以接受的Intent传过来的数据URI和数据类型，当一个意图对象中的URI被用来和一个过滤器中的URI比较时，比较的是URI的各个组成部分。2. 例如：如果过滤器仅指定了一个scheme，所有该scheme的URIs都能够和这个过滤器相匹配；如果过滤器指定了一个scheme、主机名但没有路经部分，所有具有相同scheme和主机名的URIs都可以和这个过滤器相匹配，而不管它们的路经；如果过滤器指定了一个scheme、主机名和路经，只有具有相同scheme、主机名和路经的URIs才可以和这个过滤器相匹配。3. 当然，一个过滤器中的路径规格可以包含通配符，这样只需要部分匹配即可。 四、注意点经过后期编写代码，发现需要注意的几个点： action、data这些可以在构造intent时直接作为参数传入，也可以在后面用intent的相关set方法设置。 action的值除了android默认定义好的与系统有关的行为外，如果是涉及要发送intent交给对应的自定义的Activity或Service或Broadcast Receiver处理，那么一般的值应该定义成目标组件所在的包的完整的包名。 data，就目前来看，其值的指定是通过Uri.parse(uri)。 发送请求的action有一条和过滤器中的匹配即可（其实是接收的可以写多个action 但发送的只有一种action），请求时定义的category对应的接收者过滤器中必须全都有（注意DEFAULT） 例","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"Android Studio 使用（四）","slug":"as-use-4","date":"2020-03-04T12:34:55.000Z","updated":"2020-03-04T13:32:10.333Z","comments":true,"path":"2020/03/04/as-use-4/","link":"","permalink":"http://nlbyd1119.online/2020/03/04/as-use-4/","excerpt":"一、代码","text":"一、代码 （1）测试专用布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;Button android:id=\"@+id/button4\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面4\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面3\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.1\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.25\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.4\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面1\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面2\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline3\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline17\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.55\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline18\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;Button android:id=\"@+id/button7\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面5\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.483\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button8\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面6\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline17\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline2\" /&gt; &lt;Button android:id=\"@+id/button9\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面7\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toStartOf=\"@+id/guideline4\" app:layout_constraintHorizontal_bias=\"0.677\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt; &lt;Button android:id=\"@+id/button10\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"页面8\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline18\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline4\" app:layout_constraintTop_toTopOf=\"@+id/guideline17\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）ListView相关ListView主布局和列表项布局 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main2Activity\"&gt; &lt;ListView android:id=\"@+id/listView\" android:layout_width=\"409dp\" android:layout_height=\"729dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" &gt; &lt;/ListView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"match_parent\" android:layout_height=\"190dp\" android:layout_weight=\"1\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"130dp\" android:layout_weight=\"1\" android:text=\"TextView\" /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.SimpleAdapter;import com.example.app_e.Test;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Main2Activity extends AppCompatActivity &#123; private Context context; private ListView lv1; private ArrayAdapter adapter1; private SimpleAdapter adapter2; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); private String[] texts = Test.s; private int[] pics = Test.i; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; lv1 = findViewById(R.id.listView); String[] objects = &#123;\"栉枝实乃梨\",\"山田妖精\",\"谷川柑菜\",\"青山七海\",\"五更琉璃（黑猫）\",\"莓\",\"英梨梨\",\"空银子\",\"尼娅\",\"狛井莲季\",\"小宫惠那\",\"石动乃绘\",\"小野寺小咲\",\"练白龙\",\"泰蕾莎\",\"潮留美海\",\"七宫智音\",\"由比滨结衣\",\"鲇川天理\",\"菱川六花\",\"桂雏菊\",\"柏崎星奈\",\"小豆梓\",\"森宫苍乃\",\"兰花·李\",\"高宫丽娜\",\"驹鸟莲华\",\"婕希卡\",\"羽川翼\",\"一色彩羽\",\"凉水玉青\",\"相麻堇\",\"冢本八云\",\"苏茜亚\",\"冰无小雪\",\"三宅日向\",\"流木野咲\",\"法提娜\",\"山田亚由美\",\"科户濑伊札那\",\"东云皐月\",\"李莓玲\",\"吉田一美\",\"速水玲香\",\"芙蓉枫\",\"林明美\",\"仓岛千百合\",\"米拉洁\"&#125;; //adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_list_item_1, objects); //lv1.setAdapter(adapter1); adapter2 = new SimpleAdapter(context, getData(), R.layout.list_simple_item, new String[]&#123;\"pic\", \"text\"&#125;, new int[]&#123;R.id.imageView, R.id.textView&#125;); lv1.setAdapter(adapter2); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 48; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pic\", pics[i]); map.put(\"text\", texts[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （3）GridView相关GridView主布局和列表项布局 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main3Activity\"&gt; &lt;GridView android:id=\"@+id/gridView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"1dp\" android:layout_marginTop=\"1dp\" android:layout_marginEnd=\"1dp\" android:layout_marginBottom=\"1dp\" android:horizontalSpacing=\"10dp\" android:verticalSpacing=\"10dp\" android:numColumns=\"3\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/imageView3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/h1\" /&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" /&gt;&lt;/LinearLayout&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.GridView;import android.widget.ImageView;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.example.app_e.Test;public class Main3Activity extends AppCompatActivity&#123; private int[] imgs = Test.i; private String[] texts = Test.s; private Context context; private GridView gv1; private SimpleAdapter adapter1; private String[] names = &#123;\"栉枝实乃梨\",\"山田妖精\",\"谷川柑菜\",\"青山七海\",\"五更琉璃（黑猫）\",\"莓\",\"英梨梨\",\"空银子\",\"尼娅\",\"狛井莲季\",\"小宫惠那\",\"石动乃绘\",\"小野寺小咲\",\"练白龙\",\"泰蕾莎\",\"潮留美海\",\"七宫智音\",\"由比滨结衣\"&#125;; private int[] pics = &#123;R.drawable.h1,R.drawable.h2,R.drawable.h3,R.drawable.h4,R.drawable.h5,R.drawable.h6,R.drawable.h7,R.drawable.h8,R.drawable.h9,R.drawable.h10,R.drawable.h11,R.drawable.h12,R.drawable.h13,R.drawable.h14,R.drawable.h15,R.drawable.h16,R.drawable.h17,R.drawable.h18&#125;; private List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; gv1 = findViewById(R.id.gridView); adapter1 = new SimpleAdapter(context, getData(), R.layout.grid_simple_item , new String[]&#123;\"pic\", \"name\"&#125;, new int[]&#123;R.id.imageView3, R.id.textView2&#125;); gv1.setAdapter(adapter1); gv1.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;// ImageView iv1 = findViewById(R.id.imageView4);// TextView tv1 = findViewById(R.id.textView3);// iv1.setImageResource(imgs[i]);// tv1.setText(texts[i]); Intent intent = new Intent(context, Main4Activity.class); intent.putExtra(\"index\", i); startActivity(intent); &#125; &#125;); &#125; private List&lt;Map&lt;String, Object&gt;&gt; getData() &#123; for (int i = 0; i &lt; 18; i++) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"pic\", pics[i]); map.put(\"name\", names[i]); dataList.add(map); &#125; return dataList; &#125;&#125; （4）Spinner 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.Spinner;import com.example.app_e.Test;public class Main5Activity extends AppCompatActivity &#123; private Context context; private ImageView iv1; private Spinner sp1; private ArrayAdapter adapter1; private int selected; //数据源 private int[] pics = Test.i; private String[] items = Test.objects; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main5); context = this; //实例化 iv1 = findViewById(R.id.imageView2); sp1 = findViewById(R.id.spinner); //适配器 adapter1 = new ArrayAdapter&lt;String&gt;(context, android.R.layout.simple_spinner_item, items); adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //设置 sp1.setAdapter(adapter1); //选择项方法 sp1.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; iv1.setImageResource(pics[i]); selected = i; iv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String url = \"https://baike.baidu.com/item/\" + items[selected]; Intent intent = new Intent(context, Main7Activity.class); intent.putExtra(\"url\", url); startActivity(intent); &#125; &#125;); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125;&#125; （5）DatePicker和TimePicker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import java.util.Calendar;import android.app.DatePickerDialog;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TextView;import android.widget.TimePicker;public class Main6Activity extends AppCompatActivity &#123; private Context context; private DatePicker dp1; private TimePicker tp1; private DatePickerDialog dpd1; private TextView tv1; private Button bt1; private Calendar cal; private int year; private int month; private int day; private int hour; private int minute; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main6); context = this; cal = Calendar.getInstance(); year = cal.get(Calendar.YEAR); month = cal.get(Calendar.MONTH) + 1; day = cal.get(Calendar.DAY_OF_MONTH); hour = cal.get(Calendar.HOUR); minute = cal.get(Calendar.MINUTE); String date = year + \"年\" + month + \"月\" + day + \"日\"; setTitle(date); dp1 = findViewById(R.id.datePicker); tp1 = findViewById(R.id.timePicker); tv1 = findViewById(R.id.textView4); bt1 = findViewById(R.id.button6); dp1.init(year, month - 1, day, new DatePicker.OnDateChangedListener() &#123; @Override public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) &#123; year = i; month = i1 + 1; day = i2; String date = year + \"年\" + month + \"月\" + day + \"日\"; tv1.setText(date); &#125; &#125;); tp1.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() &#123; @Override public void onTimeChanged(TimePicker timePicker, int i, int i1) &#123; hour = i; minute = i1; String time = year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\" + minute + \"分\"; tv1.setText(time); &#125; &#125;); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 布局文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main6Activity\"&gt; &lt;TimePicker android:id=\"@+id/timePicker\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:headerBackground=\"#000000\" android:calendarViewShown=\"false\" app:layout_constraintBottom_toTopOf=\"@+id/guideline14\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline13\" /&gt; &lt;DatePicker android:id=\"@+id/datePicker\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:headerBackground=\"#000000\" android:calendarViewShown=\"false\" app:layout_constraintBottom_toTopOf=\"@+id/guideline13\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintHorizontal_bias=\"0.493\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@id/guideline12\" app:layout_constraintVertical_bias=\"0.114\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline12\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.02\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline13\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.46\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline14\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.9\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline15\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.98\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline16\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.7\" /&gt; &lt;TextView android:id=\"@+id/textView4\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"TextView\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline15\" app:layout_constraintEnd_toStartOf=\"@+id/guideline16\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline14\" /&gt; &lt;Button android:id=\"@+id/button6\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"返回\" android:textSize=\"20sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline15\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toEndOf=\"@+id/textView4\" app:layout_constraintTop_toTopOf=\"@+id/guideline14\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （6）WebView清单文件开启权限 1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; Activity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.KeyEvent;import android.webkit.WebResourceRequest;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;public class Main7Activity extends AppCompatActivity &#123; private Context context; private WebView wv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main7); context = this; init(); &#125; private void init() &#123; Intent intent = getIntent(); String url = intent.getStringExtra(\"url\"); wv = findViewById(R.id.webView); wv.loadUrl(url); //覆盖默认通过第三方或系统浏览器打开网页的行为，使网页在WebView内打开 wv.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); //返回为true是在wv中打开，false则使用其他浏览器 return true; &#125; &#125;); WebSettings ws = wv.getSettings(); //启用支持JavaScript ws.setJavaScriptEnabled(true); //加载页面优先使用缓存 ws.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); &#125; //改写按键--返回的逻辑，实现页面的后退 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (wv.canGoBack()) &#123; wv.goBack(); return true; &#125; else &#123; finish(); &#125; &#125; return super.onKeyDown(keyCode, event); &#125;&#125; （7）ProgressBar布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main8Activity\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline19\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.02\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline20\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.1\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline21\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.18\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline25\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.26\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline22\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.25\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline23\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.5\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline24\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.75\" /&gt; &lt;Button android:id=\"@+id/button11\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"增加\" app:layout_constraintBottom_toTopOf=\"@+id/guideline21\" app:layout_constraintEnd_toStartOf=\"@+id/guideline22\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline20\" /&gt; &lt;Button android:id=\"@+id/button12\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"4dp\" android:layout_marginEnd=\"6dp\" android:text=\"减少\" app:layout_constraintBottom_toTopOf=\"@+id/guideline21\" app:layout_constraintEnd_toStartOf=\"@+id/guideline23\" app:layout_constraintStart_toStartOf=\"@+id/guideline22\" app:layout_constraintTop_toTopOf=\"@+id/guideline20\" /&gt; &lt;Button android:id=\"@+id/button13\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"7dp\" android:layout_marginTop=\"4dp\" android:text=\"重置\" app:layout_constraintBottom_toTopOf=\"@+id/guideline21\" app:layout_constraintEnd_toStartOf=\"@+id/guideline24\" app:layout_constraintStart_toStartOf=\"@+id/guideline23\" app:layout_constraintTop_toTopOf=\"@+id/guideline20\" /&gt; &lt;Button android:id=\"@+id/button14\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"3dp\" android:layout_marginEnd=\"6dp\" android:text=\"返回\" app:layout_constraintBottom_toTopOf=\"@+id/guideline21\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline24\" app:layout_constraintTop_toTopOf=\"@+id/guideline20\" /&gt; &lt;ProgressBar android:id=\"@+id/progressBar\" style=\"?android:attr/progressBarStyleHorizontal\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline20\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline19\" /&gt; &lt;TextView android:id=\"@+id/textView5\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"TextView\" android:textSize=\"24sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline25\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline21\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.example.app_e;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ProgressBar;import android.widget.TextView;public class Main8Activity extends AppCompatActivity implements View.OnClickListener &#123; private Context context; private ProgressBar pb1; private TextView tv1; private Button bt1; private Button bt2; private Button bt3; private Button bt4; private int first; private int second; private int max; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main8); context = this; init(); &#125; private void init() &#123; pb1 = findViewById(R.id.progressBar); tv1 = findViewById(R.id.textView5); bt1 = findViewById(R.id.button11); bt2 = findViewById(R.id.button12); bt3 = findViewById(R.id.button13); bt4 = findViewById(R.id.button14); first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(\"第一进度条百分比为\" + (int)((float)first/max * 100) + \"% 第二进度条百分比为\" + (int)((float)second/max * 100) + \"%\"); bt1.setOnClickListener(this); bt2.setOnClickListener(this); bt3.setOnClickListener(this); bt4.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button11: &#123; pb1.incrementProgressBy(10); pb1.incrementSecondaryProgressBy(10); break; &#125; case R.id.button12: &#123; pb1.incrementProgressBy(-10); pb1.incrementSecondaryProgressBy(-10); break; &#125; case R.id.button13: &#123; pb1.setProgress(0); pb1.setSecondaryProgress(10); break; &#125; case R.id.button14: &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); break; &#125; &#125; first = pb1.getProgress(); second = pb1.getSecondaryProgress(); max = pb1.getMax(); tv1.setText(\"第一进度条百分比为\" + (int)((float)first/max * 100) + \"% 第二进度条百分比为\" + (int)((float)second/max * 100) + \"%\"); &#125;&#125; （8）ViewPager子视图布局v1.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.2\" /&gt; &lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guideline3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" app:layout_constraintGuide_percent=\"0.02\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"Button\" android:textSize=\"30sp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"@+id/guideline3\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 主视图代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.example.app_s;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.PagerTabStrip;import androidx.viewpager.widget.ViewPager;import android.content.Context;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import com.example.app_s.custom.CustomPagerAdapter;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private Context context; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; private ViewPager vp; private PagerTabStrip tag; private Button bt1; private Button bt2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //获得视图对象，加入视图列表，标题加入标题列表 viewList = new ArrayList&lt;&gt;(); titleList = new ArrayList&lt;&gt;(); View v1 = View.inflate(context, R.layout.v1, null); View v2 = View.inflate(context, R.layout.v2, null); viewList.add(v1); viewList.add(v2); titleList.add(\"页面一\"); titleList.add(\"页面二\"); //针对各个视图获取控件实例，编写逻辑实现代码 bt1 = v1.findViewById(R.id.button); bt2 = v2.findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.i(\"tag\", \"测试无误\"); //Toast.makeText(context, \"测试无误\", Toast.LENGTH_LONG); &#125; &#125;); //创建设置适配器 vp = findViewById(R.id.viewPager); CustomPagerAdapter customPagerAdapter = new CustomPagerAdapter(viewList, titleList); vp.setAdapter(customPagerAdapter); //设置页面标题的属性，虽然此处报错，但可以生效 tag = findViewById(R.id.tag);// tag = (PagerTabStrip)vp.getTag(); tag.setBackgroundColor(Color.BLACK); tag.setTextColor(Color.WHITE); tag.setDrawFullUnderline(false); tag.setTabIndicatorColor(Color.YELLOW); &#125;&#125; 自定义PagerAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.example.app_s.custom;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.viewpager.widget.PagerAdapter;import java.util.List;public class CustomPagerAdapter extends PagerAdapter &#123; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; public CustomPagerAdapter(List&lt;View&gt; viewList, List&lt;String&gt; titleList) &#123; this.viewList = viewList; this.titleList = titleList; &#125; /* 返回的是页卡的数量 */ @Override public int getCount() &#123; return viewList.size(); &#125; /* 判断页卡是否来自对象 */ @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view == object; &#125; /* 实例化一个页卡 */ @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; container.addView(viewList.get(position)); return viewList.get(position); &#125; /* 销毁一个页卡 */ @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; container.removeView(viewList.get(position)); &#125; /* 给每个视图添加标题 */ @Nullable @Override public CharSequence getPageTitle(int position) &#123; return titleList.get(position); &#125;&#125; （9）图片轮播ViewFlipper主布局 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main3Activity\"&gt; &lt;ViewFlipper android:id=\"@+id/viewFlipper\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 进出效果（anim文件夹下）left_in.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:duration=\"2000\" android:fromXDelta=\"-100%p\" android:toXDelta=\"0\"/&gt; &lt;alpha android:fromAlpha=\"0.5\" android:toAlpha=\"1\" android:duration=\"2000\"/&gt;&lt;/set&gt; left_out.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:duration=\"2000\" android:fromXDelta=\"0\" android:toXDelta=\"100%p\"/&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0.5\" android:duration=\"2000\"/&gt;&lt;/set&gt; Activity代码 1234567891011121314151617181920212223242526272829303132333435package com.example.app_z;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.widget.ImageView;import android.widget.ViewFlipper;public class Main3Activity extends AppCompatActivity &#123; private Context context; private ViewFlipper vf; private int[] pic = &#123;R.drawable.h1, R.drawable.h2, R.drawable.h3, R.drawable.h4&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; vf = findViewById(R.id.viewFlipper); for (int i = 0; i &lt; pic.length; i++) &#123; vf.addView(getImageView(pic[i])); &#125; vf.setInAnimation(context, R.anim.left_in); vf.setOutAnimation(context, R.anim.left_out); vf.setFlipInterval(3000); vf.startFlipping(); &#125; private ImageView getImageView(int p) &#123; ImageView imageView = new ImageView(context); imageView.setImageResource(p); return imageView; &#125;&#125; （10）Fragment静态加载fragment_blank.xml 1234567891011121314151617181920&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot; xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot; android:layout_width&#x3D;&quot;match_parent&quot; android:layout_height&#x3D;&quot;match_parent&quot;&gt; &lt;TextView android:id&#x3D;&quot;@+id&#x2F;textView2&quot; android:layout_width&#x3D;&quot;300dp&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;占位&quot; android:textSize&#x3D;&quot;30sp&quot; &#x2F;&gt; &lt;Button android:id&#x3D;&quot;@+id&#x2F;button6&quot; android:layout_width&#x3D;&quot;wrap_content&quot; android:layout_height&#x3D;&quot;wrap_content&quot; android:text&#x3D;&quot;跳转&quot; android:textSize&#x3D;&quot;30sp&quot;&#x2F;&gt;&lt;&#x2F;LinearLayout&gt; BlankFragment.java 1234567891011121314151617181920212223package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;public class BlankFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_blank, container, false); &#125;&#125; Main2Activity.java 1234567891011121314151617181920212223242526272829303132package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Context context; private Button bt1; private TextView tv1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; bt1 = findViewById(R.id.button6); tv1 = findViewById(R.id.textView2); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(\"fragment静态加载\"); &#125; &#125;); &#125;&#125; （11）Fragment动态加载fragment_blank_fragment2.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"300dp\" android:layout_height=\"wrap_content\" android:text=\"占位\" android:textSize=\"30sp\" /&gt; &lt;Button android:id=\"@+id/button6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"跳转\" android:textSize=\"30sp\"/&gt;&lt;/LinearLayout&gt; BlankFragment2.java 1234567891011121314151617181920212223242526272829303132333435package com.example.app_n;import android.content.Context;import android.net.Uri;import android.os.Bundle;import androidx.fragment.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.TextView;public class BlankFragment2 extends Fragment &#123; private Button bt1; private TextView tv1; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_blank_fragment2, container, false); tv1 = view.findViewById(R.id.textView2); bt1 = view.findViewById(R.id.button6); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; tv1.setText(\"fragment动态加载\"); &#125; &#125;); return view; &#125;&#125; Main3Activity.java 1234567891011121314151617181920212223package com.example.app_n;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;public class Main3Activity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); BlankFragment2 blankFragment = new BlankFragment2(); FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); //注意这个R.id.frame表示的是放置fragment的布局控件 fragmentTransaction.add(R.id.frame, blankFragment); fragmentTransaction.commit(); &#125;&#125; （12）音乐播放将音频文件放在资源文件夹raw下 1234private MediaPlayer mp = new MediaPlayer();mp = MediaPlayer.create(this, R.raw.h);mp.start(); （13）无标题栏主题配置 1android:theme=\"@style/Theme.AppCompat.NoActionBar\" 参考：https://blog.csdn.net/lvxiangan/article/details/82783667 二、说明 经实践，以上代码均可较容易地重用。 存在问题，ListView和GridView的列表项无法用约束布局，导致显示效果有问题；Fragment主布局和自身布局均无法使用约束布局；DatePickerDialog和TimePickerDialog存在api版本问题报错，因而未进行完整测试，ProgressBarDialog同理；DatePicker和TimePicker的大小调整和日历显示存在问题。 学习项目：引导动画和过渡动画，自定义适配器等。 关于上篇RecycleListView的说明：事实上，RecycleView才是一种视图控件，而RecycleListView与其无关，不应使用和混淆，参考： https://blog.csdn.net/github_37130188/article/details/89648136https://blog.csdn.net/yuan1244487110/article/details/90401874https://blog.csdn.net/allen315410/article/details/40379159?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"Android Studio 使用（三）","slug":"as-use-3","date":"2020-03-01T02:43:06.000Z","updated":"2020-03-04T13:29:50.638Z","comments":true,"path":"2020/03/01/as-use-3/","link":"","permalink":"http://nlbyd1119.online/2020/03/01/as-use-3/","excerpt":"一、AndroidManifest","text":"一、AndroidManifest 全局配置 gradle模块此部分配置是放在build.gradle中，包括sdk版本等 组件配置四种组件的功能–注册–必要的标签利用intent-filter(可视为组件名片)实现组件间通信的方法 权限配置申请权限：https://www.cnblogs.com/AAAI/p/10899381.html权限参考：http://www.bejson.com/doc/AndroidManifest/自定义权限： 可以实现不同应用间组件的通信或阻止通信保护组件 二、数据源–适配器–视图（使用默认适配器，视图ListView GridView）#### 必要步骤layout 将ListView/GridView脱入主布局（约束布局）activity中 建立控件私有变量 并一定要先在onCreate中实例化 创建数据源分两类：a.格式单一的数据，由数组、集合等存储，常用的就是ArrayAdapter所用的字符串数组b.格式复杂的数据，由特定泛型的集合存储List&lt;Map&lt;Object,Object&gt;&gt;，一个Map表示一项（可包含文字图片）b类数据源涉及：定义私有数据源dataList 重写方法getData来给dataList添加数据并返回 定义适配器及设置数据源与SimpleAdapter的列表项布局准备根据两类数据源，分别对应两类适配器（常用情况下如此，但实际上还有重写适配器等实现方法，后面会记述）a.ArrayAdapter（数据源一般为字符串数组）b.SimpleAdapter（数据源一般为map列表） 特别注意参数（1） ArrayAdapter(上下文this,默认列表项布局(ID),数据源)常用的列表项布局是simple_list_item_1；android.R.layout中全部布局的效果参考：https://blog.csdn.net/qq_36408196/article/details/82819024 ，这些布局都是只有一个TextView，因此数据源只能是字符串数组；当然也可以自定义列表项布局，可能能实现展现其他形式数据的目的，也可以使用重写适配器的方法，这些以后再进行实践验证。总之，一般的ArrayAdapter使用就使用simple_list_item_1展示字符串。（2） SimpleAdapter(上下文this,数据源getData(),自定义列表项布局（ID),自定义数据源dataList中Map所有键的数组String[] from,对应Map每个键的列表项布局中控件的id组成的数组int[] to)后两个参数实现了定义数据源的map的键和布局文件中控件id的映射； 由参数可知，定义SimpleAdapter前，需先布局好列表项的形式和数据源形式（定义getData()方法）；SimpleAdapter必须自定义列表项布局，列表项如何布局与使用为ListView/GridView有关自定义列表项布局（1）应选择线性布局（2）ListView 案例布局参考：list_simple_item.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"match_parent\" android:layout_height=\"190dp\" android:layout_weight=\"1\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"130dp\" android:layout_weight=\"1\" android:text=\"TextView\" /&gt;&lt;/LinearLayout&gt; （3）GridView 案例布局参考：grid_simple_item.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/imageView3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/h1\" /&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"TextView\" /&gt;&lt;/LinearLayout&gt; 关键是android:gravity=”center”为使GridView生效，还应该在主布局中加上三个属性设置： 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".Main3Activity\"&gt; &lt;GridView android:id=\"@+id/gridView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"1dp\" android:layout_marginTop=\"1dp\" android:layout_marginEnd=\"1dp\" android:layout_marginBottom=\"1dp\" android:horizontalSpacing=\"10dp\" &lt;!--需加--&gt; android:verticalSpacing=\"10dp\" &lt;!--需加--&gt; android:numColumns=\"3\" &lt;!--自定义列数--&gt; app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （4）就以上两种布局，均存在无法自适应，显示有问题的缺陷，需要以后实践改善重写适配器（1）参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html（2）后续实践3. 给视图实例对象添加适配器4. 实现点击列表项事件方法，滚动方法（1）列表项从零计数 倒数第二个参数是点击的标号position（2）滚动事件 可实现动态增加数据源 三、案例实现（1）使用urlib爬取图片和描述，并用正则处理文本图片 123456789101112131415161718192021from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = \"https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc\"request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=\"utf-8\")# l = re.findall('&lt;img class=\"large\" data-loadfunc=0 src=\"(.+)\" data-loaded=0', s)exml = etree.HTML(s)links = exml.xpath(\"//img[@class='large']/@src\")count = 1for l in links[1:]: request = Request(l) response = urlopen(request) path = \"p\" + str(count) + \".jpg\" with open(path, \"wb\") as f: f.write(response.read()) f.flush() count = count + 1 描述 12345678910111213141516from urllib.request import urlopenfrom urllib.request import Requestimport requestsfrom lxml import etreeurl = \"https://baijiahao.baidu.com/s?id=1597344111243871701&amp;wfr=spider&amp;for=pc\"request = Request(url)response = urlopen(request)html = response.read()s = str(html, encoding=\"utf-8\")# l = re.findall('&lt;img class=\"large\" data-loadfunc=0 src=\"(.+)\" data-loaded=0', s)exml = etree.HTML(s)ss = exml.xpath(\"//div[@class='article-content']//span[@class='bjh-p']//text()\")with open(\"2.txt\", \"a\") as f: for s in ss: f.write(s + \"\\n\") f.flush() （2） 跳转页面时实现传输数据参考：https://jingyan.baidu.com/article/d621e8da20c67f2865913fe6.html 1234567//发送Intent intent = new Intent(context, target.class);intent.putExtra(key, value);startActivity(intent);//接收Intent intent = getIntent();//再由intent调用具体getExtra()方法获取 四、后续学习RecycleListView参考：https://blog.csdn.net/gongch0604/article/details/89025024https://blog.csdn.net/morgerton/article/details/78983976https://www.jianshu.com/p/b4bb52cdbeb7https://www.jianshu.com/p/4f9591291365重写适配器参考：https://blog.csdn.net/qq_33399371/article/details/76285726https://blog.csdn.net/whycmpx/article/details/80580913https://www.cnblogs.com/penghuster/p/5001161.html","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"间客（一）","slug":"间客1","date":"2020-02-29T15:43:27.000Z","updated":"2020-03-01T02:36:19.532Z","comments":true,"path":"2020/02/29/间客1/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E9%97%B4%E5%AE%A21/","excerpt":"间客","text":"间客","categories":[{"name":"猫腻","slug":"猫腻","permalink":"http://nlbyd1119.online/categories/%E7%8C%AB%E8%85%BB/"}],"tags":[{"name":"小说整理","slug":"小说整理","permalink":"http://nlbyd1119.online/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/"}]},{"title":"野上由加奈","slug":"野上由加奈","date":"2020-02-29T15:27:29.000Z","updated":"2020-02-29T15:41:37.243Z","comments":true,"path":"2020/02/29/野上由加奈/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E9%87%8E%E4%B8%8A%E7%94%B1%E5%8A%A0%E5%A5%88/","excerpt":"野上由加奈","text":"野上由加奈","categories":[{"name":"70","slug":"70","permalink":"http://nlbyd1119.online/categories/70/"}],"tags":[{"name":"声优记录","slug":"声优记录","permalink":"http://nlbyd1119.online/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/"}]},{"title":"限制级末日症候（一）","slug":"限制级末日症候1","date":"2020-02-29T11:07:04.000Z","updated":"2020-03-01T02:36:11.507Z","comments":true,"path":"2020/02/29/限制级末日症候1/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E9%99%90%E5%88%B6%E7%BA%A7%E6%9C%AB%E6%97%A5%E7%97%87%E5%80%991/","excerpt":"限制级末日症候","text":"限制级末日症候","categories":[{"name":"全部成为F","slug":"全部成为F","permalink":"http://nlbyd1119.online/categories/%E5%85%A8%E9%83%A8%E6%88%90%E4%B8%BAF/"}],"tags":[{"name":"小说整理","slug":"小说整理","permalink":"http://nlbyd1119.online/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/"}]},{"title":"水星领航员","slug":"水星领航员","date":"2020-02-29T10:26:05.000Z","updated":"2020-02-29T10:34:21.562Z","comments":true,"path":"2020/02/29/水星领航员/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E6%B0%B4%E6%98%9F%E9%A2%86%E8%88%AA%E5%91%98/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画系列《水星领航员》改编自日本漫画家天野梢原作的同名漫画。电视动画共3期，另有1部OVA。第一期于2005年10月5日至12月28日播放，共13集；第二期于2006年4月2日至9月24日播放，共26集；第三期于2008年1月7日至3月31日播放，共13集。电视动画的制作切合了播出时的季节变化, 即剧中的春夏秋冬与实际的春夏秋冬是同步的，所以，原著漫画中的部分情节到了动画里面后，发生的季节就变了。为纪念TV动画播出10周年，《水星领航员》系列新剧场版《水星领航员 The AVVENIRE》将于2015年9月26日上映。 剧情简介&emsp;&emsp;随着未来科技的飞速发展，人类在2301年将一颗蛮荒行星火星改造成为美丽的“水星”，并命名为“AQUA”。那里最著名的观光都市“新威尼斯”有着一群心怀梦想的少女，被称为“领航员”的她们每天以小船载着游客领略城市的美景。15岁的水无灯里从高度电子机械化的地球只身来到“新威尼斯”，在一所名为“ARIA”的小领航员公司找到了工作，就此开始了她的领航员生涯。 播放第一季https://v.youku.com/v_show/id_XNDM5MDkwNjMy.html?tpa=dW5pb25faWQ9MTAzNzUzXzEwMDAwMV8wMV8wMQ&amp;refer=sousuotoufang_market.qrwang_00002944_000000_QJFFvi_19031900第二季https://v.youku.com/v_show/id_XNDc1NjkwODcy.html?tpa=dW5pb25faWQ9MTAzNzUzXzEwMDAwMV8wMV8wMQ&amp;refer=sousuotoufang_market.qrwang_00002944_000000_QJFFvi_19031900第三季https://v.youku.com/v_show/id_XNDM5MDk2NzM2.html?tpa=dW5pb25faWQ9MTAzNzUzXzEwMDAwMV8wMV8wMQ&amp;refer=sousuotoufang_market.qrwang_00002944_000000_QJFFvi_19031900","categories":[{"name":"2005","slug":"2005","permalink":"http://nlbyd1119.online/categories/2005/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"重启咲良田","slug":"重启咲良田","date":"2020-02-29T10:14:26.000Z","updated":"2020-03-07T03:54:32.660Z","comments":true,"path":"2020/02/29/重启咲良田/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E9%87%8D%E5%90%AF%E5%92%B2%E8%89%AF%E7%94%B0/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《重启咲良田》改编自河野裕创作、椎名优插画的同名小说，由david production制作。动画于2017年4月5日起在TOKYO MX播出，全24话。 剧情简介&emsp;&emsp;半数居民都拥有特殊能力的街道，咲良田。在负责监视能力者的“管理局”管理下，居民过着和平的生活。“想要消去眼前之人的泪水”、“想要将声音传达给某人”。伴随着这种温柔而又细微的“愿望”，这条街道的能力诞生了。&emsp;&emsp;拥有能够回想起过去体验过的全部记忆的“记忆保持”能力的浅井惠，以及拥有“最大能够将世界倒带3天”的“重启”能力的春埼美空。她自身也受到“重启”的影响而失去了记忆，但通过与决不会忘记任何事情的惠齐心协力，两人得以将过去重来，并改变现在。&emsp;&emsp;但，也存在着即使是这样的两人也无法重来的“过去”。那是，两年前同级生相麻堇受到“重启”的影响而消失的事情。&emsp;&emsp;两人从属于名为“服务社团”的社团活动，一边过着完成学生们各种各样委托的每一天，一边寻找着能够让相麻堇复活的方法。这样的他们收到了一件委托——“希望让死去的猫复活”。&emsp;&emsp;为了消除在过去发生的“悲哀”，少年与少女穿越时间，前去改变世界—— 播放&emsp;&emsp;","categories":[{"name":"2017","slug":"2017","permalink":"http://nlbyd1119.online/categories/2017/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"我们的存在","slug":"我们的存在","date":"2020-02-29T10:08:43.000Z","updated":"2020-03-07T03:54:59.628Z","comments":true,"path":"2020/02/29/我们的存在/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E6%88%91%E4%BB%AC%E7%9A%84%E5%AD%98%E5%9C%A8/","excerpt":"概述","text":"概述 &emsp;&emsp;《我们的存在》是根据日本漫画家小畑友纪的同名少女漫画改编的电视动画。于2006年7月3日开始在KBS京都电视台放送，总共有26话。 剧情简介&emsp;&emsp;内心满怀期待，希望广交朋友的高桥七美开始了她的高中生活。她在众多同学的交谈中发现了一个倍受瞩目的焦点——据说三分之二的女生都会喜欢的男生，矢野元晴。因班委事务而接近的两人很快就有了交集。 15岁的高桥七美迎来了人生中最大的失算，所谓的喜欢，便是如此意外。渐渐地，七美开始走近矢野，以及矢野那暗藏着无法直面的回忆的过去……. 播放&emsp;&emsp;","categories":[{"name":"2006","slug":"2006","permalink":"http://nlbyd1119.online/categories/2006/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"来自新世界","slug":"来自新世界","date":"2020-02-29T09:58:58.000Z","updated":"2020-03-07T03:55:50.087Z","comments":true,"path":"2020/02/29/来自新世界/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E6%9D%A5%E8%87%AA%E6%96%B0%E4%B8%96%E7%95%8C/","excerpt":"概述","text":"概述 &emsp;&emsp;电视动画《来自新世界》是根据贵志祐介原作同名小说改编的动画作品。由A-1 Pictures制作，于2012年9月28日首播，共25话。 剧情简介&emsp;&emsp;作品以千年之后的未来为背景，讲述了日本的孩子们不断地消失，只存在想象中的奇异动物与人类展开战争的故事。反乌托邦式的未来社会「新世界」，是能够口吐真言、凭藉「咒力」操纵物体的人类，与有著等同于普通人智力的生物「化鼠」共存的世界。乍看之下一切和平，但「新世界」的孩子们被彻底地控制和管束著，不合适的记忆被消去，被认为有问题的孩子如同不良产品般被处理。因为一些违反规则的小事而莫名失去朋友的主人公早季，卷进了人类与化鼠之间的战争……本作除了令人毛骨悚然的故事情节外，还对未来社会持续破坏自然环境所引发的一系列问题… 播放&emsp;&emsp;","categories":[{"name":"2012","slug":"2012","permalink":"http://nlbyd1119.online/categories/2012/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"天元突破","slug":"天元突破","date":"2020-02-29T09:46:50.000Z","updated":"2020-03-07T03:55:13.364Z","comments":true,"path":"2020/02/29/天元突破/","link":"","permalink":"http://nlbyd1119.online/2020/02/29/%E5%A4%A9%E5%85%83%E7%AA%81%E7%A0%B4/","excerpt":"概述","text":"概述 &emsp;&emsp;《天元突破红莲螺岩》是由GAINAX制作的原创动画，于2007年4月1日至9月30日播出，2007年09月30日完结，全27话，另有DS版特典番外篇1话。该作品获选为2007年第11回文部省文化厅媒体艺术祭动画部门优秀奖。 剧情简介&emsp;&emsp;《天元突破红莲螺岩》的舞台架设在架空的未来世界，住在不知天空为何物的村庄“基哈”的少年“西蒙”在开垦村庄时，偶然挖掘到一块闪耀着神秘光芒的晶体。在那之后，巨大的机器人从天井中冲入，对村庄进行大肆地破坏，西蒙与大哥卡米纳以及从地面来的少女优子一起，与巨大的机器人展开了殊死的战斗。 播放&emsp;&emsp;","categories":[{"name":"2007","slug":"2007","permalink":"http://nlbyd1119.online/categories/2007/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"Android Studio 使用（二）","slug":"as-use-2","date":"2020-02-27T08:18:48.000Z","updated":"2020-02-29T09:45:09.287Z","comments":true,"path":"2020/02/27/as-use-2/","link":"","permalink":"http://nlbyd1119.online/2020/02/27/as-use-2/","excerpt":"基本控件练习","text":"基本控件练习 一、Activity Andoid四大组件：ActicityServiceBroadcastReceiverContent Provider Activity是一个应用程序组件，提供用户与程序交互的界面 Activity创建与注册：继承与自动生成的MainActivity相同的父类，在清单文件中注册。12345678910&lt;!-- 新建模块时自动生成的Activity --&gt;&lt;activity android:name=\".MainActivity\"&gt; &lt;!-- 表示应用程序的首启动项 --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;!-- 新创建的第二个Activity 会自动注册 --&gt;&lt;activity android:name=\".Main2Activity\"&gt;&lt;/activity&gt; Activity生命周期 二、页面跳转 Intent可以理解为信使（意图），由其来协助完成Android各个组件间的通讯。 两种跳转方式：第一个Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.app_t;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; //第一种跳转方式 简单的跳转到另一个页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //第一个参数为上下文对象，因匿名内部类无法直接取到外部类this，因此事先定义并赋this //第二个参数是目标Activity的类对象 Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //第二种跳转方式 会携带请求码，与重写的onActivity方法接收的响应码共同决定一个指定操作，可获得返回数据 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main2Activity.class); startActivityForResult(intent, 1); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 1 &amp;&amp; resultCode == 2) &#123; String content = data.getStringExtra(\"data\"); tv1 = findViewById(R.id.textView); tv1.setText(content); &#125; &#125;&#125; 第二个Activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.app_t;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Main2Activity extends AppCompatActivity &#123; private Button bt1; private Button bt2; private TextView tv1; private Context context; private String content = \"第二种跳转方法返回\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); context = this; //第一种跳转返回 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //第二种跳转返回 bt2 = findViewById(R.id.button2); bt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); //设置响应数据 data.putExtra(\"data\", content); setResult(2, data); //此处必须有finish finish(); &#125; &#125;); &#125;&#125; 三、实践细节 现在Empty Activity继承的是AppCompatActivity而非Activity，其区别可参考：https://blog.csdn.net/today_work/article/details/79300181https://blog.csdn.net/u012602304/article/details/90756655 现在获取控件实例不需类型转换 四、基本控件练习（部分） 做了一个小案例，结合了TextView，EditText，ImageView，Button，ImageButton，ToggleButton，CheckBox，RadioGroup，RadioButton，CalendarView控件，基本上熟悉了基本界面的绘制和事件的设置。 问题与细节（1）绘制布局首先要用guideline划分好区域，并在xml文件中手动修改百分比为可控值，这是保证布局在真机上显示正常（完整不重叠）的先决条件，实践证明guideline非常重要且极有作用。参考： https://www.jianshu.com/p/862caaceccb1https://www.jianshu.com/p/a4a5f8c91fdehttps://www.jianshu.com/p/2ab12ba05dc8（2）关于控件属性设置的经验：显示文本的控件切忌高度要wrap， 不能充满约束，否则很可能显示不出来文本；显示图像和日历的控件水平垂直均充满约束；其他按钮等若要显示文本的，高度也是wrap。（3）关于继承父类的问题：在实现跑马灯效果时，发现as推荐继承的是AppCompatTextView，这个不影响什么， 但属性里关于focus的两个属性必须去掉，否则无法生效。参考： https://www.cnblogs.com/merbn/p/11351459.htmlhttps://blog.csdn.net/zhangphil/article/details/81388186https://www.jianshu.com/p/6e232196c511（4）关于如何在app里添加音乐： https://blog.csdn.net/pythontojava/article/details/48058087 https://blog.csdn.net/qq_31939617/article/details/79969796（5）连接逍遥模拟器的命令： adb connect 127.0.0.1:21503（6）关于ImageView 的 ScaleType 属性： https://www.jianshu.com/p/e046b4201289https://www.jianshu.com/p/b8e75430f3dchttps://blog.csdn.net/qq_34902522/article/details/76682293（7）关于android的文档：https://www.runoob.com/android/android-resources.htmlhttps://blog.csdn.net/whitenebula/article/details/81171095https://developer.android.google.cn/reference/android/widget/TextView?hl=enhttps://developer.android.google.cn/guide/topics/ui/declaring-layouthttps://www.jianshu.com/p/a567c5cf8e1ahttps://blog.csdn.net/carson_ho/category_5959547.html（8）需要特别注意的一点是，as设计页面可能不会显示部分控件，如本机的DatePicker、TimePicker等，既然无法直接拖动放置，那么就只能手动在xml文件中输入，自然会出现。（9）关于CalendarView：https://www.jianshu.com/p/0c06f71d0be8 主要代码MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.app_f;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.ToggleButton;public class MainActivity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private Button bt1; private Context context; private ToggleButton tbt1; private ToggleButton tbt2; private ImageView iv1; private ImageView iv2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mp =MediaPlayer.create(this, R.raw.h); mp.start(); context = this; // Button 添加点击事件，跳转至第二页面 bt1 = findViewById(R.id.button); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, Main2Activity.class); startActivity(intent); &#125; &#125;); //ToggleButton 和 ImageView结合使用，切换图片 tbt1 = findViewById(R.id.toggleButton3); iv1 = findViewById(R.id.imageView); tbt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt1.getText().equals(getString(R.string.button3_text))) &#123; iv1.setImageResource(R.drawable.yml); &#125; else &#123; iv1.setImageResource(R.drawable.lrd); &#125; &#125; &#125;); tbt2 = findViewById(R.id.toggleButton4); iv2 = findViewById(R.id.imageView3); tbt2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tbt2.getText().equals(getString(R.string.button4_text))) &#123; iv2.setImageResource(R.drawable.gn); &#125; else &#123; iv2.setImageResource(R.drawable.st); &#125; &#125; &#125;); &#125;&#125; Main2Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.example.app_f;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageButton;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.TextView;import android.widget.Toast;public class Main2Activity extends AppCompatActivity &#123; private MediaPlayer mp = new MediaPlayer(); private ImageButton ibt1; private Context context; private TextView tv1; private TextView tv2; private RadioGroup rg1; private RadioButton rb1; private Button bt1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); mp = MediaPlayer.create(this, R.raw.z); mp.start(); context = this; //ImageButton 添加点击事件 跳回第一页面 ibt1 = findViewById(R.id.imageButton); ibt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mp.stop(); Intent intent = new Intent(context, MainActivity.class); startActivity(intent); &#125; &#125;); //为文字添加点击方法，以第二种形式跳转至第三页面 tv1 = findViewById(R.id.textView2); tv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(context, Main3Activity.class); startActivityForResult(intent, 2); &#125; &#125;); tv2 = findViewById(R.id.textView3); //为最后的选择提供跳转 rg1 = findViewById(R.id.radioGroup); bt1 = findViewById(R.id.button3); bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (tv2.getText().length() &gt; 0) &#123; int selected = rg1.getCheckedRadioButtonId(); if (selected == R.id.radioButton2) &#123; mp.stop(); Intent intent = new Intent(context, Main4Activity.class); startActivity(intent); &#125; else &#123; mp.stop(); Intent intent = new Intent(context, Main5Activity.class); startActivity(intent); &#125; &#125; if (tv2.getText() == null) &#123; Toast.makeText(context, \"为实现你的目的，请点击下方红字\", Toast.LENGTH_LONG * 3); &#125; &#125; &#125;); &#125; //显示第三页面返回的结果 @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == 2 &amp;&amp; resultCode == 3) &#123; String content = data.getStringExtra(\"content\"); tv2.setText(content); &#125; &#125;&#125; Main3Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.app_f;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.content.Intent;import android.media.MediaPlayer;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.CalendarView;import android.widget.CheckBox;import android.widget.EditText;import android.widget.Toast;public class Main3Activity extends AppCompatActivity &#123; private EditText et1; private EditText et2; private CalendarView cv1; private CheckBox cb1; private CheckBox cb2; private CheckBox cb3; private CheckBox cb4; private Button bt1; private String content; private Context context; private String date = \"\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); context = this; et1 = findViewById(R.id.editText); et2 = findViewById(R.id.editText2); cv1 = findViewById(R.id.calendarView); cb1 = findViewById(R.id.checkBox); cb2 = findViewById(R.id.checkBox2); cb3 = findViewById(R.id.checkBox3); cb4 = findViewById(R.id.checkBox4); bt1 = findViewById(R.id.button2); //拼凑结果 bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent data = new Intent(); StringBuffer sb = new StringBuffer(); if (et1.getText().length() &gt; 0) &#123; sb.append(\"你最怨恨的事是：\"); sb.append(et1.getText()); &#125; else &#123; Toast.makeText(context, \"输入不完整，重新输入\", Toast.LENGTH_LONG * 3).show(); &#125; if (et2.getText().length() &gt; 0) &#123; sb.append(\"\\n\"); sb.append(\"你最怨恨的人是：\"); sb.append(et2.getText()); &#125; else &#123; Toast.makeText(context, \"输入不完整，重新输入\", Toast.LENGTH_LONG * 3).show(); &#125; sb.append(\"\\n你选择的执行时间是\"); sb.append(date); sb.append(\"\\n你选择的本司员工为：\"); if (cb1.isChecked()) &#123; sb.append(cb1.getText() + \" \"); &#125; if (cb2.isChecked()) &#123; sb.append(cb2.getText() + \" \"); &#125; if (cb3.isChecked()) &#123; sb.append(cb3.getText() + \" \"); &#125; if (cb4.isChecked()) &#123; sb.append(cb4.getText() + \" \"); &#125; //Log.i(\"tag\", date); //设置响应数据 content = sb.toString(); data.putExtra(\"content\", content); setResult(3, data); finish(); &#125; &#125;); //获取选择的日期 cv1.setOnDateChangeListener(new CalendarView.OnDateChangeListener() &#123; @Override public void onSelectedDayChange(@NonNull CalendarView calendarView, int i, int i1, int i2) &#123; date = i + \"年\" + i1 + \"月\" + i2 + \"日\"; &#125; &#125;); &#125;&#125;","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"Android Studio 使用（一）","slug":"as-use-1","date":"2020-02-26T14:38:14.000Z","updated":"2020-02-27T03:56:56.691Z","comments":true,"path":"2020/02/26/as-use-1/","link":"","permalink":"http://nlbyd1119.online/2020/02/26/as-use-1/","excerpt":"as使用：问题与解决参考（2020.2.25-2.26）","text":"as使用：问题与解决参考（2020.2.25-2.26） 一、消除清单文件的黄色警告 参考：https://blog.csdn.net/LJX_ahut/article/details/89711478&emsp;https://blog.csdn.net/qq_35003588/article/details/104192062 两种方法，我采用的是修改gradle文件,在module的build.gradle 的android {}下添加: 123lintOptions &#123; disable 'GoogleAppIndexingWarning' &#125; 二、解决新增控件时布局xml文件中的报错 问题：This view is not constrained, it only has designtime positions；原因是默认约束布局，需要给控件添加约束，可以自己添加，也可以自动添加。 自动添加参考：2.x版本：https://www.jianshu.com/p/dcb76b24bbe9 https://www.jianshu.com/p/723811aa4dfe 3.x版本：https://blog.csdn.net/qunqunstyle99/article/details/81209031 https://blog.csdn.net/bssynhdjzmh/article/details/79728625 三、关于约束布局的使用（重点） 重点参考：csdn guolin：https://blog.csdn.net/guolin_blog/article/details/53122387 https://www.jianshu.com/p/6c9950d1789b 其他：https://www.jianshu.com/p/ac450f6386ee https://blog.csdn.net/guolin_blog https://www.jianshu.com/p/eff62726ea84 https://www.jianshu.com/p/81f85d761aa9 https://www.jianshu.com/p/6c9950d1789b 说明：约束布局因有发挥可视化开发优势、效率等优势（具体见上链接），而较为推荐使用，有很大的灵活性，可以自由根据自己想法调整空间具体位置、大小。要想继续学习控件，首先要知道约束布局下怎样给控件添加约束。 蓝图视图可以帮助你更清晰地查看约束和 guidelines (辅助线)，而不会被内容或背景分散注意力。 控件间垂直对齐是指控件竖直的中心线在同一条竖线上，将两控件的左右两边对应连起来或者连到相同的地方即可；水平对齐指控件水平方向的中心线在同一条横线上，将两控件上下两边对应相连或者连到相同的地方即可。 为使文字显示完全，垂直方向应用wrap，和约束没有关系。 四、关于基本控件 TextView和EditView ImageView 实际和预览不一致的可能性较大，最好将其作为组件而非背景。 Button和ImageButton：onClick事件 监听器 OnClickListner接口 R文件在生成文件夹中，不可改变，存放各控件和资源文件对应的id java文件中获取控件 返回的是View类型，需要类型转换 监听事件的三种写法：（1）匿名内部类： 是监听接口的实现类，每个控件可以实现自己独立的动作（2）外部类： 可以执行外部父类和内部匿名子类两种动作,适用于多个控件有共同动作和自己独立动作的情况 （3）接口方式实现：当前Activity实现监听器接口，需要绑定监听事件的实例调用set监听器方法，参数为this 给控件绑定监听事件的一般流程：（1）实例化控件（私有属性、类型转换、id）；（2）按照三种方法实现监听事件，注意set监听器的方法是监听器的实例。 属性：关于控件的相关尺寸，用dp，文字用sp AutoCompleteTextView和MultiAutoCompleteTextView均有自动匹配输入的功能：（1）AutoCompleteTextView均有属性completionThreshold=”n”，即设置输入n个字符时开始匹配，匹配产生的内容是自定义的；实现方法：由id获得控件实例，创建一个适配器，创建数据源并交给适配器，将适配器与控件实例绑定；（2）MultiAutoCompleteTextView与前者的区别在于支持一次输入的多关键词匹配，每次匹配的是分隔符之后的内容，需要指定分隔符；实现方法：前几步与前者同，此外还需要设置分隔符。 多状态按钮ToggleButton：实现通过更改ToggleButton状态来切换图片。实现方法：获取按钮和图片实例，给按钮设置监听器setOnCheckedChangedListner，实现监听方法切换图片源。 复选框CheckBox实现多选效果：CheckBox可单独使用，可多个共同使用；具有checked属性，默认为false;设置监听器setOnCheckedChangedListner RadioGroup与RadioButton：RadioButton不能单独使用；RadioGroup是RadioButton的集合，提供多选一的机制，可由orientation属性决定水平还是竖直排布；设置RadioGroup的监听器setOnCheckedChangedListner（注意是RadioGroup包下的） 五、一些效果的实现 使用TextView实现跑马灯效果:（1）修改布局文件控件属性的方法仅对单个TextView有效；（2）采 用自定义TextView的方法，重载isFocused方法，并在布局文件中指明；（3）注：所谓跑马灯实现，一个是内容当行单行显示+内容隐藏；一个是保持焦点，后者只有通过自定义控件类的方法才可使多个控件能同时具有焦点，从而实现效果。","categories":[{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"Android Studio 项目结构","slug":"Android-Studio-structure","date":"2020-02-25T10:41:59.000Z","updated":"2020-09-12T06:17:45.571Z","comments":true,"path":"2020/02/25/Android-Studio-structure/","link":"","permalink":"http://nlbyd1119.online/2020/02/25/Android-Studio-structure/","excerpt":"Android Studio 目录结构","text":"Android Studio 目录结构 说明 据初步了解，as和idea新建项目时最大的区别就是：idea会创建两个模块，一个与项目名称相同，一个为app模块；而as只会创建一个app模块，更符合项目仅为工作空间的含义。 为更具普适性，接下来对项目目录结构的说明是在一个项目下建好两个模块app和app_o的基础上进行的。 需要特别注意的是，在as开发时呈现的项目机构、目录并不符合磁盘上的存储形式，即在as中同属一个目录的文件实际在磁盘上也许并不在同一目录，或者有的目录不存在，因此下面将会分as中和磁盘两种情况进行说明 可能是as版本问题，在网上搜索到的as目录结果均与现使用版本存在差异，因此下面也给出了这些情况的链接。 实际上，网上搜到的as目录结构应该和磁盘情况是一致的，但与本人不一致。 后续在使用as时，发现产生区别的原因仅在于as中存在多个项目浏览文件的视图，我用的是Android视图，其他用的是Project视图而已。 本机as项目结构 磁盘项目结构https://blog.csdn.net/qq_39312230/article/details/80314236 该博客中介绍的结构和本地磁盘中结构基本一致，可参考：一、项目目录1、.gradle和.idea这两个目录下放置的都是Android Studio自动生成的一些文件，我们无须关心，也不要去手动编辑。2、app项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本都是在这个目录下进行的，待会儿还会对这个目录单独展开进行讲解。3、build这个目录你也不需要过多关心，它主要包含了一些在编译时自动生成的文件。4、gradle这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启动gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏 –&gt; File –&gt; Settings –&gt; Build，Execution，Deployment –&gt; Gradle，进行配置更改。5、.gitignore这个文件是用来将指定的目录或文件排除在版本控制之外的。6、build.gradle这是项目全局的gradle构建脚本，通常这个文件的内容是不需要修改的。下面回详细分析gradle构建脚本中的具体内容。7、gradle.properties这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。8、gradlew和gradlew.bat这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。9、xxx.imliml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），用于标识这是一个IntelliJ IDEA项目，我们不需要修改这个文件中的任何内容。10、local.properties这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们并不需要修改。除非你本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可。11、settings.gradle这个文件用于指定项目中所有引入的模块。二、app模块目录1、build这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关系。2、libs如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。3、src/AndroidTest此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试。4、src/main/java毫无疑问，java目录是放置我们所有java代码的地方，展开该目录，你将看到我们刚才创建的HelloWorldActivity文件就在里面。5、src/main/res这个目录下的内容就有点多了。简单点说，就是你在项目中使用到的所有图片，布局，字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄得乱糟糟的。6、main/AndroidManifest.xml这是你整个Android项目的配置文件，你在程序中定义的所以四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。7、test此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。8、.gitignore这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的.gitignore文件类似。9、app.imlIntelliJ IDEA项目自动生成的文件，我们不需要关心或修改这个文件中的内容。10、build.gradle这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置。11、proguard-rules.pro这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码混淆，从而让破解者难以阅读。三、项目中的资源以drawable开头的文件夹都是用来放图片的；以mipmap开头的文件夹都是用来放应用图标的；以values开头的文件夹都是用来放字符串、样式、颜色等配置的；layout文件夹是用来放布局文件的。 其他参考链接https://blog.csdn.net/admans/article/details/80921534https://www.cnblogs.com/ahochen/p/10676600.htmlhttps://www.jianshu.com/p/481b46cd5562","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://nlbyd1119.online/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"}]},{"title":"蜂蜜与四叶草","slug":"蜂蜜与四叶草","date":"2020-02-24T14:43:41.000Z","updated":"2020-03-07T03:56:31.247Z","comments":true,"path":"2020/02/24/蜂蜜与四叶草/","link":"","permalink":"http://nlbyd1119.online/2020/02/24/%E8%9C%82%E8%9C%9C%E4%B8%8E%E5%9B%9B%E5%8F%B6%E8%8D%89/","excerpt":"概述","text":"概述 &emsp;&emsp;《蜂蜜与四叶草》是根据羽海野千花创作的同名漫画改编的电视动画。2004年决定动画化，在富士电视台深夜档播放。关西电视广播决定在2005年夏天，东海电视也决定播放.动画由J.C.STAFF制作，第一季于2005年4月14日起在富士电视台播放，全24话，其第二季《蜂蜜与四叶草Ⅱ》于2006年6月29日起在富士电视台播放，全12话。动画获选为2005年第九回日本文部省文化厅媒体艺术祭动画部门推荐作品。 剧情简介&emsp;&emsp;美大学生竹本、真山、森田在破旧不堪的公寓中过着贫困而快乐的生活。&emsp;&emsp;一天，花本老师向3人介绍了他堂兄弟的女儿——小巧、惹人爱怜的插班生·叶久美。看到天真烂漫的叶久美，竹本和森田在一瞬间坠入情网。单纯得令周围人不耐烦、迟钝的竹本，以及用令人费解的方式让周围人困惑的森田。在完全相反的两人的爱情表现的交错中，森田自不必说，就连竹本甚至是叶久美也都没有察觉到对方的心情，就这样时间在流逝。&emsp;&emsp;另一方面，真山一直对至今追寻因交通事故而亡的丈夫身影的建筑设计师理花念念不忘。他同时又逐渐察觉到义无反顾爱着自己的同年级学生山田的心情。希望能填补理花心灵空缺的真山、真山的爱成为负担的理花、唯独对喜欢的真山无法表示关心的山田。&emsp;&emsp;以各自感到恋情、苦于思念的两对三角关系为中心，难过而又有些奇妙的“单相思物语”开始缓缓启动。 播放&emsp;&emsp;","categories":[{"name":"2005","slug":"2005","permalink":"http://nlbyd1119.online/categories/2005/"}],"tags":[{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"}]},{"title":"Hexo 入门操作","slug":"hello-world","date":"2020-02-24T14:03:40.439Z","updated":"2020-02-27T03:57:26.104Z","comments":true,"path":"2020/02/24/hello-world/","link":"","permalink":"http://nlbyd1119.online/2020/02/24/hello-world/","excerpt":"Hello World","text":"Hello World Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://nlbyd1119.online/categories/hexo/"}],"tags":[{"name":"博客框架","slug":"博客框架","permalink":"http://nlbyd1119.online/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/"}]}],"categories":[{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/categories/%E9%9A%8F%E7%AC%94/"},{"name":"基础","slug":"基础","permalink":"http://nlbyd1119.online/categories/%E5%9F%BA%E7%A1%80/"},{"name":"功能点学习","slug":"功能点学习","permalink":"http://nlbyd1119.online/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/"},{"name":"框架","slug":"框架","permalink":"http://nlbyd1119.online/categories/%E6%A1%86%E6%9E%B6/"},{"name":"硬件","slug":"硬件","permalink":"http://nlbyd1119.online/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/categories/%E5%89%8D%E7%AB%AF/"},{"name":"NoSql","slug":"NoSql","permalink":"http://nlbyd1119.online/categories/NoSql/"},{"name":"记录","slug":"记录","permalink":"http://nlbyd1119.online/categories/%E8%AE%B0%E5%BD%95/"},{"name":"fabric","slug":"fabric","permalink":"http://nlbyd1119.online/categories/fabric/"},{"name":"Web框架","slug":"Web框架","permalink":"http://nlbyd1119.online/categories/Web%E6%A1%86%E6%9E%B6/"},{"name":"框架使用","slug":"框架使用","permalink":"http://nlbyd1119.online/categories/%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"},{"name":"环境","slug":"环境","permalink":"http://nlbyd1119.online/categories/%E7%8E%AF%E5%A2%83/"},{"name":"控制器","slug":"控制器","permalink":"http://nlbyd1119.online/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/"},{"name":"日志","slug":"日志","permalink":"http://nlbyd1119.online/categories/%E6%97%A5%E5%BF%97/"},{"name":"模板","slug":"模板","permalink":"http://nlbyd1119.online/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"安全","slug":"安全","permalink":"http://nlbyd1119.online/categories/%E5%AE%89%E5%85%A8/"},{"name":"ORM","slug":"ORM","permalink":"http://nlbyd1119.online/categories/ORM/"},{"name":"环境配置","slug":"环境配置","permalink":"http://nlbyd1119.online/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"容器","slug":"容器","permalink":"http://nlbyd1119.online/categories/%E5%AE%B9%E5%99%A8/"},{"name":"移动布局","slug":"移动布局","permalink":"http://nlbyd1119.online/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/"},{"name":"爬虫","slug":"爬虫","permalink":"http://nlbyd1119.online/categories/%E7%88%AC%E8%99%AB/"},{"name":"Flask","slug":"Flask","permalink":"http://nlbyd1119.online/categories/Flask/"},{"name":"数据可视化","slug":"数据可视化","permalink":"http://nlbyd1119.online/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"写法","slug":"写法","permalink":"http://nlbyd1119.online/categories/%E5%86%99%E6%B3%95/"},{"name":"概念","slug":"概念","permalink":"http://nlbyd1119.online/categories/%E6%A6%82%E5%BF%B5/"},{"name":"live2d","slug":"live2d","permalink":"http://nlbyd1119.online/categories/live2d/"},{"name":"pandas","slug":"pandas","permalink":"http://nlbyd1119.online/categories/pandas/"},{"name":"numpy","slug":"numpy","permalink":"http://nlbyd1119.online/categories/numpy/"},{"name":"plot","slug":"plot","permalink":"http://nlbyd1119.online/categories/plot/"},{"name":"css","slug":"css","permalink":"http://nlbyd1119.online/categories/css/"},{"name":"JSP","slug":"JSP","permalink":"http://nlbyd1119.online/categories/JSP/"},{"name":"论文","slug":"论文","permalink":"http://nlbyd1119.online/categories/%E8%AE%BA%E6%96%87/"},{"name":"版本控制工具","slug":"版本控制工具","permalink":"http://nlbyd1119.online/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"},{"name":"2008","slug":"2008","permalink":"http://nlbyd1119.online/categories/2008/"},{"name":"2014","slug":"2014","permalink":"http://nlbyd1119.online/categories/2014/"},{"name":"2012","slug":"2012","permalink":"http://nlbyd1119.online/categories/2012/"},{"name":"2006","slug":"2006","permalink":"http://nlbyd1119.online/categories/2006/"},{"name":"2013","slug":"2013","permalink":"http://nlbyd1119.online/categories/2013/"},{"name":"2007","slug":"2007","permalink":"http://nlbyd1119.online/categories/2007/"},{"name":"2011","slug":"2011","permalink":"http://nlbyd1119.online/categories/2011/"},{"name":"2009","slug":"2009","permalink":"http://nlbyd1119.online/categories/2009/"},{"name":"猫腻","slug":"猫腻","permalink":"http://nlbyd1119.online/categories/%E7%8C%AB%E8%85%BB/"},{"name":"70","slug":"70","permalink":"http://nlbyd1119.online/categories/70/"},{"name":"全部成为F","slug":"全部成为F","permalink":"http://nlbyd1119.online/categories/%E5%85%A8%E9%83%A8%E6%88%90%E4%B8%BAF/"},{"name":"2005","slug":"2005","permalink":"http://nlbyd1119.online/categories/2005/"},{"name":"2017","slug":"2017","permalink":"http://nlbyd1119.online/categories/2017/"},{"name":"工具使用","slug":"工具使用","permalink":"http://nlbyd1119.online/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"hexo","slug":"hexo","permalink":"http://nlbyd1119.online/categories/hexo/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://nlbyd1119.online/tags/JavaWeb/"},{"name":"android","slug":"android","permalink":"http://nlbyd1119.online/tags/android/"},{"name":"随笔","slug":"随笔","permalink":"http://nlbyd1119.online/tags/%E9%9A%8F%E7%AC%94/"},{"name":"sql","slug":"sql","permalink":"http://nlbyd1119.online/tags/sql/"},{"name":"区块链","slug":"区块链","permalink":"http://nlbyd1119.online/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Go","slug":"Go","permalink":"http://nlbyd1119.online/tags/Go/"},{"name":"总结","slug":"总结","permalink":"http://nlbyd1119.online/tags/%E6%80%BB%E7%BB%93/"},{"name":"前端","slug":"前端","permalink":"http://nlbyd1119.online/tags/%E5%89%8D%E7%AB%AF/"},{"name":"PythonWeb","slug":"PythonWeb","permalink":"http://nlbyd1119.online/tags/PythonWeb/"},{"name":"效果","slug":"效果","permalink":"http://nlbyd1119.online/tags/%E6%95%88%E6%9E%9C/"},{"name":"Python Science","slug":"Python-Science","permalink":"http://nlbyd1119.online/tags/Python-Science/"},{"name":"通用","slug":"通用","permalink":"http://nlbyd1119.online/tags/%E9%80%9A%E7%94%A8/"},{"name":"番剧记录","slug":"番剧记录","permalink":"http://nlbyd1119.online/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/"},{"name":"小说整理","slug":"小说整理","permalink":"http://nlbyd1119.online/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/"},{"name":"声优记录","slug":"声优记录","permalink":"http://nlbyd1119.online/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/"},{"name":"博客框架","slug":"博客框架","permalink":"http://nlbyd1119.online/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/"}]}