<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>block_paper_2 | Memory</title>
  <meta name="description" content="1ps: 注意查 许可区块链 HyperledgerFabric：用于许可区块链的分布式操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="block_paper_2">
<meta property="og:url" content="http://nlbyd1119.online/2020/04/03/block_paper_2/index.html">
<meta property="og:site_name" content="Memory">
<meta property="og:description" content="1ps: 注意查 许可区块链 HyperledgerFabric：用于许可区块链的分布式操作系统">
<meta property="og:locale" content="zh">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200404093902895.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405085639174.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405112612953.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405113556481.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405113610124.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405114630538.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405115845187.png">
<meta property="og:image" content="http://nlbyd1119.online/block_paper_2/20200405120934651.png">
<meta property="article:published_time" content="2020-04-02T23:59:04.000Z">
<meta property="article:modified_time" content="2020-05-29T00:23:35.968Z">
<meta property="article:author" content="nlby">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nlbyd1119.online/block_paper_2/20200404093902895.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://nlbyd1119.online/2020/04/03/block_paper_2/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Memory" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.loli.net/2020/09/12/4y1TBOItE9w8WFq.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css">
  
  
  
<meta name="generator" content="Hexo 4.2.0"></head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/nlby" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">nlby</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> NanJing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
      </ul>
      
	

	  <embed src="https://jxiaoc.github.io/animeMusic/demo.html" width="100%"/>
	  <iframe frameborder="no" border="0" marginwidth="0"
						marginheight="0" width="100%" height=86 src="//music.163.com/outchain/player?type=0&id=4872500795&auto=0&height=66">
	  </iframe>
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>记录和总结一下学习过程及其他</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2005/">2005</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2006/">2006</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2007/">2007</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2008/">2008</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2009/">2009</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2011/">2011</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2012/">2012</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2013/">2013</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2014/">2014</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/2017/">2017</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/70/">70</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JSP/">JSP</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSql/">NoSql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/">ORM</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E6%A1%86%E6%9E%B6/">Web框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/fabric/">fabric</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/live2d/">live2d</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/numpy/">numpy</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pandas/">pandas</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/plot/">plot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A8%E9%83%A8%E6%88%90%E4%B8%BAF/">全部成为F</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%99%E6%B3%95/">写法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/">功能点学习</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%B9%E5%99%A8/">容器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A7%E5%88%B6%E5%99%A8/">控制器</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">数据可视化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/">框架使用</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A6%82%E5%BF%B5/">概念</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/">版本控制工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8C%AB%E8%85%BB/">猫腻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83/">环境</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A1%AC%E4%BB%B6/">硬件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%B8%83%E5%B1%80/">移动布局</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%B0%E5%BD%95/">记录</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python-Science/" rel="tag">Python Science</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PythonWeb/" rel="tag">PythonWeb</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" rel="tag">博客框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/" rel="tag">声优记录</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/" rel="tag">小说整理</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%88%E6%9E%9C/" rel="tag">效果</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" rel="tag">版本控制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/" rel="tag">番剧记录</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E7%94%A8/" rel="tag">通用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a><span class="tag-list-count">10</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Go/" style="font-size: 13.5px;">Go</a> <a href="/tags/JavaWeb/" style="font-size: 14px;">JavaWeb</a> <a href="/tags/Python-Science/" style="font-size: 13.6px;">Python Science</a> <a href="/tags/PythonWeb/" style="font-size: 13.3px;">PythonWeb</a> <a href="/tags/android/" style="font-size: 13.8px;">android</a> <a href="/tags/sql/" style="font-size: 13px;">sql</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 13.2px;">前端</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 13.4px;">区块链</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" style="font-size: 13px;">博客框架</a> <a href="/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/" style="font-size: 13px;">声优记录</a> <a href="/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/" style="font-size: 13.1px;">小说整理</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 13.3px;">总结</a> <a href="/tags/%E6%95%88%E6%9E%9C/" style="font-size: 13px;">效果</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 13px;">机器学习</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 13px;">正则表达式</a> <a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" style="font-size: 13px;">版本控制</a> <a href="/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/" style="font-size: 13.9px;">番剧记录</a> <a href="/tags/%E9%80%9A%E7%94%A8/" style="font-size: 13px;">通用</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 13.7px;">随笔</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">51</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">25</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%A8%A1%E6%9D%BF/">模板</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/09/layui-freemarker-%E6%A8%A1%E6%9D%BF/" class="title">layui freemarker 模板</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-09T04:16:29.000Z" itemprop="datePublished">2020-10-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/">功能点学习</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/06/mybatis%E4%B8%8E%E5%A4%9A%E8%A1%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="title">mybatis与多表问题解决</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-06T05:24:55.000Z" itemprop="datePublished">2020-10-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%8A%9F%E8%83%BD%E7%82%B9%E5%AD%A6%E4%B9%A0/">功能点学习</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/06/%E5%88%86%E9%A1%B5-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="title">分页 文件上传</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-06T00:38:50.000Z" itemprop="datePublished">2020-10-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
              </p>
              <p class="item-title">
                <a href="/2020/10/01/git%E4%B8%8Eidea%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95/" class="title">git与idea版本控制测试</a>
              </p>
              <p class="item-date">
                <time datetime="2020-10-01T05:54:17.000Z" itemprop="datePublished">2020-10-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a>
              </p>
              <p class="item-title">
                <a href="/2020/09/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/" class="title">接口测试</a>
              </p>
              <p class="item-date">
                <time datetime="2020-09-30T10:41:38.000Z" itemprop="datePublished">2020-09-30</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
	<!------ 位置可自定义 ------>
<div class="Canvas" style="position: fixed; right: 0px; bottom: 0px;z-index: 99999999" id="L2dCanvas"></div>

<!------ 依赖 JS | Dependent JS ------>
<!---- 可选 | Optional ---->
<!-- 兼容低版本浏览器 | Compatible with low-level browsers -->
<script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"> </script>
<!-- 音频播放兼容 | Audio playback compatible -->
<script src="https://cdn.jsdelivr.net/npm/howler@2.1.3/dist/howler.min.js"></script>
<!---- 必需 | Required ---->
<script src="https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dcubismcore.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi.js@4.6.1/dist/pixi.min.js"></script>
<!-- live2dv3.js -->
<script src="https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.0.2/static/live2dv3.js"></script>

<!------ 加载Live2d模型 | Load Live2d model ------>	
<script>
    window.onload = () => {
        new l2dViewer({
             el: document.getElementById('L2dCanvas'),
                basePath: 'https://cdn.jsdelivr.net/gh/nlby/live2dCDN@1.1.1/assets/', // 模型根目录
                modelName: 'xuefeng_3', // 模型目录
                sizeLimit: false,
                mobileLimit: false
            
            
        })
    }
</script>
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-block_paper_2" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      block_paper_2
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/04/03/block_paper_2/" class="article-date">
	  <time datetime="2020-04-02T23:59:04.000Z" itemprop="datePublished">2020-04-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/04/03/block_paper_2/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 注意查 许可区块链</span><br></pre></td></tr></table></figure>
<p><strong>HyperledgerFabric：用于许可区块链的分布式操作系统</strong></p>
<a id="more"></a>
<p><strong>摘要</strong><br>Fabric是一个<strong>模块化和可扩展</strong>的开源系统，用于部署和操作许可区块链，是Linux基金会（<a href="http://www.hyperledger.org）托管的Hyperledger项目之一。" target="_blank" rel="noopener">www.hyperledger.org）托管的Hyperledger项目之一。</a><br>Fabric是用于<strong>运行分布式应用程序的第一个真正可扩展的区块链系统</strong>。它支持<strong>模块化共识协议</strong>，该协议允许系统针对特定用例和信任模型进行定制。 Fabric也是第一个<strong>运行以标准通用编程语言编写的分布式应用程序的区块链系统</strong>，而<strong>无需依赖系统性的native加密货币</strong>。这与现有的区块链平台形成鲜明对比，现有的区块链平台要求以领域特定的语言或依赖加密货币来编写“智能合约”。 Fabric使用<strong>可移植的成员身份概念来实现许可模型</strong>，该成员身份可以与行业标准的身份管理集成在一起。为了支持这种灵活性，Fabric引入了一种全新的区块链设计，并改进了区块链应对非确定性，资源枯竭和性能攻击等问题的方式。<br>本文介绍了Fabric的架构，各种设计决策的基本原理，其最突出的实现方面以及其<strong>分布式应用程序编程模型</strong>。我们通过实现和基准化受比特币启发的数字货币来进一步评估Fabric。我们证明，在某些流行的部署配置中，Fabric可以实现每秒3500多个端到端事务的吞吐量，而亚秒级的延迟可以很好地扩展到100多个节点。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: peers 译为客户端即可 此处翻译成了对等方 对等端 为统一，先用notepad替换一下 但为了省事，译为节点</span><br></pre></td></tr></table></figure>
<p><strong>一、介绍</strong><br>区块链可以定义为用于记录交易的不可变分类账，并在相互不信任的节点组成的分布式网络中维护。每个节点都维护一个分类帐的副本。节点执行共识协议以验证交易，将交易分组为块，并在这些块上构建哈希链。该过程通过对交易进行排序（ordering the transactions）来形成分类帐，这是保持一致性所必需的。区块链随比特币一起出现，被广泛认为是在数字世界中运行可信交易所的技术。<br>在公共或未经许可的区块链中，任何人都可以在没有特定身份的情况下参与。公共区块链通常涉及native加密货币，并使用基于“工作量证明”（PoW）和经济激励措施的共识。而<strong>许可区块链在一组已知的，已认证的参与者之间运行一个区块链</strong>。<strong>许可区块链提供了一种方法来保证一组具有共同目标但彼此之间并不完全信任的实体之间的交互的安全性</strong>，例如交易资金，商品或信息的企业。通过依靠peers的身份，许可区块链可以使用传统的拜占庭容错（BFT）共识。<br>区块链可以以智能合约的形式执行任意的，可编程的交易逻辑，如以太坊那样。比特币中的脚本是该概念的前身。智能合约充当可信任的分布式应用程序，并从区块链和基本共识中获得peers间的安全性。这非常类似于使用<strong>状态机复制（SMR）</strong>构建弹性应用程序的著名方法。然而，区块链与传统的SMR不同，有着<strong>拜占庭式的缺陷</strong>，主要表现在：（1）不仅有一个，而是有许多分布式应用程序同时运行；（2）应用程序可能被动态部署或被任何人部署；（3）应用程序代码不可信，甚至可能是恶意的。这些差异需要新的设计。<br>许多现有的智能合约区块链遵循SMR的蓝图，并实现所谓的<strong>主动复制</strong>：一个用于共识或原子广播的协议首先排序事务并将其传播到所有peers；其次，每个peer依次执行事务。我们称之为<strong>order execute（排序执行）架构</strong>；它要求所有peers执行每个事务，并且所有事务都是确定性的。顺序执行架构可以在几乎所有现有的区块链系统中找到，从以太坊（基于PoW的共识）等公共区块链系统到Tendermint、Chain和Quorum等每一个被授权区块链系统（基于BFT的共识）。虽然顺序执行设计在所有系统中并不明显，因为附加事务验证步骤可能会使其模糊，但它的局限性是固有的：每个peer执行每个事务，并且事务必须是确定的。<br>先前的许可区块链受到许多限制，这些限制通常来自于它们的无许可的relatives或使用顺序执行体系结构。特别地：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps: order-execute architecture 应为排序执行(order-execute )架构，此处均错误翻译成订单执行架构，为统一，先用notepad替换一下 再把word里全部替换</span><br><span class="line">此处的执行事务即验证事务，验证交易</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">共识机制被硬编码到平台中，这与公认的理解是矛盾的，即应当没有“一刀切”的共识协议。</span><br><span class="line">交易验证的信任模型需要共识机制确认，并且不能适应智能合约的要求；</span><br><span class="line">智能合约必须以固定的，非标准的或特定领域的语言编写，这影响了其广泛的适用性并可能导致编程错误。</span><br><span class="line">所有peers顺序执行所有事务会限制性能，并且需要采取复杂的措施来防止源自不受信任合同的针对平台的服务dos攻击(denial-of-service attacks)（例如，以太坊中的gas机制）；</span><br><span class="line">事务必须是确定性的，这可能很难以编程方式确保；</span><br><span class="line">每个智能合约都在所有peers上运行，这与机密性不符，并且禁止将合约代码和状态散布给peers的子集。</span><br></pre></td></tr></table></figure>
<hr>
在本文中，我们描述了Hyperledger Fabric或简称Fabric，它是克服了这些限制的开源区块链平台。Fabric是Linux Foundation主持下的Hyperledger项目之一。在不同的行业和用例中，Fabric用于400多个原型，概念验证以及生产分布式账本系统中。这些用例包括但不限于诸如分歧解决，贸易物流，外汇结算，食品安全，合同管理，钻石产地，奖励积分管理，低流动性证券交易和结算，身份管理以及通过数字结算的领域货币。
Fabric引入了一种新的区块链架构，旨在实现弹性，灵活性，可扩展性和保密性。Fabric被设计为模块化和可扩展的通用许可区块链，是第一个支持执行以标准编程语言编写的分布式应用程序的区块链系统，从而使它们可以在多个节点上一致地执行，给人一种在单一的全球分布的区块链计算机上执行的印象。这使得Fabric成为**许可区块链的第一个分布式操作系统**。
Fabric的体系结构遵循一种**新颖的execute-order-validate范式**，用于在不可信untrusted环境中分布式执行不可信代码。它将交易流程分为**三个步骤**，可以在系统中的不同实体上运行：（1）执行交易并检查其正确性，从而认可交易（对应于其他区块链中的“交易验证”）；（2）通过共识协议进行排序，而与交易语义无关；（3）根据特定应用程序的信任假设进行交易验证，这也防止了由于并发引起的竞争情况。此设计与顺序执行范式完全不同，Fabric通常会在达成最终一致的排序之前执行（验证）交易。它结合了两种众所周知的复制方法，即被动复制和主动复制，如下所示。
首先，Fabric使用被动或主备份复制[21,27]，这种复制在分布式数据库中很常见，但是具有基于中间件的不对称更新处理[40,41]，并被移植到具有拜占庭式错误的不受信任的环境中。在Fabric中，每个事务仅由peers的一个子集（即部分peers）执行，这允许并行执行并利用“执行-验证” BFT复制来解决潜在的不确定性[37]。灵活的背书策略指定了哪个或哪些peers需要保证已正确执行给定的智能合约。
其次，Fabric包含主动复制，因为在每个peer分别执行的确定性验证步骤中，交易对账本状态的影响只有在它们之间的总顺序达成共识后才会写入。这使Fabric可以根据交易背书遵守特定应用程序的信任假设。而且，将状态更新的顺序委托给用于共识（即原子广播）的模块化组件，该组件是无状态的，并且与**执行事务并维护分类帐的对等方在逻辑上是分离**的。由于共识是模块化的，因此可以根据特定部署的信任假设量身定制其实现。尽管也可以使用区块链对等体来实现共识，但两个角色的分离增加了灵活性，并允许人们依靠完善的工具包进行CFT（崩溃容错）或BFT排序。
总的来说，这种混合复制设计在拜占庭模型中混合了被动复制和主动复制，以及执行排序验证范式，代表了Fabric体系结构的主要创新。他们解决了前面提到的问题，并为Fabric可伸缩系统提供了支持``可靠信任''假设的受许可区块链。为实现此体系结构，Fabric为以下每个组件都包含模块化构件：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•排序服务自动向peers广播状态更新，并就交易顺序建立共识。</span><br><span class="line">•成员资格服务提供者负责将peer与加密身份相关联。它保持了Fabric的许可性质。</span><br><span class="line">•可选的peer-to-peer gossip服务通过向所有peers进行排序服务来分发区块输出。</span><br><span class="line">•Fabric中的智能合约在容器环境中运行以进行隔离。它们可以用标准编程语言编写，但不能直接访问分类账状态。</span><br><span class="line">•每个peer以仅追加区块链的形式本地维护分类账，并将其作为键值存储中最新状态的快照。</span><br></pre></td></tr></table></figure>
本文的其余部分描述了Fabric的体系结构以及我们的经验。第2节总结了现有技术，并解释了各种设计决策背后的原理。第3节详细介绍了Fabric的体系结构和执行排序验证方法，说明了事务执行流程。在第4节中，特别定义了Fabric的关键组件，包括排序服务，成员服务，点对点gossip，分类帐数据库和智能合约API。在第5节中给出了在商品公共云VM上的集群和WAN环境中部署的具有比特币启发式加密货币的Fabric性能评估中获得的结果和见解。它们显示，Fabric在流行的部署配置中实现了3500 tps以上的吞吐量，以几百毫秒的延迟实现了[nality] [57]，并且可以很好地扩展到100多个peers。在第6节中，我们讨论了Fabric的一些实际生产用例。最后，第7节讨论了相关工作。
**二、背景**
**1. 区块链的顺序执行架构**
以前所有的区块链系统（无论是否许可）都遵循排序执行架构。这意味着区块链网络首先**使用共识协议对交易进行排序**，然后**在所有peers上按相同顺序执行（验证）它们**。
例如，基于PoW的无权限区块链如以太坊将结合共识和执行交易如下：（1）每个peer（即参与共识的节点）将一个包含有效事务的块组合在一起（为了确定有效性，该peer已经预先执行了这些事务）；（2）peer试图解决PoW难题；（3）如果其中有一个peer很幸运并且解决了难题，则它通过gossip协议将该块传播到网络；（4）收到该区块的每个peer均会验证难题的解决方案以及该区块中的所有交易。实际上(effectively)，每个peer都会从第一步开始重复解决了Pow的peer的执行（验证）过程。此外，所有peers都顺序执行事务（在一个块内和跨块）。排序执行架构如图1所示。
![](/block_paper_2/20200404075739094.png)
**2. 排序执行的局限性**
排序执行架构在概念上很简单，因此也被广泛使用。但是，当在通用的许可区块链中使用时，它有几个缺点。接下来我们讨论最重要的三个：
**排序执行**
在所有peers上顺序执行交易会**限制区块链可以实现的有效吞吐量**。特别是，由于吞吐量与执行延迟成反比例，因此这可能成为除最简单的智能合约之外的所有智能合约的性能瓶颈。此外，回想一下，与传统的SMR相比，区块链形成了通用计算引擎，其**有效载荷应用程序可能会被对手部署**。denial-of-service（DoS）攻击会严重降低此类区块链的性能，可能只是引入智能合约就需要花费很长时间才能执行。例如，执行无限循环的智能合约具有致命错误，但由于无法解决停止问题而无法自动检测到。
为了解决这个问题，使用加密货币的公共可编程区块链会承担执行成本。例如，以太坊引入了交易执行所消耗的gas的概念，该概念将gas price转换为数字加密货币的成本，并记入交易提交者的账单中。 以太坊在支持这一概念方面做了很多工作，为每个级别的计算步骤分配了成本，引入了自己的虚拟机来控制执行。虽然这似乎是公共区块链的可行解决方案，但对于没有native加密货币的通用系统来说，这在许可模型中是不够的。
有关分布式系统的文献提出了许多方法来改进与顺序执行相比的性能，例如通过不相关操作的并行执行。不幸的是，这些技术仍有待于在智能合约的区块链环境中成功应用。例如，有一个挑战是，需要确定地推断智能合约的所有依赖项，这在与可能的一致性约束结合时尤其具有挑战性。此外，这些技术对于对抗来自不可信开发人员合约代码的DoS攻击毫无帮助。
**非确定性代码**
排序执行体系结构的另一个重要问题是不确定性事务。在active（主动）SMR中达成共识后执行的操作必须是确定性的，否则分布式账本会“分叉”并违反区块链的基本前提，即所有peers都处于同一状态。这通常可以通过使用领域特定语言对区块链进行编程来解决（例如，以太坊Solidity）足以表达其应用，但仅限于确定性执行。但是，此类语言很难为实现者设计，并且需要程序员进行其他学习。相反，用通用语言（例如Go，Java，C / C ++）**编写智能合约会吸引更多人，并加速采用区块链解决方案**。
不幸的是，**通用语言给确定性执行带来了许多问题**。即使应用程序开发人员没有明显引入不确定性的操作，隐藏的实现细节也可能具有相同的破坏性影响（例如，在Go中amap迭代器不是确定性的）。更糟糕的是，在区块链上，创建确定性应用程序的负担落在了潜在的不受信任的程序员身上。仅创建一个带有恶意意图的非确定性合同就足以使整个区块链陷入停顿。此外，还研究了区块链上过滤器分散操作的模块化解决方案，但在实践中成本高昂。
**执行的机密性**
根据public blockchain的蓝图，许多许可的系统在所有对等点上运行所有智能合约。但是，**许可的区块链的许多预期用例都需要保密**，即可以限制对智能合约逻辑，交易数据或分类帐状态的访问。尽管从数据加密到先进的零知识证明[18]和可验证计算[42]等加密技术可以帮助实现一致性，但这通常会带来相当大的开销，在实践中不可行。
幸运的是，它将相同状态传播给所有peers，而不是在任何地方运行相同的代码。因此，可以将智能合约的执行限制为该任务所信任的peers的子集（部分peers），该子集保证执行的结果。这种设计从主动复制转向被动复制的变体[21]，适应了区块链的信任模型。
**3. 现有架构的其他限制**
**固定信任模型**
大多数获得许可的区块链都依赖于异步BFT复制协议来建立共识[57]。这样的协议通常基于一个安全假设，即在n > 3f个对等节点中，最多可以容忍f的不当行为并表现出所谓的拜占庭式错误[20]。同样的peers也经常在相同的安全性假设下执行应用程序（即使实际上可以将BFT执行限制为更少的peers）[59]。但是，无论peers在系统中的角色如何，这种量化的信任假设都可能与智能合约执行所需的信任不匹配。在灵活的系统中，**不应将应用程序级别的信任固定为协议级别的信任**。通用区块链应将这两个假设解耦，并允许应用程序具有灵活的信任模型。
**硬编码的共识**
Fabric是引入**可插拔共识**的第一个区块链系统。在使用Fabric之前，几乎所有的区块链系统（无论是否为许可链）都带有硬编码的共识协议。但是，数十年来对共识协议的研究表明，**没有这样的“一刀切”的解决方案**。例如，当部署在潜在的对抗环境中时，**BFT协议的性能差异很大**[52]。具有“链式”通信模式的协议在具有对称和同质链接的LAN群集上表现出可证明的最佳吞吐量[34]，但在广域异构网络上性能严重下降。此外，在给定部署中，诸如负载，网络参数以及实际故障或攻击之类的外部条件可能会随时间而变化。由于这些原因，BFT共识**应该具有固有的可重构性，并且理想地动态地适应不断变化的环境**[17]。另一个重要的方面是将**协议的信任假设与给定的区块链部署方案**相匹配。确实，人们可能想用基于替代信任模型的协议（例如XFT [43]）或CFT协议（例如Paxos / Raft [45]和ZooKeeper [36]）甚至是无许可协议替换BFT共识。
**4. 排序执行区块链的经验**
在实现Fabric的执行排序验证架构之前，我们获得了在排序执行模型中使用PBFT [26]构建许可区块链平台的经验。也就是说，Fabric的**早期版本**（2016年9月发布的v0.6之前的版本）是按照“传统”排序执行架构进行架构的。
从许多概念证明应用中获得的反馈来看，这种方法的局限性立即变得很明显。例如，用户经常在不同的peers观察到不同的状态，并重新报告了共识协议中的错误。在所有情况下，仔细检查后发现，罪魁祸首是不确定的事务代码。其他原因涉及性能有限，例如“每秒仅进行一次事务处理”，用户承认其平均事务处理需要200毫秒才能执行。我们已经了解到，区块链系统的关键属性（即一致性，安全性和性能）一定不能取决于其用户的知识和信誉，尤其是因为区块链应该在不可信的环境中运行。
**三、架构**
在本节中，我们介绍三阶段（three-phase）的执行排序验证架构，然后说明事务流程。
**1. Fabric概述**
Fabric是用于许可区块链的分布式操作系统，该操作系统执行以通用编程语言（例如Go，Java，Node.js）编写的分布式应用程序。它在只追加复制的分类账数据结构中安全地跟踪其执行历史，并且没有内置加密货币。
Fabric引入了执行排序验证区块链架构（如图2所示），并且不遵循标准的排序执行设计，原因在第2节中进行了解释。简而言之，Fabric的分布式应用程序由两部分组成：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种智能合约，称为chaincode，它是实现应用程序逻辑并在执行阶段运行的程序代码。链码是Fabric中分布式应用程序的中心部分，可能由不可信的开发人员编写。存在用于管理区块链系统和维护参数的特殊链代码，统称为系统链代码（第4.6节）。</span><br><span class="line">在验证阶段评估的背书策略。不可信的应用程序开发人员不能选择或修改背书策略。背书策略充当Fabric中用于交易验证的静态库，只能通过链码进行参数化。只有指定的管理员才可以通过系统管理功能修改背书策略。典型的背书策略允许链代码以背书所需的一组peers的形式指定交易的背书人（执行人，进行共识的部分节点）。它在集合上使用单调逻辑表达式，例如“五分之三”或“（A∧B）∨C”。自定义背书政策可以实施任意逻辑（例如，第5.1节中我们的比特币启发式加密货币）。</span><br></pre></td></tr></table></figure>
![](/block_paper_2/20200404092429562.png)
客户将交易发送给背书策略指定的peers。然后，每个事务由特定的peers执行，并记录其输出；此步骤也称为**背书（执行，认证交易）**。执行后，交易进入排序阶段，该阶段使用**可插拔的共识协议**生成以区块为单位的认可交易的完全有序序列。在gossip（可选）的帮助下，将这些广播给所有peers。与标准的主动复制完全根据输入的事务进行排序不同，Fabric进行事务排序还要**结合状态依赖**，在执行阶段进行计算。然后，每个peer都会在验证阶段验证与背书策略有关的状态变化以及背书交易的执行一致性。所有peers都以相**同的顺序验证交易**，并且验证是确定性的。从这个意义上讲，Fabric在拜占庭模型中引入了一种新颖的**混合复制范式**，该模型将被动复制（**状态更新的共识前计算**）和主动复制（**执行结果和状态更改的共识后验证**）组合在一起。
Fabric区块链由形成网络的一组节点组成（请参见图3）。当Fabric经过许可时，网络中的所有节点都有一个身份，是模块化的成员资格服务提供程序（MSP）提供的（第4.1节）。Fabric网络中的节点扮演三个角色：
+ 客户端提交交易建议以供执行，帮助或安排执行阶段，最后广播交易以排序
+ peers执行交易建议并验证交易。所有peers都维护区块链分类帐，这是一个仅追加的数据结构，以一条hash链的形式记录所有交易，以及状态（最新分类帐状态的简洁表示）。**并非所有的peers都执行所有交易。根据交易所属链代码的策略（背书策略），只有提案中的一个子集称为背书peers（或简称为背书人）。**
+ 排序服务节点（OSN）（或简称为排序者）是共同构成排序服务的节点。简而言之，排序服务会在Fabric中建立所有交易的有序序列，其中每个交易都包含状态更新和在执行阶段计算的依赖关系以及背书peers的加密签名。**排序者完全不了解应用程序状态，并且不参与执行或交易验证中**。这种设计选择使Fabric中的共识尽可能地**模块化**，并简化了Fabric中共识协议的替换。

<p><img src="/block_paper_2/20200404093902895.png" alt=""><br>Fabric网络实际上<strong>支持连接到同一排序服务的多个区块链</strong>。每个这样的区块链都称为一个通道，并且可能有不同的peers作为其成员。可以使用Channel来划分区块链网络的状态，但是不协调跨通道的共识，并且每个通道中的总交易顺序是相互独立的。将所有排序者都视为受信任的某些部署也可以实现peers的按通道访问控制。在下文中，我们仅提及Channel，仅关注一个Channel。<br>在接下来的三个部分中，我们将解释Fabric中的事务流程（如图4所示）并说明执行，排序和验证阶段的步骤。然后，我们总结了Fabric的信任和故障模型（第3.5节）。<br><strong>2. 执行阶段</strong><br>在执行阶段，客户端签名并将交易提议（或简称为提议）发送给一个或多个背书人(ps:部分peers)以执行。回想一下，每个链码都通过背书策略隐式指定了一组背书人。提议包含提交客户端的身份（根据MSP），执行操作形式的事务有效负载，参数以及链码的标识符，每个客户端只能使用一次的随机数（例如计数器）（或随机值），以及从客户标识符和随机数派生的交易标识符。<br>背书人通过<strong>在已安装在区块链上的指定链码上执行操作来模拟提案proposal</strong>。链码在Docker容器中运行，与主背书进程隔离。<br>针对背书人的<strong>本地区块链state模拟了提案proposal，而无需与其他peers进行同步</strong>。此外，背书人不会将模拟结果保留到分类账状态ledger state。区块链的状态由peer事务管理器（PTM）以版本化键值存储的形式维护，其中键的连续更新具有单调递增的版本号（4.4）。由一个链码创建的状态仅适用于该链码，并且不能被另一个链码直接访问。请注意，<strong>链码不应该维护程序代码中的本地状态</strong>，而只能维护通过GetState，PutState和DelState<strong>操作访问的区块链状态中维护的内容</strong>。给定适当的权限，链码可以调用另一个链码以在同一通道内访问其状态。<br>作为模拟的结果，<strong>每个背书者都会产生一个值写入集</strong>，该值写入集由模拟产生的状态更新（即修改后的键及其新值）以及一个代表提案模拟的版本依赖性的读取集（即在模拟过程中读取的所有键及其版本号）。模拟之后，<strong>背书者加密签名一条称为背书endorsement的消息</strong>，其中包含readset和writeset（以及元数据，例如交易ID，背书者ID和背书者签名），并在提案响应中将其发送回客户端。客户收集背书endorsements，直到满足交易所调用的链码的背书策略（即<strong>要收集到所有背书人返回的endorsement消息</strong>）。特别地，这要求由策略确定的所有背书者都<strong>产生相同的执行结果</strong>（即相同的读集和写集）。然后，客户继续创建交易并将其传递给排序服务。<br><strong>讨论设计选择</strong><br>当背书人在不与其他背书人同步的情况下模拟提案时，<strong>两个背书人可能会在分类账的不同状态下执行该提案，并产生不同的输出</strong>。对于要求多个背书人产生相同结果的标准背书策略，这意味着<strong>在访问相同键的操作竞争激烈的情况下，客户端可能无法满足背书策略</strong>。这是一个与<strong>通过中间件（客户端？？）进行同步的复制数据库中的主备份复制相比</strong>的新考虑因素：<strong>假设在区块链中没有一个peer可被信任以正确执行</strong>。<br>我们有意识地采用了这种设计，因为它极大地简化了架构，并且足以<strong>满足典型的区块链应用</strong>。正如比特币的方法所证明的那样，分布式应用程序可以制定为在正常情况下<strong>减少或完全消除访问同一状态的操作的争用</strong>（例如，在比特币中，不允许两个修改相同“对象”的操作，如双重支出攻击[44]）。将来，我们计划逐步增强争用contention中的Fabric的活动性语义，尤其是为了支持CRDT [51]以补充当前版本的依赖项检查，以及将用作交易定序器的按链代码的主签注者。<br>在排序阶段之前执行事务对于tolerating非确定性链码至关重要（ps:<strong>个人理解是，在非确定性情形出现时，fabric可以很好处理，因而说可以“容忍”这种情况</strong>）。具有不确定事务的Fabric中的链码只会危及其自身操作的活跃性，客户可能因此而无法收集足够数量的背书。与排序执行架构相比，这是一个根本优势，在排序执行架构中，不确定性操作会导致peers状态不一致。（ps：理解就是，<strong>fabric架构中，不一致就会不满足背书策略，就不会排序，相比无法保证事务确定性的排序执行架构，这点是优势</strong>）<br>最终，容忍非确定性执行还<strong>解决了来自不受信任链码的DoS攻击</strong>，因为背书人可以怀疑是否有DoS攻击，可以根据本地策略简单地中止执行。这不会危及系统的一致性，而且，在单执行结构中不可能单方面中止执行(<strong>ps:个人理解，是一点终止，全部终止，所以保持一致吗</strong>）。<br><strong>3. 排序阶段</strong><br>当<strong>客户端在提案中收集到足够的背书时，它会组装交易并将其提交给排序服务</strong>。该交易包含交易有效负载（即包含参数的链式代码操作），交易元数据和一组背书。排序阶段会针对每个渠道的所有已提交交易建立总体的有序序列。而即便排序者有问题时，排序仍然以原子方式广播背书endorsements，从而建立了交易共识。此外，排序服务将多个事务批处理为多个块，并输出包含事务的块的哈希链序列。将<strong>事务分组或成批处理</strong>可以提高广播协议的吞吐量，这是一种用于容错广播的众所周知的技术。<br>在较高的层次上，排序服务的接口仅支持以下两个操作，这些操作由peer调用并由通道标识符隐式参数化：</p>
<ul>
<li>broadcast（tx）：客户端调用此操作以<strong>广播任意交易tx</strong>，该交易通常包含事务处理有效负载和客户端签名以进行分发</li>
<li>B←deliver(s)：客户端调用它以<strong>获取非负序号s的对应区块blockB</strong>。该块包含交易清单[tx<br>1,…,txk]和序列中其前一区块的哈希。由于客户端可能会多次调用并且总是返回相同的块（如果有），我们假设peer在调用deliver（s）时第一次接收到blockB时，其序列号为s。</li>
<li><strong>根据论文的上下文，上面两条中的客户端client都是指peer，要严格和fabric架构中的client节点区分</strong><br>排序服务可确保一个通道上已交付的区块全部被排序。更具体地说，排序可确保每个通道具有以下安全性能：</li>
<li><strong>一致性</strong>：对于在正确的peers处以序列号s和s’分别获取分发的两个区块B和B’，使得s = s’，则可确定B = B’。</li>
<li><strong>哈希链完整性</strong>：如果某个正确peer递送序号为ｓ的区块blockB，而另一个正确peer递送序号为s+1的区块blockB’=（[tx1，。。。txk]，h’），则必定有h’= H（B），其中H（·）表示密码哈希函数。</li>
<li><strong>No skipping</strong>：如果正确peer递送序号为s &gt; 0的区块，则对i = 0，。。。，s -1，peer均已递送了编号为i的区块。</li>
<li><strong>No creation</strong>：当正确peer交付了具有编号的blockB时，则对于每个tx∈B，某些client已经广播了tx。<br>对于活动性，排序服务至少支持以下“最终”属性：</li>
<li><strong>有效性</strong>：如果正确的client(peer)调用了广播（tx），那么每个正确的peer最终都会递送一个包含tx的BlockB，并带有序列号。</li>
</ul>
<p>然而，每个单独的排序实现都允许在客户机client请求方面有自己的活跃性和公平性保证<br>由于区块链网络中可能存在大量对等点peers，但是预计只有相对较少的节点才能实现排序服务，因此可以将Fabric配置为<strong>使用内置的gossip服务，以排序服务中的交付区块传播给所有peers</strong>（第4.3节）。gossip的实现可扩展且与排序服务的特定实现无关，因此它可与CFT和BFT排序服务一起使用，从而确保Fabric的模块化。<br>排序服务还可以<strong>执行访问控制检查</strong>，以查看是否允许客户端client在给定频道上广播消息或接收块。排序服务的此功能和其他功能将在第4.2节中进一步说明。</p>
<p><strong>讨论设计选择</strong><br><strong>排序服务不维护区块链的任何状态，并且既不验证也不执行交易</strong>，这一点非常重要。这种架构是Fabric至关重要的定义功能，并使Fabric成为<strong>首个可将共识与执行和验证完全分开的区块链系统</strong>。这使共识尽可能地模块化，并实现了实施排序服务的共识协议生态系统。散列链完整性属性和块链接的存在仅是为了<strong>使peers对块序列的完整性验证更加有效</strong>。最后，请注意，我们<strong>不需要排序服务来防止交易重复</strong>。这简化了其实现，因此无需担心，因为在验证期间，peers会在重复的读写检查中过滤重复的事务。<br><strong>4. 验证阶段</strong><br><strong>区块由排序服务节点（OSN)直接或通过gossip传递给peers</strong>。然后，一个新块进入验证阶段，该阶段包括三个连续步骤：<br>（1）<strong>对该块内的所有事务并行执行背书策略评估</strong>。评估是所谓的<strong>验证系统链码（VSCC）</strong>的任务，该系统是区块链配置的一部分，是一个静态库，负责验证针对链码配置策略的签注（请参阅第4.6节）。如果不满足背书，则该交易被标记为无效，并且其影响不予理会。<br>（2）<strong>顺序对块中的所有事务进行读写冲突检查</strong>。对于每笔交易，它会将读取集字段中的键版本与分类账的当前状态中的键版本（由peers本地存储）进行比较，并确保它们仍然相同。如果版本不匹配，则交易被标记为无效，并且其影响被忽略。<br>（3）<strong>分类账更新阶段最后运行，在该阶段，将区块追加到本地存储的分类账中，并更新区块链状态</strong>。特别是，在将块添加到分类帐中时，前两个步骤中的有效性检查结果也以位掩码的形式保留，表示块中有效的交易。这有利于以后的状态重建。此外，通过将writeset中的所有键值对写入本地状态来应用所有状态更新。<br><strong>讨论设计选择</strong><br><strong>Fabric的分类帐包含所有事务，包括那些被视为无效的事务</strong>。这是从总体设计得出的，因为<strong>与链码状态无关的排序服务会生成块链，并且验证是由peers共识后完成的</strong>。在某些需要<strong>在后续审核期间跟踪无效交易的用例中需要此功能</strong>，并且与其他区块链（例如，比特币和以太坊）相反，<strong>在其他区块链中，分类账仅包含有效交易</strong>。此外，由于Fabric的允许性质，检测通过试图用无效事务填充网络来尝试发起DoS攻击的客户端很容易。一种方法是根据可以实施的政策将此类客户列入黑名单。此外，特定的部署可能会收取交易费用（使用我们的5.1节中的货币实现或其他方法）以收取交易调用费用，这将使DoS攻击的成本过高。<br><strong>5. 信任与故障模型</strong><br>Fabric可以适应灵活的信任和错误假设。通常，任何客户端都可能被认为是恶意的或拜占庭式的。peers可以划分到不同组织，每个组织形成一个可信域。这样一个peer将信任其组织内的所有peers，但不信任另一个组织的peers。排序服务将所有peers（和客户端）视为潜在的拜占庭式。<br>F<strong>abric网络的完整性取决于排序服务的一致性</strong>。排序服务的信任模型直接取决于其实现（<strong>ps:具体使用的共识协议</strong>）（请参见第3.3节）。从v1.0.6版本开始，Fabric支持在开发和测试中使用的集中式单节点实施，以及在集群上运行的CFT排序服务。第三种实现是基于BFT-SMaRt的概念证明[19]，最多可容纳三分之一的拜占庭OSN [53]。请注意，Fabric<strong>将应用程序的信任模型与共识的信任模型解耦</strong>。即<strong>分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传达，并且独立于由排序服务实施的共识假设</strong>（另请参见第3.4节）。<br><img src="/block_paper_2/20200405085639174.png" alt=""></p>
<p><strong>四、Fabric组件</strong><br>Fabric是用Go编写的，它使用gRPC框架在clients、peers和orders之间进行通信。下面我们将更详细地描述一些重要的组件。图5显示了peer的组件。<br><strong>1. 成员服务</strong><br><strong>成员资格服务提供程序（MSP）维护系统中所有节点（客户端，peers和OSN）的身份，并负责发布用于身份验证和授权的节点凭据</strong>。由于Fabric区块链为许可链，因此节点之间的所有交互都是通过经过身份验证的消息进行的，通常使用数字签名。<strong>成员资格服务在每个节点上都包含一个组件</strong>，该组件可以在其中验证交易，验证交易的完整性，签署和验证背书以及增强其他区块链操作。MSP还包含用于密钥管理和节点注册的工具。<br>MSP是一个抽象定义，可以使用不同的实例。Fabric中的默认MSP实现基于数字签名的标准PKI方法进行身份验证，并且可以适应商业证书颁发机构（CA certification authorities）.<strong>Fabric还提供了一个独立的CA，称为Fabric-CA</strong>。此外，还设想了替代的MSP实现，例如依靠匿名凭证授权客户端调用交易而不将其链接到身份的交易。<br><strong>Fabric允许两种模式来建立区块链网络</strong>。在离线模式下，凭据由CA生成并分发到所有节点。peers和osn只能在离线模式下注册。对于注册clients，Fabric-CA提供了一种在线模式，向其颁发加密凭据。 MSP配置必须确保所有节点（尤其是所有对等peers）都使用相同的有效的身份和身份验证。<br>例如，当多个组织运营区块链网络时，<strong>MSP允许身份联合</strong>。每个组织都向其自己的成员发出身份，每个peer都认可所有组织的成员。这可以通过<strong>多个MSP实例来实现</strong>，通过在每个组织和MSP之间创建映射。<br><strong>2. 排序服务</strong><br><strong>排序服务管理多个channel。在每个channel上，它提供以下服务</strong>：</p>
<ul>
<li>原子广播，用于建立交易顺序，实现广播和传递调用。</li>
<li>当channel的成员通过广播配置更新事务来修改channel时，对channel进行重新配置</li>
<li>可选地，在排序服务充当受信任实体的那些配置中，访问控制将交易的广播和块的接收限制为指定的clients和peers。<br>排序服务由系统channel上的创世区块引导。此块包含一个配置事务，该事务定义了排序服务的功能。<br>当前的作业实现由排序服务节点（OSN）组成，这些节点实施本文所述的操作并通过系统channel进行通信。<strong>实际的原子广播功能由Apache Kafka的一个实例提供</strong>，该实例基于ZooKeeper可以提供可伸缩的发布-订阅消息传递，并且即使节点崩溃也具有强一致性。<strong>Kafka可以在与OSN分离的物理节点上运行</strong>。OSN充当peers和Kafka之间的代理。<br>OSN直接<strong>将新接收的事务注入原子广播（例如，注入Kafka代理）。OSNs批处理从原子广播接收的事务及形成的区块</strong>。一旦满足以下三个条件之一，便会切断该块：（1）该块包含指定的最大交易数；（2）块已达到最大大小（以字节为单位）；或（3）自收到新区块的第一笔交易起已经经过了一段时间，如下所述。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 理解，就是 client把交易发过来，先用kafka打包区块，实现原子广播，再到osn进行处理</span><br></pre></td></tr></table></figure>
此<strong>批处理过程是确定性的，因此会在所有节点上产生相同的块</strong>。很容易看出，考虑到原子广播接收到的交易流，前两个条件是确定性的。为了确保在第三种情况下确定性的块产生，当节点从原子广播中读取块中的第一个事务时，它将启动计时器。如果在计时器到期时仍未切割该块，则OSN在该channel上广播特殊的切割时间事务，该操作指示它打算切割的块的优先级编号。另一方面，每个OSN在收到给定块编号号的第一个切割时间事务后立即切出新块。由于此事务是原子传递给所有连接的OSN，因此它们都在区块中包含相同的交易清单。OSN将一系列最新交付的区块直接保留到其系统中，因此它们可以通过传递使peers可以获取区块。</li>
</ul>
<p><strong>基于Kafka的排序服务是当前可用的三种实现之一</strong>。称为Solo的集中式订购器在一个节点上运行，并用于开发。基于BFT-SMaRt [19]的概念验证订购服务也已可用[53]；它可以确保原子广播服务，但尚未重新配置和访问控制。这说明了Fabric中共识的模块化。<br><strong>3. Peer Gossip</strong><br>将执行，排序和验证阶段分离的一个优势是，它们可以独立变化规模。但是，由于大多数共识算法（在CFT和BFT模型中）都是受带宽限制的，因此排序服务的吞吐量受到其节点网络容量的限制。无法通过增加更多的节点来扩大共识[28,57]，相反，吞吐量将降低。但是，<strong>由于排序和验证是分离的，因此我们对将执行结果有效地广播到所有peers以进行验证很有兴趣</strong>。<strong>这点，与向新加入的peers和长时间断开连接的peers的状态转移恰恰是gossip组件的目标。</strong>Fabric gossip为此目的利用了流行性多播epidemic multicas[29]。块由排序服务签名。这意味着<strong>peers可以在接收所有块后独立组装区块链并验证其完整性</strong>。<br>gossip通信层基于gRPC，并使用具有相互认证的TLS，这使得双方可以将TLS凭证绑定到远程peers的身份。<strong>gossip组件维护系统中在线peers的最新成员视图</strong>。所有peers均会根据定期分发的成员身份数据独立构建本地视图。此外，崩溃或网络中断后，peer可以重新连接到视图。<br>Fabric gossip<strong>分两个阶段进行信息分发</strong>：在push过程中，每个peer从成员资格视图中选择一组随机的活动邻居，并转发消息给它们。在pull期间，每个peer会定期探测一组随机选择的对peers，并请求丢失消息。已经显示[29,38]，同时<strong>使用这两种方法对于最佳利用可用带宽并确保所有peers以高概率接收所有消息至关重要</strong>。为了减轻从排序节点向网络发送数据块的负担，该协议还选择了一个leader peer，代表它们从排序服务中提取区块并发起gossip分发。<br><strong>4. 分类帐</strong><br>每个peer的分类帐组件在持久性存储上维护分类帐和状态，并启用模拟simulation, 验证validation和分类帐更新ledger-update阶段。大致来说，它由一个区块存储和一个peer事务管理器组成。</p>
<ul>
<li>分类账块存储区ledger block store保留事务区块，并实现为一组仅追加文件。<strong>由于块是不可变的并以确定的顺序到达的，仅追加结构可提供最佳性能</strong>。另外，块存储区维护一些索引，用于随机访问块或块中的事务。</li>
<li><strong>peer事务管理器（PTM）在版本化的键值存储中维护最新状态</strong>。它为任何链码存储的每个唯一入口键存储一个形式为（key，val，ver）的元组，其中包含其最近存储的值val和最新版本的ver。版本由块序号和块内事务（存储条目）的序列号组成。PTM使用本地键值存储来实现其版本化的变体，并使用LevelDB（在Go中）[10]和ApacheCouchDB [1]来实现。</li>
</ul>
<p>在模拟simulation过程中，<strong>PTM为事务提供最新状态的稳定快照</strong>。如第3.2节所述，PTM在GetState访问的每个条目的readset中记录一个元组（key，ver），而在该交易中用PutState更新的每个条目的writeset中记录一个tuple（key，val）。此外，PTM支持范围查询，为此它计算查询结果的加密哈希（一组元组（key，版本）），并将查询字符串本身和哈希添加到readset中。<br><strong>为了进行交易验证（第3.4节），PTM依次验证一个区块中的所有交易。这将检查事务是否与任何先前的事务冲突（在块内或更早的时间内）</strong>。对于readset中的任何键，如果readset中记录的版本与最新状态下存在的版本不同（假定已提交所有先前的有效事务），则PTM将该事务标记为无效。对于范围查询，PTM将重新执行查询并将哈希与readset中存在的哈希进行比较，以确保不发生幻像读取。这种读写冲突语义促成了单拷贝可序列化性[39]。<br><strong>分类账组件在分类账更新期间容忍peers崩溃</strong>，如下所示。收到新块后，PTM已经使用第3.4节中提到的位掩码在块内执行了验证并将事务标记为有效或无效事务。现在，分类账将块写入分类账块存储，将其刷新到磁盘，然后更新块存储索引。然后，<strong>PTM将所有有效交易的写入集的状态更改应用于本地版本存储</strong>。最后，它计算并保留一个值保存点，该值表示成功应用的最大块数。从崩溃中恢复时，<strong>值保存点用于从持久块中恢复索引和最新状态</strong>。<br><strong>5. 链码执行</strong><br>Chaincode在与peer松耦合的环境中执行，该环境支持用于添加新链码编程语言的插件。当前支持Go，Java和Node。<br>每个<strong>use-level或应用程序链码都在Docker容器环境中的单独进程中运行，该进程将链码彼此隔离，并与peers隔离</strong>。这也简化了链码生命周期的管理（即启动，停止或中止链码）。链码和peers使用gRPC消息进行通信。通过这种松散的耦合，peers不了解链码所使用的实际语言。<br>与应用程序链码相反，<strong>系统代码在peer进程中直接运行。系统链码可以实现Fabric所需的特定功能，并且可以用于用户链码之间的隔离过于严格的情况</strong>。下一节将提供有关系统链码的更多详细信息。<br><strong>6. 配置和系统链码</strong><br>Fabric可以通过channel配置和特殊的链码（称为系统链码）来定制。<br><strong>Fabric中的每个channel都形成一个逻辑区块链</strong>。通道的配置在元数据持久的特殊配置块中维护。每个配置块都包含完整的通道配置，并且不包含任何其他事务。每<strong>个区块链都以配置块（称为创世块）开头，用于引导通道</strong>。通道配置包括：（1）定义参与节点的MSP，（2）OSN的网络地址，（3）共享配置，用于共识实现和排序服务，例如批处理大小和超时；（4）控制访问排序服务操作（广播和传递）的规则，以及（5）控制如何修改通道配置的每个部分的规则。<br><strong>可以使用通道配置更新事务来更新信道的配置</strong>。此事务包含对要进行的配置更改的重新表示，以及一组签名。排序服务节点通过使用当前配置来评估更新是否有效，以验证使用签名对修改进行了授权。然后排序者生成一个新的配置块，其中嵌入了新的配置和配置更新事务。接收此块的peers验证是否根据当前配置对配置更新进行了授权；如果有效，他们会更新其当前配置。<br><strong>部署应用程序链码时要参考背书系统链码（ESCC）和验证系统链码（VSCC）</strong>。选择这两个链码，以便可以验证ESCC的输出（背书）作为VSCC输入的一部分。ESCC将提案和提案模拟结果作为输入。如果结果令人满意，则ESCC会做出回应，其中包含结果和认可。对于默认的ESCC，这种认可只是peers的本地签名身份的签名。VSCC将交易作为输入并输出该交易是否有效。对于默认的VSCC，将根据针对链码指定的背书策略收集并评估认可。进一步的系统链码实现了其他支持功能，例如链码生命周期。<br><strong>五、评估</strong><br>即使尚未对Fabric进行性能调整和优化，我们还是在本节中报告一些<strong>初步的性能数据</strong>。<strong>Fabric是一个复杂的分布式系统。它的性能取决于许多参数</strong>，包括对分布式应用程序的选择和交易规模，排序服务和共识实现及其参数，网络中节点的网络参数和拓扑，节点运行的硬件，节点和通道的数量，其他配置参数以及网络动态。因此，对Fabric的深入性能评估在以后的工作中进行。<br>在没有针对区块链的标准基准的情况下，我们使用最杰出的区块链应用程序来评估Fabric，这是<strong>一种使用比特币数据模型的权威授权的加密货币，我们将其称为Fabric coin</strong>（以下简称Fabcoin）。在其他许可区块链的背景下，Fabric的性能通常来自比特币或以太坊。例如，它也是应用程序使用其他许可区块链的基准[35，50]。<br>在下文中，我们首先介绍Fabcoin（第5.1节），它还演示了如何自定义验证阶段和背书策略。在5.2节中，我们介绍基准并讨论我们的结果。<br><strong>1. Fabric Coin (Fabcoin)</strong><br><strong>UTXO加密货币</strong><br><strong>比特币引入的数据模型已被称为“未使用的交易输出”或UTXO</strong>，并且还被许多其他加密货币和分布式应用程序使用。UTX<strong>O将数据对象演化的每个步骤表示为分类账上的单独原子状态</strong>。这种<strong>状态是通过事务创建的，并被稍后发生的另一个唯一事务破坏（或“消耗”）</strong>。<strong>每个给定的事务都会破坏许多输入状态，并创建一个或多个输出状态</strong>。Bitcoin中的coin最初是通过奖励该区块“矿工”的coinbase交易创建的。这在分类账上显示为coin状态，将矿工指定为所有者。可以用任何coin消费的意义，即<strong>通过一种交易将硬币分配给新的所有者，该交易会从原子上破坏指定前一个所有者的当前coin状态并创建代表新所有者的另一个coin状态</strong>。<br>我们在<strong>Fabric的键值存储中捕获UTXO模型</strong>。<strong>每个UTXO状态都对应于一个唯一的KVS条目</strong>，该条目创建一次（coin状态为“unspent”）并销毁一次（coin状态为“spent”）。同样，创建后，每个状态都可以视为逻辑版本为0的KVS条目；当它再次被销毁时，它会收到版本1。不应对此类条目进行任何并发更新（例如，尝试以不同的方式更新coin状态等同于将coin花费两次）。<br><strong>UTXO模型中的值是通过事务转移的</strong>，这些事务引用了多个输入状态，这些状态都属于发出事务的实体。实体拥有一个状态，因为该实体的公钥包含在状态本身中。每笔交易都会在KVS中创建一个或多个代表新所有者的输出状态，删除KVS中的输入状态，并确保输入状态中的值之和等于输出状态值之和。还有一个策略决定如何创造value（例如，比特币中的币库交易或其他系统中的特定造币厂交易）或销毁value的方式。<br><strong>Fabcoin实现</strong><br><strong>Fabcoin中的每个状态都是一个形式为（key，val）=（txid.j，（amount，owner，label））的元组</strong>，表示作为标识为txid并分配金额单位的交易的第j个输出创建的币态带有标签的实体公钥是所有者。标签是用于识别coin的给定类型的字符串（例如，“ USD”，“ EUR”，“ FBC”）。事务标识符是短值，可唯一标识每个Fabric事务。<strong>Fabcoin实现包括三个部分：（1）客户钱包，（2）Fabcoin链码，（3）用于Fabcoin实施其认可策略的自定义VSCC</strong>。<br><strong>（1）Client钱包</strong><br>默认情况下，<strong>每个Fabric客户端维护一个Fabcoin钱包</strong>，该Fabcoin钱包在本地存储一组允许客户花费coin的加密密钥。为了创建转移一个或多个coin的支出交易，客户钱包会创建一个Fabcoin请求request = (inputs, outputs, sigs)，包含：（1）投入coin状态列表，inputs = [in…]指定客户希望花费的coin状态，以及（2）输出coin状态的列表，outputs = [(amount, owner, label),…]，客户端钱包使用的签名是由输入coin状态相对应的私钥，Fabcoin请求和nonce随机数（每笔Fabric交易的一部分）串联而成，将该签名添加到一组sig中。当输入coin状态中的金额之和至少等于输出中金额的总和且输出金额为正时，交易有效。对于创建新coin的铸币交易，输入仅包含称为中央银行Central Bank（CB）的特殊实体的标识符（即对公共密钥的引用），而输出包含任意数量的coin状态。挖矿交易签名必须是在Fabcoin请求和上述随机数串联后在CB公钥下的加密签名。可以将Fabcoin配置为使用多个CB或从一组CB中指定阈值签名数。最后，<strong>客户端钱包将Fabcoin请求包含在交易中，并将其发送到其选择的peers</strong>。<br><strong>Fabcoin链码</strong><br><strong>一个peer运行Fabcoin的链码，以模拟交易并创建读取集和写入集</strong>。简而言之，在一笔支出交易的情况下，对于coin state输入集合inputs中的一个输入in，链码先执行GetState（in）获取readset及其当前版本。然后，链码将为每个输入状态执行DelState（in），还将添加到写入集中并地将coin状态标记为“已用”。最后，forj = 1，…，|| outputs ||，链码以输出的第j个outputout =(amount, owner, label)执行executePutState（txid.j，out）。另外，peers可以按照下面在Fabcoin的VSCC步骤中所述运行交易验证代码；这不是必需的，因为Fabcoin VSCC实际上可以验证交易，但是它允许（正确的）peers过滤出潜在的格式错误的交易。在我们的实现中，链码无需加密验证签名即可运行Fabcoin VSCC（仅在实际VSCC中进行了验证）<strong>(???)</strong>。<br><strong>定制VSCC</strong><br>最后，<strong>每个peer都使用自定义VSCC验证Fabcoin交易</strong>。这将在相应的一个或多个公共密钥下验证sigs中的一个或多个密码签名，并按以下方式执行语义验证。对于铸币交易，它将检查是否在匹配的交易标识符（txid）下创建了输出状态，并且所有输出金额均为正。对于一次花销交易，VSCC会额外验证（1）对于所有输入币态，已经在readset中创建了一个条目，并且该条目也已添加到writeset中并标记为已删除，（2）所有输入coin状态的数量等于所有输出coin状态的数量之和，并且（3）输入和输出coin标签匹配。在这里，VSCC通过从分类账中检索输入的coin数量来获得输入的coin数量。<br>请注意，<strong>Fabcoin VSCC不会检查交易是否存在双重支出，因为这是通过Fabric的标准验证完成的，该验证在自定义VSCC之后运行</strong>。特别是，如果两个事务试图将相同的未使用coin状态分配给新所有者，则两个事务都将通过VSCC逻辑，但随后将<strong>被PTM执行的读写冲突检查所捕获</strong>。根据第3.4节和第4.4节，PTM验证存储在分类帐中的当前版本号与读取集中的版本号匹配；因此，在第一笔交易更改coin状态的版本后，第二笔交易将被视为无效。<br><strong>2. 实验</strong><br><strong>设定</strong><br>除非有不同的明确说明，否则在我们的实验中：（1）节点运行在Fabric版本v1.1.0-preview2上，用于通过本地日志记录进行性能评估，（2）节点托管在单个IBM Cloud（SoftLayer）数据中心中（DC）专用虚拟机与1Gbps（标称）网络互连，（3）所有节点均为运行GHz的2.0 GHz 16-vCPU VM，Ubuntu具有8GB RAM和SSD作为本地磁盘，（4）单通道排序服务运行典型Kafka排序程序设置，具有3个ZooKeeper节点，4Kafka代理和3个Fabric排序程序，它们都位于不同的VM上，（5）共有5个peers，均属于不同的组织（org），都是Fabcoin背书人，以及（6）签名使用默认的256位ECDSA方案。为了测量和分阶段跨越多个节点的事务流中的延迟，在整个实验过程中，将节点时钟与NTP服务进行同步。Fabric节点之间的所有通信均配置为使用TLS。<br><strong>方法</strong><br>在每个实验中，在第一个阶段中，我们调用仅包含Fabcoin铸币操作的交易以<strong>生成coin</strong>，然后运行实验的第二阶段，在该阶段中，我们对先前铸造的coin<strong>调用Fabcoin支出操作</strong>（有效地运行单输入，单输入-输出支出交易）。在报告<strong>吞吐量测量</strong>时，我们使用在单个VM上运行的越来越多的Fabric CLI客户端（已修改以发出并发请求），直到端到端吞吐量达到饱和，并声明吞吐量刚好低于饱和度。<strong>吞吐量报告为在实验稳定状态下测得的平均值</strong>，而无视“tail”，在此“tail”中某些客户端线程已经停止提交其交易份额。在每个实验中，客户端线程共同调用至少50万个铸币并花费交易。<br><strong>实验1：选择区块大小</strong><br><strong>影响吞吐量和延迟的关键光纤网配置参数是块大小。为了固定块大小以进行后续实验，并评估块大小对性能的影响</strong>，我们进行了实验，将块大小从0.5MB更改为4MB。结果如图6所示，显示了在对等端测得的峰值吞吐量以及相应的平均端到端（e2e）延迟。<br>我们可以看到，超过2MB的块大小后，<strong>吞吐量并没有显着提高，但是延迟变得更糟</strong>（如预期的那样）。<br>因此，在以下实验中，我们<strong>采用2MB作为块大小，目的是最大化测得的吞吐量，假设大约500ms的端到端延迟是可以接受的。</strong><br><img src="/block_paper_2/20200405112612953.png" alt=""><br><strong>选择事务大小</strong><br>在此实验中，我们还观察了<strong>铸币和支出交易的大小</strong>。特别是，这2MB的区块包含473个铸币或670个支出交易，即平均交易大小支出交易为3.06kB，铸币交易为4.33kB。一般而言，Fabric中的事务量很大，因为它们<strong>带有证书信息</strong>。此外，<strong>Fabcoin的铸币交易比支出交易大</strong>，因为它们带有CB证书。这是<strong>将来改善Fabric和Fabcoin的途径</strong>。<br><strong>实验2：peer CPU的影响</strong><br>Fabric peers运行许多CPU密集型加密操作。为了<strong>估算CPU功率对吞吐量的影响</strong>，我们进行了一组实验，其中4个peers分别在4、8、16和32个vCPU VM上运行，同时还进行了块验证的粗粒度延迟分阶段以识别瓶颈。<br>我们的<strong>实验集中在验证阶段，因为使用Kafka排序服务进行排序从未成为我们集群实验（在一个数据中心内）的瓶颈</strong>。验证阶段，尤其是<strong>Fabcoin的VSCC验证，由于其许多数字签名验证，因此在计算上非常耗费时间。我们根据peers本地的验证阶段延迟来计算peers的吞吐量</strong>。<br>图2显示了使用2MB块的结果，其中包含了铸币（图7a）和支出（图7b）操作的块。对于这两种操作，所测量的吞吐量和等待时间与vCPU数量相同。我们可以看到，<strong>验证方法明显限制了可实现的（端到端）吞吐量</strong>。而且，<strong>Fabric VSCC的验证性能与CPU呈近似线性关系</strong>，因为Fabric的VSCC的背书策略验证是并行的。但是，读写检查和分类帐访问阶段是顺序的，并以大量的内核（vCPU）为主。对于支出交易而言，这一点尤其明显，因为支出超过了铸币交易可以进入2MB的块，从而<strong>延长了顺序验证阶段的时间（即读写检查和分类帐访问）</strong>（从最下面两条几乎水平的线，图二的纵轴值高于图一可以看出）。<br><img src="/block_paper_2/20200405113556481.png" alt=""><br><img src="/block_paper_2/20200405113610124.png" alt=""><br>这个实验表明，未来版本的Fabric<strong>可以通过流水线验证阶段（现在是顺序的）而受益</strong>，从而消除了客户端的顺序开销。验证端到端吞吐量，优化稳定存储访问以及并行化读写依赖性检查之间存在明显差异。<br>最后，在此实验中，我们测量了32-vCPU对等方每秒超过3560笔事务（tps）的平均花费（端到端）吞吐量。总体而言，铸币吞吐量略低于支出，但相差不到10％，其中32个vCPU对等节点的平均薄荷吞吐量达到3420tps以上。<br><strong>延迟分析</strong><br>我们在之前的实验中以峰值报告的吞吐量进一步执行了延迟的粗粒度分析。结果如表1所示。在验证开始之前，排序阶段包括peers内部的广播传递延迟和内部延迟。该表报告了<strong>铸币和支出的平均延迟，标准偏差和尾部延迟。</strong><br><img src="/block_paper_2/20200405114630538.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意这个表，很有意思，很清楚的写明了验证阶段的步骤</span><br></pre></td></tr></table></figure>
<p>我们观察到<strong>排序主导了整体延迟</strong>。我们还看到，平均延迟在550毫秒以下，并具有次秒级延迟。特别是，我们的实验中最高的端到端延迟来自负载增加期间的第一个块。可以使用排序者的切割时间参数来调节和减少较低负载下的延迟（请参阅3.3），因为我们将其设置为较大的值，所以我们在实验中基本不使用它。<br><strong>实验3：SSD与RAM磁盘</strong><br>为了评估与<strong>稳定存储</strong>相关的潜在收益，我们重复了先前的实验，将RAM磁盘（tmpfs）安装为所有对等VM上的稳定存储。<strong>好处是有限的，因为tmpfs仅有助于在peers进行验证的分类账阶段</strong>。我们在32-vCPU对等端测量了3870 SPEND tps的持续峰值吞吐量，比SSD大约提高了9％。<br><strong>实验4：LAN的可伸缩性</strong><br>在本实验及后续实验中，我们<strong>增加了peers的数量</strong>（每个peer具有16个vCPU）来评估Fabric的可伸缩性。<br>在此实验中，我们在单个IBM Cloud DC（香港）中托管的每个组织中，只有一个peer。所有peers都直接从排序服务接收区块，而不会产生gossip。我们从20个peers开始（其中10个是Fabcoin认可方），并将peers的数量增加到100个。图8中描绘了可实现的最大吞吐量，<strong>该峰值吞吐量取决于peers数量</strong>（“LAN”后缀）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 怎么感觉图和结论不符 强行理解 可伸缩性，就是要保证peers增加 吞吐量还可不变</span><br></pre></td></tr></table></figure>
<p><img src="/block_paper_2/20200405115845187.png" alt=""><br><strong>实验5：两个DC-数据中心的可伸缩性以及gossip的影响</strong><br>在后续实验中，我们将排序服务，10个背书人和客户端移至附近的东京（TK）数据中心，将不背书的peers留在了香港特区。此实验（及下一个实验）的目标是<strong>评估系统的网络带宽</strong>成为瓶颈。我们将香港的非背书peers的数量从20个改变为80个，除了固定的10个背书peers之外，还<strong>保持了与排序服务的直接连接（即每个组织一个peer）</strong>。在TK和HK中的两个VM之间报告的单TCP netperf吞吐量平均为240 Mbps。<br>在图8中示出了根据（总数）peers的数量的峰值吞吐量（“2DC”后缀）。我们清楚地看到，吞吐量与先前对30个peers进行的实验基本相同，但是<strong>当peers数目增加时，吞吐量会下降</strong>。因为满足了TK中3个OSN的网络连接，所以吞吐量降低了。我们测量了1910tps 铸币和2190tps 支出吞吐量（在香港peers中），总共90个peers。<br><strong>为了解决此问题并提高WAN上的可伸缩性，Fabric可能会使用gossip</strong>（第4.3节）。我们与香港的80个peers（总共90个peers）重复了最后一次评估，但将<strong>这些peers重新配置为8个组织，每个组织10个peers。在这种配置中，每个组织中只有一个领导者leader peers直接连接到排序服务，并向组织中的其他人散布gossip</strong>。该实验（1个gossip7个输出）在香港同行中达到了2544/2753 tps的铸币/支出 平均峰值流量，这意味着<strong>gossip很好地发挥了它的预期功能</strong>。吞吐量比LAN实验中的要低一些，因为组织负责人的peer（在两个实验中都直接连接到OSN）现在也需要管理gossip。<br><img src="/block_paper_2/20200405120934651.png" alt=""><br><strong>实验6：在多个数据中心（WAN）上的性能</strong><br>最后，我们将最后一个实验<strong>扩展到5个不同的数据中心</strong>：东京（TK），香港（HK），墨尔本（ML），悉尼（SD）和奥斯陆（OS），每个数据中心有20个peers，共有100个peers。与之前的实验一样，排序服务，10个背书人和所有客户都在TK中。我们在没有gossip（每个组织一个peer）和有gossip（分为10个组织，每个数据中心2个组织，输出7个）的情况下运行此实验。结果汇总在表2中，属于同一数据中心的averaged across peers。供参考，表的首行显示了给定数据中心中的VM与TK之间的netperf吞吐量。<br>结果再次<strong>清楚地显示了当对等点分散在WAN上时使用gossip的好处</strong>。与HK和ML相比，我们在OS和SD上看到了有趣的结果。SD gossip的吞吐量较低是由于VM在SD中的CPU限制所致；在相同的规格下，它们的验证吞吐量要比HK和ML的peers低。在OS中，总吞吐量要低得多。但是，瓶颈不是排序服务的带宽，而是我们的netperf测量表明，从OS到TK的单TCP连接带宽。因此，无法观察到OS中gossip的真正好处。我们<strong>将实验中的操作系统吞吐量稍有提高归因于gossip</strong>，减少了从操作系统到TK的TCP连接数量。</p>
<p><strong>六、应用和使用案例</strong><br>主要的云运营商包括Oracle，IBM和Microsoft已经运行（或宣布）Fabric的“区块链即服务”。此外，Fabric目前为分布式账本技术的400多个原型和概念验证提供支持以及跨不同行业和用例的多种生产系统[47]。示例包括食品安全网络[16]，用于银行的云服务区块链平台[31]和数字全球航运贸易[33]解决方案。在本节中，我们将说明已部署Fabric的一些实际用例。<br><strong>1. 外汇交易网络Foreign exchange (FX) netting</strong><br>在<strong>Fabric上运行用于双边结汇的系统</strong>。它为每对涉及的客户机构使用fabric通道来保护隐私。负责结网和结算的专门机构（“结算员”）是所有通道的成员，并负责运行排序服务。区块链有助于解决未结算的交易，并在分类账中维护所有必要的信息。客户可以实时访问此数据，并有助于流动性，解决纠纷，减少风险敞口并最大程度地降低信用风险[49]。<br><strong>2. 企业资产管理（EAM）</strong><br>该解决方案跟踪硬件资产从制造到部署，最终到处置的过程，另外捕获与硬件相关的软件资产的许可证。区块链记录资产的各种生命周期事件和相关证据。<strong>分类帐是与资产有关的所有参与者之间的透明记录系统，从而提高了传统解决方案所面临的数据质量</strong>。多方财团区块链在制造商，托运人，收货人，客户和安装人员之间运行。它使用3层架构，其用户界面通过Fabric客户端连接到peers。在线提供了第一个版本的详细说明[56]。<br><strong>3. 全球跨货币支付Global cross-currency payments</strong><br>自2017年10月起，IBM与Stellar.organd KlickEx Group合作，运营了一种跨货币支付解决方案，该解决方案处理了太平洋地区APFII组织中的合作伙伴之间的交易[15]。The Fabric区块链以参与者认可的交易形式记录金融付款，以及双方同意的条件。所有有关方面均有权了解金融交易的清算和结算。<br>该解决方案适用于所有付款类型和值，并允许金融机构选择结算网络。特别是，结算可以使用不同的方法，Fabric会根据参与者的配置来决定如何结算付款。一种可能的结算方式是通过Lumens（Stellar的加密货币）进行结算，其他方式则基于交易的金融工具的类型。</p>
<p><strong>七、相关工作</strong><br>Fabric的架构类似于Kemme和Alonso [40]率先开发的<strong>中间件复制数据库</strong>的架构。但是，与此相关的所有现有工作仅解决了崩溃失败，而<strong>不是与BFT系统相对应的分布式信任的设置</strong>。例如，具有非对称更新处理的复制数据库[41，2.[6.3]依靠一个节点来执行每个事务，这不会在区块链上工作。 Fabric的执行顺序验证体系结构可以<strong>解释为这项工作对拜占庭模型的概括，并可以实际应用于分布式分类帐</strong>。<br>从BFT数据库复制的角度来看，Byzantium [32]和HRDB [55]是Fabric的另外两个前身。Byzantium允许事务并行运行并使用主动复制，但是使用BFTmiddleware完全命令BEGIN和COMMIT / ROLLBACK。在其乐观模式下，每个操作都由一个主副本进行协调。如果怀疑该主服务器是拜占庭，则所有副本都将对该主服务器执行事务操作，并触发昂贵的协议来更改该主服务器。HRDB以一种更强大的方式依赖于正确的主机。与Fabric相比，这两个系统都<strong>使用主动复制，无法处理灵活的信任模型，并且依赖确定性操作</strong>。<br>在Eve [37]中，还探索了BFT SMR的相关架构。它的peers同时执行事务，然后使用共识协议验证它们都达到了相同的输出状态。如果状态不同，它们将回滚并顺序执行操作。Eve包含独立执行的元素，该元素也存在于Fabric中，但<strong>没有其他功能</strong>。<br>近来出现了大量的permissioned模型中的分布式分类帐平台，一些著名的平台是Tendermint [14]，Quorum [13]，Chain Core [4]，Multichain）。[12]，Hyperledger Sawtooth[9]，Volt proposal[50]等，请参阅最近概述中的参考文献[24,30]。所有平台都遵循第2节中讨论的<strong>顺序执行架构</strong>。作为代表示例，以Quorum平台[35]（以太坊为企业版本）为基础。基于Raft [45]的共识，它传播了使用gossip和Raft leader（称为Minter）将交易传播到所有peers，然后将有效交易组装到一个区块上，并使用Raft将其分配给所有peers。所有peers都按照领导者决定的顺序执行交易，因此它受到上述限制的困扰在1-2中。</p>
<p><strong>八、总结</strong><br>Fabric是用于<strong>运行许可区块链的模块化且可扩展的分布式操作系统</strong>。它介绍了一种新颖的体系结构，该体系结构将事务执行与共识分开，并实现了基于策略的，这让人联想到中间件复制的数据库。<br>通过其模块化，Fabric非常适合许多进一步的改进和研究。未来的工作将通过（1）探索基准和优化来解决性能问题;（2）对大型部署进行可伸缩性;（3）保证一致性和更通用的数据模型;（4）通过不同的共识协议保证其他弹性（5））通过密码技术等进行交易和分类账数据的隐私和机密性。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://nlbyd1119.online/2020/04/03/block_paper_2/" title="block_paper_2" target="_blank" rel="external">http://nlbyd1119.online/2020/04/03/block_paper_2/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/nlby" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/nlby" target="_blank"><span class="text-dark">nlby</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    <div id="git"></div>
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
<script>
var gitment = new Gitment({
  id: window.decodeURIComponent(window.location.pathname),
  owner: 'nlby',
  repo: 'nlbyvh.github.io',
  oauth: {
    client_id: '6d53a92df707fc123e7a',
    client_secret: '2bd9e28afe88cb142fa8fa7092c9a8c20ae25555',
  },
})
gitment.render('git')
</script>
  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/04/21/jsp-study-2/" title="jsp-study-2"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/04/02/block_paper_1/" title="block_paper_1"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	

    <div class="copyright">
    	
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
<script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script>
<script>
var gitment = new Gitment({
  // id默认为当前页面url，如果url后带参数或锚点，gitment要重新初始化
  // https://github.com/imsun/gitment/issues/55
  // 解决方案：id:window.location.pathname,或者将id设置为当前页面标题
  id: 'block_paper_2', 
  owner: 'nlby', // 可以是你的GitHub用户名，也可以是github id
  repo: 'nlbyvh.github.io',
  oauth: {
    client_id: '6d53a92df707fc123e7a',
    client_secret: '2bd9e28afe88cb142fa8fa7092c9a8c20ae25555',
  }
})
gitment.render('comments')
</script>









<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/violet.model.json"},"display":{"position":"left","width":180,"height":360},"mobile":{"show":true},"log":false});</script></body>
</html>