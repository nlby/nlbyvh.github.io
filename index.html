<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Memory</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Memory">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Memory">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="nlby">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Memory" type="application/atom+xml">
  
  
    <link rel="icon" href="http://q5uc9wpxq.bkt.clouddn.com/xj.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("F3vqXSGcnb9cM3bvLFT2skRf-gzGzoHsz", "kTj2Ad4Ye9Q3U5uHGjFXHCcx");</script>

<script src="/js/Counter.js"></script>

  
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://i.loli.net/2020/03/21/oSCA8lZVKMG6OBp.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">nlby</a></h1>
		</hgroup>

		
		<p class="header-subtitle">永远相信美好的事情即将发生</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						<li>
						<iframe frameborder="no" border="0" marginwidth="0"
						marginheight="0" width=200 height=86 src="//music.163.com/outchain/player?type=0&id=4872500795&auto=1&height=66">
						</iframe></li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JavaWeb/" style="font-size: 16px;">JavaWeb</a> <a href="/tags/android/" style="font-size: 18px;">android</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 14px;">区块链</a> <a href="/tags/%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">博客框架</a> <a href="/tags/%E5%A3%B0%E4%BC%98%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">声优记录</a> <a href="/tags/%E5%B0%8F%E8%AF%B4%E6%95%B4%E7%90%86/" style="font-size: 12px;">小说整理</a> <a href="/tags/%E7%95%AA%E5%89%A7%E8%AE%B0%E5%BD%95/" style="font-size: 20px;">番剧记录</a> <a href="/tags/%E9%80%9A%E7%94%A8/" style="font-size: 10px;">通用</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io/zh-cn/docs/">hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://nlby.github.io/">another</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">nlby</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://i.loli.net/2020/03/21/oSCA8lZVKMG6OBp.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">nlby</h1>
			</hgroup>
			
			<p class="header-subtitle">永远相信美好的事情即将发生</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-jsp-study-6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/28/jsp-study-6/" class="article-date">
  	<time datetime="2020-05-28T11:13:44.000Z" itemprop="datePublished">2020-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/28/jsp-study-6/">
        jsp-study-6
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>JSP中使用XML</strong><br><strong>一、概述</strong></p>
<ol>
<li>如果Web应用没有用到数据库独有的一些特性，而仅仅是查询数据而已，并且这些数据可能占用较大的存储空间。在这种情况下，如果选择用数据库来处理数据显然得不偿失，因为使用数据库要付出降低程序运行效率的代价。</li>
<li>当需要查询文件中的某些内容时，显然希望这种文件应当具有某种特殊的形式结构，即文件应当按照一定的标准来组织数据，这就是XML文件。</li>
</ol>
<p><strong>二、XML文件的基本结构</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➢XML是eXtensible Markup Language 缩写，称之为可扩展置标语言。</span><br><span class="line">➢所谓可扩展是指XML允许用户按照XML的规则自定义标记。</span><br><span class="line">➢XML文件是由标记构成的文本文件，使得XML文件能够很好地体现数据的结构和含义。</span><br><span class="line">➢W3C推出XML的主要目的是使得Internet上的数据相互交流更方便，让文件的内容更加显而易懂。</span><br><span class="line"></span><br><span class="line">➢规范的XML文件应当用“XML声明”开始、文件有当且仅有一个根标记，其它标记都必须封装在根标记中.</span><br><span class="line">➢根标记可以有若干个子标记，称根标记的子标记。根标记的子标记还可以有子标记，以此类推。</span><br><span class="line">➢如果一个标记仅仅包含文本，这样的标记称为叶标记。</span><br><span class="line">➢非空标记必须由“开始标记”与“结束标记”组成、空标记没有“开始标记”和“结束标记”等等。</span><br><span class="line">➢XML文件的标记必须形成树型结构，即一个标记的子标记必须包含于该标记的开始标记和结束标记之间。简单地说，就是标记之间不允许出现交叉。</span><br><span class="line"></span><br><span class="line">➢W3C吸取了HTML发展的教训，对XML指定了严格的语法标准。为了检查XML文件是否规范，一个简单的办法就是用浏览器，打开XML文件，如果XML是规范的，浏览器将显示XML源文件，否则，将显示出错信息。</span><br></pre></td></tr></table></figure>

<p><strong>三、XML声明</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➢一个规范的XML文件应当以XML声明作为文件的第一行，在其前面不能有空白、其他的处理指令或注释。</span><br><span class="line">➢XML声明以“<span class="meta">&lt;?xml”标识开始、以“?&gt;</span>”标识结束。以下是一个最基本的XML声明：<span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line">➢一个简单的XML声明中可以只包含属性version（目前该属性的值只可以取1.0），指出该XML文件使用的XML版本。</span><br><span class="line"></span><br><span class="line">➢XML声明中也可以指定encoding属性的值，该属性规定XML文件采用哪种字符集进行编码。如果在XML声明中没有指定encoding属性的值，那么该属性的默认值是UTF-8。</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">➢如果encoding属性的值为“UTF-8”，XML文件必须选择“UTF-8”编码来保存.</span><br><span class="line"></span><br><span class="line">➢如果在编写XML文件时只准备使用ASCII字符和汉字，也可以将encoding属性的值设置为gb2312.这时XML文件必须使用ANSI编码保存.</span><br><span class="line"></span><br><span class="line">➢如果在编写XML文件时只准备使用ASCII字符，也可以将encoding属性的值设置为ISO-8859-1.这时XML文件必须使用ANSI编码保存.</span><br></pre></td></tr></table></figure>

<p><strong>四、标记</strong><br>XML文件是由标记构成的文本文件。标记的名称可以由字母、数字、下划线“_”、点号“.”或连字符“-”组成，但必须以字母或下划线开头。<br>标记名称区分大小写。<br>1.空标记</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➢空标记就是不含有任何内容的标记，即不含有子标记或文本内容.</span><br><span class="line">➢空标记不需要开始标记和结束标记</span><br><span class="line">➢空标记以“<span class="tag">&lt;<span class="name">”标识开始，用“</span>/&gt;</span>”标识结束</span><br><span class="line"><span class="tag">&lt;<span class="name">空标记的名称属性列表</span>/&gt;</span>或<span class="tag">&lt;<span class="name">空标记的名称</span>/&gt;</span></span><br><span class="line">例如：</span><br><span class="line"><span class="tag">&lt;<span class="name">chair</span>  <span class="attr">width</span>=<span class="string">"24"</span>  <span class="attr">height</span>=<span class="string">"12"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">和标记名称之间不要含有空格</span></span></span><br></pre></td></tr></table></figure>
<p>2.非空标记</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➢由“开始标记”与“结束标记”组成，“开始标记”与“结束标记”之间是该标记所含有的内容。</span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">➢开始标记以“<span class="tag">&lt;<span class="name">”标识开始，用“</span>&gt;</span>”标识结束</span><br><span class="line">➢结束始标记以“<span class="tag">&lt;/<span class="name">”标识开始，用“</span>&gt;</span>”标识结束</span><br></pre></td></tr></table></figure>
<p>3.CDATA段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➢标记内容中的文本数据中不可以含有左尖括号、右尖括号、与符号、单引号和双引号这些特殊字符。如果标记内容想使用这些特殊字符，办法之一是通过使用CDATA段。</span><br><span class="line">➢CDATA段用“&lt;![CDATA[”作为段的开始，用“]]&gt;”作为段的结束。段开始和段结束之间称为CDATA段的内容，CDATA段中的内容可以包含任意的字符</span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span>&gt;</span></span><br><span class="line">&lt;![CDATA[</span><br><span class="line">booleanboo=true&amp;&amp;false</span><br><span class="line">&lt;你好&gt;</span><br><span class="line">]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.属性<br>属性是一个名值对，即属性必须由名字和值组成。属性必须在非空标记的开始标记或空标记中声明，用“=”为属性指定一个值。</p>
<p><strong>五、DOM解析器（按树形结构解析）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用XML解析器可以从XML文件中解析出所需要的数据.</span><br><span class="line">➢DOM（Document Object Model，文档对象模型）是W3C制定的一套规范标准。DOM规范的核心是按树型结构处理数据。</span><br><span class="line">➢简单地说，DOM解析器必须按着DOM规范在内存中按树型结构组织数据，DOM解析器通过读入XML文件在内存中建立一个“树”，也就是说XML文件的标记、标记的文本内容都会和内存中“树”的某个节点相对应。一个应用程序可以方便地操作内存中“树”的节点来处理XML文档，获取自己所需要的数据。</span><br></pre></td></tr></table></figure>
<p>1.使用DOM解析器的基本步骤</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">① 使用javax.xml.parsers包中的DocumentBuilderFactory类 </span><br><span class="line">    调 用 其 类 方 法 newInstance () 实 例 化 一 个 </span><br><span class="line">    DocumentBuilderFactory对象： </span><br><span class="line"></span><br><span class="line">    DocumentBuilderFactory   factory= DocumentBuilderFactory. newInstance(); </span><br><span class="line"></span><br><span class="line">② factory 对象调用new DocumentBuilder ()方法返回一个 </span><br><span class="line">    DocumentBuilder对象 （称做DOM解析器）： </span><br><span class="line"></span><br><span class="line">    DocumentBuilder  builder =  factory. newDocumentBuilder(); </span><br><span class="line"></span><br><span class="line">③ builder对象调用public Document parse(File f)方法解 </span><br><span class="line">    析参数f指定的文件，并返回一个实现了Document接口的实 </span><br><span class="line">    例，该实例被称做Document对象： </span><br><span class="line"></span><br><span class="line">    Document  document= builder. parse(new File("price.xml")) ;</span><br></pre></td></tr></table></figure>
<p>2.Document对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➢DOM解析器负责在内存中建立Document对象，即调用parse方法返回一个Document对象</span><br><span class="line">Documentdocument=builder.parse(newFile("price.xml"));</span><br><span class="line">➢parse方法将整个被解析的XML文件封装成一个Document对象，即将XML文件和内存中的Document对象相对应.</span><br><span class="line">➢Document对象就是一棵“树”，文件中的标记都和Document对象中的某个节点相对应。</span><br></pre></td></tr></table></figure>
<p>对象结构</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➢Element类、Text类和CDATASection类都是实现了Node接口的类，是比较重要的三个类，这些类的对象分别被称作Document对象中的Element节点、Text节点和CDATASection节点.</span><br><span class="line">➢一个Element节点中还可含有Element节点、Text节点和CDATASection节点。比如Document对象的根节点就是一个Element节点.</span><br></pre></td></tr></table></figure>
<p>Element节点</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Element节点经常使用下列方法获取和该节点相关的信息</span><br><span class="line">➢String getTagName()返回该节点的名称，该名称就是和此节点相对应的XML中的标记的名称。</span><br><span class="line">➢String getTextContent()返回当前节点的所有Text子孙节点中的文本内容（也就是返回相对应的XML文件中的标记及子孙标记中含有的文本内容）。</span><br><span class="line">➢String getAttribute(String name)返回节点中参数name的属性值，该属性值是和此节点对应的XML中标记中的属性值。</span><br><span class="line"></span><br><span class="line">Element节点经常使用下列方法获取和该节点相关的信息</span><br><span class="line">➢Boolean hasAttribute(String name) 判断当前节点是否有参数name指定的属性。</span><br><span class="line">➢NodeList getElementByTagName(String name)返回一个NodeList对象，该对象由当前节点的Element类型子孙节点组成，这些子孙节点的名字由参数name指定。</span><br><span class="line">➢NodeList getChildNodes()返回一个NodeList对象，该对象由当前节点的子节点组成。</span><br></pre></td></tr></table></figure>
<p>Text节点<br>Text节点使用String getWholeText()方法获取节点中的文本（包括其中的空白字符）。<br>CDATASection节点<br>CDATASection节点使用String getWholeText()方法获取该节点中的文本，即CDATA段中的文本（包括其中的空白字符）。</p>
<p><strong>六、SAX解析器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➢如果XML文件较大，相应的Document对象就要占据较多的内存空间.</span><br><span class="line">➢和DOM解析器不同的是，SAX解析器不在内存中建立和XML文件相对应的树型结构数据，SAX解析器的核心是事件处理机制。和DOM解析器相比，SAX解析器占有的内存少，对于许多应用程序，使用SAX解析器来获取XML数据具有较高的效率.</span><br></pre></td></tr></table></figure>
<p>1.使用SAX解析器的基本步骤</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">① 使用javax.xml.parsers包中的SAXParserFactory类调用其 </span><br><span class="line">    类方法newInstance ()实例化一个SAXParserFactory对象: </span><br><span class="line"></span><br><span class="line">   SAXParserFactory factory=SAXParserFactory.newInstance(); </span><br><span class="line"></span><br><span class="line">② SAXParserFactory对象调用newSAXParser ()方法返回一个 </span><br><span class="line">    SAXParser对象，称之为SAX解析器: </span><br><span class="line"></span><br><span class="line">    SAXParser saxParser=factory.newSAXParser(); </span><br><span class="line"></span><br><span class="line">③ saxParser  对 象 调 用 public void parse(File f,DefaultHandler dh)方法解析参数f指定的XML文件。 </span><br><span class="line"></span><br><span class="line">    saxParser. parse(new File(“price.xml”),handler) ;</span><br></pre></td></tr></table></figure>
<p>2.SAX解析器的工作原理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➢SAX解析器调用parse方法解析XML文件，parse方法的第2个参数dh是DefaultHandler类型，称为事件处理器。</span><br><span class="line">➢parse方法在解析XML文件的过程中，根据从文件中解析出的数据产生相应的事件，并报告这个事件给事件处理器dh，事件处理器dh就会处理所发现的数据，即处理器dh会根据相应的事件调用相应的方法来处理数据。</span><br><span class="line">➢parse方法必须等待事件处理器处理完毕后才能继续解析文件、报告下一个事件。</span><br></pre></td></tr></table></figure>
<p>3.事件的产生与处理<br>①文件开始事件与结束事件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当解析器开始解析器XML文件时，就会报告“文件开始”事件给事件处理器，然后再陆续地报告其他的事件，最后报告“文件结束”事件。解析器报告“文件开始”事件，事件处理器就会调用</span><br><span class="line">startDocument()方法；解析器报告“文件结束”事件，事件处理器就会调用endDocument()方法。</span><br></pre></td></tr></table></figure>
<p>②开始标记事件与结束标记事件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当解析器发现一个标记的开始标记时，报告开始事件给事件处理器，事件处理器调用startElement方法对发现的数据做出处理。</span><br><span class="line">startElement(String uri,String localName,String qName,Attribute satts)</span><br><span class="line"></span><br><span class="line">方法中atts是解析器发现的标记的全部属性，参数uri的取值就是解析器发现的标记的名称空间（如果没有名称空间uri是空字符串），localName是标记的名称，qName是带前缀的标记名称（如果名称空间的前缀）或标记名称（如果没有名称空间的前缀）。</span><br><span class="line"></span><br><span class="line">解析器报告完该标记的“标记开始”事件后，一定还会报告该标记的“标记结束”事件，事件处理 器就会调用endElement方法进行处理</span><br><span class="line">endElement(String uri,String localName,String qName)</span><br><span class="line">如果一个标记是空标记，解析器也报告“标记开始”事件和“标记结束”事件.</span><br></pre></td></tr></table></figure>
<p>③文本数据事件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当解析器解析报告“文本数据”事件给处理器，事件处理器就会然后调用characters方法对解析的数据做出处理</span><br><span class="line">public void characters(char[] ch,int start,int length)</span><br><span class="line"></span><br><span class="line">字符数组中ch存放的就是解析器解析出的文本数据，start</span><br><span class="line">是数组ch中存放字符的起始位置，length是存放的字符个数。</span><br><span class="line"></span><br><span class="line">注意：对于文本数据，解析器可能分成几个连续的“文本数据”报告给事件处理器。</span><br></pre></td></tr></table></figure>
<p><strong>七、XML与CSS</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JSP/">JSP</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/05/28/jsp-study-6/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jsp-study-6">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-jsp-study-5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/28/jsp-study-5/" class="article-date">
  	<time datetime="2020-05-28T02:28:36.000Z" itemprop="datePublished">2020-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/28/jsp-study-5/">
        jsp-study-5
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>JSP文件操作</strong><br><strong>一、File类</strong><br>1.File类的对象主要用来获取文件本身的一些信息，例如文件所在的目录、文件的长度、文件读写权限等，不涉及对文件的读写操作。<br>2.创建一个File对象的构造方法有3个：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filename);</span><br><span class="line">File(String directoryPath,Stringfilename);</span><br><span class="line">File(File f, String filename);</span><br></pre></td></tr></table></figure>
<p>3.经常使用File类的下列方法获取文件本身的一些信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➢ public String getName() —获取文件的名字 </span><br><span class="line"></span><br><span class="line">➢ public boolean canRead() —判断文件是否是可读的 </span><br><span class="line"></span><br><span class="line">➢ public boolean canWrite() —判断文件是否可被写入 </span><br><span class="line"></span><br><span class="line">➢ public boolean exists() —判断文件是否存在 </span><br><span class="line"></span><br><span class="line">➢ public long length() —获取文件的长度 （单位是字节） </span><br><span class="line"></span><br><span class="line">➢ public String getAbsolutePath() —获取文件的绝对路径 </span><br><span class="line"></span><br><span class="line">➢ public String getParent() —获取文件的父目录 </span><br><span class="line"></span><br><span class="line">➢ public boolean isFile() —判断是否是正常文件，而不是目录 </span><br><span class="line"></span><br><span class="line">➢ public boolean isDirectory() —判断文件是否是一个目录 </span><br><span class="line"></span><br><span class="line">➢ public boolean isHidden() —判定是否隐藏文件 </span><br><span class="line"></span><br><span class="line">➢ public long lastModified() —获取最后修改时间</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=GB2312"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*"</span>%&gt; </span><br><span class="line">&lt;HTML&gt;&lt;body bgcolor=cyan&gt;&lt;font Size=<span class="number">2</span>&gt;</span><br><span class="line">&lt;%  String jspPage=request.getServletPath();    <span class="comment">//请求的页面的名称</span></span><br><span class="line">    String webDir = request.getContextPath();<span class="comment">//获取当前Web服务目录的名称</span></span><br><span class="line">    webDir = webDir.substring(<span class="number">1</span>); <span class="comment">//去掉名称前面的目录符号：/</span></span><br><span class="line">    jspPage =jspPage.substring(<span class="number">1</span>); <span class="comment">//去掉名称前面的目录符号：/</span></span><br><span class="line">    File f= <span class="keyword">new</span> File(<span class="string">""</span>); <span class="comment">//该文件认为在Tomcat引擎启动的目录中，即bin目录中</span></span><br><span class="line">    String path = f.getAbsolutePath();</span><br><span class="line">    <span class="keyword">int</span> index = path.indexOf(<span class="string">"bin"</span>);</span><br><span class="line">    String tomcatDir = path.substring(<span class="number">0</span>,index);<span class="comment">//tomcat的安装目录</span></span><br><span class="line">    File file=<span class="keyword">new</span> File(tomcatDir+<span class="string">"/webapps/"</span>+webDir,jspPage);</span><br><span class="line">  %&gt;</span><br><span class="line">  文件&lt;%=file.getName()%&gt;是可读的吗？&lt;b&gt;&lt;%=file.canRead()%&gt;&lt;/b&gt;</span><br><span class="line"> &lt;br&gt;文件&lt;%=file.getName()%&gt;的长度：&lt;b&gt;&lt;%=file.length()%&gt;字节&lt;/b&gt;</span><br><span class="line"> &lt;br&gt;&lt;%=file.getName()%&gt;的父目录是:&lt;br&gt;&lt;b&gt;&lt;%=file.getParent()%&gt;&lt;/b&gt;</span><br><span class="line"> &lt;br&gt; &lt;%=file.getName()%&gt;的绝对路径是：&lt;br&gt;&lt;b&gt;&lt;%=file.getAbsolutePath()%&gt;</span><br><span class="line">&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
<p>4.创建目录</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File对象调用方法public boolean mkdir()创建一个目录</span><br><span class="line">如果创建成功就返回true 否则返回false 如果该目录已经存在也将返回false</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=GB2312"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*"</span>%&gt; </span><br><span class="line">&lt;HTML&gt;&lt;body bgcolor=#EEFFAD&gt;&lt;font Size=2&gt;</span><br><span class="line">&lt;% </span><br><span class="line">    String webDir = request.getContextPath();<span class="comment">//获取当前Web服务目录的名称</span></span><br><span class="line">    webDir = webDir.substring(<span class="number">1</span>); <span class="comment">//去掉名称前面的目录符号：/</span></span><br><span class="line">    File f= <span class="keyword">new</span> File(<span class="string">""</span>); <span class="comment">//该文件认为在Tomcat引擎启动的目录中，即bin目录中</span></span><br><span class="line">    String path = f.getAbsolutePath();</span><br><span class="line">    <span class="keyword">int</span> index = path.indexOf(<span class="string">"bin"</span>);</span><br><span class="line">    String tomcatDir = path.substring(<span class="number">0</span>,index);<span class="comment">//tomcat的安装目录</span></span><br><span class="line">    File dir=<span class="keyword">new</span> File(tomcatDir+<span class="string">"/webapps/"</span>+webDir+<span class="string">"/image"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"> &lt;br&gt; 在&lt;%=webDir%&gt;下创建一个新的目录：image,&lt;br&gt;成功创建了吗？</span><br><span class="line">    &lt;%=dir.mkdir()%&gt;</span><br><span class="line"> &lt;br&gt; image是目录吗？&lt;%=dir.isDirectory()%&gt;</span><br><span class="line">&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
<p>5.列出目录中的文件<br>如果File对象是一个目录，那么该对象可以调用下面的方法获得目录下的文件和子目录</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public String  [ ]  list() 用字符串形式返回目录下的全部文件. </span><br><span class="line">public File [ ]  listFiles() 用File对象形式返回目录下的全部文件。</span><br></pre></td></tr></table></figure>
<p>6.列出指定类型的文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➢public String [ ] list(FilenameFilter obj) 该方法用字符串形式返回目录下的指定类型的所有文件。 </span><br><span class="line"></span><br><span class="line">➢public  File  [ ]  listFiles(FilenameFilter obj)  该方法用File对象返回目录下的指定类型的所有文件。</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=GB2312"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.*"</span>%&gt; </span><br><span class="line">&lt;%! <span class="class"><span class="keyword">class</span> <span class="title">FileJSP</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span></span>&#123; </span><br><span class="line">       String str=<span class="keyword">null</span>;</span><br><span class="line">       FileJSP(String s)&#123;</span><br><span class="line">          str=<span class="string">"."</span>+s;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir,String name)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name.endsWith(str);</span><br><span class="line">       &#125;              </span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;HTML&gt;&lt;body bgcolor=#EEFFAD&gt;&lt;font Size=2&gt;</span><br><span class="line">&lt;% </span><br><span class="line">    String name=<span class="string">"jsp"</span>;</span><br><span class="line">    String webDir = request.getContextPath();</span><br><span class="line">    webDir = webDir.substring(<span class="number">1</span>); </span><br><span class="line">    File f= <span class="keyword">new</span> File(<span class="string">""</span>); </span><br><span class="line">    String path = f.getAbsolutePath();</span><br><span class="line">    <span class="keyword">int</span> index = path.indexOf(<span class="string">"bin"</span>);</span><br><span class="line">    String tomcatDir = path.substring(<span class="number">0</span>,index);<span class="comment">//tomcat的安装目录</span></span><br><span class="line">    File dir=<span class="keyword">new</span> File(tomcatDir+<span class="string">"/webapps/"</span>+webDir);</span><br><span class="line">%&gt;</span><br><span class="line"> &lt;br&gt; 在&lt;%=dir%&gt;下&lt;%=name%&gt;文件：</span><br><span class="line">&lt;%</span><br><span class="line">    FileJSP file_jsp=<span class="keyword">new</span> FileJSP(name);</span><br><span class="line">    String file_name[]=dir.list(file_jsp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;file_name.length;i++)</span><br><span class="line">       out.print(<span class="string">"&lt;br&gt;"</span>+file_name[i]);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
<p>7.删除文件和目录</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➢File对象调用方法public boolean delete()删除当前对象代表的文件或目录.</span><br><span class="line">➢如果对象表示的是一个目录，则该目录必须是空目录.</span><br><span class="line">➢删除成功返回true.</span><br></pre></td></tr></table></figure>
<p><strong>二、读写文件的常用流</strong><br>1.字节输入流</p>
<ul>
<li>如果对 文 件 读 取 需 求 比 较 简 单，那 么 可 以 使 用FileInputStream类（文件字节输入流），该类是InputStream类的子类（以字节为单位读取文件），该类的实例方法都是从InputStream类继承来的。</li>
<li>使用输入流通常包括4个基本步骤：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 设定输入流的源</span><br><span class="line">2. 创建指向源的输入流</span><br><span class="line">3. 让输入流读取源中的数据</span><br><span class="line">4. 关闭输入流。</span><br></pre></td></tr></table></figure></li>
<li>构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(String name);</span><br><span class="line">FileInputStream(File file);</span><br><span class="line"></span><br><span class="line">第一个构造方法使用给定的文件名name创建FileInputStream</span><br><span class="line">流，第二个构造方法使用File对象创建FileInputStream流。</span><br><span class="line">参数name和file指定的文件称为输入流的源。</span><br><span class="line">File f= new File("hello.txt");   //指定输入流的源</span><br><span class="line">try &#123;</span><br><span class="line">    FileInputStream in= new FileInputStream(f); //创建指向源的输入流</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">    System.out.println("File read error:"+e );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用输入流读取字节<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➢ 输入流的目的是提供读取源中数据的通道，程序可以通过这 </span><br><span class="line">   个通道读取源中的数据。文件字节流可以调用从父类继承的 </span><br><span class="line">   read方法顺序地读取文件，只要不关闭流，每次调用read方 </span><br><span class="line">   法就顺序地读取文件中的其余内容，直到文件的末尾或文件 </span><br><span class="line">   字节输入流被关闭。 </span><br><span class="line">➢int read() 读取单个字节的数据，该方法返回字节值 </span><br><span class="line">（0~255之间的一个整数），如果未读出字节就返回-1。 </span><br><span class="line">➢int read(byte  b[])  试图读取b.length个字节到字节数组b 中。 </span><br><span class="line">➢int read(byte b[], int off, int len) 试图读取len个字节到字 </span><br><span class="line">   节数组b 中，参数off指定从字节数组的某个位置开始存放读取 </span><br><span class="line">   的数据。</span><br></pre></td></tr></table></figure></li>
<li>关闭流<br>输入流都提供了关闭方法close()，尽管程序结束时会自动关闭所有打开的流，但是当程序使用完流后，显式地关闭任何打开的流仍是一个良好的习惯</li>
</ul>
<p>2.字节输出流</p>
<ul>
<li>如果对 文 件 写 入 需 求 比 较 简 单，那 么 可 以 使 用FileOutputStream类（文件字节输出流），它是OutputStream类的子类（以字节为单位向文件写入内容），该类的实例方法都是从OutputStream类继承来的。</li>
<li>使用输出流通常包括4个基本步骤：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 给出输出流的目的地</span><br><span class="line">2. 创建指向目的地的输出流</span><br><span class="line">3. 让输出流把数据写入到目的地</span><br><span class="line">4. 关闭输出流</span><br></pre></td></tr></table></figure></li>
<li>构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name);</span><br><span class="line">FileOutputStream(File file);</span><br><span class="line"></span><br><span class="line">第一个构造方法使用给定的文件名name创建FileOutputStream</span><br><span class="line">流，第二个构造方法使用File对象创建FileOutputStream流。</span><br><span class="line">参数name和file指定的文件称为输出流的目的地。</span><br><span class="line"></span><br><span class="line">如果输出流指向的文件不存在，java就创建该文件，如果已经</span><br><span class="line">存在，输出流将刷新该文件，使其长度为0.</span><br><span class="line"></span><br><span class="line">选择是否具有刷新功能的构造方法</span><br><span class="line">FileOutputStream(String name, booleanappend);</span><br><span class="line">FileOutputStream(File file, booleanappend);</span><br><span class="line">如果append=true，输出流不会刷新所指向的文件，write方法</span><br><span class="line">将从文件末尾开始向文件写入数据；如果append=false，输出</span><br><span class="line">流将刷新所指向的文件</span><br></pre></td></tr></table></figure></li>
<li>使用输出流写字节<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➢ 输出流的目的是提供通往目的地的通道，程序可以通过这个 </span><br><span class="line"></span><br><span class="line">   通道将程序中的数据写入到目的地。文件字节流可以调用从 </span><br><span class="line"></span><br><span class="line">   父类继承的write方法顺序地写文件。FileOutStream流顺序 </span><br><span class="line"></span><br><span class="line">   地向文件写入内容，即只要不关闭流，每次调用write方法就 </span><br><span class="line"></span><br><span class="line">   顺序地向文件写入内容，直到流被关闭。 </span><br><span class="line"></span><br><span class="line">➢ void write(int n) 输出流调用该方法向目的地写入单个字节 </span><br><span class="line"></span><br><span class="line">➢ void write(byte  b[]) 输出流调用该方法向目的地写入一个字节数组。 </span><br><span class="line"></span><br><span class="line">➢ void write(byte  b[],int off,int  len)  给定字节数组中起始于偏移量off处取len个字节写到目的地。</span><br></pre></td></tr></table></figure></li>
<li>关闭流<br>在操作系统把程序所写到输出流上的那些字节保存到磁盘上之前，有时被存放在内存缓冲区中，通过调用close()方法，可以保证操作系统把流缓冲区的内容写到它的目的地，即关闭输出流可以把该流所用的缓冲区的内容冲洗掉（通常冲洗到磁盘文件上）</li>
</ul>
<p>3.字符流</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">与FileInputStream 、FileOutputStream字节流相对应的是 </span><br><span class="line">FileReader、FileWriter字符流 （文件字符输入、输出流）， </span><br><span class="line">FileReader和FileWriter分别是Reader和Writer的子类.字符</span><br><span class="line">输入流和输出流的read和write方法使用字符数组读写数据， </span><br><span class="line">即以字符为基本单位处理数据。 </span><br><span class="line"></span><br><span class="line">构造方法分别是： </span><br><span class="line">FileReader(String filename); </span><br><span class="line">FileReader(File filename); </span><br><span class="line">FileWriter (String filename); </span><br><span class="line">FileWriter (File filename); </span><br><span class="line">FileWriter (String filename,boolean append); </span><br><span class="line">FileWriter (File filename,boolean append);</span><br></pre></td></tr></table></figure>

<p>4.缓冲流</p>
<ul>
<li>BufferedReader类和BufferedWriter的构造方法分别是<br>BufferedReader(Readerin);<br>BufferedWriter(Writerout);</li>
<li>BufferedReader流能够读取文本行，方法是readLine().<br>BufferedReader和BufferedWriter类创建的对象称为缓冲输<br>入、输出流，二者增强了读写文件的能力。需要注意的是二<br>者的源和目的地必须是字符输入流和字符输出流<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileReader inOne=new FileReader(“studen.txt”);     //创建字符输入流</span><br><span class="line">BufferReader inTwo=new BufferReader(inOne);     //创建缓冲输入流</span><br><span class="line">FileWriter tofile=new FileWriter(“hello.txt”);     //创建字符输出流</span><br><span class="line">BufferWriter out=new BufferWriter(tofile);     //创建缓冲输入流</span><br><span class="line"></span><br><span class="line">readLine ()//读取一行 </span><br><span class="line">write(String s,int off, int len)//把字符串s写到流中，参数off是s开始处的偏移量，len是写入的字符数量 </span><br><span class="line">newLine()//写入一个回车符</span><br></pre></td></tr></table></figure></li>
<li>可以把BufferedReader和BufferedWriter称为上层流，把它们指向的字符流称为底层流。 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java采用缓存技术将上层流和底层流连接。底层字符输入流首先将数据读入缓存，BufferedReader流再从缓存读取数据；BufferedWriter流将数据写入缓存，底层字符输出流会不断地将缓存中的数据写入到目的地。</span><br><span class="line"></span><br><span class="line">当BufferedWriter流调用flush()刷新缓存或调用close()方法关闭时，即使缓存没有益满，底层流也会立刻将缓存的内容写入目的地</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span> %&gt;</span><br><span class="line">&lt;HTML&gt;&lt;BODY bgcolor=cyan&gt;&lt;font size=<span class="number">2</span>&gt;</span><br><span class="line"> &lt;form action=<span class="string">"helpReadFile"</span> method=<span class="string">"post"</span> name=<span class="string">"form"</span>&gt;</span><br><span class="line"> 输入文件的路径(如:d:/<span class="number">2000</span>):</span><br><span class="line"> &lt;input type=<span class="string">"text"</span> name=<span class="string">"filePath"</span> size=<span class="number">12</span>&gt;</span><br><span class="line"> &lt;br&gt;输入文件的名字(如:Hello.java):</span><br><span class="line"> &lt;input type=<span class="string">"text"</span> name=<span class="string">"fileName"</span> size=<span class="number">9</span>&gt;</span><br><span class="line"> &lt;br&gt;&lt;input type=<span class="string">"submit"</span> value=<span class="string">"读取"</span> name=<span class="string">"submit"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line">&lt;/font&gt;&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span> %&gt;</span><br><span class="line"> &lt;jsp:useBean id=<span class="string">"fileBean"</span> type=<span class="string">"mybean.data.Example8_4_Bean"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line">&lt;HTML&gt;&lt;body bgcolor=#EEFFAE&gt;&lt;font size=2&gt;</span><br><span class="line">  文件的位置: &lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"filePath"</span>/&gt;,</span><br><span class="line">  文件的名字：&lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"fileName"</span>/&gt;,</span><br><span class="line">  文件的长度：&lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"fileLength"</span>/&gt; 字节。</span><br><span class="line">  &lt;br&gt;文件的内容：</span><br><span class="line">  &lt;br&gt;&lt;TextArea  rows=<span class="string">"6"</span> cols=<span class="string">"60"</span>&gt;</span><br><span class="line">       &lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"fileContent"</span>/&gt;</span><br><span class="line">     &lt;/TextArea&gt;</span><br><span class="line">&lt;/font&gt;&lt;/body&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>三、RandomAccessFile类</strong><br>RandomAccessFile类创建的流与前面的输入、输出流不同。RandomAccessFile类既不是输入流类InputStream类的子类，<br>也不是输出流类Outputstream类的子类。<br>习惯上，仍然称RandomAccessFile类创建的对象为一个流。<br>RandomAccessFile流的指向既可以作为源也可以作为目的地。<br>换句话说，当想对一个文件进行读写操作时，可以创建一个<br>指向该文件的RandomAccessFile流，这样既可以从这个流读<br>取文件的数据，也可以通过这个流向文件写入数据。<br>1.构造方法</p>
<ul>
<li>RandomAccessFile类的两个构造方法<br>RandomAccessFile(String name,String mode)<br>RandomAccessFile(File file,String mode)</li>
<li>参数name用来确定一个文件名，参数file是一个File对象,给<br>出创建的流的源 （也是流的目的地）。参数mode取 “r” （只<br> 读）或 “rw” （可读写），决定创建的流对文件的访问权利。 </li>
</ul>
<p>2.读写方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">readLine()从文件中读取一个文本行</span><br><span class="line">readUTF()从文件中读取一个UTF字符串</span><br><span class="line">seek(long a) 定位当前流在文件中的读写的位置</span><br><span class="line">write(byte b[]) 写b.length个字节到文件</span><br><span class="line">writeDouble(double v)向文件写入一个双精度浮点值</span><br><span class="line">writeInt(int v)向文件写入一个int值</span><br><span class="line">writeUTF(String s)写入一个UTF字符串</span><br><span class="line">getFilePointer() 获取当前流在文件中的读写的位置</span><br></pre></td></tr></table></figure>
<p><strong>四、文件上传</strong></p>
<ol>
<li>用户通过一个JSP页面上传文件给服务器时，该JSP页面必须<br>含有File类型的表单，并且表单必须将ENCTYPE的属性值设成<br>multipart/form-data。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"接受上传文件的页面"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">ENCTYPE</span>=<span class="string">"multipart/form-data"</span></span></span><br><span class="line">&lt;Input type="File" name="picture" &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>实例 例六<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> =<span class="string">"java.io.*"</span> %&gt;</span><br><span class="line"> &lt;jsp:useBean id=<span class="string">"fileBean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"mybean.data.Example8_6_Bean"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line">&lt;HTML&gt;&lt;body&gt;</span><br><span class="line"> &lt;P&gt;选择要上传的文件：&lt;BR&gt;</span><br><span class="line"> &lt;form action=<span class="string">"upFile"</span> method=<span class="string">"post"</span> ENCTYPE=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">      &lt;input type=FILE name=<span class="string">"boy"</span> size=<span class="string">"45"</span>&gt; </span><br><span class="line">      &lt;br&gt; &lt;input type=<span class="string">"submit"</span> name =<span class="string">"boy"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line"> &lt;br&gt; 上传的文件名字：</span><br><span class="line"> &lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"fileName"</span>/&gt; </span><br><span class="line">   &lt;br&gt; 上传反馈：</span><br><span class="line"> &lt;jsp:getProperty name=<span class="string">"fileBean"</span> property=<span class="string">"mess"</span>/&gt;</span><br><span class="line"> &lt;%</span><br><span class="line">    String name=fileBean.getFileName();</span><br><span class="line">    <span class="keyword">boolean</span> boo =name.endsWith(<span class="string">".jpg"</span>);</span><br><span class="line">    boo = boo||name.endsWith(<span class="string">".gif"</span>);</span><br><span class="line">    <span class="keyword">if</span>(boo) &#123;</span><br><span class="line"> %&gt;     &lt;image src = "image/&lt;%=name%&gt;" width=200 height =200&gt;&lt;%=name %&gt;&lt;/image&gt;</span><br><span class="line"> &lt;% &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"> %&gt;     &lt;%=name %&gt;</span><br><span class="line"> &lt;% &#125;</span><br><span class="line"> %&gt;</span><br><span class="line">&lt;/body&gt;&lt;/HTML&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> myservlet.control;</span><br><span class="line"><span class="keyword">import</span> mybean.data.Example8_6_Bean;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example8_6_Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.init(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">      request.setCharacterEncoding(<span class="string">"gb2312"</span>);</span><br><span class="line">      Example8_6_Bean fileBean=<span class="keyword">new</span> Example8_6_Bean();  <span class="comment">//创建Javabean对象</span></span><br><span class="line">      request.setAttribute(<span class="string">"fileBean"</span>,fileBean);</span><br><span class="line">      String fileName=<span class="keyword">null</span>;</span><br><span class="line">      HttpSession session=request.getSession(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">try</span>&#123;  </span><br><span class="line">         <span class="comment">//用客户的session对象的Id建立一个临时文件</span></span><br><span class="line">          String tempFileName=(String)session.getId();</span><br><span class="line">          String webDir = request.getContextPath();</span><br><span class="line">          webDir = webDir.substring(<span class="number">1</span>); </span><br><span class="line">          File f= <span class="keyword">new</span> File(<span class="string">""</span>); </span><br><span class="line">          String path = f.getAbsolutePath();</span><br><span class="line">          <span class="keyword">int</span> index = path.indexOf(<span class="string">"bin"</span>);</span><br><span class="line">          String tomcatDir = path.substring(<span class="number">0</span>,index);<span class="comment">//tomcat的安装目录</span></span><br><span class="line">          File dir=<span class="keyword">new</span> File(tomcatDir+<span class="string">"/webapps/"</span>+webDir+<span class="string">"/image"</span>);</span><br><span class="line">          dir.mkdir();          </span><br><span class="line">          <span class="comment">//建立临时文件f1</span></span><br><span class="line">          File f1=<span class="keyword">new</span> File(dir,tempFileName);</span><br><span class="line">          FileOutputStream o=<span class="keyword">new</span> FileOutputStream(f1);</span><br><span class="line">           <span class="comment">//将客户上传的全部信息存入f1</span></span><br><span class="line">          InputStream in=request.getInputStream();</span><br><span class="line">          <span class="keyword">byte</span> b[]=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">          <span class="keyword">int</span> n;</span><br><span class="line">          <span class="keyword">while</span>( (n=in.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">             o.write(b,<span class="number">0</span>,n);</span><br><span class="line">          &#125;</span><br><span class="line">          o.close();</span><br><span class="line">          in.close();</span><br><span class="line">           <span class="comment">//读取临时文件f1，从中获取上传文件的名字和上传文件的内容</span></span><br><span class="line">          RandomAccessFile randomRead=<span class="keyword">new</span> RandomAccessFile(f1,<span class="string">"r"</span>);</span><br><span class="line">           <span class="comment">//读出f1的第2行，析取出上传文件的名字</span></span><br><span class="line">          <span class="keyword">int</span> second=<span class="number">1</span>;</span><br><span class="line">          String secondLine=<span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">while</span>(second&lt;=<span class="number">2</span>) &#123; </span><br><span class="line">              secondLine=randomRead.readLine();</span><br><span class="line">              second++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//获取f1中第2行中"filename"之后“=”出现的位置:</span></span><br><span class="line">          <span class="keyword">int</span> position=secondLine.lastIndexOf(<span class="string">"="</span>);</span><br><span class="line">           <span class="comment">//客户上传的文件的名字是</span></span><br><span class="line">          fileName=secondLine.substring(position+<span class="number">2</span>,secondLine.length()-<span class="number">1</span>);</span><br><span class="line">          randomRead.seek(<span class="number">0</span>); <span class="comment">//再定位到文件f1的开头</span></span><br><span class="line">          <span class="comment">//获取第4行回车符号的位置</span></span><br><span class="line">          <span class="keyword">long</span>  forthEndPosition=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> forth=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span>((n=randomRead.readByte())!=-<span class="number">1</span>&amp;&amp;(forth&lt;=<span class="number">4</span>))&#123;  </span><br><span class="line">             <span class="keyword">if</span>(n==<span class="string">'\n'</span>)&#123;</span><br><span class="line">                forthEndPosition=randomRead.getFilePointer();</span><br><span class="line">                forth++;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//根据客户上传文件的名字，将该文件存入磁盘</span></span><br><span class="line">          <span class="keyword">byte</span>  cc[]=fileName.getBytes(<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">          fileName=<span class="keyword">new</span> String(cc);</span><br><span class="line">          File f2= <span class="keyword">new</span> File(dir,fileName);</span><br><span class="line">          RandomAccessFile randomWrite=<span class="keyword">new</span> RandomAccessFile(f2,<span class="string">"rw"</span>); </span><br><span class="line">          <span class="comment">//确定出文件f1中包含客户上传的文件的内容的最后位置，即倒数第6行</span></span><br><span class="line">          randomRead.seek(randomRead.length());</span><br><span class="line">          <span class="keyword">long</span> endPosition=randomRead.getFilePointer();</span><br><span class="line">          <span class="keyword">long</span> mark=endPosition;</span><br><span class="line">          <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span>((mark&gt;=<span class="number">0</span>)&amp;&amp;(j&lt;=<span class="number">6</span>)) &#123; </span><br><span class="line">              mark--;</span><br><span class="line">              randomRead.seek(mark);</span><br><span class="line">              n=randomRead.readByte();</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="string">'\n'</span>)&#123;</span><br><span class="line">                 endPosition=randomRead.getFilePointer();</span><br><span class="line">                 j++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//将randomRead流指向文件f1的第4行结束的位置</span></span><br><span class="line">          randomRead.seek(forthEndPosition);</span><br><span class="line">          <span class="keyword">long</span> startPoint=randomRead.getFilePointer();</span><br><span class="line">         <span class="comment">//从f1读出客户上传的文件存入f2（读取第4行结束位置和倒数第6行之间的内容）</span></span><br><span class="line">          <span class="keyword">while</span>(startPoint&lt;endPosition-<span class="number">1</span>)&#123;</span><br><span class="line">              n=randomRead.readByte();</span><br><span class="line">              randomWrite.write(n); </span><br><span class="line">              startPoint=randomRead.getFilePointer();</span><br><span class="line">          &#125;</span><br><span class="line">          randomWrite.close();</span><br><span class="line">          randomRead.close();</span><br><span class="line">          </span><br><span class="line">          fileBean.setMess(<span class="string">"上传成功"</span>); </span><br><span class="line">          fileBean.setFileName(fileName);   </span><br><span class="line">          f1.delete(); <span class="comment">//删除临时文件</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span>(Exception ee) &#123;</span><br><span class="line">          fileBean.setMess(<span class="string">"没有选择文件或上传失败"</span>); </span><br><span class="line">       &#125;</span><br><span class="line">      RequestDispatcher dispatcher=</span><br><span class="line">      request.getRequestDispatcher(<span class="string">"example8_6.jsp"</span>);</span><br><span class="line">      dispatcher.forward(request, response);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title">doGet</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line">      doPost(request,response);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>五、文件下载</strong></p>
<ul>
<li>JSP内置对象response调用方法getOutputStream()可以获取<br>一个指向用户的输出流，服务器将文件写入这个流，用户就<br>可以下载这个文件了。</li>
<li>当提供下载功能时，应当使用response对象向用户发送HTTP<br>头信息，这样用户的浏览器就会调用相应的外部程序打开下载的文件，response调用setHeader方法添加下载头的格式如<br>下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Content-disposition"</span>,<span class="string">"attachment;filename="</span>下载文件名<span class="string">");</span></span><br></pre></td></tr></table></figure></li>
<li>实例 例七</li>
</ul>
<p><strong>六、小结</strong></p>
<ul>
<li>输入流的指向称为源，程序从指向源的输入流中读取源中的<br>数据。而输出流的指向是数据要去的目的地，程序通过向输<br>出流中写入数据把信息送往目的地。</li>
<li>FileInputStream和FileReader流都顺序地读取文件，只要<br> 不关闭流，每次调用read方法就顺序地读取源中其余的内容， 直到源的末尾或流被关闭 。 二者的区别是，   FileInputStream 流以字节 （byte）为单位读取文件；   FileReader流以字符 （char）为单位读取文件。 </li>
<li>RandomAccessFile流的指向既可以作为源也可以作为目的<br>地，在读写文件时可以调用seek方法改变读写位置。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JSP/">JSP</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/05/28/jsp-study-5/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jsp-study-5">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-jsp-study-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/05/21/jsp-study-4/" class="article-date">
  	<time datetime="2020-05-21T12:39:22.000Z" itemprop="datePublished">2020-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/21/jsp-study-4/">
        jsp-study-4
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>MVC</strong><br><strong>MVC工作原理</strong><br>模型Model 用于存储数据的对象<br>视图View 向控制器提交所需数据 以及显示模型中的数据<br>控制器Controller 进行具体的业务逻辑操作</p>
<p>JSP+JavaBean+Servlet的MVC模式</p>
<p><strong>JSP中使用数据库<br>**一、概述</strong></p>
<ol>
<li>DBMS<br>DBMS是(Data Base Management System)的缩写，是管理数<br>据库软件的集合。<br>DBMS包含面向用户接口功能和面向系统维护功能。面向用户接口功能是提供用户访问数据库的一些必要手段。面向系统维护功能是为数据库管理者提供数据库的维护工具。<br>通常通过两层结构来访问数据库，称之为Client/Server结构。</li>
<li>关系型数据库<br>表是用两维关系来反映现实中的实体及它的属性。<br>表的每一列都代表了实体的一项属性。<br>每一列又叫表的一个字段。<br>每一个字段都有一个字段名。<br>每一个字段都只能包含同样数据类型的数据。<br>每一个字段长度是有限的。<br>表的每一行都代表实体的一个实例。</li>
</ol>
<p><strong>二、数据库系统-MySQL</strong><br>1.mysql<br>2.jdbc<br>JDBC（JavaDataBaseConnectivity）提供了访问数据库的API，即由一些Java类和接口组成，是Java运行平台的核心类库中的一部分。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我们经常使用JDBC进行如下的操作：</span><br><span class="line">1. 与一个数据库建立连接。</span><br><span class="line">2. 向已连接的数据库发送SQL语句。</span><br><span class="line">3. 处理SQL语句返回的结果。</span><br><span class="line"></span><br><span class="line">JDBC-API中重要的接口和类(java.sql包中)</span><br><span class="line"></span><br><span class="line">DriverManager类 依据数据库的不同,管理JDBC驱动</span><br><span class="line">Connection接口 负责连接数据库,并担任传送数据的任务</span><br><span class="line">Statement接口 由Connection产生,负责执行SQL语句</span><br><span class="line">PreparedStatement接口  创建一个可以编译的SQL语句对象,该对象可以被多次执行,以提高执行的效率</span><br><span class="line">ResultSet接口 负责保存Statement执行后所产生的查询结果</span><br></pre></td></tr></table></figure>
<p>JDBC工作原理<br><img src="/jsp-study-4/20200521092132447.png" alt=""><br>3.连接MySQL数据库</p>
<ul>
<li>加载驱动程序</li>
<li>建立连接<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">方式一</span><br><span class="line">try&#123;  </span><br><span class="line">    String uri= "jdbc:mysql://192.168.100.1:3306/warehouse";</span><br><span class="line">    String user ="root";</span><br><span class="line">    String password ="99";</span><br><span class="line">    con = DriverManager.getConnection(uri,user,password);</span><br><span class="line">&#125; catch(SQLExceptione)&#123;</span><br><span class="line">System.out.println(e);&#125;</span><br><span class="line"></span><br><span class="line">方式二</span><br><span class="line">try&#123;  </span><br><span class="line">String uri= </span><br><span class="line">" jdbc:mysql://192.168.100.1:3306/warehouse?user=root&amp;password=99";</span><br><span class="line">con = DriverManager.getConnection(uri);</span><br><span class="line">&#125;</span><br><span class="line">catch(SQLExceptione)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">如果root用户没有设置密码，那么将上述uri中的</span><br><span class="line">&amp;password=99</span><br><span class="line">更改为：</span><br><span class="line">&amp;password= </span><br><span class="line"></span><br><span class="line">方式三 指定字符集</span><br><span class="line">String uri = “jdbc:mysql://127.0.0.1/warehouse?”+</span><br><span class="line">"user=root&amp;password=99&amp;characterEncoding=gb2312";</span><br><span class="line">con=DriverManager.getConnection(uri);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.实例 连接 查询数据 显示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=gb2312"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.sql.*"</span> %&gt;</span><br><span class="line">&lt;HTML&gt;&lt;body bgcolor=#EEDDFF&gt;</span><br><span class="line"> &lt;% Connection con;</span><br><span class="line">    Statement sql; </span><br><span class="line">    ResultSet rs;</span><br><span class="line">    <span class="keyword">try</span>&#123;  Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">       out.println(<span class="string">"忘记把MySQL数据库的JDBC-数据库驱动程序复制到JDK的扩展目录中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; String uri= <span class="string">"jdbc:mysql://127.0.0.1/warehouse"</span>;</span><br><span class="line">          String user=<span class="string">"root"</span>;</span><br><span class="line">          String password=<span class="string">""</span>;</span><br><span class="line">          con=DriverManager.getConnection(uri,user,password);</span><br><span class="line">          <span class="comment">//也可以写成con=DriverManager.getConnection(uri+"?user=root&amp;password=");</span></span><br><span class="line">          sql=con.createStatement();</span><br><span class="line">          rs=sql.executeQuery(<span class="string">"SELECT * FROM product "</span>);</span><br><span class="line">          out.print(<span class="string">"&lt;table border=2&gt;"</span>);</span><br><span class="line">          out.print(<span class="string">"&lt;tr&gt;"</span>);</span><br><span class="line">            out.print(<span class="string">"&lt;th width=100&gt;"</span>+<span class="string">"产品号"</span>);</span><br><span class="line">            out.print(<span class="string">"&lt;th width=100&gt;"</span>+<span class="string">"名称"</span>);</span><br><span class="line">            out.print(<span class="string">"&lt;th width=50&gt;"</span>+<span class="string">"生产日期"</span>);</span><br><span class="line">            out.print(<span class="string">"&lt;th width=50&gt;"</span>+<span class="string">"价格"</span>);</span><br><span class="line">          out.print(<span class="string">"&lt;/TR&gt;"</span>);</span><br><span class="line">          <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            out.print(<span class="string">"&lt;tr&gt;"</span>);</span><br><span class="line">              out.print(<span class="string">"&lt;td &gt;"</span>+rs.getString(<span class="number">1</span>)+<span class="string">"&lt;/td&gt;"</span>); </span><br><span class="line">              out.print(<span class="string">"&lt;td &gt;"</span>+rs.getString(<span class="number">2</span>)+<span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">              out.print(<span class="string">"&lt;td &gt;"</span>+rs.getDate(<span class="string">"madeTime"</span>)+<span class="string">"&lt;/td&gt;"</span>); </span><br><span class="line">              out.print(<span class="string">"&lt;td &gt;"</span>+rs.getFloat(<span class="string">"price"</span>)+<span class="string">"&lt;/td&gt;"</span>);</span><br><span class="line">            out.print(<span class="string">"&lt;/tr&gt;"</span>) ; </span><br><span class="line">          &#125;</span><br><span class="line">          out.print(<span class="string">"&lt;/table&gt;"</span>);</span><br><span class="line">          con.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(SQLException e)&#123; </span><br><span class="line">          out.print(e);</span><br><span class="line">    &#125;</span><br><span class="line"> %&gt;</span><br><span class="line">&lt;/body&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
<p>5.查询记录<br>（1）结果集与查询</p>
<ul>
<li>让连接对象con调用方法createStatement()创建执行SQL语<br>句的Statement对象：Statement sql=con.createStatement();</li>
<li>sql对象就可以调用相应的方法，实现对数据库中表的查询<br>和修改，并将查询结果存放在一个ResultSet类声明的对象<br>中：ResultSetrs=sql.executeQuery(“SELECT * FROMproduct”);<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">返回类型 方法名称</span><br><span class="line">boolean next()</span><br><span class="line">byte getByte(int columnIndex) </span><br><span class="line">Date getDate(int columnIndex)</span><br><span class="line">double getDouble(int columnIndex) </span><br><span class="line">float getFloat(int columnIndex)</span><br><span class="line">int getInt(int columnIndex)</span><br><span class="line">long getLong(int columnIndex)</span><br><span class="line">String getString(int columnIndex)</span><br><span class="line">byte getByte(String columnName) </span><br><span class="line">Date getDate(String columnName)</span><br><span class="line">double getDouble(String columnName)</span><br><span class="line">float getFloat(String columnName)</span><br><span class="line">int getInt(String columnName)</span><br><span class="line">long getLong(String columnName)</span><br><span class="line">String getString(String columnName)</span><br></pre></td></tr></table></figure>
通过ResultSet接口中的getXxx()方法，可以取出数据，按类型取getInt、getString、getFloat…在开发中往往使用表格对数据显示进行处理<br>(2) 结果集的列名与列的数目 获得元数据<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">程序查询的时候，希望知道数据库表的字段（列）的名字以</span><br><span class="line">及表的字段的个数，那么一个办法是使用返回到程序中的结</span><br><span class="line">果集来获取相关的信息。</span><br><span class="line">(1)得到元数据对象metaData</span><br><span class="line">ResultSetMetaDatametaData=rs.getMetaData();</span><br><span class="line">(2)得到结果集的列的个数，即共有几列</span><br><span class="line">int columnCount=metaData.getColumnCount();</span><br><span class="line">(3)结果集rs中的第i列的名字：</span><br><span class="line">String columnName= metaData.getColumnName(i);</span><br></pre></td></tr></table></figure>
（3）随机查询<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用Result的next()方法顺序地查询数据，为了得到一个可</span><br><span class="line">滚动的结果集，必须使用下述方法先获得一个Statement对</span><br><span class="line">象：Statementstmt=con.createStatement(inttype,intconcurrency);</span><br><span class="line">然后，根据参数的type、concurrency的取值情况，stmt返</span><br><span class="line">回相应类型的结果集：</span><br><span class="line">ResultSetre=stmt.executeQuery(SQL语句)</span><br><span class="line"></span><br><span class="line">concurrency取值决定是否可以用结果集更新数据库</span><br><span class="line">ResultSet.CONCUR_READ_ONLY：</span><br><span class="line">不能用结果集更新数据库中的表。</span><br><span class="line">ResultSet.CONCUR_UPDATETABLE：</span><br><span class="line">能用结果集更新数据库中的表。</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">滚动查询经常用到ResultSet的下述方法：</span><br><span class="line">方法名 描述</span><br><span class="line">public booleanprevious() 将游标向上移动，当移到结果集第一行之前时返回</span><br><span class="line">false</span><br><span class="line">public  void beforeFirst() 将游标移动到结果集的初始位置，即在第一行之前</span><br><span class="line">public  void afterLast() 将游标移到结果集最后一行之后</span><br><span class="line">public  void first() 将游标移到结果集的第一行</span><br><span class="line">public  void last() 将游标移到结果集的最后一行</span><br><span class="line">public booleanisAfterLast() 判断游标是否在最后一行之后</span><br><span class="line">public booleanisBeforeFirst() 判断游标是否在第一行之前</span><br><span class="line">public booleanisFirst() 判断游标是否指向结果集的第一行</span><br><span class="line">public booleanisLast() 判断游标是否指向结果集的最后一行</span><br><span class="line">public  int getRow() 得到当前游标所指行的行号,行号从1开始，如果没有</span><br><span class="line">返回0</span><br><span class="line">public booleanabsolute(int  row) 将游标移到参数row指定的行号。如果row取负值，就</span><br><span class="line">是倒数的行数</span><br></pre></td></tr></table></figure>
（4）条件查询<br>（5）排序查询</li>
</ul>
<p>4.更新、添加、删除记录<br>5.用结果集操作数据库中的表<br>6.预处理语句 7.6 表单上传更新<br>javabean为什么那样写 是为了普适性<br>7.事务</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事务是保证数据库中数据完整性与一致性的重要机制。事务处理步骤如下：</span><br><span class="line">1．连接对象使用setAutoCommit(boolean autoCommit)方法,</span><br><span class="line">将参数autoCommit取值为false来关闭自动提交模式：</span><br><span class="line">con.setAutoCommit(false);</span><br><span class="line">2．commit()方法</span><br><span class="line">con调用commit()方法就是让事务中的SQL语句全部生效。</span><br><span class="line">3．rollback()方法</span><br><span class="line">只要事务中任何一个SQL语句没有生效,就抛出SQLException异常。在处</span><br><span class="line">理SQLException异常时,必须让con调用rollback()方法。</span><br></pre></td></tr></table></figure>
<p>8.数据库连接的常用方式<br>ODBC</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JSP/">JSP</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/05/21/jsp-study-4/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jsp-study-4">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-jsp-study-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/28/jsp-study-3/" class="article-date">
  	<time datetime="2020-04-28T09:20:54.000Z" itemprop="datePublished">2020-04-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/28/jsp-study-3/">
        jsp-study-3
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Java Servlet基础</strong><br><strong>一、Servlet概述</strong></p>
<ol>
<li>Servlet程序具备以下的基本功能<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取客户端HTML的FORM表单提交的数据和URL后面的参数信息</span><br><span class="line">创建和客户端的响应消息内容</span><br><span class="line">访问服务器端的文件系统</span><br><span class="line">连接数据库并开发基于数据库的应用</span><br><span class="line">调用其他JAVA类</span><br></pre></td></tr></table></figure></li>
<li>Servlet的特点</li>
</ol>
<p><strong>二、Servlet工作原理</strong></p>
<ol>
<li>Servlet的工作原理<br><img src="/jsp-study-3/20200428053235550.png" alt=""></li>
<li>Servlet引擎访问Servlet<br><img src="/jsp-study-3/20200428053321434.png" alt=""></li>
<li>Servlet的Service方法<br><img src="/jsp-study-3/20200428053436291.png" alt=""></li>
<li>Servlet生命周期<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建Servlet实例</span><br><span class="line">调用init方法进行初始化设置</span><br><span class="line">调用service方法处理浏览器请求</span><br><span class="line">调用destroy方法销毁Servlet实例并释放占用资源</span><br></pre></td></tr></table></figure></li>
<li>小结<br><img src="/jsp-study-3/20200428053727297.png" alt=""></li>
</ol>
<p><strong>三、Servlet的部署、创建与运行</strong><br>注意：这个地方教的是单独的servlet的处理</p>
<ol>
<li>编写一个创建Servlet对象的类<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编写javax.servlet.http包中的HttpServlet类的子类。</span><br><span class="line">将Tomcat子目录lib中的servlet-api.jar复制到Tomcat使用的JDK的扩展目录中，例如D:\jdk1.7\jre\lib\ext</span><br></pre></td></tr></table></figure>
<img src="/jsp-study-3/20200428054342940.png" alt=""></li>
<li>保存编译这个类所得到的字节码文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">保存到：\WEB-INF\classes\myservlet\control</span><br><span class="line">编译源文件：class&gt;javacmyservlet\control\Servlet源文件</span><br></pre></td></tr></table></figure></li>
<li>编写部署文件web.xml</li>
<li>运行Servlet<br><servlet-mapping>匹配规则：同一个servlet指定多个不同的url，四种不同的url形式<br><img src="/jsp-study-3/20200428055004944.png" alt=""></li>
<li>向Servlet传递参数</li>
</ol>
<p><strong>四、通过JSP页面访问servlet</strong><br>注意：不可以写成“/xxx”否则将变成请求root服务目录下的servlet</p>
<ol>
<li>通过表单向Servlet提交数据</li>
<li>通过超链接访问Servlet</li>
</ol>
<p><strong>五、共享变量</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet类是HttpServlet的子类，可以声明成员变量</span><br><span class="line">Servlet类的成员变量是被所有线程共享的数据</span><br></pre></td></tr></table></figure>
<p><strong>六、doGet和doPost方法</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Servlet类中重写doPost()或doGet()方法来响应用户的请求</span><br><span class="line">如果不同请求类型进行相同的处理，可在doGet()中调用有处理过程的doPost()方法，反之一样</span><br><span class="line">如果不同请求类型进行不同的处理，需在两个方法中编写不同的处理过程</span><br></pre></td></tr></table></figure>
<p><strong>七、重定向与转发</strong></p>
<ol>
<li>请求转发<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">得到RequestDispatcher对象</span><br><span class="line">Request Dispatcherdispatcher = request.getRequestDispatcher("a.jsp");</span><br><span class="line">转发</span><br><span class="line">dispatcher.forward(request,response);</span><br><span class="line"></span><br><span class="line">RequestDispatcher.forward方法只能在同一个Web应用程序内的资源之间转发请求</span><br></pre></td></tr></table></figure></li>
<li>重定向<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重定向</span><br><span class="line">response.sendRedirect("a.jsp");</span><br><span class="line"></span><br><span class="line">sendRedirect方法还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源</span><br></pre></td></tr></table></figure>
<img src="/jsp-study-3/20200428061112216.png" alt=""></li>
</ol>
<p><strong>JSP与Javabean</strong><br><strong>一、概述与工作原理</strong></p>
<ol>
<li>概述<br>感觉是service + dao + domain<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaBean是一个可重复使用的软件组件</span><br><span class="line">是遵循一定标准、用Java语言编写的一个类</span><br><span class="line">一般实现网页中的业务逻辑或数据库操作</span><br></pre></td></tr></table></figure></li>
<li>Javabean特点<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以实现代码的重复利用</span><br><span class="line">易编写、易维护、易使用</span><br><span class="line">跨平台</span><br></pre></td></tr></table></figure></li>
<li>JavaBean工作原理</li>
</ol>
<p><strong>二、编写Javabean和使用Javabean</strong></p>
<ol>
<li>编写Javabean<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果类的成员变量的名字是xxx，类中提供两个方法：</span><br><span class="line">    getXxx() 用来获取属性xxx</span><br><span class="line">    setXxx() 用来修改属性xxx</span><br><span class="line">对于boolean类型的成员变量，允许使用“isXxx”</span><br><span class="line">类中声明的方法的访问属性都必须是public的。</span><br><span class="line">类中声明的构造方法必须是public、无参数的。</span><br></pre></td></tr></table></figure></li>
<li>Bean字节码的保存<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①在当前Web服务目录下建立如下目录结构：</span><br><span class="line">    Web服务目录\WEB-INF\classes</span><br><span class="line">②根据类的包名，在目录classes下建立相应的子目录：</span><br><span class="line">    Web服务目录\WEB-INF\classes\tom\jiafei</span><br><span class="line">③将Bean字节码保存在相应的子目录.</span><br></pre></td></tr></table></figure></li>
<li>使用Javabean<br><img src="/jsp-study-3/20200428062844916.png" alt=""></li>
</ol>
<p><strong>注意bean名由id标识</strong><br>4. Bean的加载原理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当JSP页面使用JSP需要使用一个bean时，JSP引擎将首先根据JSP动作标记给出的bean的id,以及scope，查找JSP引擎内置pageContent对象中是否含有这样的bean，如果这样的bean存在，JSP引擎就分配这样的bean给用户。</span><br><span class="line"></span><br><span class="line">如果在pageContent中没有查找到JSP动作标记要求的bean，就根据class指定的字节码创建一个JSP动作标记要求的bean，并将所创建的bean添加到pageContent内置对象中。</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>Bean的有效范围（生命周期）<br>scope取值范围给出了bean的存活时间(生命周期)，即scope取值决定了JSP引擎分配给用户的bean的存活时间。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">page</span><br><span class="line">有效范围是当前页面.不同用户的scope取值是page的bean也是互不相同的.</span><br><span class="line">request</span><br><span class="line">bean的有效范围是request期间。不同用户的scope取值是request的bean也是互不相同的</span><br><span class="line">session</span><br><span class="line">有效范围是用户的session(会话)期间。不同用户(即不同浏览器)的scope取值是session的bean是互不相同的（占有不同的内存空间）</span><br><span class="line">application</span><br><span class="line">bean的有效范围是application期间。JSP引擎为Web服务目录下所有的JSP页面分配一个共享的bean，不同用户的scope取值是application的bean也都是相同的一个</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、获取和修改bean的属性</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以使用动作标记getProperty、setProperty；</span><br><span class="line">必须保证bean有相应的getXxx和setXxx方法；</span><br><span class="line">在程序片中直接用bean调用方法就不需要方法命名遵守getXxx和setXxx规则</span><br></pre></td></tr></table></figure>
<ol>
<li>getProperty动作标记<br><img src="/jsp-study-3/20200428065630306.png" alt=""></li>
<li>setProperty动作标记<br>使用setProperty动作标记可以设置bean的属性值。使用这个标记之前，必须使用useBean标记得到一个相应的bean。<br>（1）将bean属性的值设置为一个表达式的值或字符串<br><img src="/jsp-study-3/20200428065908555.png" alt=""><br><img src="/jsp-study-3/20200428070015639.png" alt=""></li>
</ol>
<p><strong>id就是bean的名字</strong><br>（2）通过HTTP表单的参数的值来设置bean的相应属性的值<br><img src="/jsp-study-3/20200428070055187.png" alt=""></p>
<p><strong>四、bean的辅助类</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JSP/">JSP</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/04/28/jsp-study-3/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jsp-study-3">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-jsp-study-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/21/jsp-study-2/" class="article-date">
  	<time datetime="2020-04-21T08:21:17.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/jsp-study-2/">
        jsp-study-2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>第三章 JSP内置对象</strong><br><strong>概述</strong><br>有些对象不用声明就可以在JSP页面的Java程序片和表达式部分使用，这就是JSP的内置对象。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  变量名		                真实类型		        	作用</span><br><span class="line">* pageContext		        PageContext			当前页面共享数据，还可以获取其他八个内置对象</span><br><span class="line">* request			HttpServletRequest		一次请求访问的多个资源(转发)</span><br><span class="line">* session			HttpSession			一次会话的多个请求间</span><br><span class="line">* application		        ServletContext			所有用户间共享数据</span><br><span class="line">* response			HttpServletResponse		响应对象</span><br><span class="line">* page				Object				当前页面(Servlet)的对象  this</span><br><span class="line">* out				JspWriter			输出对象，数据输出到页面上</span><br><span class="line">* config			ServletConfig			Servlet的配置对象</span><br><span class="line">* exception			Throwable			异常对象</span><br></pre></td></tr></table></figure>
<p><strong>一、request 对象</strong></p>
<ul>
<li>HTTP通信协议是用户与服务器之间一种提交( 请求)信息与响应信息(request/response)的通信协议。</li>
<li>在JSP中，内置对象request封装了用户提交的信息，那么该对象调用相应的方法可以获取封装的信息，即使用该对象可以获取用户提交的信息。</li>
</ul>
<p>1.获取用户提交的信息<br>JSP页面可以让request对象使用getParameter(String s)方法获取表单提交的信息。<br>2.处理中文字符编码<br>使用两种方式避免request对象获取的信息出现乱码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1．对信息重新编码</span><br><span class="line">    request将获取的信息重新编码，即用ISO-8859-1进</span><br><span class="line">    行编码，并将编码存放到一个字节数组中，然后再将这</span><br><span class="line">    个数组转化为字符串。如下列所示：</span><br><span class="line">    Stringstr=request.getParameter("message");</span><br><span class="line">    byteb[]=str.getBytes("ISO-8859-1");</span><br><span class="line">    str=newString(b);</span><br><span class="line">2．request设置编码</span><br><span class="line">    request在获取信息之前使用setCharacterEncoding</span><br><span class="line">    方法设置自己的编码为gb2312：</span><br><span class="line">    request.setCharacterEncoding("gb2312");</span><br></pre></td></tr></table></figure>
<p>3.常用方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getProtocol() 获取用户向服务器提交信息所使用的通信协议，比如http/1.1等。</span><br><span class="line">getServletPath() 获取用户请求的JSP页面文件的目录。</span><br><span class="line">getContextPath()获取用户请求的当前Web服务目录。</span><br><span class="line">getRemoteAddr() 获取用户的IP地址。</span><br><span class="line">getRemoteHost() 获取用户机的名称（如果获取不到，就获取IP地址）。</span><br><span class="line">getServerName() 获取服务器的名称。</span><br><span class="line">getServerPort() 获取服务器的端口号。</span><br></pre></td></tr></table></figure>
<p>4.处理HTML标记<br>5.处理超链接<br><strong>二、response 对象</strong></p>
<ul>
<li>当用户访问一个服务器的页面时，会提交一个HTTP请求，服务器收到请求时，返回HTTP响应。响应和请求类似，也有某种结构，每个响应都由状态行开始，可以包含几个头及可能的信息体（网页的结果输出部分）。</li>
<li>与request对象相对应的对象是response对象。可以用response对象对用户的请求作出动态响应，向用户端发送数据。比如，当一个用户请求访问一个JSP页面时，该页面用page指令设置页面的contentType属性的值是text/html，那么JSP引擎将按着这种属性值响应用<br>户对页面的请求，将页面的静态部分返回给用户，用户浏览器接收到该响应就会使用HTML解释器解释执行所收到的信息。</li>
</ul>
<p>1.动态响应contentType属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于page指令只能为contentType指定一个值来决定响应的MIME类型，如果想动态的改变这个属性的值来响应用户，就需要使用response对象的setContentType(String s)方法来改变contentType的属性值，该方法中的参数s可取值：text/html、text/plain、image/gif等</span><br><span class="line">当用setContentType方法动态改变了contentType的属性值，即响应的MIME类型，JSP引擎就会按着新的MIME类型将JSP页面的输出结果返回给用户.</span><br></pre></td></tr></table></figure>
<p>2.response的HTTP文件头</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应也包括一些头。response对象可以使用方法addHeader(String head,Stringvalue);或setHeader(Stringhead,Stringvalue)动态添加新的响应头和头的值，将这些头发送给用户的浏览器。如果添加的头已经存在，则先前的头被覆盖。</span><br></pre></td></tr></table></figure>
<p>3.response重定向</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">某些情况下，当响应用户时，需要将用户重新引导至另一个页面。例如，如果用户输入的表单信息不完整，就会再被引导到该表单的输入页面。</span><br><span class="line">可以使用response的sendRedirect(URL url)方法实现用户的重定向。</span><br></pre></td></tr></table></figure>
<p>4.response的状态行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当服务器对用户请求进行响应时,它发送的首行称为状态行。</span><br><span class="line">1yy (１开头的３位数)：主要是实验性质的。</span><br><span class="line">2yy：用来表明请求成功的，例如，状态代码200可以表明已成功取得了请求的页面。</span><br><span class="line">3yy：用来表明在请求满足之前应采取进一步的行动。</span><br><span class="line">4yy：当浏览器做出无法满足的请求时，返回该状态代码，例如404表示请求的页面不存在</span><br><span class="line">5yy：用来表示服务器出现问题。例如，500说明服务器内部发生错误。</span><br><span class="line">一般不需要修改状态行，在出现问题时，服务器会自动响应，发送相应的状态码。</span><br><span class="line">我们也可以使用response对象的setStatus(int n)方法来改变响应的状态行的内容</span><br></pre></td></tr></table></figure>
<p><img src="/jsp-study-2/20200421045448831.png" alt=""><br><strong>三、session对象</strong></p>
<ul>
<li>HTTP协议是一种无状态协议。一个用户向服务器发出请求（request），然后服务器返回响应（response），在服务器端不保留连接的有关信息，因此当下一次连接时，服务器已没有以前的连接信息了，无法判断这一次连接和以前的连接是否属于同一用户。</li>
<li>当一个用户访问一个Web服务目录时，可能会在这个服务目录的几个页面反复连接、反复刷新一个页面或不断地向一个页面提交信息等，服务器应当通过某种办法知道这是同一个用户。</li>
<li>Tomcat服务器可以使用内置session对象（会话）记录有关连接的信息。</li>
</ul>
<p>1.session对象的id</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.session对象被分配了一个String类型的id号，Tomcat服务器同时将这个id号发送到用户端，存放在用户的Cookie中。这样，session对象和用户之间就建立起一一对应的关系，即每个用户都对应着一个session对象（称作用户的会话），不同用户的session对象互不相同，具有不同的id号码。</span><br><span class="line">2.简单地说，用户在访问一个Web服务目录期间，服务器为该用户分配一个session对象（称作用户的会话），服务器可以在各个页面使用这个session记录当前用户的有关信息。而且服务器保证不同用户的session对象互不相同。</span><br></pre></td></tr></table></figure>
<p>2.session对象与URL重写</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果用户不支持Cookie，JSP页面可以通过URL重写来实现session对象的唯一性。所谓URL重写，就是当用户从一个页面重新连接到一个页面时，通过向这个新的URL添加参数，把session对象的id传带过去，这样就可以保障用户在该网站各个页面中的session对象是完全相同的。</span><br><span class="line"></span><br><span class="line">可以使用response对象调用encodeURL()或encodeRedirectURL（）方法实现URL重写。</span><br></pre></td></tr></table></figure>
<p>3.session对象存储数据</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session对象驻留在服务器端，该对象调用某些方法保存用户在访问某个web服务目录期间的有关数据。</span><br><span class="line">session对象使用下列方法处理数据：</span><br><span class="line">1.publicvoidsetAttribute(String key,Object obj)</span><br><span class="line">session对象可以调用该方法将参数Object指定的对象obj添加到session对象中，并为添加的对象指定了一个索引关键字。</span><br><span class="line">2.publicObjectgetAttribute(Stringkey)</span><br><span class="line">获取session对象索引关键字是key的对象。</span><br></pre></td></tr></table></figure>
<p>4.session对象的生存期限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session对象的生存期限依赖于session对象是否调用invalidate()方法使得session无效或session对象达到了设置的最长的“发呆”状态时间以及是否关闭服务器。</span><br><span class="line">如果关闭服务器，那么用户的session消失，所谓“发呆”状态时间是指用户对某个Web服务目录发出的两次请求之间的间隔时间（默认的发呆时间是30分钟）。</span><br></pre></td></tr></table></figure>
<p>5.application对象<br>application由服务器负责创建，每个Web服务目录下的application对象被访问该服务目录的<br>所有的用户共享，但不同Web服务目录下的application互不相同。<br>application 对象的常用方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)publicvoidsetAttribute(String key,Object obj)</span><br><span class="line">application对象可以调用该方法将参数Object指定的对象obj添加到application对象中，并为添加的对象指定了一个索引关键字。</span><br><span class="line">(2)publicObjectAttribute(Stringkey)</span><br><span class="line">获取application对象含有的关键字是key的对象。</span><br></pre></td></tr></table></figure>
<p><strong>五、out 对象</strong><br>out对象是一个输出流，用来向用户端输出数据。在前面的许多例子里曾多次使用out对象进行数据的输出。out对象可调用如下的方法用于各种数据的输出：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out.print(char)， out.println(char)     </span><br><span class="line">out.print(double)， out.println(double)  </span><br><span class="line">out.print(fload)， out.println(float)     </span><br><span class="line">out.print(long)， out.println(long)       </span><br><span class="line">out.print(String)， out.println(String)   </span><br><span class="line">out.newLine() , out.flush()</span><br></pre></td></tr></table></figure>
<p><strong>六、总结</strong><br>➢HTTP通信协议是用户与服务器之间一种提交（请求）信息与响应信息（request/response）的通信协议。在JSP中，内置对象request封装了用户提交的信息，request对象获取用户提交信息的最常用的方法是getParameter(String s)；内置对象response对象对用户的请求作出动态响应，向用户端发送数据。<br>➢HTTP协议是一种<strong>无状态协议</strong>。一个用户向服务器发出请求（request），然后服务器返回响应（respons），但不记忆连接的有关信息。所以，Tomcat服务器必须使用内置session对象（会话）记录有关连接的信息。同一个用户在某个Web服务目录中的session是相同的；同一个用户在不同的Web服务目录中的session是互不相同的；不同用户的session是互不相同的。<br>➢一个用户在某个Web服务目录的<strong>session对象的生存期限依赖于用户是否关闭浏览器、session对象是否调用invalidate()方法使得session无效或session对象是否达到了设置的最长的“发呆”状态时间</strong>。<br>➢内置对象application由服务器负责创建，每个Web服务目录下的application对象被访问该服务目录的所有用户共享；不同Web服务目录下的application互不相同。<br><strong>七、问题解决</strong></p>
<ol>
<li>iso-8859-1与gb2312与utf8<br>参考<a href="https://zhidao.baidu.com/question/26613602.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/26613602.html</a><br><a href="https://www.cnblogs.com/x_wukong/p/3675832.html" target="_blank" rel="noopener">https://www.cnblogs.com/x_wukong/p/3675832.html</a><br>可得结论：设置utf-8/ gbk2312为jsp charset且确定其request response字符集为utf-8/ gbk2312时，中文英文都不会有问题，意思就是在charset与必须手动设置的编码格式统一下，utf-8 gbk2312皆可正确处理所有字符，若没有手动设置，必须将传入的iso请求编码成iso，这关系就像gbk2312 utf-8可单向转成iso 而iso不能转成另两种处理，必须单独编码处理。</li>
<li>各种内置对象的生命周期</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JSP/">JSP</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/04/21/jsp-study-2/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="jsp-study-2">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-block_paper_2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/03/block_paper_2/" class="article-date">
  	<time datetime="2020-04-02T23:59:04.000Z" itemprop="datePublished">2020-04-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/03/block_paper_2/">
        block_paper_2
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 注意查 许可区块链</span><br></pre></td></tr></table></figure>
<p><strong>HyperledgerFabric：用于许可区块链的分布式操作系统</strong><br><strong>摘要</strong><br>Fabric是一个<strong>模块化和可扩展</strong>的开源系统，用于部署和操作许可区块链，是Linux基金会（<a href="http://www.hyperledger.org）托管的Hyperledger项目之一。" target="_blank" rel="noopener">www.hyperledger.org）托管的Hyperledger项目之一。</a><br>Fabric是用于<strong>运行分布式应用程序的第一个真正可扩展的区块链系统</strong>。它支持<strong>模块化共识协议</strong>，该协议允许系统针对特定用例和信任模型进行定制。 Fabric也是第一个<strong>运行以标准通用编程语言编写的分布式应用程序的区块链系统</strong>，而<strong>无需依赖系统性的native加密货币</strong>。这与现有的区块链平台形成鲜明对比，现有的区块链平台要求以领域特定的语言或依赖加密货币来编写“智能合约”。 Fabric使用<strong>可移植的成员身份概念来实现许可模型</strong>，该成员身份可以与行业标准的身份管理集成在一起。为了支持这种灵活性，Fabric引入了一种全新的区块链设计，并改进了区块链应对非确定性，资源枯竭和性能攻击等问题的方式。<br>本文介绍了Fabric的架构，各种设计决策的基本原理，其最突出的实现方面以及其<strong>分布式应用程序编程模型</strong>。我们通过实现和基准化受比特币启发的数字货币来进一步评估Fabric。我们证明，在某些流行的部署配置中，Fabric可以实现每秒3500多个端到端事务的吞吐量，而亚秒级的延迟可以很好地扩展到100多个节点。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: peers 译为客户端即可 此处翻译成了对等方 对等端 为统一，先用notepad替换一下 但为了省事，译为节点</span><br></pre></td></tr></table></figure>
<p><strong>一、介绍</strong><br>区块链可以定义为用于记录交易的不可变分类账，并在相互不信任的节点组成的分布式网络中维护。每个节点都维护一个分类帐的副本。节点执行共识协议以验证交易，将交易分组为块，并在这些块上构建哈希链。该过程通过对交易进行排序（ordering the transactions）来形成分类帐，这是保持一致性所必需的。区块链随比特币一起出现，被广泛认为是在数字世界中运行可信交易所的技术。<br>在公共或未经许可的区块链中，任何人都可以在没有特定身份的情况下参与。公共区块链通常涉及native加密货币，并使用基于“工作量证明”（PoW）和经济激励措施的共识。而<strong>许可区块链在一组已知的，已认证的参与者之间运行一个区块链</strong>。<strong>许可区块链提供了一种方法来保证一组具有共同目标但彼此之间并不完全信任的实体之间的交互的安全性</strong>，例如交易资金，商品或信息的企业。通过依靠peers的身份，许可区块链可以使用传统的拜占庭容错（BFT）共识。<br>区块链可以以智能合约的形式执行任意的，可编程的交易逻辑，如以太坊那样。比特币中的脚本是该概念的前身。智能合约充当可信任的分布式应用程序，并从区块链和基本共识中获得peers间的安全性。这非常类似于使用<strong>状态机复制（SMR）</strong>构建弹性应用程序的著名方法。然而，区块链与传统的SMR不同，有着<strong>拜占庭式的缺陷</strong>，主要表现在：（1）不仅有一个，而是有许多分布式应用程序同时运行；（2）应用程序可能被动态部署或被任何人部署；（3）应用程序代码不可信，甚至可能是恶意的。这些差异需要新的设计。<br>许多现有的智能合约区块链遵循SMR的蓝图，并实现所谓的<strong>主动复制</strong>：一个用于共识或原子广播的协议首先排序事务并将其传播到所有peers；其次，每个peer依次执行事务。我们称之为<strong>order execute（排序执行）架构</strong>；它要求所有peers执行每个事务，并且所有事务都是确定性的。顺序执行架构可以在几乎所有现有的区块链系统中找到，从以太坊（基于PoW的共识）等公共区块链系统到Tendermint、Chain和Quorum等每一个被授权区块链系统（基于BFT的共识）。虽然顺序执行设计在所有系统中并不明显，因为附加事务验证步骤可能会使其模糊，但它的局限性是固有的：每个peer执行每个事务，并且事务必须是确定的。<br>先前的许可区块链受到许多限制，这些限制通常来自于它们的无许可的relatives或使用顺序执行体系结构。特别地：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps: order-execute architecture 应为排序执行(order-execute )架构，此处均错误翻译成订单执行架构，为统一，先用notepad替换一下 再把word里全部替换</span><br><span class="line">此处的执行事务即验证事务，验证交易</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">共识机制被硬编码到平台中，这与公认的理解是矛盾的，即应当没有“一刀切”的共识协议。</span><br><span class="line">交易验证的信任模型需要共识机制确认，并且不能适应智能合约的要求；</span><br><span class="line">智能合约必须以固定的，非标准的或特定领域的语言编写，这影响了其广泛的适用性并可能导致编程错误。</span><br><span class="line">所有peers顺序执行所有事务会限制性能，并且需要采取复杂的措施来防止源自不受信任合同的针对平台的服务dos攻击(denial-of-service attacks)（例如，以太坊中的gas机制）；</span><br><span class="line">事务必须是确定性的，这可能很难以编程方式确保；</span><br><span class="line">每个智能合约都在所有peers上运行，这与机密性不符，并且禁止将合约代码和状态散布给peers的子集。</span><br></pre></td></tr></table></figure>
<hr>
在本文中，我们描述了Hyperledger Fabric或简称Fabric，它是克服了这些限制的开源区块链平台。Fabric是Linux Foundation主持下的Hyperledger项目之一。在不同的行业和用例中，Fabric用于400多个原型，概念验证以及生产分布式账本系统中。这些用例包括但不限于诸如分歧解决，贸易物流，外汇结算，食品安全，合同管理，钻石产地，奖励积分管理，低流动性证券交易和结算，身份管理以及通过数字结算的领域货币。
Fabric引入了一种新的区块链架构，旨在实现弹性，灵活性，可扩展性和保密性。Fabric被设计为模块化和可扩展的通用许可区块链，是第一个支持执行以标准编程语言编写的分布式应用程序的区块链系统，从而使它们可以在多个节点上一致地执行，给人一种在单一的全球分布的区块链计算机上执行的印象。这使得Fabric成为**许可区块链的第一个分布式操作系统**。
Fabric的体系结构遵循一种**新颖的execute-order-validate范式**，用于在不可信untrusted环境中分布式执行不可信代码。它将交易流程分为**三个步骤**，可以在系统中的不同实体上运行：（1）执行交易并检查其正确性，从而认可交易（对应于其他区块链中的“交易验证”）；（2）通过共识协议进行排序，而与交易语义无关；（3）根据特定应用程序的信任假设进行交易验证，这也防止了由于并发引起的竞争情况。此设计与顺序执行范式完全不同，Fabric通常会在达成最终一致的排序之前执行（验证）交易。它结合了两种众所周知的复制方法，即被动复制和主动复制，如下所示。
首先，Fabric使用被动或主备份复制[21,27]，这种复制在分布式数据库中很常见，但是具有基于中间件的不对称更新处理[40,41]，并被移植到具有拜占庭式错误的不受信任的环境中。在Fabric中，每个事务仅由peers的一个子集（即部分peers）执行，这允许并行执行并利用“执行-验证” BFT复制来解决潜在的不确定性[37]。灵活的背书策略指定了哪个或哪些peers需要保证已正确执行给定的智能合约。
其次，Fabric包含主动复制，因为在每个peer分别执行的确定性验证步骤中，交易对账本状态的影响只有在它们之间的总顺序达成共识后才会写入。这使Fabric可以根据交易背书遵守特定应用程序的信任假设。而且，将状态更新的顺序委托给用于共识（即原子广播）的模块化组件，该组件是无状态的，并且与**执行事务并维护分类帐的对等方在逻辑上是分离**的。由于共识是模块化的，因此可以根据特定部署的信任假设量身定制其实现。尽管也可以使用区块链对等体来实现共识，但两个角色的分离增加了灵活性，并允许人们依靠完善的工具包进行CFT（崩溃容错）或BFT排序。
总的来说，这种混合复制设计在拜占庭模型中混合了被动复制和主动复制，以及执行排序验证范式，代表了Fabric体系结构的主要创新。他们解决了前面提到的问题，并为Fabric可伸缩系统提供了支持``可靠信任''假设的受许可区块链。为实现此体系结构，Fabric为以下每个组件都包含模块化构件：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•排序服务自动向peers广播状态更新，并就交易顺序建立共识。</span><br><span class="line">•成员资格服务提供者负责将peer与加密身份相关联。它保持了Fabric的许可性质。</span><br><span class="line">•可选的peer-to-peer gossip服务通过向所有peers进行排序服务来分发区块输出。</span><br><span class="line">•Fabric中的智能合约在容器环境中运行以进行隔离。它们可以用标准编程语言编写，但不能直接访问分类账状态。</span><br><span class="line">•每个peer以仅追加区块链的形式本地维护分类账，并将其作为键值存储中最新状态的快照。</span><br></pre></td></tr></table></figure>
本文的其余部分描述了Fabric的体系结构以及我们的经验。第2节总结了现有技术，并解释了各种设计决策背后的原理。第3节详细介绍了Fabric的体系结构和执行排序验证方法，说明了事务执行流程。在第4节中，特别定义了Fabric的关键组件，包括排序服务，成员服务，点对点gossip，分类帐数据库和智能合约API。在第5节中给出了在商品公共云VM上的集群和WAN环境中部署的具有比特币启发式加密货币的Fabric性能评估中获得的结果和见解。它们显示，Fabric在流行的部署配置中实现了3500 tps以上的吞吐量，以几百毫秒的延迟实现了[nality] [57]，并且可以很好地扩展到100多个peers。在第6节中，我们讨论了Fabric的一些实际生产用例。最后，第7节讨论了相关工作。
**二、背景**
**1. 区块链的顺序执行架构**
以前所有的区块链系统（无论是否许可）都遵循排序执行架构。这意味着区块链网络首先**使用共识协议对交易进行排序**，然后**在所有peers上按相同顺序执行（验证）它们**。
例如，基于PoW的无权限区块链如以太坊将结合共识和执行交易如下：（1）每个peer（即参与共识的节点）将一个包含有效事务的块组合在一起（为了确定有效性，该peer已经预先执行了这些事务）；（2）peer试图解决PoW难题；（3）如果其中有一个peer很幸运并且解决了难题，则它通过gossip协议将该块传播到网络；（4）收到该区块的每个peer均会验证难题的解决方案以及该区块中的所有交易。实际上(effectively)，每个peer都会从第一步开始重复解决了Pow的peer的执行（验证）过程。此外，所有peers都顺序执行事务（在一个块内和跨块）。排序执行架构如图1所示。
![](/block_paper_2/20200404075739094.png)
**2. 排序执行的局限性**
排序执行架构在概念上很简单，因此也被广泛使用。但是，当在通用的许可区块链中使用时，它有几个缺点。接下来我们讨论最重要的三个：
**排序执行**
在所有peers上顺序执行交易会**限制区块链可以实现的有效吞吐量**。特别是，由于吞吐量与执行延迟成反比例，因此这可能成为除最简单的智能合约之外的所有智能合约的性能瓶颈。此外，回想一下，与传统的SMR相比，区块链形成了通用计算引擎，其**有效载荷应用程序可能会被对手部署**。denial-of-service（DoS）攻击会严重降低此类区块链的性能，可能只是引入智能合约就需要花费很长时间才能执行。例如，执行无限循环的智能合约具有致命错误，但由于无法解决停止问题而无法自动检测到。
为了解决这个问题，使用加密货币的公共可编程区块链会承担执行成本。例如，以太坊引入了交易执行所消耗的gas的概念，该概念将gas price转换为数字加密货币的成本，并记入交易提交者的账单中。 以太坊在支持这一概念方面做了很多工作，为每个级别的计算步骤分配了成本，引入了自己的虚拟机来控制执行。虽然这似乎是公共区块链的可行解决方案，但对于没有native加密货币的通用系统来说，这在许可模型中是不够的。
有关分布式系统的文献提出了许多方法来改进与顺序执行相比的性能，例如通过不相关操作的并行执行。不幸的是，这些技术仍有待于在智能合约的区块链环境中成功应用。例如，有一个挑战是，需要确定地推断智能合约的所有依赖项，这在与可能的一致性约束结合时尤其具有挑战性。此外，这些技术对于对抗来自不可信开发人员合约代码的DoS攻击毫无帮助。
**非确定性代码**
排序执行体系结构的另一个重要问题是不确定性事务。在active（主动）SMR中达成共识后执行的操作必须是确定性的，否则分布式账本会“分叉”并违反区块链的基本前提，即所有peers都处于同一状态。这通常可以通过使用领域特定语言对区块链进行编程来解决（例如，以太坊Solidity）足以表达其应用，但仅限于确定性执行。但是，此类语言很难为实现者设计，并且需要程序员进行其他学习。相反，用通用语言（例如Go，Java，C / C ++）**编写智能合约会吸引更多人，并加速采用区块链解决方案**。
不幸的是，**通用语言给确定性执行带来了许多问题**。即使应用程序开发人员没有明显引入不确定性的操作，隐藏的实现细节也可能具有相同的破坏性影响（例如，在Go中amap迭代器不是确定性的）。更糟糕的是，在区块链上，创建确定性应用程序的负担落在了潜在的不受信任的程序员身上。仅创建一个带有恶意意图的非确定性合同就足以使整个区块链陷入停顿。此外，还研究了区块链上过滤器分散操作的模块化解决方案，但在实践中成本高昂。
**执行的机密性**
根据public blockchain的蓝图，许多许可的系统在所有对等点上运行所有智能合约。但是，**许可的区块链的许多预期用例都需要保密**，即可以限制对智能合约逻辑，交易数据或分类帐状态的访问。尽管从数据加密到先进的零知识证明[18]和可验证计算[42]等加密技术可以帮助实现一致性，但这通常会带来相当大的开销，在实践中不可行。
幸运的是，它将相同状态传播给所有peers，而不是在任何地方运行相同的代码。因此，可以将智能合约的执行限制为该任务所信任的peers的子集（部分peers），该子集保证执行的结果。这种设计从主动复制转向被动复制的变体[21]，适应了区块链的信任模型。
**3. 现有架构的其他限制**
**固定信任模型**
大多数获得许可的区块链都依赖于异步BFT复制协议来建立共识[57]。这样的协议通常基于一个安全假设，即在n > 3f个对等节点中，最多可以容忍f的不当行为并表现出所谓的拜占庭式错误[20]。同样的peers也经常在相同的安全性假设下执行应用程序（即使实际上可以将BFT执行限制为更少的peers）[59]。但是，无论peers在系统中的角色如何，这种量化的信任假设都可能与智能合约执行所需的信任不匹配。在灵活的系统中，**不应将应用程序级别的信任固定为协议级别的信任**。通用区块链应将这两个假设解耦，并允许应用程序具有灵活的信任模型。
**硬编码的共识**
Fabric是引入**可插拔共识**的第一个区块链系统。在使用Fabric之前，几乎所有的区块链系统（无论是否为许可链）都带有硬编码的共识协议。但是，数十年来对共识协议的研究表明，**没有这样的“一刀切”的解决方案**。例如，当部署在潜在的对抗环境中时，**BFT协议的性能差异很大**[52]。具有“链式”通信模式的协议在具有对称和同质链接的LAN群集上表现出可证明的最佳吞吐量[34]，但在广域异构网络上性能严重下降。此外，在给定部署中，诸如负载，网络参数以及实际故障或攻击之类的外部条件可能会随时间而变化。由于这些原因，BFT共识**应该具有固有的可重构性，并且理想地动态地适应不断变化的环境**[17]。另一个重要的方面是将**协议的信任假设与给定的区块链部署方案**相匹配。确实，人们可能想用基于替代信任模型的协议（例如XFT [43]）或CFT协议（例如Paxos / Raft [45]和ZooKeeper [36]）甚至是无许可协议替换BFT共识。
**4. 排序执行区块链的经验**
在实现Fabric的执行排序验证架构之前，我们获得了在排序执行模型中使用PBFT [26]构建许可区块链平台的经验。也就是说，Fabric的**早期版本**（2016年9月发布的v0.6之前的版本）是按照“传统”排序执行架构进行架构的。
从许多概念证明应用中获得的反馈来看，这种方法的局限性立即变得很明显。例如，用户经常在不同的peers观察到不同的状态，并重新报告了共识协议中的错误。在所有情况下，仔细检查后发现，罪魁祸首是不确定的事务代码。其他原因涉及性能有限，例如“每秒仅进行一次事务处理”，用户承认其平均事务处理需要200毫秒才能执行。我们已经了解到，区块链系统的关键属性（即一致性，安全性和性能）一定不能取决于其用户的知识和信誉，尤其是因为区块链应该在不可信的环境中运行。
**三、架构**
在本节中，我们介绍三阶段（three-phase）的执行排序验证架构，然后说明事务流程。
**1. Fabric概述**
Fabric是用于许可区块链的分布式操作系统，该操作系统执行以通用编程语言（例如Go，Java，Node.js）编写的分布式应用程序。它在只追加复制的分类账数据结构中安全地跟踪其执行历史，并且没有内置加密货币。
Fabric引入了执行排序验证区块链架构（如图2所示），并且不遵循标准的排序执行设计，原因在第2节中进行了解释。简而言之，Fabric的分布式应用程序由两部分组成：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种智能合约，称为chaincode，它是实现应用程序逻辑并在执行阶段运行的程序代码。链码是Fabric中分布式应用程序的中心部分，可能由不可信的开发人员编写。存在用于管理区块链系统和维护参数的特殊链代码，统称为系统链代码（第4.6节）。</span><br><span class="line">在验证阶段评估的背书策略。不可信的应用程序开发人员不能选择或修改背书策略。背书策略充当Fabric中用于交易验证的静态库，只能通过链码进行参数化。只有指定的管理员才可以通过系统管理功能修改背书策略。典型的背书策略允许链代码以背书所需的一组peers的形式指定交易的背书人（执行人，进行共识的部分节点）。它在集合上使用单调逻辑表达式，例如“五分之三”或“（A∧B）∨C”。自定义背书政策可以实施任意逻辑（例如，第5.1节中我们的比特币启发式加密货币）。</span><br></pre></td></tr></table></figure>
![](/block_paper_2/20200404092429562.png)
客户将交易发送给背书策略指定的peers。然后，每个事务由特定的peers执行，并记录其输出；此步骤也称为**背书（执行，认证交易）**。执行后，交易进入排序阶段，该阶段使用**可插拔的共识协议**生成以区块为单位的认可交易的完全有序序列。在gossip（可选）的帮助下，将这些广播给所有peers。与标准的主动复制完全根据输入的事务进行排序不同，Fabric进行事务排序还要**结合状态依赖**，在执行阶段进行计算。然后，每个peer都会在验证阶段验证与背书策略有关的状态变化以及背书交易的执行一致性。所有peers都以相**同的顺序验证交易**，并且验证是确定性的。从这个意义上讲，Fabric在拜占庭模型中引入了一种新颖的**混合复制范式**，该模型将被动复制（**状态更新的共识前计算**）和主动复制（**执行结果和状态更改的共识后验证**）组合在一起。
Fabric区块链由形成网络的一组节点组成（请参见图3）。当Fabric经过许可时，网络中的所有节点都有一个身份，是模块化的成员资格服务提供程序（MSP）提供的（第4.1节）。Fabric网络中的节点扮演三个角色：
+ 客户端提交交易建议以供执行，帮助或安排执行阶段，最后广播交易以排序
+ peers执行交易建议并验证交易。所有peers都维护区块链分类帐，这是一个仅追加的数据结构，以一条hash链的形式记录所有交易，以及状态（最新分类帐状态的简洁表示）。**并非所有的peers都执行所有交易。根据交易所属链代码的策略（背书策略），只有提案中的一个子集称为背书peers（或简称为背书人）。**
+ 排序服务节点（OSN）（或简称为排序者）是共同构成排序服务的节点。简而言之，排序服务会在Fabric中建立所有交易的有序序列，其中每个交易都包含状态更新和在执行阶段计算的依赖关系以及背书peers的加密签名。**排序者完全不了解应用程序状态，并且不参与执行或交易验证中**。这种设计选择使Fabric中的共识尽可能地**模块化**，并简化了Fabric中共识协议的替换。

<p><img src="/block_paper_2/20200404093902895.png" alt=""><br>Fabric网络实际上<strong>支持连接到同一排序服务的多个区块链</strong>。每个这样的区块链都称为一个通道，并且可能有不同的peers作为其成员。可以使用Channel来划分区块链网络的状态，但是不协调跨通道的共识，并且每个通道中的总交易顺序是相互独立的。将所有排序者都视为受信任的某些部署也可以实现peers的按通道访问控制。在下文中，我们仅提及Channel，仅关注一个Channel。<br>在接下来的三个部分中，我们将解释Fabric中的事务流程（如图4所示）并说明执行，排序和验证阶段的步骤。然后，我们总结了Fabric的信任和故障模型（第3.5节）。<br><strong>2. 执行阶段</strong><br>在执行阶段，客户端签名并将交易提议（或简称为提议）发送给一个或多个背书人(ps:部分peers)以执行。回想一下，每个链码都通过背书策略隐式指定了一组背书人。提议包含提交客户端的身份（根据MSP），执行操作形式的事务有效负载，参数以及链码的标识符，每个客户端只能使用一次的随机数（例如计数器）（或随机值），以及从客户标识符和随机数派生的交易标识符。<br>背书人通过<strong>在已安装在区块链上的指定链码上执行操作来模拟提案proposal</strong>。链码在Docker容器中运行，与主背书进程隔离。<br>针对背书人的<strong>本地区块链state模拟了提案proposal，而无需与其他peers进行同步</strong>。此外，背书人不会将模拟结果保留到分类账状态ledger state。区块链的状态由peer事务管理器（PTM）以版本化键值存储的形式维护，其中键的连续更新具有单调递增的版本号（4.4）。由一个链码创建的状态仅适用于该链码，并且不能被另一个链码直接访问。请注意，<strong>链码不应该维护程序代码中的本地状态</strong>，而只能维护通过GetState，PutState和DelState<strong>操作访问的区块链状态中维护的内容</strong>。给定适当的权限，链码可以调用另一个链码以在同一通道内访问其状态。<br>作为模拟的结果，<strong>每个背书者都会产生一个值写入集</strong>，该值写入集由模拟产生的状态更新（即修改后的键及其新值）以及一个代表提案模拟的版本依赖性的读取集（即在模拟过程中读取的所有键及其版本号）。模拟之后，<strong>背书者加密签名一条称为背书endorsement的消息</strong>，其中包含readset和writeset（以及元数据，例如交易ID，背书者ID和背书者签名），并在提案响应中将其发送回客户端。客户收集背书endorsements，直到满足交易所调用的链码的背书策略（即<strong>要收集到所有背书人返回的endorsement消息</strong>）。特别地，这要求由策略确定的所有背书者都<strong>产生相同的执行结果</strong>（即相同的读集和写集）。然后，客户继续创建交易并将其传递给排序服务。<br><strong>讨论设计选择</strong><br>当背书人在不与其他背书人同步的情况下模拟提案时，<strong>两个背书人可能会在分类账的不同状态下执行该提案，并产生不同的输出</strong>。对于要求多个背书人产生相同结果的标准背书策略，这意味着<strong>在访问相同键的操作竞争激烈的情况下，客户端可能无法满足背书策略</strong>。这是一个与<strong>通过中间件（客户端？？）进行同步的复制数据库中的主备份复制相比</strong>的新考虑因素：<strong>假设在区块链中没有一个peer可被信任以正确执行</strong>。<br>我们有意识地采用了这种设计，因为它极大地简化了架构，并且足以<strong>满足典型的区块链应用</strong>。正如比特币的方法所证明的那样，分布式应用程序可以制定为在正常情况下<strong>减少或完全消除访问同一状态的操作的争用</strong>（例如，在比特币中，不允许两个修改相同“对象”的操作，如双重支出攻击[44]）。将来，我们计划逐步增强争用contention中的Fabric的活动性语义，尤其是为了支持CRDT [51]以补充当前版本的依赖项检查，以及将用作交易定序器的按链代码的主签注者。<br>在排序阶段之前执行事务对于tolerating非确定性链码至关重要（ps:<strong>个人理解是，在非确定性情形出现时，fabric可以很好处理，因而说可以“容忍”这种情况</strong>）。具有不确定事务的Fabric中的链码只会危及其自身操作的活跃性，客户可能因此而无法收集足够数量的背书。与排序执行架构相比，这是一个根本优势，在排序执行架构中，不确定性操作会导致peers状态不一致。（ps：理解就是，<strong>fabric架构中，不一致就会不满足背书策略，就不会排序，相比无法保证事务确定性的排序执行架构，这点是优势</strong>）<br>最终，容忍非确定性执行还<strong>解决了来自不受信任链码的DoS攻击</strong>，因为背书人可以怀疑是否有DoS攻击，可以根据本地策略简单地中止执行。这不会危及系统的一致性，而且，在单执行结构中不可能单方面中止执行(<strong>ps:个人理解，是一点终止，全部终止，所以保持一致吗</strong>）。<br><strong>3. 排序阶段</strong><br>当<strong>客户端在提案中收集到足够的背书时，它会组装交易并将其提交给排序服务</strong>。该交易包含交易有效负载（即包含参数的链式代码操作），交易元数据和一组背书。排序阶段会针对每个渠道的所有已提交交易建立总体的有序序列。而即便排序者有问题时，排序仍然以原子方式广播背书endorsements，从而建立了交易共识。此外，排序服务将多个事务批处理为多个块，并输出包含事务的块的哈希链序列。将<strong>事务分组或成批处理</strong>可以提高广播协议的吞吐量，这是一种用于容错广播的众所周知的技术。<br>在较高的层次上，排序服务的接口仅支持以下两个操作，这些操作由peer调用并由通道标识符隐式参数化：</p>
<ul>
<li>broadcast（tx）：客户端调用此操作以<strong>广播任意交易tx</strong>，该交易通常包含事务处理有效负载和客户端签名以进行分发</li>
<li>B←deliver(s)：客户端调用它以<strong>获取非负序号s的对应区块blockB</strong>。该块包含交易清单[tx<br>1,…,txk]和序列中其前一区块的哈希。由于客户端可能会多次调用并且总是返回相同的块（如果有），我们假设peer在调用deliver（s）时第一次接收到blockB时，其序列号为s。</li>
<li><strong>根据论文的上下文，上面两条中的客户端client都是指peer，要严格和fabric架构中的client节点区分</strong><br>排序服务可确保一个通道上已交付的区块全部被排序。更具体地说，排序可确保每个通道具有以下安全性能：</li>
<li><strong>一致性</strong>：对于在正确的peers处以序列号s和s’分别获取分发的两个区块B和B’，使得s = s’，则可确定B = B’。</li>
<li><strong>哈希链完整性</strong>：如果某个正确peer递送序号为ｓ的区块blockB，而另一个正确peer递送序号为s+1的区块blockB’=（[tx1，。。。txk]，h’），则必定有h’= H（B），其中H（·）表示密码哈希函数。</li>
<li><strong>No skipping</strong>：如果正确peer递送序号为s &gt; 0的区块，则对i = 0，。。。，s -1，peer均已递送了编号为i的区块。</li>
<li><strong>No creation</strong>：当正确peer交付了具有编号的blockB时，则对于每个tx∈B，某些client已经广播了tx。<br>对于活动性，排序服务至少支持以下“最终”属性：</li>
<li><strong>有效性</strong>：如果正确的client(peer)调用了广播（tx），那么每个正确的peer最终都会递送一个包含tx的BlockB，并带有序列号。</li>
</ul>
<p>然而，每个单独的排序实现都允许在客户机client请求方面有自己的活跃性和公平性保证<br>由于区块链网络中可能存在大量对等点peers，但是预计只有相对较少的节点才能实现排序服务，因此可以将Fabric配置为<strong>使用内置的gossip服务，以排序服务中的交付区块传播给所有peers</strong>（第4.3节）。gossip的实现可扩展且与排序服务的特定实现无关，因此它可与CFT和BFT排序服务一起使用，从而确保Fabric的模块化。<br>排序服务还可以<strong>执行访问控制检查</strong>，以查看是否允许客户端client在给定频道上广播消息或接收块。排序服务的此功能和其他功能将在第4.2节中进一步说明。</p>
<p><strong>讨论设计选择</strong><br><strong>排序服务不维护区块链的任何状态，并且既不验证也不执行交易</strong>，这一点非常重要。这种架构是Fabric至关重要的定义功能，并使Fabric成为<strong>首个可将共识与执行和验证完全分开的区块链系统</strong>。这使共识尽可能地模块化，并实现了实施排序服务的共识协议生态系统。散列链完整性属性和块链接的存在仅是为了<strong>使peers对块序列的完整性验证更加有效</strong>。最后，请注意，我们<strong>不需要排序服务来防止交易重复</strong>。这简化了其实现，因此无需担心，因为在验证期间，peers会在重复的读写检查中过滤重复的事务。<br><strong>4. 验证阶段</strong><br><strong>区块由排序服务节点（OSN)直接或通过gossip传递给peers</strong>。然后，一个新块进入验证阶段，该阶段包括三个连续步骤：<br>（1）<strong>对该块内的所有事务并行执行背书策略评估</strong>。评估是所谓的<strong>验证系统链码（VSCC）</strong>的任务，该系统是区块链配置的一部分，是一个静态库，负责验证针对链码配置策略的签注（请参阅第4.6节）。如果不满足背书，则该交易被标记为无效，并且其影响不予理会。<br>（2）<strong>顺序对块中的所有事务进行读写冲突检查</strong>。对于每笔交易，它会将读取集字段中的键版本与分类账的当前状态中的键版本（由peers本地存储）进行比较，并确保它们仍然相同。如果版本不匹配，则交易被标记为无效，并且其影响被忽略。<br>（3）<strong>分类账更新阶段最后运行，在该阶段，将区块追加到本地存储的分类账中，并更新区块链状态</strong>。特别是，在将块添加到分类帐中时，前两个步骤中的有效性检查结果也以位掩码的形式保留，表示块中有效的交易。这有利于以后的状态重建。此外，通过将writeset中的所有键值对写入本地状态来应用所有状态更新。<br><strong>讨论设计选择</strong><br><strong>Fabric的分类帐包含所有事务，包括那些被视为无效的事务</strong>。这是从总体设计得出的，因为<strong>与链码状态无关的排序服务会生成块链，并且验证是由peers共识后完成的</strong>。在某些需要<strong>在后续审核期间跟踪无效交易的用例中需要此功能</strong>，并且与其他区块链（例如，比特币和以太坊）相反，<strong>在其他区块链中，分类账仅包含有效交易</strong>。此外，由于Fabric的允许性质，检测通过试图用无效事务填充网络来尝试发起DoS攻击的客户端很容易。一种方法是根据可以实施的政策将此类客户列入黑名单。此外，特定的部署可能会收取交易费用（使用我们的5.1节中的货币实现或其他方法）以收取交易调用费用，这将使DoS攻击的成本过高。<br><strong>5. 信任与故障模型</strong><br>Fabric可以适应灵活的信任和错误假设。通常，任何客户端都可能被认为是恶意的或拜占庭式的。peers可以划分到不同组织，每个组织形成一个可信域。这样一个peer将信任其组织内的所有peers，但不信任另一个组织的peers。排序服务将所有peers（和客户端）视为潜在的拜占庭式。<br>F<strong>abric网络的完整性取决于排序服务的一致性</strong>。排序服务的信任模型直接取决于其实现（<strong>ps:具体使用的共识协议</strong>）（请参见第3.3节）。从v1.0.6版本开始，Fabric支持在开发和测试中使用的集中式单节点实施，以及在集群上运行的CFT排序服务。第三种实现是基于BFT-SMaRt的概念证明[19]，最多可容纳三分之一的拜占庭OSN [53]。请注意，Fabric<strong>将应用程序的信任模型与共识的信任模型解耦</strong>。即<strong>分布式应用程序可以定义自己的信任假设，这些假设通过背书策略传达，并且独立于由排序服务实施的共识假设</strong>（另请参见第3.4节）。<br><img src="/block_paper_2/20200405085639174.png" alt=""></p>
<p><strong>四、Fabric组件</strong><br>Fabric是用Go编写的，它使用gRPC框架在clients、peers和orders之间进行通信。下面我们将更详细地描述一些重要的组件。图5显示了peer的组件。<br><strong>1. 成员服务</strong><br><strong>成员资格服务提供程序（MSP）维护系统中所有节点（客户端，peers和OSN）的身份，并负责发布用于身份验证和授权的节点凭据</strong>。由于Fabric区块链为许可链，因此节点之间的所有交互都是通过经过身份验证的消息进行的，通常使用数字签名。<strong>成员资格服务在每个节点上都包含一个组件</strong>，该组件可以在其中验证交易，验证交易的完整性，签署和验证背书以及增强其他区块链操作。MSP还包含用于密钥管理和节点注册的工具。<br>MSP是一个抽象定义，可以使用不同的实例。Fabric中的默认MSP实现基于数字签名的标准PKI方法进行身份验证，并且可以适应商业证书颁发机构（CA certification authorities）.<strong>Fabric还提供了一个独立的CA，称为Fabric-CA</strong>。此外，还设想了替代的MSP实现，例如依靠匿名凭证授权客户端调用交易而不将其链接到身份的交易。<br><strong>Fabric允许两种模式来建立区块链网络</strong>。在离线模式下，凭据由CA生成并分发到所有节点。peers和osn只能在离线模式下注册。对于注册clients，Fabric-CA提供了一种在线模式，向其颁发加密凭据。 MSP配置必须确保所有节点（尤其是所有对等peers）都使用相同的有效的身份和身份验证。<br>例如，当多个组织运营区块链网络时，<strong>MSP允许身份联合</strong>。每个组织都向其自己的成员发出身份，每个peer都认可所有组织的成员。这可以通过<strong>多个MSP实例来实现</strong>，通过在每个组织和MSP之间创建映射。<br><strong>2. 排序服务</strong><br><strong>排序服务管理多个channel。在每个channel上，它提供以下服务</strong>：</p>
<ul>
<li>原子广播，用于建立交易顺序，实现广播和传递调用。</li>
<li>当channel的成员通过广播配置更新事务来修改channel时，对channel进行重新配置</li>
<li>可选地，在排序服务充当受信任实体的那些配置中，访问控制将交易的广播和块的接收限制为指定的clients和peers。<br>排序服务由系统channel上的创世区块引导。此块包含一个配置事务，该事务定义了排序服务的功能。<br>当前的作业实现由排序服务节点（OSN）组成，这些节点实施本文所述的操作并通过系统channel进行通信。<strong>实际的原子广播功能由Apache Kafka的一个实例提供</strong>，该实例基于ZooKeeper可以提供可伸缩的发布-订阅消息传递，并且即使节点崩溃也具有强一致性。<strong>Kafka可以在与OSN分离的物理节点上运行</strong>。OSN充当peers和Kafka之间的代理。<br>OSN直接<strong>将新接收的事务注入原子广播（例如，注入Kafka代理）。OSNs批处理从原子广播接收的事务及形成的区块</strong>。一旦满足以下三个条件之一，便会切断该块：（1）该块包含指定的最大交易数；（2）块已达到最大大小（以字节为单位）；或（3）自收到新区块的第一笔交易起已经经过了一段时间，如下所述。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 理解，就是 client把交易发过来，先用kafka打包区块，实现原子广播，再到osn进行处理</span><br></pre></td></tr></table></figure>
此<strong>批处理过程是确定性的，因此会在所有节点上产生相同的块</strong>。很容易看出，考虑到原子广播接收到的交易流，前两个条件是确定性的。为了确保在第三种情况下确定性的块产生，当节点从原子广播中读取块中的第一个事务时，它将启动计时器。如果在计时器到期时仍未切割该块，则OSN在该channel上广播特殊的切割时间事务，该操作指示它打算切割的块的优先级编号。另一方面，每个OSN在收到给定块编号号的第一个切割时间事务后立即切出新块。由于此事务是原子传递给所有连接的OSN，因此它们都在区块中包含相同的交易清单。OSN将一系列最新交付的区块直接保留到其系统中，因此它们可以通过传递使peers可以获取区块。</li>
</ul>
<p><strong>基于Kafka的排序服务是当前可用的三种实现之一</strong>。称为Solo的集中式订购器在一个节点上运行，并用于开发。基于BFT-SMaRt [19]的概念验证订购服务也已可用[53]；它可以确保原子广播服务，但尚未重新配置和访问控制。这说明了Fabric中共识的模块化。<br><strong>3. Peer Gossip</strong><br>将执行，排序和验证阶段分离的一个优势是，它们可以独立变化规模。但是，由于大多数共识算法（在CFT和BFT模型中）都是受带宽限制的，因此排序服务的吞吐量受到其节点网络容量的限制。无法通过增加更多的节点来扩大共识[28,57]，相反，吞吐量将降低。但是，<strong>由于排序和验证是分离的，因此我们对将执行结果有效地广播到所有peers以进行验证很有兴趣</strong>。<strong>这点，与向新加入的peers和长时间断开连接的peers的状态转移恰恰是gossip组件的目标。</strong>Fabric gossip为此目的利用了流行性多播epidemic multicas[29]。块由排序服务签名。这意味着<strong>peers可以在接收所有块后独立组装区块链并验证其完整性</strong>。<br>gossip通信层基于gRPC，并使用具有相互认证的TLS，这使得双方可以将TLS凭证绑定到远程peers的身份。<strong>gossip组件维护系统中在线peers的最新成员视图</strong>。所有peers均会根据定期分发的成员身份数据独立构建本地视图。此外，崩溃或网络中断后，peer可以重新连接到视图。<br>Fabric gossip<strong>分两个阶段进行信息分发</strong>：在push过程中，每个peer从成员资格视图中选择一组随机的活动邻居，并转发消息给它们。在pull期间，每个peer会定期探测一组随机选择的对peers，并请求丢失消息。已经显示[29,38]，同时<strong>使用这两种方法对于最佳利用可用带宽并确保所有peers以高概率接收所有消息至关重要</strong>。为了减轻从排序节点向网络发送数据块的负担，该协议还选择了一个leader peer，代表它们从排序服务中提取区块并发起gossip分发。<br><strong>4. 分类帐</strong><br>每个peer的分类帐组件在持久性存储上维护分类帐和状态，并启用模拟simulation, 验证validation和分类帐更新ledger-update阶段。大致来说，它由一个区块存储和一个peer事务管理器组成。</p>
<ul>
<li>分类账块存储区ledger block store保留事务区块，并实现为一组仅追加文件。<strong>由于块是不可变的并以确定的顺序到达的，仅追加结构可提供最佳性能</strong>。另外，块存储区维护一些索引，用于随机访问块或块中的事务。</li>
<li><strong>peer事务管理器（PTM）在版本化的键值存储中维护最新状态</strong>。它为任何链码存储的每个唯一入口键存储一个形式为（key，val，ver）的元组，其中包含其最近存储的值val和最新版本的ver。版本由块序号和块内事务（存储条目）的序列号组成。PTM使用本地键值存储来实现其版本化的变体，并使用LevelDB（在Go中）[10]和ApacheCouchDB [1]来实现。</li>
</ul>
<p>在模拟simulation过程中，<strong>PTM为事务提供最新状态的稳定快照</strong>。如第3.2节所述，PTM在GetState访问的每个条目的readset中记录一个元组（key，ver），而在该交易中用PutState更新的每个条目的writeset中记录一个tuple（key，val）。此外，PTM支持范围查询，为此它计算查询结果的加密哈希（一组元组（key，版本）），并将查询字符串本身和哈希添加到readset中。<br><strong>为了进行交易验证（第3.4节），PTM依次验证一个区块中的所有交易。这将检查事务是否与任何先前的事务冲突（在块内或更早的时间内）</strong>。对于readset中的任何键，如果readset中记录的版本与最新状态下存在的版本不同（假定已提交所有先前的有效事务），则PTM将该事务标记为无效。对于范围查询，PTM将重新执行查询并将哈希与readset中存在的哈希进行比较，以确保不发生幻像读取。这种读写冲突语义促成了单拷贝可序列化性[39]。<br><strong>分类账组件在分类账更新期间容忍peers崩溃</strong>，如下所示。收到新块后，PTM已经使用第3.4节中提到的位掩码在块内执行了验证并将事务标记为有效或无效事务。现在，分类账将块写入分类账块存储，将其刷新到磁盘，然后更新块存储索引。然后，<strong>PTM将所有有效交易的写入集的状态更改应用于本地版本存储</strong>。最后，它计算并保留一个值保存点，该值表示成功应用的最大块数。从崩溃中恢复时，<strong>值保存点用于从持久块中恢复索引和最新状态</strong>。<br><strong>5. 链码执行</strong><br>Chaincode在与peer松耦合的环境中执行，该环境支持用于添加新链码编程语言的插件。当前支持Go，Java和Node。<br>每个<strong>use-level或应用程序链码都在Docker容器环境中的单独进程中运行，该进程将链码彼此隔离，并与peers隔离</strong>。这也简化了链码生命周期的管理（即启动，停止或中止链码）。链码和peers使用gRPC消息进行通信。通过这种松散的耦合，peers不了解链码所使用的实际语言。<br>与应用程序链码相反，<strong>系统代码在peer进程中直接运行。系统链码可以实现Fabric所需的特定功能，并且可以用于用户链码之间的隔离过于严格的情况</strong>。下一节将提供有关系统链码的更多详细信息。<br><strong>6. 配置和系统链码</strong><br>Fabric可以通过channel配置和特殊的链码（称为系统链码）来定制。<br><strong>Fabric中的每个channel都形成一个逻辑区块链</strong>。通道的配置在元数据持久的特殊配置块中维护。每个配置块都包含完整的通道配置，并且不包含任何其他事务。每<strong>个区块链都以配置块（称为创世块）开头，用于引导通道</strong>。通道配置包括：（1）定义参与节点的MSP，（2）OSN的网络地址，（3）共享配置，用于共识实现和排序服务，例如批处理大小和超时；（4）控制访问排序服务操作（广播和传递）的规则，以及（5）控制如何修改通道配置的每个部分的规则。<br><strong>可以使用通道配置更新事务来更新信道的配置</strong>。此事务包含对要进行的配置更改的重新表示，以及一组签名。排序服务节点通过使用当前配置来评估更新是否有效，以验证使用签名对修改进行了授权。然后排序者生成一个新的配置块，其中嵌入了新的配置和配置更新事务。接收此块的peers验证是否根据当前配置对配置更新进行了授权；如果有效，他们会更新其当前配置。<br><strong>部署应用程序链码时要参考背书系统链码（ESCC）和验证系统链码（VSCC）</strong>。选择这两个链码，以便可以验证ESCC的输出（背书）作为VSCC输入的一部分。ESCC将提案和提案模拟结果作为输入。如果结果令人满意，则ESCC会做出回应，其中包含结果和认可。对于默认的ESCC，这种认可只是peers的本地签名身份的签名。VSCC将交易作为输入并输出该交易是否有效。对于默认的VSCC，将根据针对链码指定的背书策略收集并评估认可。进一步的系统链码实现了其他支持功能，例如链码生命周期。<br><strong>五、评估</strong><br>即使尚未对Fabric进行性能调整和优化，我们还是在本节中报告一些<strong>初步的性能数据</strong>。<strong>Fabric是一个复杂的分布式系统。它的性能取决于许多参数</strong>，包括对分布式应用程序的选择和交易规模，排序服务和共识实现及其参数，网络中节点的网络参数和拓扑，节点运行的硬件，节点和通道的数量，其他配置参数以及网络动态。因此，对Fabric的深入性能评估在以后的工作中进行。<br>在没有针对区块链的标准基准的情况下，我们使用最杰出的区块链应用程序来评估Fabric，这是<strong>一种使用比特币数据模型的权威授权的加密货币，我们将其称为Fabric coin</strong>（以下简称Fabcoin）。在其他许可区块链的背景下，Fabric的性能通常来自比特币或以太坊。例如，它也是应用程序使用其他许可区块链的基准[35，50]。<br>在下文中，我们首先介绍Fabcoin（第5.1节），它还演示了如何自定义验证阶段和背书策略。在5.2节中，我们介绍基准并讨论我们的结果。<br><strong>1. Fabric Coin (Fabcoin)</strong><br><strong>UTXO加密货币</strong><br><strong>比特币引入的数据模型已被称为“未使用的交易输出”或UTXO</strong>，并且还被许多其他加密货币和分布式应用程序使用。UTX<strong>O将数据对象演化的每个步骤表示为分类账上的单独原子状态</strong>。这种<strong>状态是通过事务创建的，并被稍后发生的另一个唯一事务破坏（或“消耗”）</strong>。<strong>每个给定的事务都会破坏许多输入状态，并创建一个或多个输出状态</strong>。Bitcoin中的coin最初是通过奖励该区块“矿工”的coinbase交易创建的。这在分类账上显示为coin状态，将矿工指定为所有者。可以用任何coin消费的意义，即<strong>通过一种交易将硬币分配给新的所有者，该交易会从原子上破坏指定前一个所有者的当前coin状态并创建代表新所有者的另一个coin状态</strong>。<br>我们在<strong>Fabric的键值存储中捕获UTXO模型</strong>。<strong>每个UTXO状态都对应于一个唯一的KVS条目</strong>，该条目创建一次（coin状态为“unspent”）并销毁一次（coin状态为“spent”）。同样，创建后，每个状态都可以视为逻辑版本为0的KVS条目；当它再次被销毁时，它会收到版本1。不应对此类条目进行任何并发更新（例如，尝试以不同的方式更新coin状态等同于将coin花费两次）。<br><strong>UTXO模型中的值是通过事务转移的</strong>，这些事务引用了多个输入状态，这些状态都属于发出事务的实体。实体拥有一个状态，因为该实体的公钥包含在状态本身中。每笔交易都会在KVS中创建一个或多个代表新所有者的输出状态，删除KVS中的输入状态，并确保输入状态中的值之和等于输出状态值之和。还有一个策略决定如何创造value（例如，比特币中的币库交易或其他系统中的特定造币厂交易）或销毁value的方式。<br><strong>Fabcoin实现</strong><br><strong>Fabcoin中的每个状态都是一个形式为（key，val）=（txid.j，（amount，owner，label））的元组</strong>，表示作为标识为txid并分配金额单位的交易的第j个输出创建的币态带有标签的实体公钥是所有者。标签是用于识别coin的给定类型的字符串（例如，“ USD”，“ EUR”，“ FBC”）。事务标识符是短值，可唯一标识每个Fabric事务。<strong>Fabcoin实现包括三个部分：（1）客户钱包，（2）Fabcoin链码，（3）用于Fabcoin实施其认可策略的自定义VSCC</strong>。<br><strong>（1）Client钱包</strong><br>默认情况下，<strong>每个Fabric客户端维护一个Fabcoin钱包</strong>，该Fabcoin钱包在本地存储一组允许客户花费coin的加密密钥。为了创建转移一个或多个coin的支出交易，客户钱包会创建一个Fabcoin请求request = (inputs, outputs, sigs)，包含：（1）投入coin状态列表，inputs = [in…]指定客户希望花费的coin状态，以及（2）输出coin状态的列表，outputs = [(amount, owner, label),…]，客户端钱包使用的签名是由输入coin状态相对应的私钥，Fabcoin请求和nonce随机数（每笔Fabric交易的一部分）串联而成，将该签名添加到一组sig中。当输入coin状态中的金额之和至少等于输出中金额的总和且输出金额为正时，交易有效。对于创建新coin的铸币交易，输入仅包含称为中央银行Central Bank（CB）的特殊实体的标识符（即对公共密钥的引用），而输出包含任意数量的coin状态。挖矿交易签名必须是在Fabcoin请求和上述随机数串联后在CB公钥下的加密签名。可以将Fabcoin配置为使用多个CB或从一组CB中指定阈值签名数。最后，<strong>客户端钱包将Fabcoin请求包含在交易中，并将其发送到其选择的peers</strong>。<br><strong>Fabcoin链码</strong><br><strong>一个peer运行Fabcoin的链码，以模拟交易并创建读取集和写入集</strong>。简而言之，在一笔支出交易的情况下，对于coin state输入集合inputs中的一个输入in，链码先执行GetState（in）获取readset及其当前版本。然后，链码将为每个输入状态执行DelState（in），还将添加到写入集中并地将coin状态标记为“已用”。最后，forj = 1，…，|| outputs ||，链码以输出的第j个outputout =(amount, owner, label)执行executePutState（txid.j，out）。另外，peers可以按照下面在Fabcoin的VSCC步骤中所述运行交易验证代码；这不是必需的，因为Fabcoin VSCC实际上可以验证交易，但是它允许（正确的）peers过滤出潜在的格式错误的交易。在我们的实现中，链码无需加密验证签名即可运行Fabcoin VSCC（仅在实际VSCC中进行了验证）<strong>(???)</strong>。<br><strong>定制VSCC</strong><br>最后，<strong>每个peer都使用自定义VSCC验证Fabcoin交易</strong>。这将在相应的一个或多个公共密钥下验证sigs中的一个或多个密码签名，并按以下方式执行语义验证。对于铸币交易，它将检查是否在匹配的交易标识符（txid）下创建了输出状态，并且所有输出金额均为正。对于一次花销交易，VSCC会额外验证（1）对于所有输入币态，已经在readset中创建了一个条目，并且该条目也已添加到writeset中并标记为已删除，（2）所有输入coin状态的数量等于所有输出coin状态的数量之和，并且（3）输入和输出coin标签匹配。在这里，VSCC通过从分类账中检索输入的coin数量来获得输入的coin数量。<br>请注意，<strong>Fabcoin VSCC不会检查交易是否存在双重支出，因为这是通过Fabric的标准验证完成的，该验证在自定义VSCC之后运行</strong>。特别是，如果两个事务试图将相同的未使用coin状态分配给新所有者，则两个事务都将通过VSCC逻辑，但随后将<strong>被PTM执行的读写冲突检查所捕获</strong>。根据第3.4节和第4.4节，PTM验证存储在分类帐中的当前版本号与读取集中的版本号匹配；因此，在第一笔交易更改coin状态的版本后，第二笔交易将被视为无效。<br><strong>2. 实验</strong><br><strong>设定</strong><br>除非有不同的明确说明，否则在我们的实验中：（1）节点运行在Fabric版本v1.1.0-preview2上，用于通过本地日志记录进行性能评估，（2）节点托管在单个IBM Cloud（SoftLayer）数据中心中（DC）专用虚拟机与1Gbps（标称）网络互连，（3）所有节点均为运行GHz的2.0 GHz 16-vCPU VM，Ubuntu具有8GB RAM和SSD作为本地磁盘，（4）单通道排序服务运行典型Kafka排序程序设置，具有3个ZooKeeper节点，4Kafka代理和3个Fabric排序程序，它们都位于不同的VM上，（5）共有5个peers，均属于不同的组织（org），都是Fabcoin背书人，以及（6）签名使用默认的256位ECDSA方案。为了测量和分阶段跨越多个节点的事务流中的延迟，在整个实验过程中，将节点时钟与NTP服务进行同步。Fabric节点之间的所有通信均配置为使用TLS。<br><strong>方法</strong><br>在每个实验中，在第一个阶段中，我们调用仅包含Fabcoin铸币操作的交易以<strong>生成coin</strong>，然后运行实验的第二阶段，在该阶段中，我们对先前铸造的coin<strong>调用Fabcoin支出操作</strong>（有效地运行单输入，单输入-输出支出交易）。在报告<strong>吞吐量测量</strong>时，我们使用在单个VM上运行的越来越多的Fabric CLI客户端（已修改以发出并发请求），直到端到端吞吐量达到饱和，并声明吞吐量刚好低于饱和度。<strong>吞吐量报告为在实验稳定状态下测得的平均值</strong>，而无视“tail”，在此“tail”中某些客户端线程已经停止提交其交易份额。在每个实验中，客户端线程共同调用至少50万个铸币并花费交易。<br><strong>实验1：选择区块大小</strong><br><strong>影响吞吐量和延迟的关键光纤网配置参数是块大小。为了固定块大小以进行后续实验，并评估块大小对性能的影响</strong>，我们进行了实验，将块大小从0.5MB更改为4MB。结果如图6所示，显示了在对等端测得的峰值吞吐量以及相应的平均端到端（e2e）延迟。<br>我们可以看到，超过2MB的块大小后，<strong>吞吐量并没有显着提高，但是延迟变得更糟</strong>（如预期的那样）。<br>因此，在以下实验中，我们<strong>采用2MB作为块大小，目的是最大化测得的吞吐量，假设大约500ms的端到端延迟是可以接受的。</strong><br><img src="/block_paper_2/20200405112612953.png" alt=""><br><strong>选择事务大小</strong><br>在此实验中，我们还观察了<strong>铸币和支出交易的大小</strong>。特别是，这2MB的区块包含473个铸币或670个支出交易，即平均交易大小支出交易为3.06kB，铸币交易为4.33kB。一般而言，Fabric中的事务量很大，因为它们<strong>带有证书信息</strong>。此外，<strong>Fabcoin的铸币交易比支出交易大</strong>，因为它们带有CB证书。这是<strong>将来改善Fabric和Fabcoin的途径</strong>。<br><strong>实验2：peer CPU的影响</strong><br>Fabric peers运行许多CPU密集型加密操作。为了<strong>估算CPU功率对吞吐量的影响</strong>，我们进行了一组实验，其中4个peers分别在4、8、16和32个vCPU VM上运行，同时还进行了块验证的粗粒度延迟分阶段以识别瓶颈。<br>我们的<strong>实验集中在验证阶段，因为使用Kafka排序服务进行排序从未成为我们集群实验（在一个数据中心内）的瓶颈</strong>。验证阶段，尤其是<strong>Fabcoin的VSCC验证，由于其许多数字签名验证，因此在计算上非常耗费时间。我们根据peers本地的验证阶段延迟来计算peers的吞吐量</strong>。<br>图2显示了使用2MB块的结果，其中包含了铸币（图7a）和支出（图7b）操作的块。对于这两种操作，所测量的吞吐量和等待时间与vCPU数量相同。我们可以看到，<strong>验证方法明显限制了可实现的（端到端）吞吐量</strong>。而且，<strong>Fabric VSCC的验证性能与CPU呈近似线性关系</strong>，因为Fabric的VSCC的背书策略验证是并行的。但是，读写检查和分类帐访问阶段是顺序的，并以大量的内核（vCPU）为主。对于支出交易而言，这一点尤其明显，因为支出超过了铸币交易可以进入2MB的块，从而<strong>延长了顺序验证阶段的时间（即读写检查和分类帐访问）</strong>（从最下面两条几乎水平的线，图二的纵轴值高于图一可以看出）。<br><img src="/block_paper_2/20200405113556481.png" alt=""><br><img src="/block_paper_2/20200405113610124.png" alt=""><br>这个实验表明，未来版本的Fabric<strong>可以通过流水线验证阶段（现在是顺序的）而受益</strong>，从而消除了客户端的顺序开销。验证端到端吞吐量，优化稳定存储访问以及并行化读写依赖性检查之间存在明显差异。<br>最后，在此实验中，我们测量了32-vCPU对等方每秒超过3560笔事务（tps）的平均花费（端到端）吞吐量。总体而言，铸币吞吐量略低于支出，但相差不到10％，其中32个vCPU对等节点的平均薄荷吞吐量达到3420tps以上。<br><strong>延迟分析</strong><br>我们在之前的实验中以峰值报告的吞吐量进一步执行了延迟的粗粒度分析。结果如表1所示。在验证开始之前，排序阶段包括peers内部的广播传递延迟和内部延迟。该表报告了<strong>铸币和支出的平均延迟，标准偏差和尾部延迟。</strong><br><img src="/block_paper_2/20200405114630538.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意这个表，很有意思，很清楚的写明了验证阶段的步骤</span><br></pre></td></tr></table></figure>
<p>我们观察到<strong>排序主导了整体延迟</strong>。我们还看到，平均延迟在550毫秒以下，并具有次秒级延迟。特别是，我们的实验中最高的端到端延迟来自负载增加期间的第一个块。可以使用排序者的切割时间参数来调节和减少较低负载下的延迟（请参阅3.3），因为我们将其设置为较大的值，所以我们在实验中基本不使用它。<br><strong>实验3：SSD与RAM磁盘</strong><br>为了评估与<strong>稳定存储</strong>相关的潜在收益，我们重复了先前的实验，将RAM磁盘（tmpfs）安装为所有对等VM上的稳定存储。<strong>好处是有限的，因为tmpfs仅有助于在peers进行验证的分类账阶段</strong>。我们在32-vCPU对等端测量了3870 SPEND tps的持续峰值吞吐量，比SSD大约提高了9％。<br><strong>实验4：LAN的可伸缩性</strong><br>在本实验及后续实验中，我们<strong>增加了peers的数量</strong>（每个peer具有16个vCPU）来评估Fabric的可伸缩性。<br>在此实验中，我们在单个IBM Cloud DC（香港）中托管的每个组织中，只有一个peer。所有peers都直接从排序服务接收区块，而不会产生gossip。我们从20个peers开始（其中10个是Fabcoin认可方），并将peers的数量增加到100个。图8中描绘了可实现的最大吞吐量，<strong>该峰值吞吐量取决于peers数量</strong>（“LAN”后缀）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 怎么感觉图和结论不符 强行理解 可伸缩性，就是要保证peers增加 吞吐量还可不变</span><br></pre></td></tr></table></figure>
<p><img src="/block_paper_2/20200405115845187.png" alt=""><br><strong>实验5：两个DC-数据中心的可伸缩性以及gossip的影响</strong><br>在后续实验中，我们将排序服务，10个背书人和客户端移至附近的东京（TK）数据中心，将不背书的peers留在了香港特区。此实验（及下一个实验）的目标是<strong>评估系统的网络带宽</strong>成为瓶颈。我们将香港的非背书peers的数量从20个改变为80个，除了固定的10个背书peers之外，还<strong>保持了与排序服务的直接连接（即每个组织一个peer）</strong>。在TK和HK中的两个VM之间报告的单TCP netperf吞吐量平均为240 Mbps。<br>在图8中示出了根据（总数）peers的数量的峰值吞吐量（“2DC”后缀）。我们清楚地看到，吞吐量与先前对30个peers进行的实验基本相同，但是<strong>当peers数目增加时，吞吐量会下降</strong>。因为满足了TK中3个OSN的网络连接，所以吞吐量降低了。我们测量了1910tps 铸币和2190tps 支出吞吐量（在香港peers中），总共90个peers。<br><strong>为了解决此问题并提高WAN上的可伸缩性，Fabric可能会使用gossip</strong>（第4.3节）。我们与香港的80个peers（总共90个peers）重复了最后一次评估，但将<strong>这些peers重新配置为8个组织，每个组织10个peers。在这种配置中，每个组织中只有一个领导者leader peers直接连接到排序服务，并向组织中的其他人散布gossip</strong>。该实验（1个gossip7个输出）在香港同行中达到了2544/2753 tps的铸币/支出 平均峰值流量，这意味着<strong>gossip很好地发挥了它的预期功能</strong>。吞吐量比LAN实验中的要低一些，因为组织负责人的peer（在两个实验中都直接连接到OSN）现在也需要管理gossip。<br><img src="/block_paper_2/20200405120934651.png" alt=""><br><strong>实验6：在多个数据中心（WAN）上的性能</strong><br>最后，我们将最后一个实验<strong>扩展到5个不同的数据中心</strong>：东京（TK），香港（HK），墨尔本（ML），悉尼（SD）和奥斯陆（OS），每个数据中心有20个peers，共有100个peers。与之前的实验一样，排序服务，10个背书人和所有客户都在TK中。我们在没有gossip（每个组织一个peer）和有gossip（分为10个组织，每个数据中心2个组织，输出7个）的情况下运行此实验。结果汇总在表2中，属于同一数据中心的averaged across peers。供参考，表的首行显示了给定数据中心中的VM与TK之间的netperf吞吐量。<br>结果再次<strong>清楚地显示了当对等点分散在WAN上时使用gossip的好处</strong>。与HK和ML相比，我们在OS和SD上看到了有趣的结果。SD gossip的吞吐量较低是由于VM在SD中的CPU限制所致；在相同的规格下，它们的验证吞吐量要比HK和ML的peers低。在OS中，总吞吐量要低得多。但是，瓶颈不是排序服务的带宽，而是我们的netperf测量表明，从OS到TK的单TCP连接带宽。因此，无法观察到OS中gossip的真正好处。我们<strong>将实验中的操作系统吞吐量稍有提高归因于gossip</strong>，减少了从操作系统到TK的TCP连接数量。</p>
<p><strong>六、应用和使用案例</strong><br>主要的云运营商包括Oracle，IBM和Microsoft已经运行（或宣布）Fabric的“区块链即服务”。此外，Fabric目前为分布式账本技术的400多个原型和概念验证提供支持以及跨不同行业和用例的多种生产系统[47]。示例包括食品安全网络[16]，用于银行的云服务区块链平台[31]和数字全球航运贸易[33]解决方案。在本节中，我们将说明已部署Fabric的一些实际用例。<br><strong>1. 外汇交易网络Foreign exchange (FX) netting</strong><br>在<strong>Fabric上运行用于双边结汇的系统</strong>。它为每对涉及的客户机构使用fabric通道来保护隐私。负责结网和结算的专门机构（“结算员”）是所有通道的成员，并负责运行排序服务。区块链有助于解决未结算的交易，并在分类账中维护所有必要的信息。客户可以实时访问此数据，并有助于流动性，解决纠纷，减少风险敞口并最大程度地降低信用风险[49]。<br><strong>2. 企业资产管理（EAM）</strong><br>该解决方案跟踪硬件资产从制造到部署，最终到处置的过程，另外捕获与硬件相关的软件资产的许可证。区块链记录资产的各种生命周期事件和相关证据。<strong>分类帐是与资产有关的所有参与者之间的透明记录系统，从而提高了传统解决方案所面临的数据质量</strong>。多方财团区块链在制造商，托运人，收货人，客户和安装人员之间运行。它使用3层架构，其用户界面通过Fabric客户端连接到peers。在线提供了第一个版本的详细说明[56]。<br><strong>3. 全球跨货币支付Global cross-currency payments</strong><br>自2017年10月起，IBM与Stellar.organd KlickEx Group合作，运营了一种跨货币支付解决方案，该解决方案处理了太平洋地区APFII组织中的合作伙伴之间的交易[15]。The Fabric区块链以参与者认可的交易形式记录金融付款，以及双方同意的条件。所有有关方面均有权了解金融交易的清算和结算。<br>该解决方案适用于所有付款类型和值，并允许金融机构选择结算网络。特别是，结算可以使用不同的方法，Fabric会根据参与者的配置来决定如何结算付款。一种可能的结算方式是通过Lumens（Stellar的加密货币）进行结算，其他方式则基于交易的金融工具的类型。</p>
<p><strong>七、相关工作</strong><br>Fabric的架构类似于Kemme和Alonso [40]率先开发的<strong>中间件复制数据库</strong>的架构。但是，与此相关的所有现有工作仅解决了崩溃失败，而<strong>不是与BFT系统相对应的分布式信任的设置</strong>。例如，具有非对称更新处理的复制数据库[41，2.[6.3]依靠一个节点来执行每个事务，这不会在区块链上工作。 Fabric的执行顺序验证体系结构可以<strong>解释为这项工作对拜占庭模型的概括，并可以实际应用于分布式分类帐</strong>。<br>从BFT数据库复制的角度来看，Byzantium [32]和HRDB [55]是Fabric的另外两个前身。Byzantium允许事务并行运行并使用主动复制，但是使用BFTmiddleware完全命令BEGIN和COMMIT / ROLLBACK。在其乐观模式下，每个操作都由一个主副本进行协调。如果怀疑该主服务器是拜占庭，则所有副本都将对该主服务器执行事务操作，并触发昂贵的协议来更改该主服务器。HRDB以一种更强大的方式依赖于正确的主机。与Fabric相比，这两个系统都<strong>使用主动复制，无法处理灵活的信任模型，并且依赖确定性操作</strong>。<br>在Eve [37]中，还探索了BFT SMR的相关架构。它的peers同时执行事务，然后使用共识协议验证它们都达到了相同的输出状态。如果状态不同，它们将回滚并顺序执行操作。Eve包含独立执行的元素，该元素也存在于Fabric中，但<strong>没有其他功能</strong>。<br>近来出现了大量的permissioned模型中的分布式分类帐平台，一些著名的平台是Tendermint [14]，Quorum [13]，Chain Core [4]，Multichain）。[12]，Hyperledger Sawtooth[9]，Volt proposal[50]等，请参阅最近概述中的参考文献[24,30]。所有平台都遵循第2节中讨论的<strong>顺序执行架构</strong>。作为代表示例，以Quorum平台[35]（以太坊为企业版本）为基础。基于Raft [45]的共识，它传播了使用gossip和Raft leader（称为Minter）将交易传播到所有peers，然后将有效交易组装到一个区块上，并使用Raft将其分配给所有peers。所有peers都按照领导者决定的顺序执行交易，因此它受到上述限制的困扰在1-2中。</p>
<p><strong>八、总结</strong><br>Fabric是用于<strong>运行许可区块链的模块化且可扩展的分布式操作系统</strong>。它介绍了一种新颖的体系结构，该体系结构将事务执行与共识分开，并实现了基于策略的，这让人联想到中间件复制的数据库。<br>通过其模块化，Fabric非常适合许多进一步的改进和研究。未来的工作将通过（1）探索基准和优化来解决性能问题;（2）对大型部署进行可伸缩性;（3）保证一致性和更通用的数据模型;（4）通过不同的共识协议保证其他弹性（5））通过密码技术等进行交易和分类账数据的隐私和机密性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/04/03/block_paper_2/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="block_paper_2">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-block_paper_1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/04/02/block_paper_1/" class="article-date">
  	<time datetime="2020-04-02T01:44:28.000Z" itemprop="datePublished">2020-04-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/02/block_paper_1/">
        block_paper_1
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>数据流测试调查</strong><br><strong>零、概述</strong><br><strong>1.数据流测试定义</strong><br>数据流测试（DFT）是一系列<strong>测试策略</strong>，旨在验证<strong>每个程序变量的定义及其用途之间的相互作用</strong>。这种感兴趣的测试目标称为“ def-use”对。<br><strong>2.DFT发展</strong><br>DFT根据各种<strong>测试充足性标准</strong>（即<strong>数据流覆盖标准</strong>）选择测试数据，以练习每一对。 DFT的最初概念是由Herman于1976年提出的。从那时起，已经进行了许多理论和经验研究，以分析DFT的复杂性和有效性。在过去的四十年中，DFT一直受到关注，并且提出了来自不同方面的各种方法来追求自动和高效的数据流测试。<br><strong>3.论文工作</strong><br>这项调查对数据流测试进行了详细的概述，包括执行和自动化数据流的挑战和方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）介绍了用于识别def-use对的数据流分析技术； </span><br><span class="line">（2）分类并讨论了基于数据流的测试数据生成技术，例如基于搜索的测试，随机测试，基于抵押品覆盖率的测试，基于符号执行的测试以及基于模型检查的测试； </span><br><span class="line">（3）讨论了跟踪数据流覆盖范围的技术； </span><br><span class="line">（4）提出了几种DFT应用程序，包括软件故障定位，Web安全测试和规范一致性检查； </span><br><span class="line">（5）总结了最近的进展，并讨论了对更实际的数据流测试的未来研究方向。</span><br></pre></td></tr></table></figure>
<p><strong>一、介绍</strong></p>
<h5>DFT概念</h5>数据流测试（DFT）是一系列测试策略，它们选择**程序路径**来行使与数据对象有关的**定义使用关系**。它在所有路径测试和分支/语句测试之间进行定位，以查明潜在的数据流异常。当用作测试选择标准时，DFT可以提供更全面的测试方法，以确保某个软件的测试充分性，并检测要求不高的标准未必发现的错误。
<h5>DFT研究</h5>数据流测试的概念源自编译器优化中使用的**数据流分析**[Allen and Cocke 1976]，最初是由Herman [1976]在1976年提出的。从那时起，各种基于数据流的覆盖率的概念略有不同。准则[RappsandWeyuker1982; Laski and Korel 1983； Rapps和Weyuker 1985；弗兰克和韦尤克（Frankl and Weyuker）1988；克拉克等。 1989年； Harrold and Rothermel 1994]已经提出并进行了研究。这种**多样性的主要原因在于行使定义-使用关系的方式不同**，以及在过程和面向对象的**编程语言**中的不同适应方式。后来，通过一些实证研究证明了DFT的有效性[Frankl and Weiss 1993; Foreman and Zweben 1993； Weyuker 1993；哈钦斯等。 1994年；（Frankl and Iakounenko 1998），这表明**基于数据流的覆盖标准优于基于控制流的标准**（例如，语句或分支覆盖）。此外，由Khannur [2011]组织的在线软件测试知识中心报告说，在实践中，“通过将90％的数据覆盖率作为标准所检测到的错误数量能够发现缺陷的数量是90％所检测到的缺陷的两倍。分支机构的覆盖标准（控制流）。
在过去的四十年中，对数据流测试进行了持续的研究（如图1所示）。为了实现实用且有效的DFT，已经进行了大量研究工作。但是，很少有文献对它的技术水平进行过深入的调查或分析，这使学术研究人员和软件从业人员不了解该领域的**成熟度**。例如，关于数据流测试的介绍性章节可以在许多软件测试教程中找到，例如Beizer [1990]，Pezze和Young [2007]以及Ammann和Offutt [2008]的书。他们介绍了基本概念并确定了挑战，但没有讨论其**自动化**。此外，DFT提供了一种更密集的选择测试用例的方法，这是其执行中最耗费人力的任务之一（对于其他结构测试标准也是如此），并且对其测试有效性和效率产生了重大影响科学。但是，尚未专门研究DFT的**自动测试数据生成技术**。尽管有Edvardsson [1999]和Anand等人。[2013]调查了自动测试数据生成的各种技术，他们主要在基于控制流的覆盖标准的背景下讨论了这些技术。
<h5>本文研究内容</h5>尽管DFT具有检测数据交互故障的能力，但实际程序与所提出的DFT技术的实用性之间仍然存在很大差距。从而，我们认为，对于学术研究人员和工业从业人员，都非常需要审查当前的研究状态，认识到其**应用中的困难**，并指出未来的**研究方向**以缩小差距。为了提供DFT的系统概述，我们从DFT的三个基本阶段开始：（1）数据流分析，（2）数据流测试数据生成和（3）数据流覆盖率计算。在本文中，我们主要集中在后两个步骤中使用的技术，并提供了一个相对简短的DFT中数据流分析技术的摘要，因为Kennedy [1979]已经对数据流分析本身进行了研究。
此外，我们提出了关于数据流测试的首次调查：我们建立了DFT发布资料库，其中包含1976年至2015年期间的97篇论文。几个流行的在线数字图书馆（例如ACM数字图书馆，IEEE搜索Xplore，Springer Online，ElsevierOnline，Wiley Online和ScienceDirect）以收集有效的论文，这些论文的标题或摘要均包含以下关键字（在搜索过程中不断完善）：“def-use对”，“数据流关系”，“数据流测试+分析”，“数据流测试+测试生成”，“数据流覆盖范围”和“停用测试”。然后，遵循这些相同的关键字规则，我们遍历了这些论文的每个参考文献以收集缺失的出版物。现在可以在线获取该信息库。1我们将其分为七个主要类别：
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-测试数据生成。研究通用方法或技术以自动化基于数据流的测试生成</span><br><span class="line">-数据流分析。在不同编程语言及其特征的背景下研究用于分析数据流关系（即def-use对）的技术</span><br><span class="line">—覆盖率跟踪（计算）。对用于跟踪数据流覆盖范围的技术的研究，即确定满足哪些使用定义对</span><br><span class="line">-实证分析。分析执行数据流测试的复杂性并将其故障检测有效性与其他覆盖标准进行比较的研究</span><br><span class="line">-应用。将数据流测试应用于其他研究领域的研究，例如软件故障定位，Web安全测试和规范一致性检查</span><br><span class="line">-理论。数据流覆盖标准的基础理论和理论分析研究</span><br><span class="line">-工具。有关构建，说明和评估数据流测试工具的研究</span><br></pre></td></tr></table></figure>
请注意，有些论文可能涉及多个类别。例如，一篇论文可以介绍一种工具，也可以提出一种新的覆盖率计算方法。我们**根据其主要目标将每篇论文归为一类**。因此，我们的分类在某种程度上可能是**主观**的。尽管如此，我们相信图2中显示的每个研究主题的百分比仍可以公平地代表DFT中的当前研究状态。
本调查的其余部分安排如下。
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第2部分通过示例说明对DFT进行了概述，然后介绍了DFT的基本测试过程以及其应用中的各种挑战。</span><br><span class="line">第3节总结了用于查找def-use对的数据流分析技术。</span><br><span class="line">第4部分研究了DFT测试数据生成的一般方法，并讨论了它们的原理，优点和缺点。</span><br><span class="line">第5节介绍了DFT的覆盖率跟踪技术和工具。</span><br><span class="line">第6节讨论了最新的研究进展，</span><br><span class="line">第7节讨论了DFT的应用程序。</span><br><span class="line">第8节介绍了我们对数据流测试的新见解和未来的研究方向。</span><br><span class="line">第9节得出结论。</span><br></pre></td></tr></table></figure>
**二、数据流测试概述**
本节介绍数据流测试中的一些基本概念。然后讨论了DFT的基本测试过程及其遇到的困难。
**1. 基本概念**
程序路径可以表示为控制点的序列，形式为l1，l2，...，ln。我们区分两种类型的路径。**控制流路径是沿着程序的控制流图的一系列控制点；执行路径是由程序输入驱动的一系列执行控制点。**
<h5>定义2.1（使用定义对def-use）。</h5>按照Herman [1976]的经典定义，当变量的赋值（即定义或def）中至少**存在一个控制流路径时**，会出现def-use对**du（ld，lu，x）**。在控制点ld处的x到在控制点lu处的语句，其中**使用了相同的变量x**（即use），在该变量上**没有出现x的重新定义**（即，从def到use的路径是def-clear）。
尤其是，在数据流测试中区分了两种类型的变量用途[Rapps和Weyuker1982，1985]。如果x在计算或输出语句中使用，则将该使用称为**计算使用（或c使用）**，并将该对表示为**dcu（ld，lu，x）**，其中x在ld处定义并使用在lu。如果在条件语句中使用x，则其使用称为**谓词使用（或p-使用）**。此时，出现了两个def-use对，分别表示为**dpu（ld，（lu，lt），x）和dpu（ld，（lu，lf），x）**，其中x在ld处定义，在lu处使用，但是具有两个相反的流向（lu，lt）和（lu，lf）：前者表示使用x的条件语句的真实边；后者是错误边。

<p>在整篇文章中，我们专注于<strong>动态数据流测试</strong>，这是大多数研究工作中的目标问题。下面，我们给出（动态）数据流测试的定义。</p>
<h5>定义2.2（动态数据流测试）</h5>给定程序P中的使用对du（ld，lu，x），数据流测试的目的是找到一个输入t，该**输入t诱导执行路径p穿过ld，然后不经过中间重新定义就穿过lu**（即，在ld和lu之间杀死x。我们说这个**测试用例t满足du对**。
<h5>覆盖标准</h5>Rapps和Weyuker [1982，1985]首先[5]定义了**所有def-use对至少覆盖一次的要求**，这是**所有def-use覆盖标准（或全部用途覆盖率）的标准**，这意味着每对至少应有一个def-clear路径被掩盖。特别是，对于c型使用对，p应该覆盖ld和lu；对于p用法对，p应该覆盖ld和真或假边缘，即（lu，lt）或（lu，lf）。

<p><strong>2. 例子</strong><br><img src="/block_paper_1/20200402103158035.png" alt=""><br>上图图显示了一个示例程序power，它以两个整数x和y作为输入并输出x y。其控制流图（CFG）显示在图3的右列中。遵循Rapps和Weyuker[1982]的定义，下图显示了power中变量的定义和使用以及相应的def-use对。 。我们可以看到该示例程序总共有19条语句，8个分支和20个def-use对。<br> <img src="/block_paper_1/20200402103520307.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps:关于控制点 就是输入返回 条件判断 变量定义赋值</span><br></pre></td></tr></table></figure>
<p>例如，以下是关于变量res的两个def-use对：<br>du1=（l8，l17，res），    （1）<br>du2=（l8，l18，res）。    （2）<br>这里，du1是一个def-use对，因为关于变量res的定义（在第8行）可以通过控制流达到相应的用途（在第17行），路径为pathl8, l9, l13, 114, l17。这对可行因为可以找到满足该对的测试输入。. For example, t = ( x →1, y →0) can induce an execution path p（4 6 7 8 9 13 14 16 17).对于du2，它是一个def-use对，因为它的定义（在第8行）可以通过路径18、19、113、118到达相应的用途（在18行）。但是，du2是不可行的：如果有测试可以使用的输入，在l13必须满足y&gt; 0。由于y尚未在代码中修改，因此y&gt; 0在l4处也成立。结果，由于19处的环路保护为true，因此将在10处重新定义res。显然，这一对没有这样的输入，既可以避免循环中的重新定义，也可以使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps:由此可见，所谓重新定义是变量重新赋值 du2因为最后use点需要输入必须满足一定条件，而满足该条件必定会进入改变变量res值的分支，因此不会存在满足条件的输入</span><br><span class="line">还有个问题，定义必须是赋值才可是吗 比如double res;就不算定义 res = 1;才算</span><br><span class="line">还有个问题，def必须是初次赋值的点对吧，不能是中间的再次赋值作为def</span><br></pre></td></tr></table></figure>
<p><strong>3. 基本测试流程</strong><br>数据流测试包括三个基本阶段：<strong>数据流分析，测试数据生成和覆盖范围跟踪</strong>（如图所示），如调查结果所示，它们总共占研究工作的近50％。<br><img src="/block_paper_1/20200402110014352.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">—数据流分析阶段。数据流分析算法将被测程序P作为输入来计算测验目标（即使用定义对）。</span><br><span class="line">—测试数据生成阶段。采用一种测试方法来生成测试输入t，以满足目标限定使用对du。</span><br><span class="line">—覆盖率跟踪阶段。针对覆盖对du的程序P执行测试输入t。如果du被覆盖且未重新定义，则将t合并到测试套件T中。</span><br></pre></td></tr></table></figure>
<p>整个测试过程将继续进行，直到<strong>满足所有对或测试预算（例如测试时间）用完为止</strong>。最后，将针对程序P重放生成的测试套件T，以使用测试预告片检查正确性。<br><strong>4. 难点</strong><br>尽管DFT能够检测数据流故障，但仍然存在一些困难[Weyuker 1990； 2003； 3。 Denaro等。 [2013]阻止了它在工业实践中的广泛应用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不可扩展的数据流分析。 DFT中需要一种数据流分析算法，以从被测程序中识别使用定义对。但是，数据流分析过程很难针对大型实际程序进行扩展，尤其是在考虑了所有程序功能（例如别名，数组，结构和类对象）的情况下。必须做出适当的近似以在精度和可伸缩性之间进行权衡。</span><br><span class="line">数据流测试设计的复杂性。与程序中的数据流标准相关的测试目标数量远比简单的控制流准则要大得多。6此外，需要付出更多的努力才能得出数据流测试用例：测试人员必须涵盖了变量定义及其相应的用途，而没有变量的重新定义，而不仅仅是覆盖语句或分支。</span><br><span class="line">不可行的测试目标。由于将静态数据流分析技术应用于确定测试目标时比较保守，因此，def-use对可能包括不可行的对。如果存在可以通过的执行路径，则一对是可行的。否则，它是不可行的（例如，第2.2节中的对（18、18，res）是不可行的）。在没有关于目标对是否可行的事先知识的情况下，测试方法可能徒劳地花费大量时间来覆盖不可行的停用使用对。</span><br></pre></td></tr></table></figure>
<p>在这里，<strong>确定不可行的测试目标的问题实际上是不确定</strong>的，并且没有任何技术可以可靠地给出可行性的明确结论。它在DFT中不是唯一的，但在结构测试中也存在。尽管存在上述困难，但如本调查所示，借助现有技术和最新进展，DFT可以<strong>实现自动化，并且可以缓解这些问题</strong>。</p>
<p><strong>三、经典数据流分析–提取def-use对的研究</strong><br>为了识别DFT中的测试目标（即使用定义对），通常使用达到定义的程序[Allen and Cocke 1976]（它也启发了数据流覆盖标准的定义），实际上回答了这个问题。 ：对于每种变量使用，哪些定义可以潜在地为其提供值？<br>Harrold和Soffa [1994]使用标准的迭代数据流分析来计算高级语言的定义-使用关系。通过控制流图为每个过程提取过程内定义和使用信息，然后将其用于计算跨越过程边界的过程间定义使用对。 Pande等。 [1994]扩展了到达定义分析，以处理具有C语言单级指针的程序。该算法考虑了特定于程序点的指针引起的别名，并且具有多项式时间复杂度。<br>为了应对传统的穷举式和增量式数据流分析的复杂性，Duesterwald等人。 [1996，1997]提出了一种<strong>需求驱动的数据流分析技术</strong>，以在集成测试用于验证程序接口时辅助DFT。该分析是作为面向目标的搜索执行的，而不是使用详尽的信息传播。它可以在每个自下而上的集成步骤中高效地计算新建立的数据流信息，而无需在每个步骤之间存储到达定义解决方案。<br>Harrold and Rothermel[1994]扩展了面向对象语言的数据流分析，它不仅考虑了方法内的定义-使用关系（即，方法内部定义使用对），还通过实例变量（即方法间和类内部定义使用对）计算数据流关系。 Chatterjee和Ryder [1999]提出了一种基于指向分析的流和上下文敏感算法，以计算面向对象库的定义使用对。该算法解决了参数之间的未知混叠，参数的未知具体类型以及动态分配和异常的难题。 Souterand Pollock[2003]和Denaro等。[2008]也将经典的数据流分析<strong>扩展到了面向对象的程序</strong>，尤其是考虑了由类对象创建的上下文def-use对的构造。<br>为了提高静态def-use对分析的精度，Bod´ik等人。 [1997]提出了一种方法，通过利用在编译时可以检测到的一些不可行路径的信息来排除部分不可行的def-use对（请注意，识别所有不可行路径的问题尚不确定）。该方法检测静态分支相关性以标识不可行的程序子路径，然后排除跨越这些不可行子路径的定义使用对。该算法在过程内和过程间级别均以需求驱动方式实现，适用于回归测试和集成测试中的DFT。<br><strong>经典的数据流分析属于静态分析</strong>，在实践中可能必须通过别名分析以不同的精度级别（例如，对流和/或上下文敏感）进行增强。实际上，应该做出适当的近似以在精度和可伸缩性之间进行权衡。<br><strong>四、基于数据流的测试数据生成方法</strong><br>本节介绍了各种<strong>自动化基于数据流的测试数据生成的方</strong>法，这些方法对DFT的有效性和效率有很大的影响。从出版物存储库中，我们发现测试生成问题是数据流测试研究中最活跃的研究主题，并且在过去20年中一直受到关注。共有27篇技术研究论文与该主题相关。根据他们的测试技术，我们将它们分为五个主要组：<strong>基于搜索的测试，随机测试，基于抵押物覆盖的测试，基于符号执行的测试以及基于模型检查的测试</strong>。<br>我们计算了这些论文中使用的每种测试方法的百分比7（如图6所示）。我们发现基于搜索的测试方法（包括<strong>遗传算法和优化算法</strong>）是研究最广泛的方法，它占了近50％研究工作。基于抵押物覆盖的方法和随机测试也很流行。但是，很少研究更复杂的测试方法，例如符号执行和模型检查。<br>在下文中，我们将在独立的部分中详细介绍这些方法，从研究最广泛的到研究最少的部分，即基于搜索的测试（4.1节），随机测试（4.2节），基于抵押物覆盖率的测试（第4.3节），基于符号执行的测试（第4.4节）和基于模型检查的测试（第4.5节）。最后，在4.6节中讨论了其他一些方法。<br><strong>1. 基于搜索的数据流测试方法</strong><br>基于搜索的软件测试[Harman等。 [2015年]，作为基于搜索的一般软件工程领域的一个实例，在过去的几十年中一直受到广泛的研究兴趣。</p>
<h5>1.1基于搜索的方法原理</h5>基于搜索的方法包括各种**元启发式技术**[McMinn2004]，并利用它们来识别诸如测试用例生成之类的组合问题的解决方案。通常，测试数据生成的问题是无法确定的，但是可以将其**解释为搜索问题**，在该问题中，它会**从程序输入域中搜索所需的值来满足测试要求**。
<h5>遗传算法</h5>1975年提出的**遗传算法（GA）**[荷兰，1992年]是元启发式搜索技术的代表，它受到遗传学和自然选择的启发。在测试数据生成期间，GA从**一组候选个体（即测试用例）**开始，然后使用**搜索运算符**（例如选择，交叉和变异）来生成下一个有希望的测试用例。选择**从种群中选择有效的个体进行重组**（即交叉和突变）。两个独立个体之间的交叉产生了两个新的测试案例，这些案例共享了父母的遗传物质，而突变使部分人口的变化很小。
已经提出了几种**基于GA的测试方法**来解决DFT问题[Girgis 2005; Ghiduk等。 2007年； Vivanti等。 2013]。
（一）
Girgis [2005]首先使用GA进行数据流测试所有用途的覆盖范围。在Girgis [2005]中，GA使用**长度为m的二进制字符串s作为染色体（即测试用例）来表示输入变量的值**。假设被测程序有k个输入变量（例如v1，...，vi，...，vk，1ik），vi的输入范围是[ai，bi]，而di是期望的精度。vi的值。然后，通过公式建立从二进制字符串si到具有域[ai，bi]的变量值vi的映射：
![](/block_paper_1/20200402113226764.png)
其中vij是二进制字符串si的十进制值。以图3（第2节）中的程序为例，并假设x和y的输入范围分别为[-2，9]和[-4，13]。**染色体是长度为9的二进制字符串**，其中从左起的前4位代表x的值，接下来的5位代表x的值y。例如，二进制字符串s 010100110表示一个x 5和y 6的测试用例。在生成测试之前，GA使用Michalewicz [1994]提出的这种编码方法来生成测试用例的**初始填充**。
在Girgis [2005]中，GA**使用涵盖的def-use路径数与总的def-use路径数之间的比率作为适应度函数，该函数专门使用覆盖率信息来确定单个测试用例的有效性**。这种基于GA的方法的**工作原理**如下。首先，它生成一组以二进制字符串形式编码的测试用例。然后，它使用基于轮盘算法的选择方法[Michalewicz 1994]根据适合度的个体来选择有前途的个体。接下来，GA使用搜索运算符（即交叉和变异）产生新的选定亲本的染色体。在预定义的迭代次数之后，GA可以输出一组可以覆盖目标def-use路径的所需测试用例（由于此搜索问题的不确定性，可能仍然存在未发现的def-use路径）。
（二）
Ghiduk等[2007]后来发现，Girgis[2005]使用的适应度函数内部存在**一些缺陷**，这些缺陷可能过于粗糙，无法在以下情况下确定测试用例的接近性：（1）如果两个测试用例覆盖相同的数字对于def-use路径，它们将被赋予相同的适用性值；（2）如果一个测试用例没有涵盖任何def-use路径，则其适应性值将被赋予“ 0”。结果，当选择有前途的个体进行重组时，它可能会丢失有用的信息。为了解决这个问题，他们遵循Girgis [2005]中的类似程序，提出了一种**新的多目标适应度函数**。该功能根据其支配性（Lengauer和Tarjan 1979）与数据流需求的定义和使用之间的关系，来评估测试数据的适用性。特别是，它将def-use对视为**def和use这两个目标**。为了评估测试用例相对于目标def-use对的接近程度，它针对这两个目标使用了优势路径的遗漏节点。该功能的建立基于两个观察结果：（1）覆盖def的测试用例比不覆盖def和use或仅覆盖use的测试用例更近，以及（2）遗漏但包含但不存在的测试用例尝试覆盖def或使用比未命中且不尝试覆盖def或使用的测试用例更接近（尝试覆盖目标语句的测试用例意味着，在随后的搜索中，其变体接近目标。 ）。他们遵循这样一种测试方法：一次针对一个使用期限对，一次可以满足特定的测试要求。在评估中，他们发现这种GA方法比随机测试花费更少的搜索时间并且需要更少的程序迭代。但是，目前尚不清楚该技术在性能上比Girgis [2005]有多少，因为没有提供相关结果。
（三）
Vivanti等。[2013]使用遗传算法来处理**面向对象程序**的数据流测试。对于面向对象程序中的类测试，测试用例以一系列方法调用的形式表示[Tonella 2004]。按照对类进行测试的概念[Harrold andRothermel 1994]，他们确定了**三种def-use对：方法内对，方法间对和类内对**。他们使用**“节点-节点”适应度函数**[Wegener等。[2001]，其中搜索首先被导向到达第一个节点（即def节点），然后从那里导向到达第二个节点（即使用节点）。但是，作者发现，一次针对单个测试目标时，测试人员面临在所有测试目标之间合理分配测试资源的问题。此外，对于不可行的测试目标，将浪费在其上的测试资源。为了克服这些问题，他们没有使用一次一次定位一对对象的经典方法，而是将整个测试套件[Fraser andArcuri 2013]应用于数据流测试，从而优化了涵盖所有测试的测试用例集目标。预期该方法受不可行的测试目标的影响较小。通过对SF100类语料库的评估[Fraser和Arcuri2012]，他们确认数据流测试的测试目标远比分支测试的目标要大，但最终的测试套件在故障检测方面更有效。
（四）
Denaro等。 [2015]也使用类似的遗传算法在面向对象系统中使用基于数据流的测试数据来扩展**初始测试套件**。Liaskos等。 [2007]和Liaskos和Roper[2008]将GA与人工免疫系统（AIS）混合[Liaskos和Roper 2007]算法来完成针对Java库类的数据流测试。这种组合技术显示了其在提高测试性能方面的潜力。
（五）
Baresi等。开发基于GA的测试工具Testful [Baresi等。 2010; Baresi and Miraz 2010]，用于Java类的结构测试。这个GA变体使用了**多目标适应度函数**，并且在类级别以及方法级别上都可以工作。前者为类对象生成有用的状态，后者使用它们到达未发现的状态类中的代码。在Miraz [2010]中，Matteo应用了该GA变体来覆盖定义使用对。作者指出，对面向对象的程序明确使用def-use对通常会有所收获，因为它可以正确地关联通过交换数据（例如，对象的字段）相互协作的方法。其他工作包括Oster [2005]和Deng等。 [2009]，他们也使用GA来自动化数据流测试，但只评估了一些小例子。
还尝试使用基于优化的搜索技术来解决DFT问题。 Nayak和Mohapatra [2010]和Singla等。 [2011a，2011b]使用粒子群优化，而Ghiduk[2010]使用蚁群优化。受自然行为的启发，这些优化算法模拟了这些行为，以在DFT的上下文中找到最佳解决方案。但是，这些方法仅在玩具程序上进行了评估。它们在大型程序上的有效性仍不清楚。
<h5>1.2讨论</h5>基于搜索的技术已经被用于执行简单的覆盖标准（例如，语句和分支测试[Anand等，2013]）以及一些高级覆盖标准[Ammann等。 2003; Inc 1992]（例如逻辑覆盖率[Awedikian等，2009； Ghani和Clark，2009]）和数据流覆盖率，如前所述。这种方法将测试数据生成视为一个**域搜索问题**，因此，它在**解决非线性约束和查找浮点输入方面更有能力**[Lakhotia等。 2009年，2010年； Bagnara等。 2013]，而不是那些基于约束的方法（例如，符号执行）。
但是，仍然存在一些需要注意和研究的问题：首先，基于搜索的技术的**测试性能在很大程度上取决于基础的适应度函数**（可能需要很长时间才能找到好的解决方案），因此要足够谨慎在设计和优化中需要。其次，与遗传算法相比，一些基于优化的算法（例如，粒子群优化和菌落优化）研究较少，它们在现实程序中的**可扩展性**仍然不清楚。第三，尽管多目标适应功能[Lakhotia等。2007年； Fraser andArcuri 2013]可以减轻不可行对的影响，但仍然**无法检测到不可行对**。
**2. 基于随机测试的数据流测试方法**
随机测试[Bird andMunoz 1983]是使用最广泛且最具成本效益的测试方法之一。在其经典实现中，从程序**规范的值范围中随机选择测试输入**，然后针对测试中的程序执行测试输入。
这种经典的随机测试技术已被用作易于执行但相当有效的基线方法，用于几项工作中的数据流测试[Girgis 2005; Ghiduk等。 2007年； Su等。 2015]。对于面向对象的系统，测试用例是一系列的类构造函数调用和方法调用的序列[Pacheco等。 2007]。适应于随机产生这些序列以行使被测类别的随机测试也已用于数据流测试领域[Alexander等。2010;Denaro等。 2015]。此外，其他形式的随机测试[Girgis等。[2014]，例如，从程序图中随机选择测试路径以覆盖定义使用对（然后使用测试生成器从那些测试路径中导出相应的测试用例），用于实现数据流测试。
<h5>讨论</h5>随机测试具有成本效益低并且易于实现，但是只能区分**有限的程序行为集**。结果，在没有任何优化的情况下，随机测试通常**无法实现令人满意的数据流覆盖范围**。但是，借助一些优化技术，随机测试可以成为DFT的一种**竞争性测试**生成方法。
例如，研究人员发现，如果先前选择的测试无法揭示程序错误，那么应该选择新的测试，使其远离已执行的测试。
从而提高触发故障的机会。自适应随机测试[Chen2008; Ciupa等。 2008年； Lin等。 2009年； Arcuri and Briand 2011]，例如增强传统随机测试，将测试用例平均分布在其输入域中，可以提高数据流测试的效率。此外，反馈导向的随机测试[Pacheco等。 2007]）通过合并从创建测试用例时获得的反馈信息来改善随机测试，也可以使DFT受益。
**3. 基于抵押品覆盖率的数据流测试方法**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps:应该是附带覆盖的含义</span><br></pre></td></tr></table></figure>
在软件测试中，已利用抵押物覆盖范围来优化测试套件的生成[Harman等。 2010; Fraser and Arcuri 2013]。它基于以下观察结果：满足测试目标的测试用例可以**“意外地”涵盖其他测试目标**。因此，如果我们**排除这些涵盖的测试目标**，并将测试预算投入到其余未发现的目标中，则可以减少所得测试套件的大小以及测试执行和Oracle检查的成本。同样，在执行程序以满足给定的测试标准（例如分支覆盖范围）时，与**其他覆盖标准**（例如数据流覆盖范围）有关的测试目标也可能被意外覆盖，这是附带覆盖的另一种形式[Malevris and Yates 2006]。
形式上，如果对于所有程序P，满足P的所有测试目标（针对C1）的测试用例也满足针对C2的那些测试用例，则测试标准C1包含另一个标准C2。例如，下图（在Rapps和Weyuker [1982，1985]中给出）显示了**不同测试覆盖率标准之间的包含关系**。8箭头尾部的标准包含了箭头头的标准（例如，分支标准包含了）声明标准）。由于包含关系是传递性的，因此它实际上定义了各种覆盖标准之间的关系。阴影标准是七种类型的数据流测试标准（有关详细定义，请参见Rapps和Weyuker [1982，1985]），这些标准强调了行使定义-使用关系的不同方法。所有用途的覆盖范围是所有实际用途的覆盖范围（请参阅第2.1节中的定义2.2），它包含所有c用途和所有p用途覆盖范围。此外，所有用途的覆盖范围也包含分支机构的覆盖范围。
![](/block_paper_1/20200402022553498.png)
**尝试基于附带覆盖的想法来解决数据流测试**
（一）
ing[Malevris and Yates 2006; Santelices和Harrold 2007；梅洛和安东尼奥1999；
Marre和Bertolino 1996，2003;Santelices等。2006]。 Malevris和Yates[2006]在打算进行分支测试时研究了数据流覆盖的水平。在实证研究中，他们从控制流图中选择路径，以用不同的编程语言（包括Fortran，Pascal，C和Java）编写的59个单元来满足所有分支的覆盖范围，并**衡量同时实现的数据流覆盖范围到七个数据流标准**（上图中的阴影）。在他们的实验中，执行分支测试并选择平均每单位6.44条路径时，平均可以实现超过35％的所有du路径覆盖和超过40％的所有用途覆盖。该研究还表明，可以**将实际数据流覆盖范围建模为一个函数**，该函数将有关分支测试的选定路径数和其中的可行路径数作为参数。此外，他们还发现（1）数据流覆盖范围与单位使用的语言无关；（2）可以根据抵押覆盖范围来估计DFT所需的可能的测试预算，以及（3）在数据流测试之前进行分支测试可能更具成本效益，因为在分支测试期间将涵盖部分使用数据对。
（二）
Merlo和Antoniol [1999]利用def-use对和节点（即语句）之间的覆盖率含义来实现过程内数据流测试。前支配器和后支配器分析用于识别一组节点，这些节点的覆盖范围可能暗示def-use对子集的覆盖范围。他们在16KLOC Gnu查找工具上评估了该方法，发现当覆盖每个例程的节点时，平均而言，肯定有75％的def-use对被覆盖。
（三）
Santelices等。[2006]提出了一种**基于谓词条件的任何类型的程序实体（例如分支，定义使用对和调用序列）的包含算法**。此谓词条件是路径条件的特殊形式[Robschink and Snelting 2002]，从系统依赖图计算得出，以表示实体对其覆盖范围的必要但不充分的条件。构建包括每个实体的所有这些谓词条件的表，以创建实体的包含关系以进行有效的覆盖范围跟踪。
后来，Santelices和Harrold [2007]提出了一种**从分支结构覆盖范围自动推断数据流覆盖范围的方法**。在静态分析阶段，使用可推断性分析将def-use对分为三类：可推断的（覆盖范围始终可以从分支覆盖范围中推断出来），有条件的可推断性（可以从某些但不是全部的分支覆盖范围中推断出覆盖范围）程序执行）和不可推断的（无法从分支覆盖率推断出覆盖率）。在动态测试套件执行阶段，将针对三种类型的实体记录分支覆盖范围：定义，用途和定义用途对的销毁。最后，覆盖率跟踪阶段将静态和动态分析的结果作为输入，并报告已明确覆盖，可能覆盖或未覆盖的def-use对。尽管这种方法可能会损失一些覆盖精度，但是显着的好处是，由于该程序是在分支覆盖级别而不是数据流覆盖级别进行检测的，因此可以大大减轻覆盖跟踪的开销。
（四）
Marre和Bertolino [1996，2003]提出了一种方法，用于识别最小数量的def-use对，以便覆盖这些对的路径可以覆盖程序中的所有对。换句话说，可以通**过集合中那些对的覆盖范围来推断集合外的那些对的覆盖范围**。该集合称为扩展集合，其中的对称为无约束对。该集合的基数实际上是实现所有用途覆盖范围所需的测试套件大小的上限。结果，它可以帮助估计数据流测试的成本。 Harrold等。[1993]提出了一种从测试套件中生成具有代表性的测试用例集的技术，该方法可以达到与原始整个测试套件相同的覆盖率。该技术通过利用抵押物覆盖范围来最小化测试套件的大小，并且独立于测试方法。它仅需要测试需求和满足以下条件的测试案例之间的关联这个要求。对数据流测试的评估表明，该技术可以有效地删除多余的测试用例，但又不影响覆盖率，这在回归测试中特别有用，可以降低测试成本。
<h5>讨论</h5>借助现有的测试数据，基于抵押物覆盖范围的方法在数据流测试中具有多个优点：（1）仅考虑非约束对，它可以减少测试套件的大小以及开销。覆盖范围跟踪； （2）可以通过无约束对的数量来估计应该分配多少测试预算； （3）它可以帮助理解程序中不同级别的实体（例如，语句，分支和def-use对）之间的关系。
但是，由于此方法**使用低级程序实体（例如，语句或分支）的覆盖范围来推断高级实体（例如，def-use对）的覆盖范围**，因此可能无法为其覆盖范围不易推断。而且，它也不能区分不可行的对。
**4. 基于符号执行的数据流测试方法**
符号执行由金[1976]首次提出，是一种经典的程序分析技术，已**广泛应用于软件测试**中[Cadar andSen 2013]。
**符号执行原理**
符号执行**使用符号值而不是具体值作为程序输入**。结果，由这些**输入组成的符号表达式可用于表示程序变量的值**。在符号执行期间，程序状态在任何时候都包括（1）程序变量的符号表达式（值），（2）符号输入上的布尔约束形式的路径约束（pc），需要满足以下条件：到达该程序点，并且（3）一个程序计数器，表示要执行的下一个程序语句。
该技术的**工作原理**如下：在执行过程中，将使用每个分支点上输入的新约束来更新pc。如果新PC不满足要求，则将停止对相应路径的探索。否则，执行将沿着该分支点继续，这样pc的任何解决方案都将执行相应的路径。特别是，当条件语句的两个方向（即分支）都可行时，路径探索将继续进行下去。搜索策略[Cadar等。 2008年； Burnim and Sen 2008； Cadar等。 2006]将被指定搜索方向的优先顺序。符号执行的这种经典方法也称为静态符号执行（SSE）。在图8中，我们说明了在图3（第2节）中的示例程序上的符号执行。在这里，探索了三个程序路径，并通过**解决所收集的路径约束来生成测试输入**（如图8（a）所示）。执行树在图8（b）中给出。
![](/block_paper_1/20200402023706520.png)
**基于静态符号执行的方法**
Girgis [1993]首先使用了类似的静态符号执行系统来生成基于数据流的测试数据。该方法首先从被测试程序的CFG到特定的控制流标准（例如分支覆盖范围）生成一组程序路径。由于来自CFG的循环可能会生成无限的程序路径，因此它通过使用称为ZOT子集的路径子集，通过要求路径遍历循环零次，一次和两次来近似整个路径空间。然后，将重点放在可以覆盖感兴趣的def-use对的那些可执行路径上。在该系统中，测试人员可以通过检查沿该路径收集的路径约束是否可满足来确定路径可行性。通过**解决可行路径的路径约束，该系统可以生成满足给定数据流测试标准的测试套件**。
对于图3中的示例程序，该方法首先相对于控制流标准（例如分支覆盖）静态地探索尽可能多的路径。假设它找到一个静态路径p = l4，l5，l8，l9，l10，l11，l9，l13，l18。在此，p遍历循环（位于19和12之间）一次并静态覆盖dua（l10，l18，res）。对应的pc（即y==1 y> 0）的解（x›→0，y›→1）可以满足该对。
**基于动态符号执行的方法**
Godefroid等。 [2005]和Sen等。 [2005]**将符号执行与具体执行交织**在一起，以提高静态符号执行的可伸缩性。这种混合技术（称为**动态符号执行或约束测试**[Godefroid et al。2005; Sen et al。2005]）沿执行路径（与静态符号执行相同）收集路径约束，该约束由具体程序触发输入。如果路径约束变得过于复杂并且超出了约束求解器的范围，则可以使用这些具体值通过值替换来简化它。
Su等。 [2015]首先采用了这种**动态符号执行技术**，以在称为CAUT的DSE引擎之上进行数据流测试。 2009年； Yu等。 2011; Sun等。 2009年； Su等。 2014]。在他们的方法中，数据流测试被视为目标搜索问题。它首先找出一组切点，任何切入点都必须经过这些切点才能覆盖一对定义使用对。这些切点可以缩小路径搜索空间，并引导路径探索尽快到达该对。为了进一步提高测试性能，它使用了有向符号执行方法的最短距离分支优先启发式方法（优先级最高的指令距离指定目标的分支方向）[Zamfir andCandea 2010; Ma等。 2011]）和重新定义路径修剪技术（def和使用之间的子路径上不能出现重新定义）。
对于图3中的示例程序，假设目标def-use对为du（8,17，res）。DSE通过获取任意测试输入t开始，例如，t=（x›→0，y›→42）。这个测试输入触发执行路径p
![](/block_paper_1/20200402024221388.png)
它已经涵盖了du1的定义。为了涵盖其使用，经典的DSE方法
（例如，使用深度优先或随机路径搜索[Burnim and Sen 2008]），系统地对p上的分支节点进行翻转，以探索新路径，直到覆盖使用为止。但是，路径爆炸的问题（路径p上的数百个分支节点（包括来自p的新生成路径的节点）可以翻转为派生新路径）可能会使探索非常缓慢。
![](/block_paper_1/20200402024437802.png)
**讨论**
经典的符号执行是**基于路径的测试方法，可以系统地探索路径以覆盖目标定义使用对**。在早期工作中[Girgis 1993]，Girgis使用控制流标准作为覆盖率度量标准来指导路径探索，这可以缓解路径爆炸问题，但**可能会带来无法覆盖某些使用期限对**的风险。例如，图8（a）中的三个路径已经覆盖了功能函数中的所有分支，但是不满足使用定义对du（l10，l17，res）（新的测试输入（x 1，y 1））对应于路径l4，l7，l8，l9，l10，l11，l9，l13，l14，l17的路径可以覆盖这对）。原因是控制流准则可能不包含数据流准则。此外，使用符号推理时，经典的符号执行必须做出一些近似，这**可能会丢失数据流测试的精度**。例如，当x的具体值未知时（一种方法是将a[x]视为整个数组的使用a）。相反，基于动态符号执行的方法可以更加精确和高效。例如，使用动态执行信息可以更轻松，更准确地检测到由别名引起的变量重新定义，并且动态程序执行比静态程序执行快得多。
但是，基于SSE的方法和基于DSE的方法都无法识别不可行的对，因为基于符号执行的测试是基于显式路径的方法，在所有程序路径都被确定之前，无法得出对的可行性的结论。探索。在没有关于目标对是否可行的事先知识的情况下，这些测试方法可能徒劳地花费大量时间来覆盖不可行的对。
**5. 基于模型检查的数据流测试方法**
**模型检查原理**
模型检查[Clarke等。 [1999]是一种经典的形式验证方法。**进行属性检查时，模型检查器可以构造见证人或找到反样本。**在较高的层次上，模型检查器将系统规范和感兴趣的属性作为输入；然后检查是否违反了该属性。如果该属性被违反，则会生成一个反例来证明该违反。否则，该财产被认定为满意（即未违反）。结果，这种模型检查方法可用于测试目的[Fraser等。 [2009]，尤其是当这些反例被解释为测试用例时，这可以帮助分析人员识别并修复故障。
**基于WCTL的模型检查**
![](/block_paper_1/20200402025101268.png)
![](/block_paper_1/20200402025132180.png)
**讨论**
这种基于Kripke结构的模型检查方法具有以下优点：（1）由于它适用于**抽象模型**，因此该方法与语言无关。它甚至可以扩展规范模型上的数据流测试[Hong等。 2000;乌拉尔等。 2000]。（2）这种方法将数据流测试问题转化为**模型检查问题**，这可以从模型检查器的未来发展中受益。
但是，它也可能会受到一些限制：（1）从理论上讲，此方法中最常用的定义使用对数可以是O（n2），其中n是图中顶点（即语句）的数目G。因此，相对于G，公式的数量可以是二次的。如果将其应用于基于过程间程序的测试，则由所有函数构建的整个图G将包含大量顶点。此方法的**可伸缩性**可能会受到影响。（2）此外，这种方法无法轻松检测不可行的对，因为它所基于的抽象模型并不了解潜在的路径约束。
**基于CEGAR的模型检查**
另一种软件模型检查方法称为CounterExample-Guided基于**抽象提炼**（CEGAR）模型检查[Ball and Rajamani2002; Henzinger等。 2002年；Chaki等。 [2003年]是在2002年提出的。给定程序源代码和时间安全规范，CE-GAR**要么静态地证明程序满足该规范，要么生成一个程序。**
反例路径以证明违规。从那时起，它被应用于自动检查OS设备驱动程序的安全属性[Ball and Rajamani 2002; Beyer等。 2007年； Beyer和Keremoglu 2011]以及生成测试用例[Beyer等。 [2004]。
Beyer等。[2004]提出了一种基于CEGAR的两阶段方法，即从反例进行模型检查和测试，以自动生成结构测试用例。它首先检查感兴趣的程序位置q是否可到达，以使q处的谓词p（即安全性）为真。从在q处显示p的程序路径，基于CEGAR的模型检查器可以生成一个测试用例，以证明p在q处的真相。类似地，它也可以产生一个测试用例，以表明p在q处的虚假性。如果在谓词p设置为true的情况下检查了所有程序位置或分支，则可以很好地实现语句或分支的覆盖范围。
Su等。[2015]进一步调整了这种基于CEGAR的模型检查方法，以针对所有使用定义标准进行数据流测试。提出了一种简单但功能强大的程序转换方法，将测试需求直接编码到被测程序中。它将原始程序P插入Pj，并将数据流测试的问题减少到对Pj的可达性检查。在目标定义使用对的定义位置之前，引入了一个变量cover_flag并将其初始化为false。该标志在def之后立即设置为true。为了找到从def位置到使用位置的def-clear路径，在相同变量的其他定义之后，将cover_flag变量立即设置为false。在使用之前，它将目标谓词p设置为cover_flag true。结果，如果可以到达使用位置，我们将得到一个很好的例子，并得出结论，该对在测试案例中是可行的。否则，将证明该对是不可行的（或者，由于问题无法确定，该算法不会在受约束的时间预算内终止，并且会将结果报告为未知）。
对于图3中的示例程序以及方程式（1）中的两对du1和du2和（2），用这两个测试要求编码的转换程序分别如图10（a）和图10（b）所示。对于du1（18,17，res）对，图10（a）在突出显示的语句中显示了du1的变换函数功效和编码测试要求。变量cover_flag在l2处引入。初始化为false并在l7的def之后立即将其设置为true，并在l10的变量res的其他定义之后立即将其设置为false。在使用之前，在14点设置检查点以验证cover_flag是否可以为true。如果检查点不可达，则可以证明这对不可行。否则，可能会产生反例（即涵盖该对的测试用例）。在该示例中，模型检查器可以找到可能的路径l2，l3，l4，l6，l7，l8，l9，l13，l14，l16，l17。但是对于图10（b）中的du2（l8，l18，res）对，模型检查器可以快速得出结论：没有路径可以到达检查点并见证cover_flag的真实性。因此，du2是不可行的。
**讨论**
这种基于CEGAR的模型检查方法具有以下优点：（1）数据流测试问题可以轻松**转换为路径可达性检查问题。** CEGAR可以为可行的def-use对生成反例（即测试用例），还可以检测没有误报的不可行对。这项技术本身甚至可以受益于基于CEGAR的模型检查器的未来发展。 （2）在CEGAR中，可以**将测试要求直接编码到被测程序中**，而无需手动编写诸如CTL / WCTL公式的时间属性。与其他基于模型检查的方法相比，它更加灵活且易于实现。
但是，一般而言，CEGAR无法确定所有def-use对的可行性，因为检查路径可行性本身的问题尚不确定。在这种情况下，CEGAR可能不会终止，只能得出未知结论。另外，CEGAR本质上是静态方法。生成可行对的测试用例时，其**测试性能可能不及其他动态测试方法**（例如，基于动态符号执行的方法[Su等人2015]）高。
**6. 其他方法**
Khamis等。 [2011]增强动态域减少程序[Offutt等。 1999]（DRR）对Pascal程序执行数据流测试。 DDR技术基本上**集成了符号执行和基于约束的测试的思想**。它从输入变量的初始域以及程序流程图开始，并通过指定的路径动态驱动执行，以达到目标测试目标。在路径探索过程中，采用符号执行来减小输入变量的范围。然后使用搜索算法来找到可以满足路径约束的一组值。作者还通过一些处理循环和数组的方法来增强此技术。但是它仅通过一些概念证明示例来说明该想法，其实用性尚不清楚。
Buy 等。 [2000]结合数据流分析，**静态符号执行和自动演绎来执行数据流测试**。符号执行首先确定类中每种方法的输入和输出值之间的关系，然后从可行且清晰的路径（包括目标对）收集方法的前提条件。后来，使用一种自动向后推导技术来找到满足这些先决条件的方法调用（例如，测试用例）的顺序。但是，几乎没有证据表明这种方法的实用性。后来，Martena等人。 [2002]将该技术从单个类扩展到多个类，即测试类间的交互。它从简单的类到更复杂的类逐步生成测试用例。
Baluda等。 [2010]，Baluda[2011]和Baluda等人。 [2011]提出了一种称为抽象提炼和粗化（ARC）的新颖方法，通过**识别不可行的分支来提高分支覆盖率测试的准确性**。这种方法源于属性检查算法[Beckman等。 2008年； Gulavani等。 [2006年]，其目的是证明错误的陈述不可达或产生执行该陈述的测试用例。 Baluda等。将该算法用于结构测试并通过“粗化”对其进行增强，以提高其可扩展性。 Baluda [2011]声称这种方法独立于覆盖标准，并且特别适用于这样的覆盖标准，这些覆盖标准由于存在不可行的测试目标（如数据流测试标准）而遭受了极大的折磨。
<hr>
**总结**
尽管在识别基于数据流的测试数据方面遇到了许多挑战，但研究人员已经开发出各种使该过程自动化的通用方法。**基于搜索的测试和基于附带覆盖的测试是用于自动生成测试数据的两种研究最为广泛的技术**（如图6所示）。合理的解释是，这两种技术对于DFT而言**相对容易实现**。基于符号执行和基于模型检查的技术相当早就引起了人们的注意，但是直到最近它们还没有应用于大型的现实程序，而仅应用于实验室程序。这些技术比其他方法**更难以实施，而且在很大程度上依赖于其他技术的进步**（例如约束解决），这一事实可以解释这种现象。另外，对于过程语言（例如，C）和面向对象的语言（例如，Java），都存在几种学术工具。但是，根据我们的调查，仍然**没有支持DFT的商业工具**。开发高效且易于实现的技术需要付出更多的努力。
我们还需要注意的是，由于存在根本的不确定性问题，**没有任何现有的测试技术能够可靠地识别出不可行的线对（其他结构测试也是如此）**。当应用其中任何一个时，一个人可能总是无法覆盖某些对，并且不知道是因为没有进行足够的测试还是因为它们永远无法覆盖。
**五、覆盖跟踪的方法**
本节讨论了现有文献中用于**跟踪数据流覆盖范围**的一些方法，并总结了可用的数据流覆盖范围工具。
**1. 覆盖跟踪技术**
测试覆盖率是衡量**软件测试的彻底程度以及软件开发人员对其可靠性的信心程度**的常用工具。几种技术[Frankl 1987; Ostrand和Weyuker 1991a； Horgan and London 1992； Misurda等。 2005b； Santelices和Harrold 2007； Harrold和Soffa（1994）的开发是为了追踪def-use对的覆盖范围。
（一）
弗兰克（Frankl）（1987）提出了一种基于确定性有限自动机的方法来跟踪定义使用对的覆盖状态。在她的方法中，一对du与一个正则表达式相关，该正则表达式描述了覆盖它的控制流路径。与du关联的每个自动机都针对所有执行路径进行检查。一旦某个路径被某个自动机接受，就将du对设置为覆盖。但是，当被测过程递归调用自身时，此方法必须进行特殊处理。 
（二）
Ostrand和Weyuker [1991a]使用记忆跟踪技术来精确确定覆盖了哪些对，而Kamkar等人（1991年）则采用了这种方法。 [1993]使用动态切片来提高覆盖精度。一些工作[Harrold and Malloy 1992; Su等。 [2015]利用动态数据流分析提高跟踪数据流覆盖率的精度。
（三）
Horgan和London [1992]利用代码工具来跟踪DFT覆盖范围，此后称为最后定义技术。在他们的方法中，从数据流图生成一张停用关系表，并在每个代码块处插入一个探针。运行时例程记录每个已定义的变量以及定义该变量的块。执行使用该已定义变量的块时，将验证该变量的最后定义，并将该对设置为覆盖。
（四）
Misurda等。 [2005b]提出了一种以需求为导向的策略来跟踪def-use对的覆盖，其目的是提高静态检测方法的性能（例如Horgan和London [1992]）。该方法的工作方式如下：首先，确定测试区域中的所有可变定义，并将种子探针插入其位置；第二，达到定义后，将按其所有可能的用途按需插入覆盖范围探针；第三，达到用途后，将立即删除该用途的探测，并将由最近访问的定义和该用途组成的配对标记为已覆盖。
（五）
Santelices和Harrold [2007]开发了一种有效的基于矩阵的策略来直接跟踪数据流覆盖范围。在此策略中，将创建一个coverage矩阵并将其初始化为零，其中每一列代表一个变量用途（与用途ID关联），并且列中的每个单元格记录该用途的定义（与定义ID关联）（也就是说，一个单元对应于一个def-use对。在这种结构中，可以通过使用ID和定义ID快速访问矩阵单元，以减少探针的运行时成本。在运行时，探针跟踪变量的最后定义。每次使用时，都会插入一个探针，该探针使用用途ID和最后定义ID更新矩阵中该对的覆盖状态。
在Santelices和Harrold [2007]中，设计了一种新颖的覆盖率推断策略，该策略使用分支覆盖率来推断数据流覆盖率。通过在动态执行之前使用静态分析，将对分为树类型，即可推断的，有条件可推断的和不可推断的对。在运行时，此方法跟踪分支覆盖，这是一种成本较低的代码工具。**测试套件执行后，它输出实际覆盖和有条件覆盖的对**。有关详细信息，请参阅第4.3节中基于抵押物覆盖率的测试方法。
为了使覆盖范围跟踪更具可扩展性，Harrold [1994]开发了一种在多处理器系统上接受测试的技术，并产生了可并行的覆盖范围跟踪工作量。工作负载可以静态或动态地调度到不同的平台上。对多处理器系统的评估表明，与单处理器系统相比，它具有良好的加速性能。
**讨论**
数据流覆盖在跟踪其覆盖范围时会**增加高昂的开销**。主要原因是：（1）基于数据流的**测试目标通常比语句或分支要多得多**；（2）数据流覆盖范围将约束（即，满足清晰清晰的路径）置于**程序路径**上，而不是简单地编写程序实体，这会使跟踪更加昂贵。现有方法主要诉诸有效的数据结构或利用覆盖推断来减轻开销。
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 覆盖到底指的是什么呢</span><br></pre></td></tr></table></figure>
**2. 覆盖工具**
有很多健壮的覆盖工具[Yang等。 [2009年]进行报表和分支机构的覆盖，但是只**有少数几个可用于数据流覆盖**。表一总结了用于数据流测试的覆盖工具，包括ASSET [Frankl and Weyuker 1985;弗兰克（Frankl）等人。 1985年；弗兰克（Frankl）1987； Frankl和Weyuker 1988年（第一个数据流覆盖工具），ATAC [Horgan and London 1992年]，Coverlipse，DaTec[Denaro等人。2008，2009]，DuaF [Santelices andHarrold 2007]，TACTIC [Ostrand and Weyuker 1991b]，POKE-TOOL [Chaim1991]，JaBUTi [Vincenzi等。 2005]，JMockit和Jazz [Misurda等。2005a]，DFC[Bluemke和Rembiszewski 2009、2012]和BA-DUA [Chaim和de Araujo2013a；de Araujo and Chaim 2014]。对于每种工具，该表列出了其支持的语言，是否跟踪过程内或过程间对或两者，基于它的分析基础结构，所使用的覆盖率跟踪技术及其可用性。在总共12种工具中，有6种是公开可用的，但它们都不是商业工具，Hassan和Andrews[2013]以及de Araujo和Chaim [2014]最近也对此进行了报道。
![](/block_paper_1/20200402031648506.png)
**六、近期进展**
本节讨论数据流测试的最新进展的三个方面：（1）新的覆盖标准，（2）动态数据流分析和（3）有效的覆盖跟踪。
**1. 新的覆盖标准**
Hassan和Andrews[2013]引入了一个新的覆盖标准系列，称为多点跨度覆盖率（MPSC）。具有间隙g和p点的MPSC的仪器记录所取分支的元组（b1，b2，...，bp）的覆盖范围，其中元组中的每个分支是在前一个之后的g个分支。经验评估表明，从分支机构的覆盖范围概括出的MPSC覆盖范围，在衡量测试有效性时，可以达到比所有常规使用覆盖范围更高的准确性。而且MPSC覆盖的工具也比数据流覆盖的工具更有效。
亚历山大等。 [2010]扩展了经典的数据流标准，以测试和分析面向对象系统中的多态关系。新的覆盖标准考虑了类的状态变量之间的定义和使用，特别是在存在继承，动态绑定以及状态变量和方法的多态覆盖的情况下。目的是提高面向对象程序中DFT的故障检测能力。
**2. 动态数据流分析**
 Denaro等。 [2014]和Vivanti [2014]研究了DFT中使用的传统静态数据流分析的局限性。他们使用动态数据流分析技术，通过**观察具体的程序执行来识别相关的数据流关系**。这种方法利用了可从具体执行中获得的精确别名信息，以将内存数据和类状态变量相互关联。结果，它比考虑静态计算的别名关系要精确得多。
对五个Java项目的评估表明，传统的静态数据流分析遗漏了大量数据流关系，这破坏了以前DFT方法的有效性。这种动态技术为数据流测试的新方向提供了启示，该方向可以更好地涵盖基于数据流的测试目标。
Denaro等。 [2015]将该动态数据流分析技术调整为测试面向对象的系统。这种方法不是先验地计算所有对，而是运行一些带有动态分析的测试，合并跟踪以推断从未执行过的对，生成新的测试以覆盖它们，然后进行迭代，直到找不到新的东西为止。结果比现有分支机构覆盖率测试套件的变异分数高出约30％。
**3. 高效的覆盖率追踪**
阻碍DFT广泛采用的一个因素是通过测试跟踪def-use对的覆盖范围的成本。由于DFT旨在实现更全面的程序测试，因此由代码工具施加的运行时成本大大高于其他结构标准。一些技术[Misurda等。 2005b； Santelices和Harrold [2007]提出了基于昂贵的计算和数据结构来解决此问题的建议。
Chaim andAraujo [Chaim anddeAraujo 2013a; 1998年；对数据流问题的经典解决方案（例如，达到定义[Aho et al。1986]）的启发。 de Araujo and Chaim 2014]发明了一种按位算法（BA）算法，该算法使用具有按位运算的位向量来跟踪Java字节码程序的数据流覆盖率。对于每条指令，此方法都使用已知的数据流分析技术来计算定义和使用的变量（局部变量或字段）。之后，它将在每个指令（或块）处检测BA代码，该代码用于确定线对的覆盖范围。 BA代码跟踪三个工作集，即活动对，覆盖对和当前困对，它们在测试执行期间进行更新。这些工作集以位向量实现，并通过有效的按位运算进行操作，其大小由被测方法对的数量给出。
作者还给出了正确性证明[Chaim and de Araujo 2013b]和理论分析，表明他们的算法比以前的需求驱动和基于矩阵的方法[Misurda等人，要求的内存和执行时间更少。 2005b； Santelices and Harrold 2007]。在他们的评估中[Chaim and de Araujo 2013a]，通过模拟这些仪器策略进一步证实了这一结论[Chaim等。 2011]。在de Araujo和Chaim [2014]中，此方法适用于处理具有200KLOC和300K对的大型系统，其执行开销可与流行的控制流测试工具强加。
**七、应用领域**
本节讨论了DFT应用程序的三个方面：（1）软件故障定位，（2）Web应用程序测试和（3）规范一致性检查。
**1. 软件故障定位**
在程序调试中，软件故障定位是一项繁琐且耗时的工作，以查找程序错误和错误。 Agrawal等。 [1995]提出了一种将DFT和执行切片结合在一起以实现更有效的故障定位的新颖方法。他们的工作基于这样一个假设，即错误在于测试用例的一部分，该部分无法执行而不是成功执行。结果，测试人员可以将语句集中在失败的片段上。称为ATAC的数据流测试工具[Horgan and London 1992]用于生成数据流测试。这些测试后来被用来检测种子故障并从Unix排序程序中计算执行片段。他们发现数据流测试可以有效地检测出那些种子错误，并且骰子可以显着提高故障定位性能。
Santelices等。 [2009]提出了一种轻量级的故障定位技术，该技术使用不同的覆盖标准来检测程序中的可疑错误语句。在他们的方法中，他们使用针对轻量级覆盖实体（包括语句，分支和def-use对）的测试来调查不同覆盖类型在故障定位中的好处。研究表明，通过不同的覆盖类型可以发现不同的故障，但是将这些不同的覆盖类型进行组合可以实现总体最佳性能。
**2. Web应用测试**
近年来，网络应用的快速发展丰富了人们的日常生活。但是，当体系结构和实现变得越来越复杂时，测试Web应用程序将变得艰巨。已经做出了一些努力来针对Web应用程序进行数据流测试。
由于Web应用程序中的数据可以存储在HTML文档中，因此可能会影响服务器和客户端之间的数据交互。刘等。 [2000]扩展了DFT方法用于Web应用程序，以检查此类数据交互的正确性。在他们的方法中，他们提出了一个Web应用程序测试模型来描述被测应用程序，并提出了一种DFT结构模型来捕获数据流信息。在WATM中，应用程序中的每个部分都将被建模为一个对象，该对象可以是HTML文档的客户端页面，Common GatewayInterface脚本的服务器页面以及Java applet或ActiveX工具的组件等等。这些模型中的每个模型都由属性和操作组成，以存储基本信息。 DFT结构模型使用四个流程图来捕获相关的数据流信息。在获得数据流信息之后，将生成测试用例以涵盖对象内，对象间和客户间方面。通过这种方式，DFT被扩展为测试Web应用程序。
Qi等。[2006]开发了一种基于多重代理的DFT方法来测试Web应用程序。他们将测试任务分为三个级别：方法级别，对象级别和对象群集级别。这些级别的每个测试代理将构建一个带有数据流信息的相应程序模型。数据流测试的整个任务可以分为子任务，并由这些测试代理执行。
Mei等。 [2008]利用DFT测试面向服务的工作流应用程序，例如WS-BPEL应用程序。他们发现XPath在工作流集成中起着重要作用，但可能包含从XML消息中提取的错误数据，这破坏了这些应用程序的可靠性。因此，他们将XPath重写图开发为一种数据结构，以对WS-BPEL中的XPath进行建模。然后，他们从概念上确定了XRG中的def-use对，并提出了一组数据流测试标准来测试WS-BPEL应用程序。
Alshahwan和Harman [2012]提出了一种基于状态的DFT技术用于Web应用程序，该技术会生成HTTP请求的新序列，以增强现有测试套件的覆盖范围和故障检测。新测试旨在执行状态变量（例如，会话变量）的定义，并确保这些值不变地达到相应的用途。他们发现，结果测试套件确实可以提高测试套件的质量。
**3. 规格一致性检查**
在软件开发中广泛使用各种规范模型来构建可靠的系统，这有助于自动生成一致的实现。因此，**检查模型的一致性**是确保实现正确性的重要手段。 Wang和Cavarra [2009]提出了一种基于DFT的方法来检查需求模型的一致性。该方法可以概括为四个过程：
（1）根据系统需求构建需求模型；（2）构建相关的调用序列以覆盖这些模型中的方法间用法；（3）从这些调用序列中获取布尔约束，并得出测试套件；（4）检查模型con -通过应用基于DFT的测试套件来保持一致性。此外，开发人员可以通过检查此测试套件将其最初的理解与要求进行比较。
还有一些工作可以从诸如SDL（规范和描述语言）之类的规范模型中生成基于数据流的测试套件。 2000]和状态图[Hong等。 2000]。生成的测试套件提供了测试实现是否符合高级规范模型的功能。
**4. 其他应用**
DFT也已应用于测试其他程序或应用程序。 Zhao [2003]使用DFT**测试面向方面的程序**。 Harrold和Malloy [1992]使用DFT**检查并行化的代码**。 DFT也已应用于**测试面向对象的库**[Chatterjee and Ryder 1999]和**服务编排**[Mei等。 2009]。
此外，我们调查了已应用DFT的每种语言的百分比（如图11所示）。我们可以观察到以下情况：首先，DFT最初应用于过程语言（例如Fortran，Pascal，C），但是近年来，面向对象的程序得到了更多的重视，因为DFT可以在检查对象状态时帮助发现更多细微的错误。。其次，在执行数据流测试时，面向对象的语言（例如C ++和Java）是最受欢迎的语言。第三，规范语言和Web服务也吸引了研究兴趣。
图12显示了1990年以来出版物每年报告的评估程序数量（我们在1990年之前省略了论文，因为它们主要关注理论和形式分析）。我们可以观察到（1）DFT在在过去的10年中，受评估程序的数量不断增加，并且（2）DFT逐渐应用于除实验室程序之外的实际程序。此外，我们发现数据流分析和覆盖跟踪技术（最大规模为200KLOC）比测试生成技术（最大规模为15KLOC）具有更高的可扩展性。这表明需要更多的研究工作来缩小这一差距。
**八、新见解和未来工作**
本节介绍了我们在此次调查中获得的新见解。遵循DFT的三个基本测试过程，即数据流分析，测试数据生成和覆盖率跟踪，我们建议以下未来研究方向。
**数据流分析：数据流分析负责识别使用定义对**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)	为了更好地涵盖测试目标，可以将已知的静态数据流分析技术与动态数据流分析技术相结合[Denaro等。2014、2015]，并在可扩展性和精度之间取得平衡。</span><br><span class="line">(2)	数据流分析过程可以利用抵押物覆盖的概念来推断在def-use对本身之间或在def-use对与其他程序结构（例如，语句和分支）之间的覆盖关系。目的是确定对最小的对，其覆盖范围暗示其他对的覆盖范围，以便数据流测试可以专注于这些关键对，从而可以降低测试成本。</span><br><span class="line">(3)	数据流分析技术的类型应根据测试方案确定。例如，对于单元测试，可以使用传统的详尽数据流分析。但是对于回归测试或集成测试，需求驱动的数据流分析技术更合适，因为它可以避免不必要的开销。</span><br><span class="line">(4)	可以开发新的数据流分析技术并将其适应于不同的编程语言。例如，过程语言和面向对象语言在def-use对的构造上有很大不同。</span><br></pre></td></tr></table></figure>
**测试数据生成：测试数据的生成旨在有效地为def-use对生成合适的测试用例。**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)	可以组合各种动态测试方法，包括随机测试，基于遗传/优化的测试和基于符号执行的测试，以满足定义使用对。尽管它们无法处理不可行的配对，但它们在测试生成方面具有不同的优势。</span><br><span class="line">(2)	基于模型检查的方法可用于补充动态测试方法。它可以为可行的de-use对生成测试，并处理不可行对的一部分。可以将成对的测试需求转换为可接受的模型检查器形式，然后可以使用模型检查器检查路径可行性并作为测试用例输出反例。</span><br><span class="line">(3)	基于符号执行的方法在基于路径的测试生成中有效，但面临路径爆炸问题，而模型检查方法（CEGAR）在检查路径可行性时有效。结果，CEGAR的运行时信息可以通知符号执行，从而避免不必要的路径探索并提高其在DFT中的性能。</span><br><span class="line">(4)	基于搜索和基于符号执行的测试技术的结合已经被用于实现更有效的分支测试[Inkumsah and Xie 2008; Baars等。 2011]。它们的组合也可以改善DFT。</span><br></pre></td></tr></table></figure>
**覆盖范围跟踪：可以提出有效的覆盖率跟踪**
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算法来提高大型现实系统中数据流测试的可用性。可以采用诸如BA算法[de Araujo and Chaim 2014]之类的仪器方法。基于前面提到的新见识和研究方向，可以提出一种新颖的混合数据流测试框架（如图13所示）以实现更实用的数据流测试。它由三个基本组件组成：数据流分析仪，测试数据生成器和覆盖率监视器。给定一个程序作为输入，此混合框架（1）输出用于可行测试目标的测试数据，（2）消除不可行的测试目标。它介于动态测试方法和静态模型检查器之间，以最大化数据流覆盖范围。希望它可以通过结合其组件方法的优势来获得更好的性能，并从数据流分析，测试数据生成和覆盖范围跟踪的未来发展中受益。此外，该框架可以从两个方面促进DFT研究。一种是在更公平的基础上评估和比较不同的测试技术。另一个是对更多实际程序执行数据流覆盖率测试，以更深入地了解其有效性和复杂性[Namin</span><br><span class="line">和Andrews 2009； Inozemtseva和Holmes，2014年]。</span><br><span class="line">此外，未来的研究工作可能会努力开发新的具有成本效益的覆盖标准，以补充数据流覆盖标准。新标准应该易于执行，并且具有与DFT相当的故障检测能力（例如，Hassan和Andrews [2013]和Li等人[2013]）。数据流覆盖标准也可以扩展到各种测试场景（例如，面向对象的系统，Web应用程序和移动应用程序），以检查数据操作的正确性。</span><br></pre></td></tr></table></figure>
**九、结论**
在过去的40年中，数据流测试已经得到越来越广泛的研究。鉴于其检查数据交互的能力，已开发出各种方法和技术来追求高效和自动化的数据流测试。据我们所知，这是第一个针对数据流测试的系统调查。我们已经建立了包含97篇研究论文的出版物资料库，展示了研究的现状，并提供了该领域的综合分析。我们将基于数据流的测试生成方法分为五类。对于每个类别，我们都解释了其技术原理并讨论了其优缺点。技术还概述了覆盖跟踪和数据流分析。基于此调查，我们提出了新的见解和未来的研究方向，旨在使DFT更加有效和实用。

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 覆盖率是如何计算的</span><br></pre></td></tr></table></figure>









      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/04/02/block_paper_1/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="block_paper_1">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-version-control" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/26/version-control/" class="article-date">
  	<time datetime="2020-03-26T13:31:48.000Z" itemprop="datePublished">2020-03-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/26/version-control/">
        version-control
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>版本控制工具</strong><br><strong>git</strong><br><strong>svn</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E7%94%A8/" rel="tag">通用</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/">版本控制工具</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/03/26/version-control/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="version-control">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-a-study-6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/25/a-study-6/" class="article-date">
  	<time datetime="2020-03-25T13:07:46.000Z" itemprop="datePublished">2020-03-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/25/a-study-6/">
        a-study-6
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>安卓常用画图类</strong><br><strong>一、概述</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• Bitmap：相当于我们绘制出来的图像，获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。</span><br><span class="line">• Paint：相当于我们绘图所用的画笔，绘制几何，文本，位图的风格与颜色信息。</span><br><span class="line">• Canvas：相当于我们绘图所用的画布，调用方法进行图像绘制。</span><br></pre></td></tr></table></figure>
<p><strong>二、BITMAP</strong><br>1.作用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• Bitmap在Android中指的是一张图片，可以是png，也可以是jpg等其他图片格式。</span><br><span class="line">• Bitmap是Android系统中的图像处理中最重要类之一。Bitmap可以获取图像文件信息，对图像进行剪切、旋转、缩放，压缩等操作，并可以以指定格式保存图像文件。</span><br><span class="line">• Bitmap是一个final类，因此不能被继承。Bitmap只有一个构造方法，且该构造方法是没有任何访问权限修饰符修饰，也就是说该构造方法是friendly。</span><br></pre></td></tr></table></figure>
<p>2.内部枚举类<br><img src="https://i.loli.net/2020/03/25/8GrHh4C2fK3oVub.png" alt="20200325092139753.png"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Bitmap中有两个内部枚举类：</span><br><span class="line">• Config是用来设置颜色配置信息的。</span><br><span class="line">• CompressFormat是用来设置压缩方式的。</span><br><span class="line"></span><br><span class="line">• Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。</span><br><span class="line">• Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。</span><br><span class="line">• Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。</span><br><span class="line">• Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。</span><br><span class="line"></span><br><span class="line">• Bitmap.CompressFormat.JPEG：表示以JPEG压缩算法进行图像压缩，压缩后的格式可以是".jpg"或者".jpeg"，是一种有损压缩。</span><br><span class="line">• Bitmap.CompressFormat.PNG：表示以PNG压缩算法进行图像压缩，压缩后的格式可以是".png"，是一种无损压缩。</span><br><span class="line">• Bitmap.CompressFormat.WEBP：表示以WebP压缩算法进行图像压缩，压缩后的格式可以是".webp"，是一种有损压缩，质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。美中不足的是，WebP格式图像的编码时间“比JPEG格式图像长8倍”。</span><br></pre></td></tr></table></figure>
<p>3.构造</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">• Bitmap的类构造函数是私有的，因此不能直接通过构造方法实例化。</span><br><span class="line">• 一般利用Bitmap的静态方法createBitmap()和BitmapFactory的decode系列静态方法创建Bitmap对象。</span><br><span class="line"></span><br><span class="line">• BitmapFactory类提供了4类方法用来加载Bitmap：</span><br><span class="line">• decodeFile()：从文件系统加载。</span><br><span class="line">• String sd_patch= “/sdcard/test.png”;</span><br><span class="line">• Bitmap bm= BitmapFactory.decodeFile(sd_path);</span><br><span class="line"></span><br><span class="line">• decodeResource()：以R.drawable.xxx的形式从本地资源中加载。</span><br><span class="line">• Bitmap bm = BitmapFactory.decodeResource(this.getContext().getResources(), R.drawable.pop);</span><br><span class="line"></span><br><span class="line">• decodeStream()：从输入流加载。</span><br><span class="line">• FileInputStream = new FileInputStream(“/sdcard/test.png”);</span><br><span class="line">• Bitmap bm= BitmapFactory.decodeStream(fis);</span><br><span class="line"></span><br><span class="line">• decodeByteArray()：从字节数组中加载。</span><br><span class="line">• Bitmap bm = BitmapFactory.decodeByteArray(myByte,0,myByte.length);</span><br></pre></td></tr></table></figure>
<p><strong>二、PAINT</strong><br>1.构造</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• Paint有3个构造方法，可以通过这3个构造方法创建Paint对象：</span><br><span class="line">• Paint()：用默认设置创建一个Paint对象。</span><br><span class="line">• Paint(int flags)：用特殊标记创建一个Paint对象：</span><br><span class="line">• Paint.FILTER_BITMAP_FLAG：使位图过滤的位掩码标志。</span><br><span class="line">• Paint.ANTI_ALIAS_FLAG：使位图抗锯齿的标志。</span><br><span class="line">• Paint.DITHER_FLAG：使位图进行有利的抖动的位掩码标志。</span><br><span class="line">• Paint(Paint paint)：用指定Paint对象的参数初始化一个新的Paint对象。</span><br></pre></td></tr></table></figure>
<p>2.常用方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">• Paint常用方法：</span><br><span class="line">• setARGB(int a, int r, int g, int b)：设置画笔颜色。</span><br><span class="line">• setAntiAlias(booleanaa)：设置是否抗锯齿。</span><br><span class="line">• setColor(int color)：设置画笔颜色。</span><br><span class="line">• setAlpha(int a)：设置画笔透明度。</span><br><span class="line">• setTextSize(float textSize)：设置字体大小。</span><br><span class="line">• setUnderlineText(booleanunderlineText)：设置文本带有下划线效果。</span><br><span class="line">• setStrikeThruText(booleanstrikeThruText)：设置文本带删除线效果。</span><br><span class="line"></span><br><span class="line">• setTextSkewX(float skewX)：设置文本倾斜度。</span><br><span class="line">• setTextScaleX(float scaleX)：设置文本缩放大小。</span><br><span class="line">• setTextAlign(Paint.Alignalign)：设置文本对齐方式。</span><br><span class="line">• setTypeface(Typeface typeface)：设置字体。</span><br><span class="line">• setStyle(Paint.Stylestyle)：设置画笔样式，画笔样式有3种：Paint.Style.FILL：默认值，用这种风格绘制的几何图与文本将被填充，它画出来的是实心图</span><br><span class="line">• Paint.Style.STROKE：用这种风格绘制的几何图与文本将被画出外边框，它画出来的是空心图</span><br><span class="line">• Paint.Style.FILL_AND_STROKE：用这种风格绘制的几何图与文本将被填充并被画出外边框，从表面看它画出来的也是实心图，不过比一般画出来的实心图多了一层外边框。</span><br><span class="line"></span><br><span class="line">• setStrokeWidth(float width)：设置画笔外边框的宽度，可以想象成画笔“画出线条的宽度”。</span><br><span class="line">• setXfermode(Xfermodexfermode)：设置图像重叠时的处理方式。</span><br><span class="line">• setShader(Shadershader)：设置着色器。</span><br><span class="line">• setPathEffect(PathEffecteffect)：设置或者清除路径效果。</span><br></pre></td></tr></table></figure>
<p><strong>三、CANVAS</strong><br>1.概述</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• Canvas拥有“绘制”调用，可以调用方法进行图像绘制。</span><br><span class="line">• 画图时需要4个基本元素：</span><br><span class="line">• 拥有像素的Bitmap。</span><br><span class="line">• 可以进行绘制调用的Canvas。</span><br><span class="line">• 图元（比如：Rect, Path, text, Bitmap）。</span><br><span class="line">• 描述风格与颜色的Paint。</span><br></pre></td></tr></table></figure>
<p>2.构造</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• Canvas有两个构造方法，可以通过这两个构造方法创建Canvas对象：</span><br><span class="line">• Canvas()：创建一个空的Canvas对象。</span><br><span class="line">• Canvas(Bitmap bitmap)：用指定的位图构造一个Canvas对象。</span><br></pre></td></tr></table></figure>
<p>3.常用方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">• drawARGB()：用指定ARGB颜色填充画布上面的位图</span><br><span class="line">• drawRGB()：用指定RGB颜色填充画布上面的位图</span><br><span class="line">• drawColor()：用指定颜色填充画布上面的位图</span><br><span class="line">• drawArc()：画圆弧</span><br><span class="line">• drawBitmap()：画位图</span><br><span class="line">• drawCircle()：画圆</span><br><span class="line">• drawLine()：画直线</span><br><span class="line"></span><br><span class="line">• drawLines()：画折线</span><br><span class="line">• drawOval()：画椭圆</span><br><span class="line">• drawRect()：画矩形</span><br><span class="line">• drawRoundRect()：画圆角矩形</span><br><span class="line">• drawPoint()：画点</span><br><span class="line">• drawPoints()：画一组点</span><br><span class="line">• drawPath()：画路径</span><br><span class="line">• drawText()：画文本</span><br></pre></td></tr></table></figure>
<p><strong>ANIMATION</strong><br><strong>一、概述</strong><br>Android Animation分为两类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 传统动画：包括帧动画（Frame Animation）和补间动画（Tween Animation），又称为DrawableAnimation和View Animation。</span><br><span class="line">• 属性动画（Property Animation）。</span><br></pre></td></tr></table></figure>
<p><strong>二、传统动画</strong><br>Frame Animation</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• Frame Animation（DrawableAnimation）是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源。</span><br><span class="line">• Frame Animation的原理是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果。</span><br><span class="line">• 这种动画的实质其实是Drawable，所以这种动画的XML定义方式文件一般放在res/drawable/目录下。</span><br></pre></td></tr></table></figure>
<p>TweenAnimation</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">• TweenAnimation（View Animation）可以在一个视图容器内执行一系列简单变换。譬如，有一个TextView对象，可以移动、旋转、缩放、透明度设置其文本，当然，如果它有一个背景图像，背景图像会随着文本变化。</span><br><span class="line">• TweenAnimation 具体有4种形式：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。</span><br><span class="line">• 补间动画通过XML或Android代码定义，建议使用XML文件定义，因为它更具可读性、可重用性。</span><br><span class="line"></span><br><span class="line">--------------------关于配置anime--------------------</span><br><span class="line">相关类名：</span><br><span class="line">• AlphaAnimation：渐变透明度动画效果，对应XML中的<span class="tag">&lt;<span class="name">alpha</span>&gt;</span>，放置在res/anim/目录。</span><br><span class="line">• RotateAnimation：画面转移旋转动画效果，对应XML中的<span class="tag">&lt;<span class="name">rotate</span>&gt;</span>，放置在res/anim/目录。</span><br><span class="line">• ScaleAnimation：渐变尺寸伸缩动画效果，对应XML中的<span class="tag">&lt;<span class="name">scale</span>&gt;</span>，放置在res/anim/目录。</span><br><span class="line">• TranslateAnimation：画面转换位置移动动画效果，对应XML中的<span class="tag">&lt;<span class="name">translate</span>&gt;</span> 放置在res/anim/目录。</span><br><span class="line">• AnimationSet：一个持有其它动画元素alpha、scale、translate、rotate或者其它set元素的容器，对应XML中的<span class="tag">&lt;<span class="name">set</span>&gt;</span>，放置在res/anim/目录。</span><br><span class="line"></span><br><span class="line">Animation属性：</span><br><span class="line">• android:detachWallpaper：是否在壁纸上运行，对应setDetachWallpaper(boolean)。</span><br><span class="line">• android:duration：动画持续时间，毫秒为单位，对应setDuration(long)。</span><br><span class="line">• android:fillAfter：控件动画结束时是否保持动画最后的状态，对应setFillAfter(boolean) 。</span><br><span class="line">• android:fillBefore：控件动画结束时是否还原到开始动画前的状态，对应setFillBefore(boolean)。</span><br><span class="line">• android:fillEnabled：与android:fillBefore效果相同，对应setFillEnabled(boolean) 。</span><br><span class="line">• android:interpolator：设定插值器（指定的动画效果，譬如回弹等），对应setInterpolator(Interpolator)。</span><br><span class="line">• android:repeatCount：重复次数，对应setInterpolator(Interpolator)。</span><br><span class="line">• android:repeatMode：重复类型有两个值，reverse表示倒序回放，restart表示从头播放，对应setInterpolator(Interpolator) 。</span><br><span class="line">• android:startOffset：调用start函数之后等待开始运行的时间，单位为毫秒，对应setStartOffset(long)。</span><br><span class="line">• android:zAdjustment：表示被设置动画的内容运行时在Z轴上的位置（top/bottom/normal），默认为normal ，对应setZAdjustment(int)。</span><br><span class="line"></span><br><span class="line">• Interpolator 主要作用是可以控制动画的变化速率，就是动画进行的快慢节奏：</span><br><span class="line">• @android:anim/accelerate_decelerate_interpolator：动画始末速率较慢，中间加速。</span><br><span class="line">• @android:anim/accelerate_interpolator：动画开始速率较慢，之后慢慢加速。</span><br><span class="line">• AnticipateInterpolator@android:anim/anticipate_interpolator开始的时候从后向前甩。</span><br><span class="line">• @android:anim/anticipate_overshoot_interpolator类似上面AnticipateInterpolator。</span><br><span class="line">• @android:anim/bounce_interpolator：动画结束时弹起。</span><br><span class="line">• @android:anim/cycle_interpolator：循环播放速率改变为正弦曲线。</span><br><span class="line">• @android:anim/decelerate_interpolator：动画开始快然后慢。</span><br><span class="line">• @android:anim/linear_interpolator：动画匀速改变。</span><br><span class="line">• @android:anim/overshoot_interpolator：向前弹出一定值之后回到原来位置。</span><br></pre></td></tr></table></figure>
<p>逐帧动画&amp; 补间动画存在一定的缺点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• 作用对象局限。有些情况下的动画效果只是视图的某个属性&amp; 对象而不是整个视图。</span><br><span class="line">• 没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，而不会真正去改变View的属性。</span><br><span class="line">• 动画效果单一。补间动画只能实现平移、旋转、缩放&amp; 透明度这些简单的动画需求，一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现。</span><br></pre></td></tr></table></figure>
<p><strong>三、属性动画（Property Animation）</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• 为了解决补间动画的缺陷，在Android 3.0（API 11）开始，系统提供了一种全新的动画模式：属性动画（Property Animation）。</span><br><span class="line">• 作用对象：任意Java 对象，不再局限于视图View对象。</span><br><span class="line">• 实现的动画效果：可自定义各种动画效果，不再局限于4种基本变换：平移、旋转、缩放&amp; 透明度。</span><br><span class="line">• 工作原理：在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。</span><br></pre></td></tr></table></figure>
<p><strong>四、ANIMATION LISTENER</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">• anim.setAnimationListener(<span class="keyword">new</span> AnimationListener() &#123;</span><br><span class="line">• <span class="meta">@Override</span></span><br><span class="line">• <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancle</span><span class="params">(Animation animation)</span> </span>&#123;…&#125;</span><br><span class="line">• <span class="meta">@Override</span></span><br><span class="line">• <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;…&#125;</span><br><span class="line">• <span class="meta">@Override</span></span><br><span class="line">• <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;…&#125;</span><br><span class="line">• <span class="meta">@Override</span></span><br><span class="line">• <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;…&#125;</span><br><span class="line">• &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>MEDIAPLAYER</strong><br><strong>一、功能与设置源</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Android可以通过Mediaplayer类提供的API，实现以下音频、视频文件的播放：</span><br><span class="line">• 自带resource资源：MediaPlayer.create(this, R.raw.test);</span><br><span class="line">• SD卡或其他文件路径下的媒体文件：mp.setDataSource(“/sdcard/test.mp3”);</span><br><span class="line">• 网络媒体文件：mp.setDataSource("http://www.citynorth.cn/music/confucius.mp3");</span><br><span class="line"></span><br><span class="line">• setDataSource一共四个方法：</span><br><span class="line">• setDataSource(String path) ；//文件系统路径</span><br><span class="line">• setDataSource(FileDescriptorfd)；//assets文件</span><br><span class="line">• setDataSource(Context context, Uri uri)；//网络虚拟路径</span><br><span class="line">• setDataSource(FileDescriptorfd, long offset, long length)；</span><br><span class="line">• 若URI中包含网络资源，需在AndroidManifest.xml中申请Internet访问权限：</span><br><span class="line">• <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>二、生命周期</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• Idle 状态：当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，则并不会触发onError(),也不会进入Error状态。</span><br><span class="line">• End 状态：通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。</span><br><span class="line">• Initialized 状态：这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，表示此时要播放的文件已经设置好了。</span><br><span class="line"></span><br><span class="line">• Prepared 状态：初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放。</span><br><span class="line">• Preparing 状态：这个状态比较好理解，主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。MediaPlayer准备资源调用prepare()时，会执行一段稍长的时间，因为它在解码媒体数据，如果解码时间过长那么会出现主线程阻塞，从而触发ANR异常，导致程序运行很慢，所以框架提供了prepareAsync()异步准备方法并提供资源准备监听，当资源准备完成会触发MediaPlayer.OnPreparedListener的onPrepared()方法。</span><br><span class="line"></span><br><span class="line">• Stop 状态：Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。</span><br><span class="line">• PlaybackCompleted状态：文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。</span><br><span class="line"></span><br><span class="line">• Error状态：如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。</span><br><span class="line">• 通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。</span><br></pre></td></tr></table></figure>
<p><strong>三、常用方法</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">• int getCurrentPosition()：获取当前播放的位置。</span><br><span class="line">• int getAudioSessionId()：返回音频的session ID。</span><br><span class="line">• int getDuration()：得到文件的时间。</span><br><span class="line">• TrackInfo[] getTrackInfo()：返回一个track信息的数组。</span><br><span class="line">• booleanisLooping()：是否循环播放。</span><br><span class="line">• booleanisPlaying()：是否正在播放。</span><br><span class="line"></span><br><span class="line">• void pause ()：暂停。</span><br><span class="line">• void start ()：开始。</span><br><span class="line">• void stop ()：停止。</span><br><span class="line">• void prepare()：同步的方式装载流媒体文件。</span><br><span class="line">• void prepareAsync()：异步的方式装载流媒体文件。</span><br><span class="line">• void reset()：重置MediaPlayer至未初始化状态。</span><br><span class="line">• void release ()：回收流媒体资源。</span><br><span class="line">• void seekTo(int msec)：指定播放的位置（以毫秒为单位时间）。</span><br><span class="line"></span><br><span class="line">• void setAudioStreamType(intstreamtype)：指定流媒体类型。</span><br><span class="line">• void setLooping(booleanlooping)：设置是否单曲循环。</span><br><span class="line">• void setNextMediaPlayer(MediaPlayernext)：当这个MediaPlayer播放完毕后，MediaPlayernext开始播放。</span><br><span class="line">• void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。</span><br><span class="line">• void setScreenOnWhilePlaying(Boolean screenOn)：播放时是否保持屏幕常亮，是否阻止屏幕自动休眠。</span><br></pre></td></tr></table></figure>
<p><strong>四、展示控件–SurfaceView</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• View通过刷新来重绘视图，Android系统通过发出VSYNC信号来进行屏幕的重绘，刷新的时间间隔为16ms。在一些需要频繁刷新，执行很多逻辑操作的时候，超过了16ms，就会导致卡顿.</span><br><span class="line">• SurfaceView继承自View，但拥有独立的绘制表面，即它不与其宿主窗口共享同一个绘图表面，可以单独在一个线程进行绘制，并不会占用主线程的资源。这样，绘制就会比较高效，游戏，视频播放，还有最近热门的直播，都可以用SurfaceView。</span><br><span class="line"></span><br><span class="line">SurfaceView和View的区别：</span><br><span class="line">• View主要适用于主动更新的情况下，而SurfaceView主要适用于被动更新，例如频繁地刷新。</span><br><span class="line">• View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面的刷新。</span><br><span class="line">• View在绘图时没有使用双缓冲机制，而SufaceView在底层实现机制中就已经实现了双缓冲机制。</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/" rel="tag">android</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>
	</div>


      
        
<div class="counter-tag counter">
    <span id="/2020/03/25/a-study-6/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="a-study-6">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
    <article id="post-a-case-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/24/a-case-1/" class="article-date">
  	<time datetime="2020-03-24T10:20:37.000Z" itemprop="datePublished">2020-03-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/24/a-case-1/">
        a-case-1
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>数据库记事本</strong><br><strong>一、系统分析</strong><br><img src="/a-case-1/20200324063612965.png" alt=""><br><strong>二、系统设计</strong><br>1.系统目标<br><img src="/a-case-1/20200324063758276.png" alt=""><br>2.系统功能结构<br><img src="/a-case-1/20200324063858476.png" alt=""><br>3.系统业务流程<br><img src="/a-case-1/20200324063941046.png" alt=""><br><strong>三、系统实施</strong><br>1.开发及运行环境<br>2.项目创建<br>3.项目工程结构<br>4.主界面实现<br>（1）导航界面布局activity_menu.xml<br>（2）编辑界面布局activity_note_edit.xml<br>（3）列表页面布局activity_note_list.xml<br>5.逻辑实现<br>（1）菜单MenuActivity.java<br>（2）MainActivity.java<br>（3）<br>（4）数据库NoteDBAdapter类</p>
<ul>
<li>数据库设计</li>
<li>类实现</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/" rel="tag">android</a></li></ul>
	</div>

      

      
        
<div class="counter-tag counter">
    <span id="/2020/03/24/a-case-1/" class="leancloud_visitors post-title-link"
          style="font-size: 12px" data-flag-title="a-case-1">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 nlby
      </div>
	  <!--<audio src="/music/1.mp3" autoplay="autoplay" loop="-1" /></audio>-->
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>

    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hk416.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>